var wx = Object.defineProperty;
var _x = (s, o, l) => o in s ? wx(s, o, { enumerable: !0, configurable: !0, writable: !0, value: l }) : s[o] = l;
var gc = (s, o, l) => _x(s, typeof o != "symbol" ? o + "" : o, l);
import { inject, ref as ref$1, defineComponent, useSlots, useAttrs, shallowRef, getCurrentInstance, toRaw, createVNode, mergeProps as mergeProps$1, isVNode, h, Fragment, cloneVNode, watch, provide, reactive, onMounted, onBeforeUnmount, Teleport, nextTick, onUnmounted, isRef, onActivated, createApp, Text as Text$1, computed, watchEffect, createTextVNode, unref, withMemo, onBeforeMount } from "vue";
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
var lodash = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash.exports;
(function(s, o) {
  (function() {
    var l, u = "4.17.21", c = 200, m = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", g = "Expected a function", v = "Invalid `variable` option passed into `_.template`", b = "__lodash_hash_undefined__", S = 500, E = "__lodash_placeholder__", P = 1, T = 2, N = 4, O = 1, z = 2, Q = 1, W = 2, ue = 4, te = 8, K = 16, ve = 32, ee = 64, Re = 128, wt = 256, yt = 512, xt = 30, Kt = "...", tn = 800, ln = 16, rn = 1, an = 2, Gt = 3, nn = 1 / 0, vt = 9007199254740991, Et = 17976931348623157e292, Qt = NaN, un = 4294967295, gn = un - 1, dn = un >>> 1, yn = [
      ["ary", Re],
      ["bind", Q],
      ["bindKey", W],
      ["curry", te],
      ["curryRight", K],
      ["flip", yt],
      ["partial", ve],
      ["partialRight", ee],
      ["rearg", wt]
    ], vn = "[object Arguments]", Pn = "[object Array]", On = "[object AsyncFunction]", _n = "[object Boolean]", Nn = "[object Date]", Un = "[object DOMException]", Xn = "[object Error]", zn = "[object Function]", jn = "[object GeneratorFunction]", kn = "[object Map]", Yn = "[object Number]", Zn = "[object Null]", er = "[object Object]", bn = "[object Promise]", Ln = "[object Proxy]", Kn = "[object RegExp]", Bn = "[object Set]", Fn = "[object String]", Gn = "[object Symbol]", Wn = "[object Undefined]", Mn = "[object WeakMap]", Tn = "[object WeakSet]", Rn = "[object ArrayBuffer]", hn = "[object DataView]", Qn = "[object Float32Array]", rr = "[object Float64Array]", tr = "[object Int8Array]", Cr = "[object Int16Array]", Fr = "[object Int32Array]", An = "[object Uint8Array]", Hn = "[object Uint8ClampedArray]", ir = "[object Uint16Array]", dr = "[object Uint32Array]", ar = /\b__p \+= '';/g, Or = /\b(__p \+=) '' \+/g, Sr = /(__e\(.*?\)|\b__t\)) \+\n'';/g, kr = /&(?:amp|lt|gt|quot|#39);/g, Nr = /[&<>"']/g, Ur = RegExp(kr.source), _r = RegExp(Nr.source), Zr = /<%-([\s\S]+?)%>/g, Jr = /<%([\s\S]+?)%>/g, ii = /<%=([\s\S]+?)%>/g, Ti = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Mi = /^\w*$/, ui = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ii = /[\\^$.*+?()[\]{}|]/g, bs = RegExp(Ii.source), Oi = /^\s+/, Vs = /\s/, _s = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Is = /\{\n\/\* \[wrapped with (.+)\] \*/, Fa = /,? & /, io = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Da = /[()=,{}\[\]\/\s]/, oo = /\\(\\)?/g, Xs = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, so = /\w*$/, Ol = /^[-+]0x[0-9a-f]+$/i, kl = /^0b[01]+$/i, uc = /^\[object .+?Constructor\]$/, Vl = /^0o[0-7]+$/i, Ma = /^(?:0|[1-9]\d*)$/, Ll = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Oa = /($^)/, cc = /['\n\r\u2028\u2029\\]/g, va = "\\ud800-\\udfff", yc = "\\u0300-\\u036f", vc = "\\ufe20-\\ufe2f", Af = "\\u20d0-\\u20ff", Yr = yc + vc + Af, Ra = "\\u2700-\\u27bf", Bl = "a-z\\xdf-\\xf6\\xf8-\\xff", Nf = "\\xac\\xb1\\xd7\\xf7", Ff = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", xc = "\\u2000-\\u206f", Df = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", zl = "A-Z\\xc0-\\xd6\\xd8-\\xde", La = "\\ufe0e\\ufe0f", ya = Nf + Ff + xc + Df, Al = "['’]", bc = "[" + va + "]", dc = "[" + ya + "]", ao = "[" + Yr + "]", fc = "\\d+", Rf = "[" + Ra + "]", Nl = "[" + Bl + "]", jl = "[^" + va + ya + fc + Ra + Bl + zl + "]", lo = "\\ud83c[\\udffb-\\udfff]", Cc = "(?:" + ao + "|" + lo + ")", Fl = "[^" + va + "]", ki = "(?:\\ud83c[\\udde6-\\uddff]){2}", Dl = "[\\ud800-\\udbff][\\udc00-\\udfff]", Js = "[" + zl + "]", Hl = "\\u200d", Ul = "(?:" + Nl + "|" + jl + ")", Of = "(?:" + Js + "|" + jl + ")", pc = "(?:" + Al + "(?:d|ll|m|re|s|t|ve))?", hc = "(?:" + Al + "(?:D|LL|M|RE|S|T|VE))?", de = Cc + "?", en = "[" + La + "]?", mn = "(?:" + Hl + "(?:" + [Fl, ki, Dl].join("|") + ")" + en + de + ")*", $n = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Vn = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", sr = en + de + mn, cr = "(?:" + [Rf, ki, Dl].join("|") + ")" + sr, Br = "(?:" + [Fl + ao + "?", ao, ki, Dl, bc].join("|") + ")", Kr = RegExp(Al, "g"), Li = RegExp(ao, "g"), Pi = RegExp(lo + "(?=" + lo + ")|" + Br + sr, "g"), Zs = RegExp([
      Js + "?" + Nl + "+" + pc + "(?=" + [dc, Js, "$"].join("|") + ")",
      Of + "+" + hc + "(?=" + [dc, Js + Ul, "$"].join("|") + ")",
      Js + "?" + Ul + "+" + pc,
      Js + "+" + hc,
      Vn,
      $n,
      fc,
      cr
    ].join("|"), "g"), Rl = RegExp("[" + Hl + va + Yr + La + "]"), Kl = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ml = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], mc = -1, Wr = {};
    Wr[Qn] = Wr[rr] = Wr[tr] = Wr[Cr] = Wr[Fr] = Wr[An] = Wr[Hn] = Wr[ir] = Wr[dr] = !0, Wr[vn] = Wr[Pn] = Wr[Rn] = Wr[_n] = Wr[hn] = Wr[Nn] = Wr[Xn] = Wr[zn] = Wr[kn] = Wr[Yn] = Wr[er] = Wr[Kn] = Wr[Bn] = Wr[Fn] = Wr[Mn] = !1;
    var Hr = {};
    Hr[vn] = Hr[Pn] = Hr[Rn] = Hr[hn] = Hr[_n] = Hr[Nn] = Hr[Qn] = Hr[rr] = Hr[tr] = Hr[Cr] = Hr[Fr] = Hr[kn] = Hr[Yn] = Hr[er] = Hr[Kn] = Hr[Bn] = Hr[Fn] = Hr[Gn] = Hr[An] = Hr[Hn] = Hr[ir] = Hr[dr] = !0, Hr[Xn] = Hr[zn] = Hr[Mn] = !1;
    var Mf = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, Vf = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Bf = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, zf = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, jf = parseFloat, Hf = parseInt, Sc = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal, Uf = typeof self == "object" && self && self.Object === Object && self, di = Sc || Uf || Function("return this")(), Wl = o && !o.nodeType && o, Qs = Wl && !0 && s && !s.nodeType && s, $c = Qs && Qs.exports === Wl, Gl = $c && Sc.process, Yi = function() {
      try {
        var fn = Qs && Qs.require && Qs.require("util").types;
        return fn || Gl && Gl.binding && Gl.binding("util");
      } catch {
      }
    }(), wc = Yi && Yi.isArrayBuffer, _c = Yi && Yi.isDate, Ec = Yi && Yi.isMap, Pc = Yi && Yi.isRegExp, Tc = Yi && Yi.isSet, Ic = Yi && Yi.isTypedArray;
    function Hi(fn, wn, xn) {
      switch (xn.length) {
        case 0:
          return fn.call(wn);
        case 1:
          return fn.call(wn, xn[0]);
        case 2:
          return fn.call(wn, xn[0], xn[1]);
        case 3:
          return fn.call(wn, xn[0], xn[1], xn[2]);
      }
      return fn.apply(wn, xn);
    }
    function Kf(fn, wn, xn, Jn) {
      for (var fr = -1, Mr = fn == null ? 0 : fn.length; ++fr < Mr; ) {
        var ni = fn[fr];
        wn(Jn, ni, xn(ni), fn);
      }
      return Jn;
    }
    function Xi(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function Wf(fn, wn) {
      for (var xn = fn == null ? 0 : fn.length; xn-- && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function kc(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (!wn(fn[xn], xn, fn))
          return !1;
      return !0;
    }
    function Bs(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        wn(ni, xn, fn) && (Mr[fr++] = ni);
      }
      return Mr;
    }
    function uo(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return !!xn && xa(fn, wn, 0) > -1;
    }
    function ql(fn, wn, xn) {
      for (var Jn = -1, fr = fn == null ? 0 : fn.length; ++Jn < fr; )
        if (xn(wn, fn[Jn]))
          return !0;
      return !1;
    }
    function qr(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = Array(Jn); ++xn < Jn; )
        fr[xn] = wn(fn[xn], xn, fn);
      return fr;
    }
    function zs(fn, wn) {
      for (var xn = -1, Jn = wn.length, fr = fn.length; ++xn < Jn; )
        fn[fr + xn] = wn[xn];
      return fn;
    }
    function Yl(fn, wn, xn, Jn) {
      var fr = -1, Mr = fn == null ? 0 : fn.length;
      for (Jn && Mr && (xn = fn[++fr]); ++fr < Mr; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Gf(fn, wn, xn, Jn) {
      var fr = fn == null ? 0 : fn.length;
      for (Jn && fr && (xn = fn[--fr]); fr--; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Xl(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (wn(fn[xn], xn, fn))
          return !0;
      return !1;
    }
    var qf = Zl("length");
    function Yf(fn) {
      return fn.split("");
    }
    function Xf(fn) {
      return fn.match(io) || [];
    }
    function Ac(fn, wn, xn) {
      var Jn;
      return xn(fn, function(fr, Mr, ni) {
        if (wn(fr, Mr, ni))
          return Jn = Mr, !1;
      }), Jn;
    }
    function co(fn, wn, xn, Jn) {
      for (var fr = fn.length, Mr = xn + (Jn ? 1 : -1); Jn ? Mr-- : ++Mr < fr; )
        if (wn(fn[Mr], Mr, fn))
          return Mr;
      return -1;
    }
    function xa(fn, wn, xn) {
      return wn === wn ? lp(fn, wn, xn) : co(fn, Nc, xn);
    }
    function Zf(fn, wn, xn, Jn) {
      for (var fr = xn - 1, Mr = fn.length; ++fr < Mr; )
        if (Jn(fn[fr], wn))
          return fr;
      return -1;
    }
    function Nc(fn) {
      return fn !== fn;
    }
    function Fc(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return xn ? Ql(fn, wn) / xn : Qt;
    }
    function Zl(fn) {
      return function(wn) {
        return wn == null ? l : wn[fn];
      };
    }
    function Jl(fn) {
      return function(wn) {
        return fn == null ? l : fn[wn];
      };
    }
    function Dc(fn, wn, xn, Jn, fr) {
      return fr(fn, function(Mr, ni, Gr) {
        xn = Jn ? (Jn = !1, Mr) : wn(xn, Mr, ni, Gr);
      }), xn;
    }
    function Jf(fn, wn) {
      var xn = fn.length;
      for (fn.sort(wn); xn--; )
        fn[xn] = fn[xn].value;
      return fn;
    }
    function Ql(fn, wn) {
      for (var xn, Jn = -1, fr = fn.length; ++Jn < fr; ) {
        var Mr = wn(fn[Jn]);
        Mr !== l && (xn = xn === l ? Mr : xn + Mr);
      }
      return xn;
    }
    function eu(fn, wn) {
      for (var xn = -1, Jn = Array(fn); ++xn < fn; )
        Jn[xn] = wn(xn);
      return Jn;
    }
    function Qf(fn, wn) {
      return qr(wn, function(xn) {
        return [xn, fn[xn]];
      });
    }
    function Rc(fn) {
      return fn && fn.slice(0, Vc(fn) + 1).replace(Oi, "");
    }
    function Ui(fn) {
      return function(wn) {
        return fn(wn);
      };
    }
    function tu(fn, wn) {
      return qr(wn, function(xn) {
        return fn[xn];
      });
    }
    function Va(fn, wn) {
      return fn.has(wn);
    }
    function Oc(fn, wn) {
      for (var xn = -1, Jn = fn.length; ++xn < Jn && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function Lc(fn, wn) {
      for (var xn = fn.length; xn-- && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function ep(fn, wn) {
      for (var xn = fn.length, Jn = 0; xn--; )
        fn[xn] === wn && ++Jn;
      return Jn;
    }
    var tp = Jl(Mf), np = Jl(Vf);
    function rp(fn) {
      return "\\" + zf[fn];
    }
    function ip(fn, wn) {
      return fn == null ? l : fn[wn];
    }
    function ba(fn) {
      return Rl.test(fn);
    }
    function sp(fn) {
      return Kl.test(fn);
    }
    function ap(fn) {
      for (var wn, xn = []; !(wn = fn.next()).done; )
        xn.push(wn.value);
      return xn;
    }
    function nu(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn, fr) {
        xn[++wn] = [fr, Jn];
      }), xn;
    }
    function Mc(fn, wn) {
      return function(xn) {
        return fn(wn(xn));
      };
    }
    function Hs(fn, wn) {
      for (var xn = -1, Jn = fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        (ni === wn || ni === E) && (fn[xn] = E, Mr[fr++] = xn);
      }
      return Mr;
    }
    function fo(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = Jn;
      }), xn;
    }
    function op(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = [Jn, Jn];
      }), xn;
    }
    function lp(fn, wn, xn) {
      for (var Jn = xn - 1, fr = fn.length; ++Jn < fr; )
        if (fn[Jn] === wn)
          return Jn;
      return -1;
    }
    function up(fn, wn, xn) {
      for (var Jn = xn + 1; Jn--; )
        if (fn[Jn] === wn)
          return Jn;
      return Jn;
    }
    function Ca(fn) {
      return ba(fn) ? dp(fn) : qf(fn);
    }
    function Cs(fn) {
      return ba(fn) ? fp(fn) : Yf(fn);
    }
    function Vc(fn) {
      for (var wn = fn.length; wn-- && Vs.test(fn.charAt(wn)); )
        ;
      return wn;
    }
    var cp = Jl(Bf);
    function dp(fn) {
      for (var wn = Pi.lastIndex = 0; Pi.test(fn); )
        ++wn;
      return wn;
    }
    function fp(fn) {
      return fn.match(Pi) || [];
    }
    function hp(fn) {
      return fn.match(Zs) || [];
    }
    var mp = function fn(wn) {
      wn = wn == null ? di : Sa.defaults(di.Object(), wn, Sa.pick(di, Ml));
      var xn = wn.Array, Jn = wn.Date, fr = wn.Error, Mr = wn.Function, ni = wn.Math, Gr = wn.Object, ru = wn.RegExp, gp = wn.String, Zi = wn.TypeError, po = xn.prototype, yp = Mr.prototype, $a = Gr.prototype, ho = wn["__core-js_shared__"], mo = yp.toString, zr = $a.hasOwnProperty, vp = 0, Bc = function() {
        var f = /[^.]+$/.exec(ho && ho.keys && ho.keys.IE_PROTO || "");
        return f ? "Symbol(src)_1." + f : "";
      }(), go = $a.toString, xp = mo.call(Gr), bp = di._, Cp = ru(
        "^" + mo.call(zr).replace(Ii, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), yo = $c ? wn.Buffer : l, Us = wn.Symbol, vo = wn.Uint8Array, zc = yo ? yo.allocUnsafe : l, xo = Mc(Gr.getPrototypeOf, Gr), jc = Gr.create, Hc = $a.propertyIsEnumerable, bo = po.splice, Uc = Us ? Us.isConcatSpreadable : l, Ba = Us ? Us.iterator : l, sa = Us ? Us.toStringTag : l, Co = function() {
        try {
          var f = ha(Gr, "defineProperty");
          return f({}, "", {}), f;
        } catch {
        }
      }(), Sp = wn.clearTimeout !== di.clearTimeout && wn.clearTimeout, wp = Jn && Jn.now !== di.Date.now && Jn.now, _p = wn.setTimeout !== di.setTimeout && wn.setTimeout, So = ni.ceil, wo = ni.floor, iu = Gr.getOwnPropertySymbols, Ep = yo ? yo.isBuffer : l, Kc = wn.isFinite, Pp = po.join, Tp = Mc(Gr.keys, Gr), ri = ni.max, wi = ni.min, Ip = Jn.now, Ap = wn.parseInt, Wc = ni.random, Np = po.reverse, su = ha(wn, "DataView"), za = ha(wn, "Map"), au = ha(wn, "Promise"), wa = ha(wn, "Set"), ja = ha(wn, "WeakMap"), Ua = ha(Gr, "create"), _o = ja && new ja(), Ea = {}, Fp = ma(su), Dp = ma(za), Rp = ma(au), Op = ma(wa), Lp = ma(ja), Eo = Us ? Us.prototype : l, Ka = Eo ? Eo.valueOf : l, Gc = Eo ? Eo.toString : l;
      function Ft(f) {
        if (Qr(f) && !pr(f) && !(f instanceof Pr)) {
          if (f instanceof Ji)
            return f;
          if (zr.call(f, "__wrapped__"))
            return Yd(f);
        }
        return new Ji(f);
      }
      var Pa = /* @__PURE__ */ function() {
        function f() {
        }
        return function(y) {
          if (!Xr(y))
            return {};
          if (jc)
            return jc(y);
          f.prototype = y;
          var w = new f();
          return f.prototype = l, w;
        };
      }();
      function Po() {
      }
      function Ji(f, y) {
        this.__wrapped__ = f, this.__actions__ = [], this.__chain__ = !!y, this.__index__ = 0, this.__values__ = l;
      }
      Ft.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Zr,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Jr,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ii,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: Ft
        }
      }, Ft.prototype = Po.prototype, Ft.prototype.constructor = Ft, Ji.prototype = Pa(Po.prototype), Ji.prototype.constructor = Ji;
      function Pr(f) {
        this.__wrapped__ = f, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = un, this.__views__ = [];
      }
      function Mp() {
        var f = new Pr(this.__wrapped__);
        return f.__actions__ = Vi(this.__actions__), f.__dir__ = this.__dir__, f.__filtered__ = this.__filtered__, f.__iteratees__ = Vi(this.__iteratees__), f.__takeCount__ = this.__takeCount__, f.__views__ = Vi(this.__views__), f;
      }
      function Bp() {
        if (this.__filtered__) {
          var f = new Pr(this);
          f.__dir__ = -1, f.__filtered__ = !0;
        } else
          f = this.clone(), f.__dir__ *= -1;
        return f;
      }
      function zp() {
        var f = this.__wrapped__.value(), y = this.__dir__, w = pr(f), Y = y < 0, dt = w ? f.length : 0, Wt = rm(0, dt, this.__views__), sn = Wt.start, cn = Wt.end, pn = cn - sn, En = Y ? cn : sn - 1, In = this.__iteratees__, Dn = In.length, qn = 0, nr = wi(pn, this.__takeCount__);
        if (!w || !Y && dt == pn && nr == pn)
          return vd(f, this.__actions__);
        var lr = [];
        e:
          for (; pn-- && qn < nr; ) {
            En += y;
            for (var gr = -1, ur = f[En]; ++gr < Dn; ) {
              var $r = In[gr], Ir = $r.iteratee, Gi = $r.type, Fi = Ir(ur);
              if (Gi == an)
                ur = Fi;
              else if (!Fi) {
                if (Gi == rn)
                  continue e;
                break e;
              }
            }
            lr[qn++] = ur;
          }
        return lr;
      }
      Pr.prototype = Pa(Po.prototype), Pr.prototype.constructor = Pr;
      function ca(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Up() {
        this.__data__ = Ua ? Ua(null) : {}, this.size = 0;
      }
      function Kp(f) {
        var y = this.has(f) && delete this.__data__[f];
        return this.size -= y ? 1 : 0, y;
      }
      function Wp(f) {
        var y = this.__data__;
        if (Ua) {
          var w = y[f];
          return w === b ? l : w;
        }
        return zr.call(y, f) ? y[f] : l;
      }
      function Gp(f) {
        var y = this.__data__;
        return Ua ? y[f] !== l : zr.call(y, f);
      }
      function qp(f, y) {
        var w = this.__data__;
        return this.size += this.has(f) ? 0 : 1, w[f] = Ua && y === l ? b : y, this;
      }
      ca.prototype.clear = Up, ca.prototype.delete = Kp, ca.prototype.get = Wp, ca.prototype.has = Gp, ca.prototype.set = qp;
      function ks(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Yp() {
        this.__data__ = [], this.size = 0;
      }
      function Xp(f) {
        var y = this.__data__, w = To(y, f);
        if (w < 0)
          return !1;
        var Y = y.length - 1;
        return w == Y ? y.pop() : bo.call(y, w, 1), --this.size, !0;
      }
      function Zp(f) {
        var y = this.__data__, w = To(y, f);
        return w < 0 ? l : y[w][1];
      }
      function eh(f) {
        return To(this.__data__, f) > -1;
      }
      function th(f, y) {
        var w = this.__data__, Y = To(w, f);
        return Y < 0 ? (++this.size, w.push([f, y])) : w[Y][1] = y, this;
      }
      ks.prototype.clear = Yp, ks.prototype.delete = Xp, ks.prototype.get = Zp, ks.prototype.has = eh, ks.prototype.set = th;
      function As(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function nh() {
        this.size = 0, this.__data__ = {
          hash: new ca(),
          map: new (za || ks)(),
          string: new ca()
        };
      }
      function rh(f) {
        var y = el(this, f).delete(f);
        return this.size -= y ? 1 : 0, y;
      }
      function ih(f) {
        return el(this, f).get(f);
      }
      function sh(f) {
        return el(this, f).has(f);
      }
      function ah(f, y) {
        var w = el(this, f), Y = w.size;
        return w.set(f, y), this.size += w.size == Y ? 0 : 1, this;
      }
      As.prototype.clear = nh, As.prototype.delete = rh, As.prototype.get = ih, As.prototype.has = sh, As.prototype.set = ah;
      function da(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.__data__ = new As(); ++y < w; )
          this.add(f[y]);
      }
      function oh(f) {
        return this.__data__.set(f, b), this;
      }
      function lh(f) {
        return this.__data__.has(f);
      }
      da.prototype.add = da.prototype.push = oh, da.prototype.has = lh;
      function Ss(f) {
        var y = this.__data__ = new ks(f);
        this.size = y.size;
      }
      function uh() {
        this.__data__ = new ks(), this.size = 0;
      }
      function ch(f) {
        var y = this.__data__, w = y.delete(f);
        return this.size = y.size, w;
      }
      function dh(f) {
        return this.__data__.get(f);
      }
      function fh(f) {
        return this.__data__.has(f);
      }
      function ph(f, y) {
        var w = this.__data__;
        if (w instanceof ks) {
          var Y = w.__data__;
          if (!za || Y.length < c - 1)
            return Y.push([f, y]), this.size = ++w.size, this;
          w = this.__data__ = new As(Y);
        }
        return w.set(f, y), this.size = w.size, this;
      }
      Ss.prototype.clear = uh, Ss.prototype.delete = ch, Ss.prototype.get = dh, Ss.prototype.has = fh, Ss.prototype.set = ph;
      function qc(f, y) {
        var w = pr(f), Y = !w && ga(f), dt = !w && !Y && Ys(f), Wt = !w && !Y && !dt && Aa(f), sn = w || Y || dt || Wt, cn = sn ? eu(f.length, gp) : [], pn = cn.length;
        for (var En in f)
          (y || zr.call(f, En)) && !(sn && // Safari 9 has enumerable `arguments.length` in strict mode.
          (En == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          dt && (En == "offset" || En == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          Wt && (En == "buffer" || En == "byteLength" || En == "byteOffset") || // Skip index properties.
          Rs(En, pn))) && cn.push(En);
        return cn;
      }
      function Yc(f) {
        var y = f.length;
        return y ? f[yu(0, y - 1)] : l;
      }
      function hh(f, y) {
        return xl(Vi(f), fa(y, 0, f.length));
      }
      function mh(f) {
        return xl(Vi(f));
      }
      function ou(f, y, w) {
        (w !== l && !$s(f[y], w) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function Wa(f, y, w) {
        var Y = f[y];
        (!(zr.call(f, y) && $s(Y, w)) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function To(f, y) {
        for (var w = f.length; w--; )
          if ($s(f[w][0], y))
            return w;
        return -1;
      }
      function gh(f, y, w, Y) {
        return Ks(f, function(dt, Wt, sn) {
          y(Y, dt, w(dt), sn);
        }), Y;
      }
      function Xc(f, y) {
        return f && Ps(y, oi(y), f);
      }
      function yh(f, y) {
        return f && Ps(y, zi(y), f);
      }
      function Ns(f, y, w) {
        y == "__proto__" && Co ? Co(f, y, {
          configurable: !0,
          enumerable: !0,
          value: w,
          writable: !0
        }) : f[y] = w;
      }
      function lu(f, y) {
        for (var w = -1, Y = y.length, dt = xn(Y), Wt = f == null; ++w < Y; )
          dt[w] = Wt ? l : ec(f, y[w]);
        return dt;
      }
      function fa(f, y, w) {
        return f === f && (w !== l && (f = f <= w ? f : w), y !== l && (f = f >= y ? f : y)), f;
      }
      function Qi(f, y, w, Y, dt, Wt) {
        var sn, cn = y & P, pn = y & T, En = y & N;
        if (w && (sn = dt ? w(f, Y, dt, Wt) : w(f)), sn !== l)
          return sn;
        if (!Xr(f))
          return f;
        var In = pr(f);
        if (In) {
          if (sn = sm(f), !cn)
            return Vi(f, sn);
        } else {
          var Dn = Ei(f), qn = Dn == zn || Dn == jn;
          if (Ys(f))
            return Cd(f, cn);
          if (Dn == er || Dn == vn || qn && !dt) {
            if (sn = pn || qn ? {} : Bd(f), !cn)
              return pn ? qh(f, yh(sn, f)) : Gh(f, Xc(sn, f));
          } else {
            if (!Hr[Dn])
              return dt ? f : {};
            sn = am(f, Dn, cn);
          }
        }
        Wt || (Wt = new Ss());
        var nr = Wt.get(f);
        if (nr)
          return nr;
        Wt.set(f, sn), gf(f) ? f.forEach(function(ur) {
          sn.add(Qi(ur, y, w, ur, f, Wt));
        }) : hf(f) && f.forEach(function(ur, $r) {
          sn.set($r, Qi(ur, y, w, $r, f, Wt));
        });
        var lr = En ? pn ? Iu : Tu : pn ? zi : oi, gr = In ? l : lr(f);
        return Xi(gr || f, function(ur, $r) {
          gr && ($r = ur, ur = f[$r]), Wa(sn, $r, Qi(ur, y, w, $r, f, Wt));
        }), sn;
      }
      function vh(f) {
        var y = oi(f);
        return function(w) {
          return Zc(w, f, y);
        };
      }
      function Zc(f, y, w) {
        var Y = w.length;
        if (f == null)
          return !Y;
        for (f = Gr(f); Y--; ) {
          var dt = w[Y], Wt = y[dt], sn = f[dt];
          if (sn === l && !(dt in f) || !Wt(sn))
            return !1;
        }
        return !0;
      }
      function Jc(f, y, w) {
        if (typeof f != "function")
          throw new Zi(g);
        return no(function() {
          f.apply(l, w);
        }, y);
      }
      function Ga(f, y, w, Y) {
        var dt = -1, Wt = uo, sn = !0, cn = f.length, pn = [], En = y.length;
        if (!cn)
          return pn;
        w && (y = qr(y, Ui(w))), Y ? (Wt = ql, sn = !1) : y.length >= c && (Wt = Va, sn = !1, y = new da(y));
        e:
          for (; ++dt < cn; ) {
            var In = f[dt], Dn = w == null ? In : w(In);
            if (In = Y || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = En; qn--; )
                if (y[qn] === Dn)
                  continue e;
              pn.push(In);
            } else Wt(y, Dn, Y) || pn.push(In);
          }
        return pn;
      }
      var Ks = Ed(Es), Qc = Ed(cu, !0);
      function xh(f, y) {
        var w = !0;
        return Ks(f, function(Y, dt, Wt) {
          return w = !!y(Y, dt, Wt), w;
        }), w;
      }
      function Io(f, y, w) {
        for (var Y = -1, dt = f.length; ++Y < dt; ) {
          var Wt = f[Y], sn = y(Wt);
          if (sn != null && (cn === l ? sn === sn && !Wi(sn) : w(sn, cn)))
            var cn = sn, pn = Wt;
        }
        return pn;
      }
      function bh(f, y, w, Y) {
        var dt = f.length;
        for (w = hr(w), w < 0 && (w = -w > dt ? 0 : dt + w), Y = Y === l || Y > dt ? dt : hr(Y), Y < 0 && (Y += dt), Y = w > Y ? 0 : vf(Y); w < Y; )
          f[w++] = y;
        return f;
      }
      function ed(f, y) {
        var w = [];
        return Ks(f, function(Y, dt, Wt) {
          y(Y, dt, Wt) && w.push(Y);
        }), w;
      }
      function $i(f, y, w, Y, dt) {
        var Wt = -1, sn = f.length;
        for (w || (w = lm), dt || (dt = []); ++Wt < sn; ) {
          var cn = f[Wt];
          y > 0 && w(cn) ? y > 1 ? $i(cn, y - 1, w, Y, dt) : zs(dt, cn) : Y || (dt[dt.length] = cn);
        }
        return dt;
      }
      var uu = Pd(), td = Pd(!0);
      function Es(f, y) {
        return f && uu(f, y, oi);
      }
      function cu(f, y) {
        return f && td(f, y, oi);
      }
      function Ao(f, y) {
        return Bs(y, function(w) {
          return Os(f[w]);
        });
      }
      function pa(f, y) {
        y = Gs(y, f);
        for (var w = 0, Y = y.length; f != null && w < Y; )
          f = f[Ts(y[w++])];
        return w && w == Y ? f : l;
      }
      function nd(f, y, w) {
        var Y = y(f);
        return pr(f) ? Y : zs(Y, w(f));
      }
      function Ai(f) {
        return f == null ? f === l ? Wn : Zn : sa && sa in Gr(f) ? nm(f) : mm(f);
      }
      function du(f, y) {
        return f > y;
      }
      function Ch(f, y) {
        return f != null && zr.call(f, y);
      }
      function Sh(f, y) {
        return f != null && y in Gr(f);
      }
      function $h(f, y, w) {
        return f >= wi(y, w) && f < ri(y, w);
      }
      function fu(f, y, w) {
        for (var Y = w ? ql : uo, dt = f[0].length, Wt = f.length, sn = Wt, cn = xn(Wt), pn = 1 / 0, En = []; sn--; ) {
          var In = f[sn];
          sn && y && (In = qr(In, Ui(y))), pn = wi(In.length, pn), cn[sn] = !w && (y || dt >= 120 && In.length >= 120) ? new da(sn && In) : l;
        }
        In = f[0];
        var Dn = -1, qn = cn[0];
        e:
          for (; ++Dn < dt && En.length < pn; ) {
            var nr = In[Dn], lr = y ? y(nr) : nr;
            if (nr = w || nr !== 0 ? nr : 0, !(qn ? Va(qn, lr) : Y(En, lr, w))) {
              for (sn = Wt; --sn; ) {
                var gr = cn[sn];
                if (!(gr ? Va(gr, lr) : Y(f[sn], lr, w)))
                  continue e;
              }
              qn && qn.push(lr), En.push(nr);
            }
          }
        return En;
      }
      function wh(f, y, w, Y) {
        return Es(f, function(dt, Wt, sn) {
          y(Y, w(dt), Wt, sn);
        }), Y;
      }
      function qa(f, y, w) {
        y = Gs(y, f), f = Ud(f, y);
        var Y = f == null ? f : f[Ts(ys(y))];
        return Y == null ? l : Hi(Y, f, w);
      }
      function rd(f) {
        return Qr(f) && Ai(f) == vn;
      }
      function _h(f) {
        return Qr(f) && Ai(f) == Rn;
      }
      function Eh(f) {
        return Qr(f) && Ai(f) == Nn;
      }
      function Ya(f, y, w, Y, dt) {
        return f === y ? !0 : f == null || y == null || !Qr(f) && !Qr(y) ? f !== f && y !== y : Ph(f, y, w, Y, Ya, dt);
      }
      function Ph(f, y, w, Y, dt, Wt) {
        var sn = pr(f), cn = pr(y), pn = sn ? Pn : Ei(f), En = cn ? Pn : Ei(y);
        pn = pn == vn ? er : pn, En = En == vn ? er : En;
        var In = pn == er, Dn = En == er, qn = pn == En;
        if (qn && Ys(f)) {
          if (!Ys(y))
            return !1;
          sn = !0, In = !1;
        }
        if (qn && !In)
          return Wt || (Wt = new Ss()), sn || Aa(f) ? Ld(f, y, w, Y, dt, Wt) : em(f, y, pn, w, Y, dt, Wt);
        if (!(w & O)) {
          var nr = In && zr.call(f, "__wrapped__"), lr = Dn && zr.call(y, "__wrapped__");
          if (nr || lr) {
            var gr = nr ? f.value() : f, ur = lr ? y.value() : y;
            return Wt || (Wt = new Ss()), dt(gr, ur, w, Y, Wt);
          }
        }
        return qn ? (Wt || (Wt = new Ss()), tm(f, y, w, Y, dt, Wt)) : !1;
      }
      function Th(f) {
        return Qr(f) && Ei(f) == kn;
      }
      function pu(f, y, w, Y) {
        var dt = w.length, Wt = dt, sn = !Y;
        if (f == null)
          return !Wt;
        for (f = Gr(f); dt--; ) {
          var cn = w[dt];
          if (sn && cn[2] ? cn[1] !== f[cn[0]] : !(cn[0] in f))
            return !1;
        }
        for (; ++dt < Wt; ) {
          cn = w[dt];
          var pn = cn[0], En = f[pn], In = cn[1];
          if (sn && cn[2]) {
            if (En === l && !(pn in f))
              return !1;
          } else {
            var Dn = new Ss();
            if (Y)
              var qn = Y(En, In, pn, f, y, Dn);
            if (!(qn === l ? Ya(In, En, O | z, Y, Dn) : qn))
              return !1;
          }
        }
        return !0;
      }
      function id(f) {
        if (!Xr(f) || cm(f))
          return !1;
        var y = Os(f) ? Cp : uc;
        return y.test(ma(f));
      }
      function Ih(f) {
        return Qr(f) && Ai(f) == Kn;
      }
      function kh(f) {
        return Qr(f) && Ei(f) == Bn;
      }
      function Ah(f) {
        return Qr(f) && Pl(f.length) && !!Wr[Ai(f)];
      }
      function sd(f) {
        return typeof f == "function" ? f : f == null ? ji : typeof f == "object" ? pr(f) ? ld(f[0], f[1]) : od(f) : If(f);
      }
      function hu(f) {
        if (!to(f))
          return Tp(f);
        var y = [];
        for (var w in Gr(f))
          zr.call(f, w) && w != "constructor" && y.push(w);
        return y;
      }
      function Nh(f) {
        if (!Xr(f))
          return hm(f);
        var y = to(f), w = [];
        for (var Y in f)
          Y == "constructor" && (y || !zr.call(f, Y)) || w.push(Y);
        return w;
      }
      function mu(f, y) {
        return f < y;
      }
      function ad(f, y) {
        var w = -1, Y = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(dt, Wt, sn) {
          Y[++w] = y(dt, Wt, sn);
        }), Y;
      }
      function od(f) {
        var y = Nu(f);
        return y.length == 1 && y[0][2] ? jd(y[0][0], y[0][1]) : function(w) {
          return w === f || pu(w, f, y);
        };
      }
      function ld(f, y) {
        return Du(f) && zd(y) ? jd(Ts(f), y) : function(w) {
          var Y = ec(w, f);
          return Y === l && Y === y ? tc(w, f) : Ya(y, Y, O | z);
        };
      }
      function No(f, y, w, Y, dt) {
        f !== y && uu(y, function(Wt, sn) {
          if (dt || (dt = new Ss()), Xr(Wt))
            Fh(f, y, sn, w, No, Y, dt);
          else {
            var cn = Y ? Y(Ou(f, sn), Wt, sn + "", f, y, dt) : l;
            cn === l && (cn = Wt), ou(f, sn, cn);
          }
        }, zi);
      }
      function Fh(f, y, w, Y, dt, Wt, sn) {
        var cn = Ou(f, w), pn = Ou(y, w), En = sn.get(pn);
        if (En) {
          ou(f, w, En);
          return;
        }
        var In = Wt ? Wt(cn, pn, w + "", f, y, sn) : l, Dn = In === l;
        if (Dn) {
          var qn = pr(pn), nr = !qn && Ys(pn), lr = !qn && !nr && Aa(pn);
          In = pn, qn || nr || lr ? pr(cn) ? In = cn : ei(cn) ? In = Vi(cn) : nr ? (Dn = !1, In = Cd(pn, !0)) : lr ? (Dn = !1, In = Sd(pn, !0)) : In = [] : ro(pn) || ga(pn) ? (In = cn, ga(cn) ? In = xf(cn) : (!Xr(cn) || Os(cn)) && (In = Bd(pn))) : Dn = !1;
        }
        Dn && (sn.set(pn, In), dt(In, pn, Y, Wt, sn), sn.delete(pn)), ou(f, w, In);
      }
      function ud(f, y) {
        var w = f.length;
        if (w)
          return y += y < 0 ? w : 0, Rs(y, w) ? f[y] : l;
      }
      function cd(f, y, w) {
        y.length ? y = qr(y, function(Wt) {
          return pr(Wt) ? function(sn) {
            return pa(sn, Wt.length === 1 ? Wt[0] : Wt);
          } : Wt;
        }) : y = [ji];
        var Y = -1;
        y = qr(y, Ui(or()));
        var dt = ad(f, function(Wt, sn, cn) {
          var pn = qr(y, function(En) {
            return En(Wt);
          });
          return { criteria: pn, index: ++Y, value: Wt };
        });
        return Jf(dt, function(Wt, sn) {
          return Wh(Wt, sn, w);
        });
      }
      function Dh(f, y) {
        return dd(f, y, function(w, Y) {
          return tc(f, Y);
        });
      }
      function dd(f, y, w) {
        for (var Y = -1, dt = y.length, Wt = {}; ++Y < dt; ) {
          var sn = y[Y], cn = pa(f, sn);
          w(cn, sn) && Xa(Wt, Gs(sn, f), cn);
        }
        return Wt;
      }
      function Rh(f) {
        return function(y) {
          return pa(y, f);
        };
      }
      function gu(f, y, w, Y) {
        var dt = Y ? Zf : xa, Wt = -1, sn = y.length, cn = f;
        for (f === y && (y = Vi(y)), w && (cn = qr(f, Ui(w))); ++Wt < sn; )
          for (var pn = 0, En = y[Wt], In = w ? w(En) : En; (pn = dt(cn, In, pn, Y)) > -1; )
            cn !== f && bo.call(cn, pn, 1), bo.call(f, pn, 1);
        return f;
      }
      function fd(f, y) {
        for (var w = f ? y.length : 0, Y = w - 1; w--; ) {
          var dt = y[w];
          if (w == Y || dt !== Wt) {
            var Wt = dt;
            Rs(dt) ? bo.call(f, dt, 1) : bu(f, dt);
          }
        }
        return f;
      }
      function yu(f, y) {
        return f + wo(Wc() * (y - f + 1));
      }
      function Oh(f, y, w, Y) {
        for (var dt = -1, Wt = ri(So((y - f) / (w || 1)), 0), sn = xn(Wt); Wt--; )
          sn[Y ? Wt : ++dt] = f, f += w;
        return sn;
      }
      function vu(f, y) {
        var w = "";
        if (!f || y < 1 || y > vt)
          return w;
        do
          y % 2 && (w += f), y = wo(y / 2), y && (f += f);
        while (y);
        return w;
      }
      function vr(f, y) {
        return Lu(Hd(f, y, ji), f + "");
      }
      function Lh(f) {
        return Yc(Na(f));
      }
      function Mh(f, y) {
        var w = Na(f);
        return xl(w, fa(y, 0, w.length));
      }
      function Xa(f, y, w, Y) {
        if (!Xr(f))
          return f;
        y = Gs(y, f);
        for (var dt = -1, Wt = y.length, sn = Wt - 1, cn = f; cn != null && ++dt < Wt; ) {
          var pn = Ts(y[dt]), En = w;
          if (pn === "__proto__" || pn === "constructor" || pn === "prototype")
            return f;
          if (dt != sn) {
            var In = cn[pn];
            En = Y ? Y(In, pn, cn) : l, En === l && (En = Xr(In) ? In : Rs(y[dt + 1]) ? [] : {});
          }
          Wa(cn, pn, En), cn = cn[pn];
        }
        return f;
      }
      var pd = _o ? function(f, y) {
        return _o.set(f, y), f;
      } : ji, Vh = Co ? function(f, y) {
        return Co(f, "toString", {
          configurable: !0,
          enumerable: !1,
          value: rc(y),
          writable: !0
        });
      } : ji;
      function Bh(f) {
        return xl(Na(f));
      }
      function ms(f, y, w) {
        var Y = -1, dt = f.length;
        y < 0 && (y = -y > dt ? 0 : dt + y), w = w > dt ? dt : w, w < 0 && (w += dt), dt = y > w ? 0 : w - y >>> 0, y >>>= 0;
        for (var Wt = xn(dt); ++Y < dt; )
          Wt[Y] = f[Y + y];
        return Wt;
      }
      function zh(f, y) {
        var w;
        return Ks(f, function(Y, dt, Wt) {
          return w = y(Y, dt, Wt), !w;
        }), !!w;
      }
      function Do(f, y, w) {
        var Y = 0, dt = f == null ? Y : f.length;
        if (typeof y == "number" && y === y && dt <= dn) {
          for (; Y < dt; ) {
            var Wt = Y + dt >>> 1, sn = f[Wt];
            sn !== null && !Wi(sn) && (w ? sn <= y : sn < y) ? Y = Wt + 1 : dt = Wt;
          }
          return dt;
        }
        return xu(f, y, ji, w);
      }
      function xu(f, y, w, Y) {
        var dt = 0, Wt = f == null ? 0 : f.length;
        if (Wt === 0)
          return 0;
        y = w(y);
        for (var sn = y !== y, cn = y === null, pn = Wi(y), En = y === l; dt < Wt; ) {
          var In = wo((dt + Wt) / 2), Dn = w(f[In]), qn = Dn !== l, nr = Dn === null, lr = Dn === Dn, gr = Wi(Dn);
          if (sn)
            var ur = Y || lr;
          else En ? ur = lr && (Y || qn) : cn ? ur = lr && qn && (Y || !nr) : pn ? ur = lr && qn && !nr && (Y || !gr) : nr || gr ? ur = !1 : ur = Y ? Dn <= y : Dn < y;
          ur ? dt = In + 1 : Wt = In;
        }
        return wi(Wt, gn);
      }
      function hd(f, y) {
        for (var w = -1, Y = f.length, dt = 0, Wt = []; ++w < Y; ) {
          var sn = f[w], cn = y ? y(sn) : sn;
          if (!w || !$s(cn, pn)) {
            var pn = cn;
            Wt[dt++] = sn === 0 ? 0 : sn;
          }
        }
        return Wt;
      }
      function gd(f) {
        return typeof f == "number" ? f : Wi(f) ? Qt : +f;
      }
      function Ki(f) {
        if (typeof f == "string")
          return f;
        if (pr(f))
          return qr(f, Ki) + "";
        if (Wi(f))
          return Gc ? Gc.call(f) : "";
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function Ws(f, y, w) {
        var Y = -1, dt = uo, Wt = f.length, sn = !0, cn = [], pn = cn;
        if (w)
          sn = !1, dt = ql;
        else if (Wt >= c) {
          var En = y ? null : Jh(f);
          if (En)
            return fo(En);
          sn = !1, dt = Va, pn = new da();
        } else
          pn = y ? [] : cn;
        e:
          for (; ++Y < Wt; ) {
            var In = f[Y], Dn = y ? y(In) : In;
            if (In = w || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = pn.length; qn--; )
                if (pn[qn] === Dn)
                  continue e;
              y && pn.push(Dn), cn.push(In);
            } else dt(pn, Dn, w) || (pn !== cn && pn.push(Dn), cn.push(In));
          }
        return cn;
      }
      function bu(f, y) {
        return y = Gs(y, f), f = Ud(f, y), f == null || delete f[Ts(ys(y))];
      }
      function yd(f, y, w, Y) {
        return Xa(f, y, w(pa(f, y)), Y);
      }
      function Ro(f, y, w, Y) {
        for (var dt = f.length, Wt = Y ? dt : -1; (Y ? Wt-- : ++Wt < dt) && y(f[Wt], Wt, f); )
          ;
        return w ? ms(f, Y ? 0 : Wt, Y ? Wt + 1 : dt) : ms(f, Y ? Wt + 1 : 0, Y ? dt : Wt);
      }
      function vd(f, y) {
        var w = f;
        return w instanceof Pr && (w = w.value()), Yl(y, function(Y, dt) {
          return dt.func.apply(dt.thisArg, zs([Y], dt.args));
        }, w);
      }
      function Cu(f, y, w) {
        var Y = f.length;
        if (Y < 2)
          return Y ? Ws(f[0]) : [];
        for (var dt = -1, Wt = xn(Y); ++dt < Y; )
          for (var sn = f[dt], cn = -1; ++cn < Y; )
            cn != dt && (Wt[dt] = Ga(Wt[dt] || sn, f[cn], y, w));
        return Ws($i(Wt, 1), y, w);
      }
      function xd(f, y, w) {
        for (var Y = -1, dt = f.length, Wt = y.length, sn = {}; ++Y < dt; ) {
          var cn = Y < Wt ? y[Y] : l;
          w(sn, f[Y], cn);
        }
        return sn;
      }
      function Su(f) {
        return ei(f) ? f : [];
      }
      function wu(f) {
        return typeof f == "function" ? f : ji;
      }
      function Gs(f, y) {
        return pr(f) ? f : Du(f, y) ? [f] : qd(Vr(f));
      }
      var jh = vr;
      function qs(f, y, w) {
        var Y = f.length;
        return w = w === l ? Y : w, !y && w >= Y ? f : ms(f, y, w);
      }
      var bd = Sp || function(f) {
        return di.clearTimeout(f);
      };
      function Cd(f, y) {
        if (y)
          return f.slice();
        var w = f.length, Y = zc ? zc(w) : new f.constructor(w);
        return f.copy(Y), Y;
      }
      function _u(f) {
        var y = new f.constructor(f.byteLength);
        return new vo(y).set(new vo(f)), y;
      }
      function Hh(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.byteLength);
      }
      function Uh(f) {
        var y = new f.constructor(f.source, so.exec(f));
        return y.lastIndex = f.lastIndex, y;
      }
      function Kh(f) {
        return Ka ? Gr(Ka.call(f)) : {};
      }
      function Sd(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.length);
      }
      function $d(f, y) {
        if (f !== y) {
          var w = f !== l, Y = f === null, dt = f === f, Wt = Wi(f), sn = y !== l, cn = y === null, pn = y === y, En = Wi(y);
          if (!cn && !En && !Wt && f > y || Wt && sn && pn && !cn && !En || Y && sn && pn || !w && pn || !dt)
            return 1;
          if (!Y && !Wt && !En && f < y || En && w && dt && !Y && !Wt || cn && w && dt || !sn && dt || !pn)
            return -1;
        }
        return 0;
      }
      function Wh(f, y, w) {
        for (var Y = -1, dt = f.criteria, Wt = y.criteria, sn = dt.length, cn = w.length; ++Y < sn; ) {
          var pn = $d(dt[Y], Wt[Y]);
          if (pn) {
            if (Y >= cn)
              return pn;
            var En = w[Y];
            return pn * (En == "desc" ? -1 : 1);
          }
        }
        return f.index - y.index;
      }
      function wd(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = w.length, cn = -1, pn = y.length, En = ri(Wt - sn, 0), In = xn(pn + En), Dn = !Y; ++cn < pn; )
          In[cn] = y[cn];
        for (; ++dt < sn; )
          (Dn || dt < Wt) && (In[w[dt]] = f[dt]);
        for (; En--; )
          In[cn++] = f[dt++];
        return In;
      }
      function _d(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = -1, cn = w.length, pn = -1, En = y.length, In = ri(Wt - cn, 0), Dn = xn(In + En), qn = !Y; ++dt < In; )
          Dn[dt] = f[dt];
        for (var nr = dt; ++pn < En; )
          Dn[nr + pn] = y[pn];
        for (; ++sn < cn; )
          (qn || dt < Wt) && (Dn[nr + w[sn]] = f[dt++]);
        return Dn;
      }
      function Vi(f, y) {
        var w = -1, Y = f.length;
        for (y || (y = xn(Y)); ++w < Y; )
          y[w] = f[w];
        return y;
      }
      function Ps(f, y, w, Y) {
        var dt = !w;
        w || (w = {});
        for (var Wt = -1, sn = y.length; ++Wt < sn; ) {
          var cn = y[Wt], pn = Y ? Y(w[cn], f[cn], cn, w, f) : l;
          pn === l && (pn = f[cn]), dt ? Ns(w, cn, pn) : Wa(w, cn, pn);
        }
        return w;
      }
      function Gh(f, y) {
        return Ps(f, Fu(f), y);
      }
      function qh(f, y) {
        return Ps(f, Md(f), y);
      }
      function Oo(f, y) {
        return function(w, Y) {
          var dt = pr(w) ? Kf : gh, Wt = y ? y() : {};
          return dt(w, f, or(Y, 2), Wt);
        };
      }
      function Ta(f) {
        return vr(function(y, w) {
          var Y = -1, dt = w.length, Wt = dt > 1 ? w[dt - 1] : l, sn = dt > 2 ? w[2] : l;
          for (Wt = f.length > 3 && typeof Wt == "function" ? (dt--, Wt) : l, sn && Ni(w[0], w[1], sn) && (Wt = dt < 3 ? l : Wt, dt = 1), y = Gr(y); ++Y < dt; ) {
            var cn = w[Y];
            cn && f(y, cn, Y, Wt);
          }
          return y;
        });
      }
      function Ed(f, y) {
        return function(w, Y) {
          if (w == null)
            return w;
          if (!Bi(w))
            return f(w, Y);
          for (var dt = w.length, Wt = y ? dt : -1, sn = Gr(w); (y ? Wt-- : ++Wt < dt) && Y(sn[Wt], Wt, sn) !== !1; )
            ;
          return w;
        };
      }
      function Pd(f) {
        return function(y, w, Y) {
          for (var dt = -1, Wt = Gr(y), sn = Y(y), cn = sn.length; cn--; ) {
            var pn = sn[f ? cn : ++dt];
            if (w(Wt[pn], pn, Wt) === !1)
              break;
          }
          return y;
        };
      }
      function Yh(f, y, w) {
        var Y = y & Q, dt = eo(f);
        function Wt() {
          var sn = this && this !== di && this instanceof Wt ? dt : f;
          return sn.apply(Y ? w : this, arguments);
        }
        return Wt;
      }
      function Td(f) {
        return function(y) {
          y = Vr(y);
          var w = ba(y) ? Cs(y) : l, Y = w ? w[0] : y.charAt(0), dt = w ? qs(w, 1).join("") : y.slice(1);
          return Y[f]() + dt;
        };
      }
      function Ia(f) {
        return function(y) {
          return Yl(Pf(Ef(y).replace(Kr, "")), f, "");
        };
      }
      function eo(f) {
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return new f();
            case 1:
              return new f(y[0]);
            case 2:
              return new f(y[0], y[1]);
            case 3:
              return new f(y[0], y[1], y[2]);
            case 4:
              return new f(y[0], y[1], y[2], y[3]);
            case 5:
              return new f(y[0], y[1], y[2], y[3], y[4]);
            case 6:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5]);
            case 7:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5], y[6]);
          }
          var w = Pa(f.prototype), Y = f.apply(w, y);
          return Xr(Y) ? Y : w;
        };
      }
      function Xh(f, y, w) {
        var Y = eo(f);
        function dt() {
          for (var Wt = arguments.length, sn = xn(Wt), cn = Wt, pn = ka(dt); cn--; )
            sn[cn] = arguments[cn];
          var En = Wt < 3 && sn[0] !== pn && sn[Wt - 1] !== pn ? [] : Hs(sn, pn);
          if (Wt -= En.length, Wt < w)
            return Fd(
              f,
              y,
              Lo,
              dt.placeholder,
              l,
              sn,
              En,
              l,
              l,
              w - Wt
            );
          var In = this && this !== di && this instanceof dt ? Y : f;
          return Hi(In, this, sn);
        }
        return dt;
      }
      function Id(f) {
        return function(y, w, Y) {
          var dt = Gr(y);
          if (!Bi(y)) {
            var Wt = or(w, 3);
            y = oi(y), w = function(cn) {
              return Wt(dt[cn], cn, dt);
            };
          }
          var sn = f(y, w, Y);
          return sn > -1 ? dt[Wt ? y[sn] : sn] : l;
        };
      }
      function kd(f) {
        return Ds(function(y) {
          var w = y.length, Y = w, dt = Ji.prototype.thru;
          for (f && y.reverse(); Y--; ) {
            var Wt = y[Y];
            if (typeof Wt != "function")
              throw new Zi(g);
            if (dt && !sn && Jo(Wt) == "wrapper")
              var sn = new Ji([], !0);
          }
          for (Y = sn ? Y : w; ++Y < w; ) {
            Wt = y[Y];
            var cn = Jo(Wt), pn = cn == "wrapper" ? Au(Wt) : l;
            pn && Ru(pn[0]) && pn[1] == (Re | te | ve | wt) && !pn[4].length && pn[9] == 1 ? sn = sn[Jo(pn[0])].apply(sn, pn[3]) : sn = Wt.length == 1 && Ru(Wt) ? sn[cn]() : sn.thru(Wt);
          }
          return function() {
            var En = arguments, In = En[0];
            if (sn && En.length == 1 && pr(In))
              return sn.plant(In).value();
            for (var Dn = 0, qn = w ? y[Dn].apply(this, En) : In; ++Dn < w; )
              qn = y[Dn].call(this, qn);
            return qn;
          };
        });
      }
      function Lo(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & Re, Dn = y & Q, qn = y & W, nr = y & (te | K), lr = y & yt, gr = qn ? l : eo(f);
        function ur() {
          for (var $r = arguments.length, Ir = xn($r), Gi = $r; Gi--; )
            Ir[Gi] = arguments[Gi];
          if (nr)
            var Fi = ka(ur), qi = ep(Ir, Fi);
          if (Y && (Ir = wd(Ir, Y, dt, nr)), Wt && (Ir = _d(Ir, Wt, sn, nr)), $r -= qi, nr && $r < En) {
            var ti = Hs(Ir, Fi);
            return Fd(
              f,
              y,
              Lo,
              ur.placeholder,
              w,
              Ir,
              ti,
              cn,
              pn,
              En - $r
            );
          }
          var ws = Dn ? w : this, Ms = qn ? ws[f] : f;
          return $r = Ir.length, cn ? Ir = gm(Ir, cn) : lr && $r > 1 && Ir.reverse(), In && pn < $r && (Ir.length = pn), this && this !== di && this instanceof ur && (Ms = gr || eo(Ms)), Ms.apply(ws, Ir);
        }
        return ur;
      }
      function Ad(f, y) {
        return function(w, Y) {
          return wh(w, f, y(Y), {});
        };
      }
      function Mo(f, y) {
        return function(w, Y) {
          var dt;
          if (w === l && Y === l)
            return y;
          if (w !== l && (dt = w), Y !== l) {
            if (dt === l)
              return Y;
            typeof w == "string" || typeof Y == "string" ? (w = Ki(w), Y = Ki(Y)) : (w = gd(w), Y = gd(Y)), dt = f(w, Y);
          }
          return dt;
        };
      }
      function Eu(f) {
        return Ds(function(y) {
          return y = qr(y, Ui(or())), vr(function(w) {
            var Y = this;
            return f(y, function(dt) {
              return Hi(dt, Y, w);
            });
          });
        });
      }
      function Bo(f, y) {
        y = y === l ? " " : Ki(y);
        var w = y.length;
        if (w < 2)
          return w ? vu(y, f) : y;
        var Y = vu(y, So(f / Ca(y)));
        return ba(y) ? qs(Cs(Y), 0, f).join("") : Y.slice(0, f);
      }
      function Zh(f, y, w, Y) {
        var dt = y & Q, Wt = eo(f);
        function sn() {
          for (var cn = -1, pn = arguments.length, En = -1, In = Y.length, Dn = xn(In + pn), qn = this && this !== di && this instanceof sn ? Wt : f; ++En < In; )
            Dn[En] = Y[En];
          for (; pn--; )
            Dn[En++] = arguments[++cn];
          return Hi(qn, dt ? w : this, Dn);
        }
        return sn;
      }
      function Nd(f) {
        return function(y, w, Y) {
          return Y && typeof Y != "number" && Ni(y, w, Y) && (w = Y = l), y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), Y = Y === l ? y < w ? 1 : -1 : Ls(Y), Oh(y, w, Y, f);
        };
      }
      function Zo(f) {
        return function(y, w) {
          return typeof y == "string" && typeof w == "string" || (y = xs(y), w = xs(w)), f(y, w);
        };
      }
      function Fd(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & te, Dn = In ? sn : l, qn = In ? l : sn, nr = In ? Wt : l, lr = In ? l : Wt;
        y |= In ? ve : ee, y &= ~(In ? ee : ve), y & ue || (y &= ~(Q | W));
        var gr = [
          f,
          y,
          dt,
          nr,
          Dn,
          lr,
          qn,
          cn,
          pn,
          En
        ], ur = w.apply(l, gr);
        return Ru(f) && Kd(ur, gr), ur.placeholder = Y, Wd(ur, f, y);
      }
      function Pu(f) {
        var y = ni[f];
        return function(w, Y) {
          if (w = xs(w), Y = Y == null ? 0 : wi(hr(Y), 292), Y && Kc(w)) {
            var dt = (Vr(w) + "e").split("e"), Wt = y(dt[0] + "e" + (+dt[1] + Y));
            return dt = (Vr(Wt) + "e").split("e"), +(dt[0] + "e" + (+dt[1] - Y));
          }
          return y(w);
        };
      }
      var Jh = wa && 1 / fo(new wa([, -0]))[1] == nn ? function(f) {
        return new wa(f);
      } : ac;
      function Dd(f) {
        return function(y) {
          var w = Ei(y);
          return w == kn ? nu(y) : w == Bn ? op(y) : Qf(y, f(y));
        };
      }
      function Fs(f, y, w, Y, dt, Wt, sn, cn) {
        var pn = y & W;
        if (!pn && typeof f != "function")
          throw new Zi(g);
        var En = Y ? Y.length : 0;
        if (En || (y &= ~(ve | ee), Y = dt = l), sn = sn === l ? sn : ri(hr(sn), 0), cn = cn === l ? cn : hr(cn), En -= dt ? dt.length : 0, y & ee) {
          var In = Y, Dn = dt;
          Y = dt = l;
        }
        var qn = pn ? l : Au(f), nr = [
          f,
          y,
          w,
          Y,
          dt,
          In,
          Dn,
          Wt,
          sn,
          cn
        ];
        if (qn && pm(nr, qn), f = nr[0], y = nr[1], w = nr[2], Y = nr[3], dt = nr[4], cn = nr[9] = nr[9] === l ? pn ? 0 : f.length : ri(nr[9] - En, 0), !cn && y & (te | K) && (y &= ~(te | K)), !y || y == Q)
          var lr = Yh(f, y, w);
        else y == te || y == K ? lr = Xh(f, y, cn) : (y == ve || y == (Q | ve)) && !dt.length ? lr = Zh(f, y, w, Y) : lr = Lo.apply(l, nr);
        var gr = qn ? pd : Kd;
        return Wd(gr(lr, nr), f, y);
      }
      function Rd(f, y, w, Y) {
        return f === l || $s(f, $a[w]) && !zr.call(Y, w) ? y : f;
      }
      function Od(f, y, w, Y, dt, Wt) {
        return Xr(f) && Xr(y) && (Wt.set(y, f), No(f, y, l, Od, Wt), Wt.delete(y)), f;
      }
      function Qh(f) {
        return ro(f) ? l : f;
      }
      function Ld(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = f.length, pn = y.length;
        if (cn != pn && !(sn && pn > cn))
          return !1;
        var En = Wt.get(f), In = Wt.get(y);
        if (En && In)
          return En == y && In == f;
        var Dn = -1, qn = !0, nr = w & z ? new da() : l;
        for (Wt.set(f, y), Wt.set(y, f); ++Dn < cn; ) {
          var lr = f[Dn], gr = y[Dn];
          if (Y)
            var ur = sn ? Y(gr, lr, Dn, y, f, Wt) : Y(lr, gr, Dn, f, y, Wt);
          if (ur !== l) {
            if (ur)
              continue;
            qn = !1;
            break;
          }
          if (nr) {
            if (!Xl(y, function($r, Ir) {
              if (!Va(nr, Ir) && (lr === $r || dt(lr, $r, w, Y, Wt)))
                return nr.push(Ir);
            })) {
              qn = !1;
              break;
            }
          } else if (!(lr === gr || dt(lr, gr, w, Y, Wt))) {
            qn = !1;
            break;
          }
        }
        return Wt.delete(f), Wt.delete(y), qn;
      }
      function em(f, y, w, Y, dt, Wt, sn) {
        switch (w) {
          case hn:
            if (f.byteLength != y.byteLength || f.byteOffset != y.byteOffset)
              return !1;
            f = f.buffer, y = y.buffer;
          case Rn:
            return !(f.byteLength != y.byteLength || !Wt(new vo(f), new vo(y)));
          case _n:
          case Nn:
          case Yn:
            return $s(+f, +y);
          case Xn:
            return f.name == y.name && f.message == y.message;
          case Kn:
          case Fn:
            return f == y + "";
          case kn:
            var cn = nu;
          case Bn:
            var pn = Y & O;
            if (cn || (cn = fo), f.size != y.size && !pn)
              return !1;
            var En = sn.get(f);
            if (En)
              return En == y;
            Y |= z, sn.set(f, y);
            var In = Ld(cn(f), cn(y), Y, dt, Wt, sn);
            return sn.delete(f), In;
          case Gn:
            if (Ka)
              return Ka.call(f) == Ka.call(y);
        }
        return !1;
      }
      function tm(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = Tu(f), pn = cn.length, En = Tu(y), In = En.length;
        if (pn != In && !sn)
          return !1;
        for (var Dn = pn; Dn--; ) {
          var qn = cn[Dn];
          if (!(sn ? qn in y : zr.call(y, qn)))
            return !1;
        }
        var nr = Wt.get(f), lr = Wt.get(y);
        if (nr && lr)
          return nr == y && lr == f;
        var gr = !0;
        Wt.set(f, y), Wt.set(y, f);
        for (var ur = sn; ++Dn < pn; ) {
          qn = cn[Dn];
          var $r = f[qn], Ir = y[qn];
          if (Y)
            var Gi = sn ? Y(Ir, $r, qn, y, f, Wt) : Y($r, Ir, qn, f, y, Wt);
          if (!(Gi === l ? $r === Ir || dt($r, Ir, w, Y, Wt) : Gi)) {
            gr = !1;
            break;
          }
          ur || (ur = qn == "constructor");
        }
        if (gr && !ur) {
          var Fi = f.constructor, qi = y.constructor;
          Fi != qi && "constructor" in f && "constructor" in y && !(typeof Fi == "function" && Fi instanceof Fi && typeof qi == "function" && qi instanceof qi) && (gr = !1);
        }
        return Wt.delete(f), Wt.delete(y), gr;
      }
      function Ds(f) {
        return Lu(Hd(f, l, Jd), f + "");
      }
      function Tu(f) {
        return nd(f, oi, Fu);
      }
      function Iu(f) {
        return nd(f, zi, Md);
      }
      var Au = _o ? function(f) {
        return _o.get(f);
      } : ac;
      function Jo(f) {
        for (var y = f.name + "", w = Ea[y], Y = zr.call(Ea, y) ? w.length : 0; Y--; ) {
          var dt = w[Y], Wt = dt.func;
          if (Wt == null || Wt == f)
            return dt.name;
        }
        return y;
      }
      function ka(f) {
        var y = zr.call(Ft, "placeholder") ? Ft : f;
        return y.placeholder;
      }
      function or() {
        var f = Ft.iteratee || ic;
        return f = f === ic ? sd : f, arguments.length ? f(arguments[0], arguments[1]) : f;
      }
      function el(f, y) {
        var w = f.__data__;
        return um(y) ? w[typeof y == "string" ? "string" : "hash"] : w.map;
      }
      function Nu(f) {
        for (var y = oi(f), w = y.length; w--; ) {
          var Y = y[w], dt = f[Y];
          y[w] = [Y, dt, zd(dt)];
        }
        return y;
      }
      function ha(f, y) {
        var w = ip(f, y);
        return id(w) ? w : l;
      }
      function nm(f) {
        var y = zr.call(f, sa), w = f[sa];
        try {
          f[sa] = l;
          var Y = !0;
        } catch {
        }
        var dt = go.call(f);
        return Y && (y ? f[sa] = w : delete f[sa]), dt;
      }
      var Fu = iu ? function(f) {
        return f == null ? [] : (f = Gr(f), Bs(iu(f), function(y) {
          return Hc.call(f, y);
        }));
      } : oc, Md = iu ? function(f) {
        for (var y = []; f; )
          zs(y, Fu(f)), f = xo(f);
        return y;
      } : oc, Ei = Ai;
      (su && Ei(new su(new ArrayBuffer(1))) != hn || za && Ei(new za()) != kn || au && Ei(au.resolve()) != bn || wa && Ei(new wa()) != Bn || ja && Ei(new ja()) != Mn) && (Ei = function(f) {
        var y = Ai(f), w = y == er ? f.constructor : l, Y = w ? ma(w) : "";
        if (Y)
          switch (Y) {
            case Fp:
              return hn;
            case Dp:
              return kn;
            case Rp:
              return bn;
            case Op:
              return Bn;
            case Lp:
              return Mn;
          }
        return y;
      });
      function rm(f, y, w) {
        for (var Y = -1, dt = w.length; ++Y < dt; ) {
          var Wt = w[Y], sn = Wt.size;
          switch (Wt.type) {
            case "drop":
              f += sn;
              break;
            case "dropRight":
              y -= sn;
              break;
            case "take":
              y = wi(y, f + sn);
              break;
            case "takeRight":
              f = ri(f, y - sn);
              break;
          }
        }
        return { start: f, end: y };
      }
      function im(f) {
        var y = f.match(Is);
        return y ? y[1].split(Fa) : [];
      }
      function Vd(f, y, w) {
        y = Gs(y, f);
        for (var Y = -1, dt = y.length, Wt = !1; ++Y < dt; ) {
          var sn = Ts(y[Y]);
          if (!(Wt = f != null && w(f, sn)))
            break;
          f = f[sn];
        }
        return Wt || ++Y != dt ? Wt : (dt = f == null ? 0 : f.length, !!dt && Pl(dt) && Rs(sn, dt) && (pr(f) || ga(f)));
      }
      function sm(f) {
        var y = f.length, w = new f.constructor(y);
        return y && typeof f[0] == "string" && zr.call(f, "index") && (w.index = f.index, w.input = f.input), w;
      }
      function Bd(f) {
        return typeof f.constructor == "function" && !to(f) ? Pa(xo(f)) : {};
      }
      function am(f, y, w) {
        var Y = f.constructor;
        switch (y) {
          case Rn:
            return _u(f);
          case _n:
          case Nn:
            return new Y(+f);
          case hn:
            return Hh(f, w);
          case Qn:
          case rr:
          case tr:
          case Cr:
          case Fr:
          case An:
          case Hn:
          case ir:
          case dr:
            return Sd(f, w);
          case kn:
            return new Y();
          case Yn:
          case Fn:
            return new Y(f);
          case Kn:
            return Uh(f);
          case Bn:
            return new Y();
          case Gn:
            return Kh(f);
        }
      }
      function om(f, y) {
        var w = y.length;
        if (!w)
          return f;
        var Y = w - 1;
        return y[Y] = (w > 1 ? "& " : "") + y[Y], y = y.join(w > 2 ? ", " : " "), f.replace(_s, `{
/* [wrapped with ` + y + `] */
`);
      }
      function lm(f) {
        return pr(f) || ga(f) || !!(Uc && f && f[Uc]);
      }
      function Rs(f, y) {
        var w = typeof f;
        return y = y ?? vt, !!y && (w == "number" || w != "symbol" && Ma.test(f)) && f > -1 && f % 1 == 0 && f < y;
      }
      function Ni(f, y, w) {
        if (!Xr(w))
          return !1;
        var Y = typeof y;
        return (Y == "number" ? Bi(w) && Rs(y, w.length) : Y == "string" && y in w) ? $s(w[y], f) : !1;
      }
      function Du(f, y) {
        if (pr(f))
          return !1;
        var w = typeof f;
        return w == "number" || w == "symbol" || w == "boolean" || f == null || Wi(f) ? !0 : Mi.test(f) || !Ti.test(f) || y != null && f in Gr(y);
      }
      function um(f) {
        var y = typeof f;
        return y == "string" || y == "number" || y == "symbol" || y == "boolean" ? f !== "__proto__" : f === null;
      }
      function Ru(f) {
        var y = Jo(f), w = Ft[y];
        if (typeof w != "function" || !(y in Pr.prototype))
          return !1;
        if (f === w)
          return !0;
        var Y = Au(w);
        return !!Y && f === Y[0];
      }
      function cm(f) {
        return !!Bc && Bc in f;
      }
      var dm = ho ? Os : lc;
      function to(f) {
        var y = f && f.constructor, w = typeof y == "function" && y.prototype || $a;
        return f === w;
      }
      function zd(f) {
        return f === f && !Xr(f);
      }
      function jd(f, y) {
        return function(w) {
          return w == null ? !1 : w[f] === y && (y !== l || f in Gr(w));
        };
      }
      function fm(f) {
        var y = $l(f, function(Y) {
          return w.size === S && w.clear(), Y;
        }), w = y.cache;
        return y;
      }
      function pm(f, y) {
        var w = f[1], Y = y[1], dt = w | Y, Wt = dt < (Q | W | Re), sn = Y == Re && w == te || Y == Re && w == wt && f[7].length <= y[8] || Y == (Re | wt) && y[7].length <= y[8] && w == te;
        if (!(Wt || sn))
          return f;
        Y & Q && (f[2] = y[2], dt |= w & Q ? 0 : ue);
        var cn = y[3];
        if (cn) {
          var pn = f[3];
          f[3] = pn ? wd(pn, cn, y[4]) : cn, f[4] = pn ? Hs(f[3], E) : y[4];
        }
        return cn = y[5], cn && (pn = f[5], f[5] = pn ? _d(pn, cn, y[6]) : cn, f[6] = pn ? Hs(f[5], E) : y[6]), cn = y[7], cn && (f[7] = cn), Y & Re && (f[8] = f[8] == null ? y[8] : wi(f[8], y[8])), f[9] == null && (f[9] = y[9]), f[0] = y[0], f[1] = dt, f;
      }
      function hm(f) {
        var y = [];
        if (f != null)
          for (var w in Gr(f))
            y.push(w);
        return y;
      }
      function mm(f) {
        return go.call(f);
      }
      function Hd(f, y, w) {
        return y = ri(y === l ? f.length - 1 : y, 0), function() {
          for (var Y = arguments, dt = -1, Wt = ri(Y.length - y, 0), sn = xn(Wt); ++dt < Wt; )
            sn[dt] = Y[y + dt];
          dt = -1;
          for (var cn = xn(y + 1); ++dt < y; )
            cn[dt] = Y[dt];
          return cn[y] = w(sn), Hi(f, this, cn);
        };
      }
      function Ud(f, y) {
        return y.length < 2 ? f : pa(f, ms(y, 0, -1));
      }
      function gm(f, y) {
        for (var w = f.length, Y = wi(y.length, w), dt = Vi(f); Y--; ) {
          var Wt = y[Y];
          f[Y] = Rs(Wt, w) ? dt[Wt] : l;
        }
        return f;
      }
      function Ou(f, y) {
        if (!(y === "constructor" && typeof f[y] == "function") && y != "__proto__")
          return f[y];
      }
      var Kd = Gd(pd), no = _p || function(f, y) {
        return di.setTimeout(f, y);
      }, Lu = Gd(Vh);
      function Wd(f, y, w) {
        var Y = y + "";
        return Lu(f, om(Y, ym(im(Y), w)));
      }
      function Gd(f) {
        var y = 0, w = 0;
        return function() {
          var Y = Ip(), dt = ln - (Y - w);
          if (w = Y, dt > 0) {
            if (++y >= tn)
              return arguments[0];
          } else
            y = 0;
          return f.apply(l, arguments);
        };
      }
      function xl(f, y) {
        var w = -1, Y = f.length, dt = Y - 1;
        for (y = y === l ? Y : y; ++w < y; ) {
          var Wt = yu(w, dt), sn = f[Wt];
          f[Wt] = f[w], f[w] = sn;
        }
        return f.length = y, f;
      }
      var qd = fm(function(f) {
        var y = [];
        return f.charCodeAt(0) === 46 && y.push(""), f.replace(ui, function(w, Y, dt, Wt) {
          y.push(dt ? Wt.replace(oo, "$1") : Y || w);
        }), y;
      });
      function Ts(f) {
        if (typeof f == "string" || Wi(f))
          return f;
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function ma(f) {
        if (f != null) {
          try {
            return mo.call(f);
          } catch {
          }
          try {
            return f + "";
          } catch {
          }
        }
        return "";
      }
      function ym(f, y) {
        return Xi(yn, function(w) {
          var Y = "_." + w[0];
          y & w[1] && !uo(f, Y) && f.push(Y);
        }), f.sort();
      }
      function Yd(f) {
        if (f instanceof Pr)
          return f.clone();
        var y = new Ji(f.__wrapped__, f.__chain__);
        return y.__actions__ = Vi(f.__actions__), y.__index__ = f.__index__, y.__values__ = f.__values__, y;
      }
      function vm(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = ri(hr(y), 0);
        var Y = f == null ? 0 : f.length;
        if (!Y || y < 1)
          return [];
        for (var dt = 0, Wt = 0, sn = xn(So(Y / y)); dt < Y; )
          sn[Wt++] = ms(f, dt, dt += y);
        return sn;
      }
      function xm(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = 0, dt = []; ++y < w; ) {
          var Wt = f[y];
          Wt && (dt[Y++] = Wt);
        }
        return dt;
      }
      function bm() {
        var f = arguments.length;
        if (!f)
          return [];
        for (var y = xn(f - 1), w = arguments[0], Y = f; Y--; )
          y[Y - 1] = arguments[Y];
        return zs(pr(w) ? Vi(w) : [w], $i(y, 1));
      }
      var Cm = vr(function(f, y) {
        return ei(f) ? Ga(f, $i(y, 1, ei, !0)) : [];
      }), Sm = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), or(w, 2)) : [];
      }), $m = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), l, w) : [];
      });
      function wm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function _m(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function Em(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0, !0) : [];
      }
      function Pm(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0) : [];
      }
      function Tm(f, y, w, Y) {
        var dt = f == null ? 0 : f.length;
        return dt ? (w && typeof w != "number" && Ni(f, y, w) && (w = 0, Y = dt), bh(f, y, w, Y)) : [];
      }
      function Xd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), co(f, or(y, 3), dt);
      }
      function Zd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y - 1;
        return w !== l && (dt = hr(w), dt = w < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), co(f, or(y, 3), dt, !0);
      }
      function Jd(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, 1) : [];
      }
      function Im(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, nn) : [];
      }
      function km(f, y) {
        var w = f == null ? 0 : f.length;
        return w ? (y = y === l ? 1 : hr(y), $i(f, y)) : [];
      }
      function Am(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = {}; ++y < w; ) {
          var dt = f[y];
          Y[dt[0]] = dt[1];
        }
        return Y;
      }
      function Qd(f) {
        return f && f.length ? f[0] : l;
      }
      function Nm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), xa(f, y, dt);
      }
      function Fm(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 0, -1) : [];
      }
      var Dm = vr(function(f) {
        var y = qr(f, Su);
        return y.length && y[0] === f[0] ? fu(y) : [];
      }), Rm = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y === ys(w) ? y = l : w.pop(), w.length && w[0] === f[0] ? fu(w, or(y, 2)) : [];
      }), Om = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y = typeof y == "function" ? y : l, y && w.pop(), w.length && w[0] === f[0] ? fu(w, l, y) : [];
      });
      function Lm(f, y) {
        return f == null ? "" : Pp.call(f, y);
      }
      function ys(f) {
        var y = f == null ? 0 : f.length;
        return y ? f[y - 1] : l;
      }
      function Mm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y;
        return w !== l && (dt = hr(w), dt = dt < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), y === y ? up(f, y, dt) : co(f, Nc, dt, !0);
      }
      function Vm(f, y) {
        return f && f.length ? ud(f, hr(y)) : l;
      }
      var Bm = vr(ef);
      function ef(f, y) {
        return f && f.length && y && y.length ? gu(f, y) : f;
      }
      function zm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, or(w, 2)) : f;
      }
      function jm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, l, w) : f;
      }
      var Hm = Ds(function(f, y) {
        var w = f == null ? 0 : f.length, Y = lu(f, y);
        return fd(f, qr(y, function(dt) {
          return Rs(dt, w) ? +dt : dt;
        }).sort($d)), Y;
      });
      function Um(f, y) {
        var w = [];
        if (!(f && f.length))
          return w;
        var Y = -1, dt = [], Wt = f.length;
        for (y = or(y, 3); ++Y < Wt; ) {
          var sn = f[Y];
          y(sn, Y, f) && (w.push(sn), dt.push(Y));
        }
        return fd(f, dt), w;
      }
      function Mu(f) {
        return f == null ? f : Np.call(f);
      }
      function Km(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (w && typeof w != "number" && Ni(f, y, w) ? (y = 0, w = Y) : (y = y == null ? 0 : hr(y), w = w === l ? Y : hr(w)), ms(f, y, w)) : [];
      }
      function Wm(f, y) {
        return Do(f, y);
      }
      function Gm(f, y, w) {
        return xu(f, y, or(w, 2));
      }
      function qm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y);
          if (Y < w && $s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Ym(f, y) {
        return Do(f, y, !0);
      }
      function Xm(f, y, w) {
        return xu(f, y, or(w, 2), !0);
      }
      function Zm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y, !0) - 1;
          if ($s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Jm(f) {
        return f && f.length ? hd(f) : [];
      }
      function Qm(f, y) {
        return f && f.length ? hd(f, or(y, 2)) : [];
      }
      function eg(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 1, y) : [];
      }
      function tg(f, y, w) {
        return f && f.length ? (y = w || y === l ? 1 : hr(y), ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function ng(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function rg(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !1, !0) : [];
      }
      function ig(f, y) {
        return f && f.length ? Ro(f, or(y, 3)) : [];
      }
      var ag = vr(function(f) {
        return Ws($i(f, 1, ei, !0));
      }), og = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Ws($i(f, 1, ei, !0), or(y, 2));
      }), lg = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Ws($i(f, 1, ei, !0), l, y);
      });
      function ug(f) {
        return f && f.length ? Ws(f) : [];
      }
      function cg(f, y) {
        return f && f.length ? Ws(f, or(y, 2)) : [];
      }
      function ey(f, y) {
        return y = typeof y == "function" ? y : l, f && f.length ? Ws(f, l, y) : [];
      }
      function Bu(f) {
        if (!(f && f.length))
          return [];
        var y = 0;
        return f = Bs(f, function(w) {
          if (ei(w))
            return y = ri(w.length, y), !0;
        }), eu(y, function(w) {
          return qr(f, Zl(w));
        });
      }
      function tf(f, y) {
        if (!(f && f.length))
          return [];
        var w = Bu(f);
        return y == null ? w : qr(w, function(Y) {
          return Hi(y, l, Y);
        });
      }
      var ty = vr(function(f, y) {
        return ei(f) ? Ga(f, y) : [];
      }), ny = vr(function(f) {
        return Cu(Bs(f, ei));
      }), ry = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Cu(Bs(f, ei), or(y, 2));
      }), iy = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Cu(Bs(f, ei), l, y);
      }), sy = vr(Bu);
      function ay(f, y) {
        return xd(f || [], y || [], Wa);
      }
      function oy(f, y) {
        return xd(f || [], y || [], Xa);
      }
      var ly = vr(function(f) {
        var y = f.length, w = y > 1 ? f[y - 1] : l;
        return w = typeof w == "function" ? (f.pop(), w) : l, tf(f, w);
      });
      function nf(f) {
        var y = Ft(f);
        return y.__chain__ = !0, y;
      }
      function uy(f, y) {
        return y(f), f;
      }
      function bl(f, y) {
        return y(f);
      }
      var cy = Ds(function(f) {
        var y = f.length, w = y ? f[0] : 0, Y = this.__wrapped__, dt = function(Wt) {
          return lu(Wt, f);
        };
        return y > 1 || this.__actions__.length || !(Y instanceof Pr) || !Rs(w) ? this.thru(dt) : (Y = Y.slice(w, +w + (y ? 1 : 0)), Y.__actions__.push({
          func: bl,
          args: [dt],
          thisArg: l
        }), new Ji(Y, this.__chain__).thru(function(Wt) {
          return y && !Wt.length && Wt.push(l), Wt;
        }));
      });
      function dy() {
        return nf(this);
      }
      function fy() {
        return new Ji(this.value(), this.__chain__);
      }
      function py() {
        this.__values__ === l && (this.__values__ = yf(this.value()));
        var f = this.__index__ >= this.__values__.length, y = f ? l : this.__values__[this.__index__++];
        return { done: f, value: y };
      }
      function hy() {
        return this;
      }
      function my(f) {
        for (var y, w = this; w instanceof Po; ) {
          var Y = Yd(w);
          Y.__index__ = 0, Y.__values__ = l, y ? dt.__wrapped__ = Y : y = Y;
          var dt = Y;
          w = w.__wrapped__;
        }
        return dt.__wrapped__ = f, y;
      }
      function gy() {
        var f = this.__wrapped__;
        if (f instanceof Pr) {
          var y = f;
          return this.__actions__.length && (y = new Pr(this)), y = y.reverse(), y.__actions__.push({
            func: bl,
            args: [Mu],
            thisArg: l
          }), new Ji(y, this.__chain__);
        }
        return this.thru(Mu);
      }
      function yy() {
        return vd(this.__wrapped__, this.__actions__);
      }
      var vy = Oo(function(f, y, w) {
        zr.call(f, w) ? ++f[w] : Ns(f, w, 1);
      });
      function xy(f, y, w) {
        var Y = pr(f) ? kc : xh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      function by(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, or(y, 3));
      }
      var Cy = Id(Xd), Sy = Id(Zd);
      function $y(f, y) {
        return $i(Cl(f, y), 1);
      }
      function wy(f, y) {
        return $i(Cl(f, y), nn);
      }
      function _y(f, y, w) {
        return w = w === l ? 1 : hr(w), $i(Cl(f, y), w);
      }
      function rf(f, y) {
        var w = pr(f) ? Xi : Ks;
        return w(f, or(y, 3));
      }
      function sf(f, y) {
        var w = pr(f) ? Wf : Qc;
        return w(f, or(y, 3));
      }
      var Ey = Oo(function(f, y, w) {
        zr.call(f, w) ? f[w].push(y) : Ns(f, w, [y]);
      });
      function Py(f, y, w, Y) {
        f = Bi(f) ? f : Na(f), w = w && !Y ? hr(w) : 0;
        var dt = f.length;
        return w < 0 && (w = ri(dt + w, 0)), Tl(f) ? w <= dt && f.indexOf(y, w) > -1 : !!dt && xa(f, y, w) > -1;
      }
      var Ty = vr(function(f, y, w) {
        var Y = -1, dt = typeof y == "function", Wt = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(sn) {
          Wt[++Y] = dt ? Hi(y, sn, w) : qa(sn, y, w);
        }), Wt;
      }), Iy = Oo(function(f, y, w) {
        Ns(f, w, y);
      });
      function Cl(f, y) {
        var w = pr(f) ? qr : ad;
        return w(f, or(y, 3));
      }
      function ky(f, y, w, Y) {
        return f == null ? [] : (pr(y) || (y = y == null ? [] : [y]), w = Y ? l : w, pr(w) || (w = w == null ? [] : [w]), cd(f, y, w));
      }
      var Ay = Oo(function(f, y, w) {
        f[w ? 0 : 1].push(y);
      }, function() {
        return [[], []];
      });
      function Ny(f, y, w) {
        var Y = pr(f) ? Yl : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Ks);
      }
      function Fy(f, y, w) {
        var Y = pr(f) ? Gf : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Qc);
      }
      function Dy(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, El(or(y, 3)));
      }
      function Ry(f) {
        var y = pr(f) ? Yc : Lh;
        return y(f);
      }
      function Oy(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y);
        var Y = pr(f) ? hh : Mh;
        return Y(f, y);
      }
      function Ly(f) {
        var y = pr(f) ? mh : Bh;
        return y(f);
      }
      function My(f) {
        if (f == null)
          return 0;
        if (Bi(f))
          return Tl(f) ? Ca(f) : f.length;
        var y = Ei(f);
        return y == kn || y == Bn ? f.size : hu(f).length;
      }
      function Vy(f, y, w) {
        var Y = pr(f) ? Xl : zh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      var By = vr(function(f, y) {
        if (f == null)
          return [];
        var w = y.length;
        return w > 1 && Ni(f, y[0], y[1]) ? y = [] : w > 2 && Ni(y[0], y[1], y[2]) && (y = [y[0]]), cd(f, $i(y, 1), []);
      }), Sl = wp || function() {
        return di.Date.now();
      };
      function zy(f, y) {
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          if (--f < 1)
            return y.apply(this, arguments);
        };
      }
      function af(f, y, w) {
        return y = w ? l : y, y = f && y == null ? f.length : y, Fs(f, Re, l, l, l, l, y);
      }
      function of(f, y) {
        var w;
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          return --f > 0 && (w = y.apply(this, arguments)), f <= 1 && (y = l), w;
        };
      }
      var zu = vr(function(f, y, w) {
        var Y = Q;
        if (w.length) {
          var dt = Hs(w, ka(zu));
          Y |= ve;
        }
        return Fs(f, Y, y, w, dt);
      }), lf = vr(function(f, y, w) {
        var Y = Q | W;
        if (w.length) {
          var dt = Hs(w, ka(lf));
          Y |= ve;
        }
        return Fs(y, Y, f, w, dt);
      });
      function uf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, te, l, l, l, l, l, y);
        return Y.placeholder = uf.placeholder, Y;
      }
      function cf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, K, l, l, l, l, l, y);
        return Y.placeholder = cf.placeholder, Y;
      }
      function df(f, y, w) {
        var Y, dt, Wt, sn, cn, pn, En = 0, In = !1, Dn = !1, qn = !0;
        if (typeof f != "function")
          throw new Zi(g);
        y = xs(y) || 0, Xr(w) && (In = !!w.leading, Dn = "maxWait" in w, Wt = Dn ? ri(xs(w.maxWait) || 0, y) : Wt, qn = "trailing" in w ? !!w.trailing : qn);
        function nr(ti) {
          var ws = Y, Ms = dt;
          return Y = dt = l, En = ti, sn = f.apply(Ms, ws), sn;
        }
        function lr(ti) {
          return En = ti, cn = no($r, y), In ? nr(ti) : sn;
        }
        function gr(ti) {
          var ws = ti - pn, Ms = ti - En, kf = y - ws;
          return Dn ? wi(kf, Wt - Ms) : kf;
        }
        function ur(ti) {
          var ws = ti - pn, Ms = ti - En;
          return pn === l || ws >= y || ws < 0 || Dn && Ms >= Wt;
        }
        function $r() {
          var ti = Sl();
          if (ur(ti))
            return Ir(ti);
          cn = no($r, gr(ti));
        }
        function Ir(ti) {
          return cn = l, qn && Y ? nr(ti) : (Y = dt = l, sn);
        }
        function Gi() {
          cn !== l && bd(cn), En = 0, Y = pn = dt = cn = l;
        }
        function Fi() {
          return cn === l ? sn : Ir(Sl());
        }
        function qi() {
          var ti = Sl(), ws = ur(ti);
          if (Y = arguments, dt = this, pn = ti, ws) {
            if (cn === l)
              return lr(pn);
            if (Dn)
              return bd(cn), cn = no($r, y), nr(pn);
          }
          return cn === l && (cn = no($r, y)), sn;
        }
        return qi.cancel = Gi, qi.flush = Fi, qi;
      }
      var jy = vr(function(f, y) {
        return Jc(f, 1, y);
      }), Hy = vr(function(f, y, w) {
        return Jc(f, xs(y) || 0, w);
      });
      function Uy(f) {
        return Fs(f, yt);
      }
      function $l(f, y) {
        if (typeof f != "function" || y != null && typeof y != "function")
          throw new Zi(g);
        var w = function() {
          var Y = arguments, dt = y ? y.apply(this, Y) : Y[0], Wt = w.cache;
          if (Wt.has(dt))
            return Wt.get(dt);
          var sn = f.apply(this, Y);
          return w.cache = Wt.set(dt, sn) || Wt, sn;
        };
        return w.cache = new ($l.Cache || As)(), w;
      }
      $l.Cache = As;
      function El(f) {
        if (typeof f != "function")
          throw new Zi(g);
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return !f.call(this);
            case 1:
              return !f.call(this, y[0]);
            case 2:
              return !f.call(this, y[0], y[1]);
            case 3:
              return !f.call(this, y[0], y[1], y[2]);
          }
          return !f.apply(this, y);
        };
      }
      function Ky(f) {
        return of(2, f);
      }
      var Wy = jh(function(f, y) {
        y = y.length == 1 && pr(y[0]) ? qr(y[0], Ui(or())) : qr($i(y, 1), Ui(or()));
        var w = y.length;
        return vr(function(Y) {
          for (var dt = -1, Wt = wi(Y.length, w); ++dt < Wt; )
            Y[dt] = y[dt].call(this, Y[dt]);
          return Hi(f, this, Y);
        });
      }), Uu = vr(function(f, y) {
        var w = Hs(y, ka(Uu));
        return Fs(f, ve, l, y, w);
      }), ff = vr(function(f, y) {
        var w = Hs(y, ka(ff));
        return Fs(f, ee, l, y, w);
      }), Gy = Ds(function(f, y) {
        return Fs(f, wt, l, l, l, y);
      });
      function qy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y === l ? y : hr(y), vr(f, y);
      }
      function Yy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y == null ? 0 : ri(hr(y), 0), vr(function(w) {
          var Y = w[y], dt = qs(w, 0, y);
          return Y && zs(dt, Y), Hi(f, this, dt);
        });
      }
      function Xy(f, y, w) {
        var Y = !0, dt = !0;
        if (typeof f != "function")
          throw new Zi(g);
        return Xr(w) && (Y = "leading" in w ? !!w.leading : Y, dt = "trailing" in w ? !!w.trailing : dt), df(f, y, {
          leading: Y,
          maxWait: y,
          trailing: dt
        });
      }
      function Zy(f) {
        return af(f, 1);
      }
      function Jy(f, y) {
        return Uu(wu(y), f);
      }
      function Qy() {
        if (!arguments.length)
          return [];
        var f = arguments[0];
        return pr(f) ? f : [f];
      }
      function ev(f) {
        return Qi(f, N);
      }
      function tv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, N, y);
      }
      function nv(f) {
        return Qi(f, P | N);
      }
      function rv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, P | N, y);
      }
      function iv(f, y) {
        return y == null || Zc(f, y, oi(y));
      }
      function $s(f, y) {
        return f === y || f !== f && y !== y;
      }
      var sv = Zo(du), av = Zo(function(f, y) {
        return f >= y;
      }), ga = rd(/* @__PURE__ */ function() {
        return arguments;
      }()) ? rd : function(f) {
        return Qr(f) && zr.call(f, "callee") && !Hc.call(f, "callee");
      }, pr = xn.isArray, ov = wc ? Ui(wc) : _h;
      function Bi(f) {
        return f != null && Pl(f.length) && !Os(f);
      }
      function ei(f) {
        return Qr(f) && Bi(f);
      }
      function lv(f) {
        return f === !0 || f === !1 || Qr(f) && Ai(f) == _n;
      }
      var Ys = Ep || lc, uv = _c ? Ui(_c) : Eh;
      function cv(f) {
        return Qr(f) && f.nodeType === 1 && !ro(f);
      }
      function dv(f) {
        if (f == null)
          return !0;
        if (Bi(f) && (pr(f) || typeof f == "string" || typeof f.splice == "function" || Ys(f) || Aa(f) || ga(f)))
          return !f.length;
        var y = Ei(f);
        if (y == kn || y == Bn)
          return !f.size;
        if (to(f))
          return !hu(f).length;
        for (var w in f)
          if (zr.call(f, w))
            return !1;
        return !0;
      }
      function fv(f, y) {
        return Ya(f, y);
      }
      function pv(f, y, w) {
        w = typeof w == "function" ? w : l;
        var Y = w ? w(f, y) : l;
        return Y === l ? Ya(f, y, l, w) : !!Y;
      }
      function Wu(f) {
        if (!Qr(f))
          return !1;
        var y = Ai(f);
        return y == Xn || y == Un || typeof f.message == "string" && typeof f.name == "string" && !ro(f);
      }
      function hv(f) {
        return typeof f == "number" && Kc(f);
      }
      function Os(f) {
        if (!Xr(f))
          return !1;
        var y = Ai(f);
        return y == zn || y == jn || y == On || y == Ln;
      }
      function pf(f) {
        return typeof f == "number" && f == hr(f);
      }
      function Pl(f) {
        return typeof f == "number" && f > -1 && f % 1 == 0 && f <= vt;
      }
      function Xr(f) {
        var y = typeof f;
        return f != null && (y == "object" || y == "function");
      }
      function Qr(f) {
        return f != null && typeof f == "object";
      }
      var hf = Ec ? Ui(Ec) : Th;
      function mv(f, y) {
        return f === y || pu(f, y, Nu(y));
      }
      function gv(f, y, w) {
        return w = typeof w == "function" ? w : l, pu(f, y, Nu(y), w);
      }
      function yv(f) {
        return mf(f) && f != +f;
      }
      function vv(f) {
        if (dm(f))
          throw new fr(m);
        return id(f);
      }
      function xv(f) {
        return f === null;
      }
      function bv(f) {
        return f == null;
      }
      function mf(f) {
        return typeof f == "number" || Qr(f) && Ai(f) == Yn;
      }
      function ro(f) {
        if (!Qr(f) || Ai(f) != er)
          return !1;
        var y = xo(f);
        if (y === null)
          return !0;
        var w = zr.call(y, "constructor") && y.constructor;
        return typeof w == "function" && w instanceof w && mo.call(w) == xp;
      }
      var Zu = Pc ? Ui(Pc) : Ih;
      function Cv(f) {
        return pf(f) && f >= -vt && f <= vt;
      }
      var gf = Tc ? Ui(Tc) : kh;
      function Tl(f) {
        return typeof f == "string" || !pr(f) && Qr(f) && Ai(f) == Fn;
      }
      function Wi(f) {
        return typeof f == "symbol" || Qr(f) && Ai(f) == Gn;
      }
      var Aa = Ic ? Ui(Ic) : Ah;
      function Sv(f) {
        return f === l;
      }
      function $v(f) {
        return Qr(f) && Ei(f) == Mn;
      }
      function wv(f) {
        return Qr(f) && Ai(f) == Tn;
      }
      var _v = Zo(mu), Ev = Zo(function(f, y) {
        return f <= y;
      });
      function yf(f) {
        if (!f)
          return [];
        if (Bi(f))
          return Tl(f) ? Cs(f) : Vi(f);
        if (Ba && f[Ba])
          return ap(f[Ba]());
        var y = Ei(f), w = y == kn ? nu : y == Bn ? fo : Na;
        return w(f);
      }
      function Ls(f) {
        if (!f)
          return f === 0 ? f : 0;
        if (f = xs(f), f === nn || f === -nn) {
          var y = f < 0 ? -1 : 1;
          return y * Et;
        }
        return f === f ? f : 0;
      }
      function hr(f) {
        var y = Ls(f), w = y % 1;
        return y === y ? w ? y - w : y : 0;
      }
      function vf(f) {
        return f ? fa(hr(f), 0, un) : 0;
      }
      function xs(f) {
        if (typeof f == "number")
          return f;
        if (Wi(f))
          return Qt;
        if (Xr(f)) {
          var y = typeof f.valueOf == "function" ? f.valueOf() : f;
          f = Xr(y) ? y + "" : y;
        }
        if (typeof f != "string")
          return f === 0 ? f : +f;
        f = Rc(f);
        var w = kl.test(f);
        return w || Vl.test(f) ? Hf(f.slice(2), w ? 2 : 8) : Ol.test(f) ? Qt : +f;
      }
      function xf(f) {
        return Ps(f, zi(f));
      }
      function Pv(f) {
        return f ? fa(hr(f), -vt, vt) : f === 0 ? f : 0;
      }
      function Vr(f) {
        return f == null ? "" : Ki(f);
      }
      var Tv = Ta(function(f, y) {
        if (to(y) || Bi(y)) {
          Ps(y, oi(y), f);
          return;
        }
        for (var w in y)
          zr.call(y, w) && Wa(f, w, y[w]);
      }), bf = Ta(function(f, y) {
        Ps(y, zi(y), f);
      }), Il = Ta(function(f, y, w, Y) {
        Ps(y, zi(y), f, Y);
      }), Iv = Ta(function(f, y, w, Y) {
        Ps(y, oi(y), f, Y);
      }), kv = Ds(lu);
      function Av(f, y) {
        var w = Pa(f);
        return y == null ? w : Xc(w, y);
      }
      var Nv = vr(function(f, y) {
        f = Gr(f);
        var w = -1, Y = y.length, dt = Y > 2 ? y[2] : l;
        for (dt && Ni(y[0], y[1], dt) && (Y = 1); ++w < Y; )
          for (var Wt = y[w], sn = zi(Wt), cn = -1, pn = sn.length; ++cn < pn; ) {
            var En = sn[cn], In = f[En];
            (In === l || $s(In, $a[En]) && !zr.call(f, En)) && (f[En] = Wt[En]);
          }
        return f;
      }), Fv = vr(function(f) {
        return f.push(l, Od), Hi(Cf, l, f);
      });
      function Dv(f, y) {
        return Ac(f, or(y, 3), Es);
      }
      function Rv(f, y) {
        return Ac(f, or(y, 3), cu);
      }
      function Ov(f, y) {
        return f == null ? f : uu(f, or(y, 3), zi);
      }
      function Lv(f, y) {
        return f == null ? f : td(f, or(y, 3), zi);
      }
      function Mv(f, y) {
        return f && Es(f, or(y, 3));
      }
      function Vv(f, y) {
        return f && cu(f, or(y, 3));
      }
      function Bv(f) {
        return f == null ? [] : Ao(f, oi(f));
      }
      function zv(f) {
        return f == null ? [] : Ao(f, zi(f));
      }
      function ec(f, y, w) {
        var Y = f == null ? l : pa(f, y);
        return Y === l ? w : Y;
      }
      function jv(f, y) {
        return f != null && Vd(f, y, Ch);
      }
      function tc(f, y) {
        return f != null && Vd(f, y, Sh);
      }
      var Hv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), f[y] = w;
      }, rc(ji)), Uv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), zr.call(f, y) ? f[y].push(w) : f[y] = [w];
      }, or), Kv = vr(qa);
      function oi(f) {
        return Bi(f) ? qc(f) : hu(f);
      }
      function zi(f) {
        return Bi(f) ? qc(f, !0) : Nh(f);
      }
      function Wv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, y(Y, dt, Wt), Y);
        }), w;
      }
      function Gv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, dt, y(Y, dt, Wt));
        }), w;
      }
      var qv = Ta(function(f, y, w) {
        No(f, y, w);
      }), Cf = Ta(function(f, y, w, Y) {
        No(f, y, w, Y);
      }), Yv = Ds(function(f, y) {
        var w = {};
        if (f == null)
          return w;
        var Y = !1;
        y = qr(y, function(Wt) {
          return Wt = Gs(Wt, f), Y || (Y = Wt.length > 1), Wt;
        }), Ps(f, Iu(f), w), Y && (w = Qi(w, P | T | N, Qh));
        for (var dt = y.length; dt--; )
          bu(w, y[dt]);
        return w;
      });
      function Xv(f, y) {
        return Sf(f, El(or(y)));
      }
      var Zv = Ds(function(f, y) {
        return f == null ? {} : Dh(f, y);
      });
      function Sf(f, y) {
        if (f == null)
          return {};
        var w = qr(Iu(f), function(Y) {
          return [Y];
        });
        return y = or(y), dd(f, w, function(Y, dt) {
          return y(Y, dt[0]);
        });
      }
      function Jv(f, y, w) {
        y = Gs(y, f);
        var Y = -1, dt = y.length;
        for (dt || (dt = 1, f = l); ++Y < dt; ) {
          var Wt = f == null ? l : f[Ts(y[Y])];
          Wt === l && (Y = dt, Wt = w), f = Os(Wt) ? Wt.call(f) : Wt;
        }
        return f;
      }
      function Qv(f, y, w) {
        return f == null ? f : Xa(f, y, w);
      }
      function e1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : Xa(f, y, w, Y);
      }
      var $f = Dd(oi), wf = Dd(zi);
      function t1(f, y, w) {
        var Y = pr(f), dt = Y || Ys(f) || Aa(f);
        if (y = or(y, 4), w == null) {
          var Wt = f && f.constructor;
          dt ? w = Y ? new Wt() : [] : Xr(f) ? w = Os(Wt) ? Pa(xo(f)) : {} : w = {};
        }
        return (dt ? Xi : Es)(f, function(sn, cn, pn) {
          return y(w, sn, cn, pn);
        }), w;
      }
      function n1(f, y) {
        return f == null ? !0 : bu(f, y);
      }
      function r1(f, y, w) {
        return f == null ? f : yd(f, y, wu(w));
      }
      function i1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : yd(f, y, wu(w), Y);
      }
      function Na(f) {
        return f == null ? [] : tu(f, oi(f));
      }
      function s1(f) {
        return f == null ? [] : tu(f, zi(f));
      }
      function a1(f, y, w) {
        return w === l && (w = y, y = l), w !== l && (w = xs(w), w = w === w ? w : 0), y !== l && (y = xs(y), y = y === y ? y : 0), fa(xs(f), y, w);
      }
      function o1(f, y, w) {
        return y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), f = xs(f), $h(f, y, w);
      }
      function l1(f, y, w) {
        if (w && typeof w != "boolean" && Ni(f, y, w) && (y = w = l), w === l && (typeof y == "boolean" ? (w = y, y = l) : typeof f == "boolean" && (w = f, f = l)), f === l && y === l ? (f = 0, y = 1) : (f = Ls(f), y === l ? (y = f, f = 0) : y = Ls(y)), f > y) {
          var Y = f;
          f = y, y = Y;
        }
        if (w || f % 1 || y % 1) {
          var dt = Wc();
          return wi(f + dt * (y - f + jf("1e-" + ((dt + "").length - 1))), y);
        }
        return yu(f, y);
      }
      var u1 = Ia(function(f, y, w) {
        return y = y.toLowerCase(), f + (w ? _f(y) : y);
      });
      function _f(f) {
        return nc(Vr(f).toLowerCase());
      }
      function Ef(f) {
        return f = Vr(f), f && f.replace(Ll, tp).replace(Li, "");
      }
      function c1(f, y, w) {
        f = Vr(f), y = Ki(y);
        var Y = f.length;
        w = w === l ? Y : fa(hr(w), 0, Y);
        var dt = w;
        return w -= y.length, w >= 0 && f.slice(w, dt) == y;
      }
      function d1(f) {
        return f = Vr(f), f && _r.test(f) ? f.replace(Nr, np) : f;
      }
      function f1(f) {
        return f = Vr(f), f && bs.test(f) ? f.replace(Ii, "\\$&") : f;
      }
      var p1 = Ia(function(f, y, w) {
        return f + (w ? "-" : "") + y.toLowerCase();
      }), m1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toLowerCase();
      }), g1 = Td("toLowerCase");
      function y1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        if (!y || Y >= y)
          return f;
        var dt = (y - Y) / 2;
        return Bo(wo(dt), w) + f + Bo(So(dt), w);
      }
      function v1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? f + Bo(y - Y, w) : f;
      }
      function x1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? Bo(y - Y, w) + f : f;
      }
      function b1(f, y, w) {
        return w || y == null ? y = 0 : y && (y = +y), Ap(Vr(f).replace(Oi, ""), y || 0);
      }
      function C1(f, y, w) {
        return (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y), vu(Vr(f), y);
      }
      function S1() {
        var f = arguments, y = Vr(f[0]);
        return f.length < 3 ? y : y.replace(f[1], f[2]);
      }
      var $1 = Ia(function(f, y, w) {
        return f + (w ? "_" : "") + y.toLowerCase();
      });
      function w1(f, y, w) {
        return w && typeof w != "number" && Ni(f, y, w) && (y = w = l), w = w === l ? un : w >>> 0, w ? (f = Vr(f), f && (typeof y == "string" || y != null && !Zu(y)) && (y = Ki(y), !y && ba(f)) ? qs(Cs(f), 0, w) : f.split(y, w)) : [];
      }
      var _1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + nc(y);
      });
      function E1(f, y, w) {
        return f = Vr(f), w = w == null ? 0 : fa(hr(w), 0, f.length), y = Ki(y), f.slice(w, w + y.length) == y;
      }
      function P1(f, y, w) {
        var Y = Ft.templateSettings;
        w && Ni(f, y, w) && (y = l), f = Vr(f), y = Il({}, y, Y, Rd);
        var dt = Il({}, y.imports, Y.imports, Rd), Wt = oi(dt), sn = tu(dt, Wt), cn, pn, En = 0, In = y.interpolate || Oa, Dn = "__p += '", qn = ru(
          (y.escape || Oa).source + "|" + In.source + "|" + (In === ii ? Xs : Oa).source + "|" + (y.evaluate || Oa).source + "|$",
          "g"
        ), nr = "//# sourceURL=" + (zr.call(y, "sourceURL") ? (y.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++mc + "]") + `
`;
        f.replace(qn, function(ur, $r, Ir, Gi, Fi, qi) {
          return Ir || (Ir = Gi), Dn += f.slice(En, qi).replace(cc, rp), $r && (cn = !0, Dn += `' +
__e(` + $r + `) +
'`), Fi && (pn = !0, Dn += `';
` + Fi + `;
__p += '`), Ir && (Dn += `' +
((__t = (` + Ir + `)) == null ? '' : __t) +
'`), En = qi + ur.length, ur;
        }), Dn += `';
`;
        var lr = zr.call(y, "variable") && y.variable;
        if (!lr)
          Dn = `with (obj) {
` + Dn + `
}
`;
        else if (Da.test(lr))
          throw new fr(v);
        Dn = (pn ? Dn.replace(ar, "") : Dn).replace(Or, "$1").replace(Sr, "$1;"), Dn = "function(" + (lr || "obj") + `) {
` + (lr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (cn ? ", __e = _.escape" : "") + (pn ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Dn + `return __p
}`;
        var gr = Tf(function() {
          return Mr(Wt, nr + "return " + Dn).apply(l, sn);
        });
        if (gr.source = Dn, Wu(gr))
          throw gr;
        return gr;
      }
      function T1(f) {
        return Vr(f).toLowerCase();
      }
      function I1(f) {
        return Vr(f).toUpperCase();
      }
      function k1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return Rc(f);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Cs(y), Wt = Oc(Y, dt), sn = Lc(Y, dt) + 1;
        return qs(Y, Wt, sn).join("");
      }
      function A1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.slice(0, Vc(f) + 1);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Lc(Y, Cs(y)) + 1;
        return qs(Y, 0, dt).join("");
      }
      function N1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.replace(Oi, "");
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Oc(Y, Cs(y));
        return qs(Y, dt).join("");
      }
      function F1(f, y) {
        var w = xt, Y = Kt;
        if (Xr(y)) {
          var dt = "separator" in y ? y.separator : dt;
          w = "length" in y ? hr(y.length) : w, Y = "omission" in y ? Ki(y.omission) : Y;
        }
        f = Vr(f);
        var Wt = f.length;
        if (ba(f)) {
          var sn = Cs(f);
          Wt = sn.length;
        }
        if (w >= Wt)
          return f;
        var cn = w - Ca(Y);
        if (cn < 1)
          return Y;
        var pn = sn ? qs(sn, 0, cn).join("") : f.slice(0, cn);
        if (dt === l)
          return pn + Y;
        if (sn && (cn += pn.length - cn), Zu(dt)) {
          if (f.slice(cn).search(dt)) {
            var En, In = pn;
            for (dt.global || (dt = ru(dt.source, Vr(so.exec(dt)) + "g")), dt.lastIndex = 0; En = dt.exec(In); )
              var Dn = En.index;
            pn = pn.slice(0, Dn === l ? cn : Dn);
          }
        } else if (f.indexOf(Ki(dt), cn) != cn) {
          var qn = pn.lastIndexOf(dt);
          qn > -1 && (pn = pn.slice(0, qn));
        }
        return pn + Y;
      }
      function D1(f) {
        return f = Vr(f), f && Ur.test(f) ? f.replace(kr, cp) : f;
      }
      var R1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toUpperCase();
      }), nc = Td("toUpperCase");
      function Pf(f, y, w) {
        return f = Vr(f), y = w ? l : y, y === l ? sp(f) ? hp(f) : Xf(f) : f.match(y) || [];
      }
      var Tf = vr(function(f, y) {
        try {
          return Hi(f, l, y);
        } catch (w) {
          return Wu(w) ? w : new fr(w);
        }
      }), O1 = Ds(function(f, y) {
        return Xi(y, function(w) {
          w = Ts(w), Ns(f, w, zu(f[w], f));
        }), f;
      });
      function L1(f) {
        var y = f == null ? 0 : f.length, w = or();
        return f = y ? qr(f, function(Y) {
          if (typeof Y[1] != "function")
            throw new Zi(g);
          return [w(Y[0]), Y[1]];
        }) : [], vr(function(Y) {
          for (var dt = -1; ++dt < y; ) {
            var Wt = f[dt];
            if (Hi(Wt[0], this, Y))
              return Hi(Wt[1], this, Y);
          }
        });
      }
      function M1(f) {
        return vh(Qi(f, P));
      }
      function rc(f) {
        return function() {
          return f;
        };
      }
      function V1(f, y) {
        return f == null || f !== f ? y : f;
      }
      var B1 = kd(), z1 = kd(!0);
      function ji(f) {
        return f;
      }
      function ic(f) {
        return sd(typeof f == "function" ? f : Qi(f, P));
      }
      function j1(f) {
        return od(Qi(f, P));
      }
      function H1(f, y) {
        return ld(f, Qi(y, P));
      }
      var U1 = vr(function(f, y) {
        return function(w) {
          return qa(w, f, y);
        };
      }), K1 = vr(function(f, y) {
        return function(w) {
          return qa(f, w, y);
        };
      });
      function sc(f, y, w) {
        var Y = oi(y), dt = Ao(y, Y);
        w == null && !(Xr(y) && (dt.length || !Y.length)) && (w = y, y = f, f = this, dt = Ao(y, oi(y)));
        var Wt = !(Xr(w) && "chain" in w) || !!w.chain, sn = Os(f);
        return Xi(dt, function(cn) {
          var pn = y[cn];
          f[cn] = pn, sn && (f.prototype[cn] = function() {
            var En = this.__chain__;
            if (Wt || En) {
              var In = f(this.__wrapped__), Dn = In.__actions__ = Vi(this.__actions__);
              return Dn.push({ func: pn, args: arguments, thisArg: f }), In.__chain__ = En, In;
            }
            return pn.apply(f, zs([this.value()], arguments));
          });
        }), f;
      }
      function W1() {
        return di._ === this && (di._ = bp), this;
      }
      function ac() {
      }
      function G1(f) {
        return f = hr(f), vr(function(y) {
          return ud(y, f);
        });
      }
      var q1 = Eu(qr), Y1 = Eu(kc), X1 = Eu(Xl);
      function If(f) {
        return Du(f) ? Zl(Ts(f)) : Rh(f);
      }
      function Z1(f) {
        return function(y) {
          return f == null ? l : pa(f, y);
        };
      }
      var J1 = Nd(), Q1 = Nd(!0);
      function oc() {
        return [];
      }
      function lc() {
        return !1;
      }
      function ex() {
        return {};
      }
      function tx() {
        return "";
      }
      function nx() {
        return !0;
      }
      function rx(f, y) {
        if (f = hr(f), f < 1 || f > vt)
          return [];
        var w = un, Y = wi(f, un);
        y = or(y), f -= un;
        for (var dt = eu(Y, y); ++w < f; )
          y(w);
        return dt;
      }
      function ix(f) {
        return pr(f) ? qr(f, Ts) : Wi(f) ? [f] : Vi(qd(Vr(f)));
      }
      function sx(f) {
        var y = ++vp;
        return Vr(f) + y;
      }
      var ax = Mo(function(f, y) {
        return f + y;
      }, 0), ox = Pu("ceil"), lx = Mo(function(f, y) {
        return f / y;
      }, 1), ux = Pu("floor");
      function cx(f) {
        return f && f.length ? Io(f, ji, du) : l;
      }
      function dx(f, y) {
        return f && f.length ? Io(f, or(y, 2), du) : l;
      }
      function fx(f) {
        return Fc(f, ji);
      }
      function px(f, y) {
        return Fc(f, or(y, 2));
      }
      function hx(f) {
        return f && f.length ? Io(f, ji, mu) : l;
      }
      function mx(f, y) {
        return f && f.length ? Io(f, or(y, 2), mu) : l;
      }
      var gx = Mo(function(f, y) {
        return f * y;
      }, 1), yx = Pu("round"), vx = Mo(function(f, y) {
        return f - y;
      }, 0);
      function xx(f) {
        return f && f.length ? Ql(f, ji) : 0;
      }
      function bx(f, y) {
        return f && f.length ? Ql(f, or(y, 2)) : 0;
      }
      return Ft.after = zy, Ft.ary = af, Ft.assign = Tv, Ft.assignIn = bf, Ft.assignInWith = Il, Ft.assignWith = Iv, Ft.at = kv, Ft.before = of, Ft.bind = zu, Ft.bindAll = O1, Ft.bindKey = lf, Ft.castArray = Qy, Ft.chain = nf, Ft.chunk = vm, Ft.compact = xm, Ft.concat = bm, Ft.cond = L1, Ft.conforms = M1, Ft.constant = rc, Ft.countBy = vy, Ft.create = Av, Ft.curry = uf, Ft.curryRight = cf, Ft.debounce = df, Ft.defaults = Nv, Ft.defaultsDeep = Fv, Ft.defer = jy, Ft.delay = Hy, Ft.difference = Cm, Ft.differenceBy = Sm, Ft.differenceWith = $m, Ft.drop = wm, Ft.dropRight = _m, Ft.dropRightWhile = Em, Ft.dropWhile = Pm, Ft.fill = Tm, Ft.filter = by, Ft.flatMap = $y, Ft.flatMapDeep = wy, Ft.flatMapDepth = _y, Ft.flatten = Jd, Ft.flattenDeep = Im, Ft.flattenDepth = km, Ft.flip = Uy, Ft.flow = B1, Ft.flowRight = z1, Ft.fromPairs = Am, Ft.functions = Bv, Ft.functionsIn = zv, Ft.groupBy = Ey, Ft.initial = Fm, Ft.intersection = Dm, Ft.intersectionBy = Rm, Ft.intersectionWith = Om, Ft.invert = Hv, Ft.invertBy = Uv, Ft.invokeMap = Ty, Ft.iteratee = ic, Ft.keyBy = Iy, Ft.keys = oi, Ft.keysIn = zi, Ft.map = Cl, Ft.mapKeys = Wv, Ft.mapValues = Gv, Ft.matches = j1, Ft.matchesProperty = H1, Ft.memoize = $l, Ft.merge = qv, Ft.mergeWith = Cf, Ft.method = U1, Ft.methodOf = K1, Ft.mixin = sc, Ft.negate = El, Ft.nthArg = G1, Ft.omit = Yv, Ft.omitBy = Xv, Ft.once = Ky, Ft.orderBy = ky, Ft.over = q1, Ft.overArgs = Wy, Ft.overEvery = Y1, Ft.overSome = X1, Ft.partial = Uu, Ft.partialRight = ff, Ft.partition = Ay, Ft.pick = Zv, Ft.pickBy = Sf, Ft.property = If, Ft.propertyOf = Z1, Ft.pull = Bm, Ft.pullAll = ef, Ft.pullAllBy = zm, Ft.pullAllWith = jm, Ft.pullAt = Hm, Ft.range = J1, Ft.rangeRight = Q1, Ft.rearg = Gy, Ft.reject = Dy, Ft.remove = Um, Ft.rest = qy, Ft.reverse = Mu, Ft.sampleSize = Oy, Ft.set = Qv, Ft.setWith = e1, Ft.shuffle = Ly, Ft.slice = Km, Ft.sortBy = By, Ft.sortedUniq = Jm, Ft.sortedUniqBy = Qm, Ft.split = w1, Ft.spread = Yy, Ft.tail = eg, Ft.take = tg, Ft.takeRight = ng, Ft.takeRightWhile = rg, Ft.takeWhile = ig, Ft.tap = uy, Ft.throttle = Xy, Ft.thru = bl, Ft.toArray = yf, Ft.toPairs = $f, Ft.toPairsIn = wf, Ft.toPath = ix, Ft.toPlainObject = xf, Ft.transform = t1, Ft.unary = Zy, Ft.union = ag, Ft.unionBy = og, Ft.unionWith = lg, Ft.uniq = ug, Ft.uniqBy = cg, Ft.uniqWith = ey, Ft.unset = n1, Ft.unzip = Bu, Ft.unzipWith = tf, Ft.update = r1, Ft.updateWith = i1, Ft.values = Na, Ft.valuesIn = s1, Ft.without = ty, Ft.words = Pf, Ft.wrap = Jy, Ft.xor = ny, Ft.xorBy = ry, Ft.xorWith = iy, Ft.zip = sy, Ft.zipObject = ay, Ft.zipObjectDeep = oy, Ft.zipWith = ly, Ft.entries = $f, Ft.entriesIn = wf, Ft.extend = bf, Ft.extendWith = Il, sc(Ft, Ft), Ft.add = ax, Ft.attempt = Tf, Ft.camelCase = u1, Ft.capitalize = _f, Ft.ceil = ox, Ft.clamp = a1, Ft.clone = ev, Ft.cloneDeep = nv, Ft.cloneDeepWith = rv, Ft.cloneWith = tv, Ft.conformsTo = iv, Ft.deburr = Ef, Ft.defaultTo = V1, Ft.divide = lx, Ft.endsWith = c1, Ft.eq = $s, Ft.escape = d1, Ft.escapeRegExp = f1, Ft.every = xy, Ft.find = Cy, Ft.findIndex = Xd, Ft.findKey = Dv, Ft.findLast = Sy, Ft.findLastIndex = Zd, Ft.findLastKey = Rv, Ft.floor = ux, Ft.forEach = rf, Ft.forEachRight = sf, Ft.forIn = Ov, Ft.forInRight = Lv, Ft.forOwn = Mv, Ft.forOwnRight = Vv, Ft.get = ec, Ft.gt = sv, Ft.gte = av, Ft.has = jv, Ft.hasIn = tc, Ft.head = Qd, Ft.identity = ji, Ft.includes = Py, Ft.indexOf = Nm, Ft.inRange = o1, Ft.invoke = Kv, Ft.isArguments = ga, Ft.isArray = pr, Ft.isArrayBuffer = ov, Ft.isArrayLike = Bi, Ft.isArrayLikeObject = ei, Ft.isBoolean = lv, Ft.isBuffer = Ys, Ft.isDate = uv, Ft.isElement = cv, Ft.isEmpty = dv, Ft.isEqual = fv, Ft.isEqualWith = pv, Ft.isError = Wu, Ft.isFinite = hv, Ft.isFunction = Os, Ft.isInteger = pf, Ft.isLength = Pl, Ft.isMap = hf, Ft.isMatch = mv, Ft.isMatchWith = gv, Ft.isNaN = yv, Ft.isNative = vv, Ft.isNil = bv, Ft.isNull = xv, Ft.isNumber = mf, Ft.isObject = Xr, Ft.isObjectLike = Qr, Ft.isPlainObject = ro, Ft.isRegExp = Zu, Ft.isSafeInteger = Cv, Ft.isSet = gf, Ft.isString = Tl, Ft.isSymbol = Wi, Ft.isTypedArray = Aa, Ft.isUndefined = Sv, Ft.isWeakMap = $v, Ft.isWeakSet = wv, Ft.join = Lm, Ft.kebabCase = p1, Ft.last = ys, Ft.lastIndexOf = Mm, Ft.lowerCase = m1, Ft.lowerFirst = g1, Ft.lt = _v, Ft.lte = Ev, Ft.max = cx, Ft.maxBy = dx, Ft.mean = fx, Ft.meanBy = px, Ft.min = hx, Ft.minBy = mx, Ft.stubArray = oc, Ft.stubFalse = lc, Ft.stubObject = ex, Ft.stubString = tx, Ft.stubTrue = nx, Ft.multiply = gx, Ft.nth = Vm, Ft.noConflict = W1, Ft.noop = ac, Ft.now = Sl, Ft.pad = y1, Ft.padEnd = v1, Ft.padStart = x1, Ft.parseInt = b1, Ft.random = l1, Ft.reduce = Ny, Ft.reduceRight = Fy, Ft.repeat = C1, Ft.replace = S1, Ft.result = Jv, Ft.round = yx, Ft.runInContext = fn, Ft.sample = Ry, Ft.size = My, Ft.snakeCase = $1, Ft.some = Vy, Ft.sortedIndex = Wm, Ft.sortedIndexBy = Gm, Ft.sortedIndexOf = qm, Ft.sortedLastIndex = Ym, Ft.sortedLastIndexBy = Xm, Ft.sortedLastIndexOf = Zm, Ft.startCase = _1, Ft.startsWith = E1, Ft.subtract = vx, Ft.sum = xx, Ft.sumBy = bx, Ft.template = P1, Ft.times = rx, Ft.toFinite = Ls, Ft.toInteger = hr, Ft.toLength = vf, Ft.toLower = T1, Ft.toNumber = xs, Ft.toSafeInteger = Pv, Ft.toString = Vr, Ft.toUpper = I1, Ft.trim = k1, Ft.trimEnd = A1, Ft.trimStart = N1, Ft.truncate = F1, Ft.unescape = D1, Ft.uniqueId = sx, Ft.upperCase = R1, Ft.upperFirst = nc, Ft.each = rf, Ft.eachRight = sf, Ft.first = Qd, sc(Ft, function() {
        var f = {};
        return Es(Ft, function(y, w) {
          zr.call(Ft.prototype, w) || (f[w] = y);
        }), f;
      }(), { chain: !1 }), Ft.VERSION = u, Xi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(f) {
        Ft[f].placeholder = Ft;
      }), Xi(["drop", "take"], function(f, y) {
        Pr.prototype[f] = function(w) {
          w = w === l ? 1 : ri(hr(w), 0);
          var Y = this.__filtered__ && !y ? new Pr(this) : this.clone();
          return Y.__filtered__ ? Y.__takeCount__ = wi(w, Y.__takeCount__) : Y.__views__.push({
            size: wi(w, un),
            type: f + (Y.__dir__ < 0 ? "Right" : "")
          }), Y;
        }, Pr.prototype[f + "Right"] = function(w) {
          return this.reverse()[f](w).reverse();
        };
      }), Xi(["filter", "map", "takeWhile"], function(f, y) {
        var w = y + 1, Y = w == rn || w == Gt;
        Pr.prototype[f] = function(dt) {
          var Wt = this.clone();
          return Wt.__iteratees__.push({
            iteratee: or(dt, 3),
            type: w
          }), Wt.__filtered__ = Wt.__filtered__ || Y, Wt;
        };
      }), Xi(["head", "last"], function(f, y) {
        var w = "take" + (y ? "Right" : "");
        Pr.prototype[f] = function() {
          return this[w](1).value()[0];
        };
      }), Xi(["initial", "tail"], function(f, y) {
        var w = "drop" + (y ? "" : "Right");
        Pr.prototype[f] = function() {
          return this.__filtered__ ? new Pr(this) : this[w](1);
        };
      }), Pr.prototype.compact = function() {
        return this.filter(ji);
      }, Pr.prototype.find = function(f) {
        return this.filter(f).head();
      }, Pr.prototype.findLast = function(f) {
        return this.reverse().find(f);
      }, Pr.prototype.invokeMap = vr(function(f, y) {
        return typeof f == "function" ? new Pr(this) : this.map(function(w) {
          return qa(w, f, y);
        });
      }), Pr.prototype.reject = function(f) {
        return this.filter(El(or(f)));
      }, Pr.prototype.slice = function(f, y) {
        f = hr(f);
        var w = this;
        return w.__filtered__ && (f > 0 || y < 0) ? new Pr(w) : (f < 0 ? w = w.takeRight(-f) : f && (w = w.drop(f)), y !== l && (y = hr(y), w = y < 0 ? w.dropRight(-y) : w.take(y - f)), w);
      }, Pr.prototype.takeRightWhile = function(f) {
        return this.reverse().takeWhile(f).reverse();
      }, Pr.prototype.toArray = function() {
        return this.take(un);
      }, Es(Pr.prototype, function(f, y) {
        var w = /^(?:filter|find|map|reject)|While$/.test(y), Y = /^(?:head|last)$/.test(y), dt = Ft[Y ? "take" + (y == "last" ? "Right" : "") : y], Wt = Y || /^find/.test(y);
        dt && (Ft.prototype[y] = function() {
          var sn = this.__wrapped__, cn = Y ? [1] : arguments, pn = sn instanceof Pr, En = cn[0], In = pn || pr(sn), Dn = function($r) {
            var Ir = dt.apply(Ft, zs([$r], cn));
            return Y && qn ? Ir[0] : Ir;
          };
          In && w && typeof En == "function" && En.length != 1 && (pn = In = !1);
          var qn = this.__chain__, nr = !!this.__actions__.length, lr = Wt && !qn, gr = pn && !nr;
          if (!Wt && In) {
            sn = gr ? sn : new Pr(this);
            var ur = f.apply(sn, cn);
            return ur.__actions__.push({ func: bl, args: [Dn], thisArg: l }), new Ji(ur, qn);
          }
          return lr && gr ? f.apply(this, cn) : (ur = this.thru(Dn), lr ? Y ? ur.value()[0] : ur.value() : ur);
        });
      }), Xi(["pop", "push", "shift", "sort", "splice", "unshift"], function(f) {
        var y = po[f], w = /^(?:push|sort|unshift)$/.test(f) ? "tap" : "thru", Y = /^(?:pop|shift)$/.test(f);
        Ft.prototype[f] = function() {
          var dt = arguments;
          if (Y && !this.__chain__) {
            var Wt = this.value();
            return y.apply(pr(Wt) ? Wt : [], dt);
          }
          return this[w](function(sn) {
            return y.apply(pr(sn) ? sn : [], dt);
          });
        };
      }), Es(Pr.prototype, function(f, y) {
        var w = Ft[y];
        if (w) {
          var Y = w.name + "";
          zr.call(Ea, Y) || (Ea[Y] = []), Ea[Y].push({ name: y, func: w });
        }
      }), Ea[Lo(l, W).name] = [{
        name: "wrapper",
        func: l
      }], Pr.prototype.clone = Mp, Pr.prototype.reverse = Bp, Pr.prototype.value = zp, Ft.prototype.at = cy, Ft.prototype.chain = dy, Ft.prototype.commit = fy, Ft.prototype.next = py, Ft.prototype.plant = my, Ft.prototype.reverse = gy, Ft.prototype.toJSON = Ft.prototype.valueOf = Ft.prototype.value = yy, Ft.prototype.first = Ft.prototype.head, Ba && (Ft.prototype[Ba] = hy), Ft;
    }, Sa = mp();
    Qs ? ((Qs.exports = Sa)._ = Sa, Wl._ = Sa) : di._ = Sa;
  }).call(commonjsGlobal);
})(lodash, lodash.exports);
var lodashExports = lodash.exports;
const log = (s, ...o) => {
  lodashExports.get(process, "env.NODE_ENV") === "development" && console.log(s, ...o);
};
class BaseFoundation {
  /** @return enum{css className} */
  /* istanbul ignore next */
  static get cssClasses() {
    return {};
  }
  /** @return enum{strings} */
  /* istanbul ignore next */
  static get strings() {
    return {};
  }
  /** @return enum{numbers} */
  /* istanbul ignore next */
  static get numbers() {
    return {};
  }
  static get defaultAdapter() {
    return {
      getProp: lodashExports.noop,
      getProps: lodashExports.noop,
      getState: lodashExports.noop,
      getStates: lodashExports.noop,
      setState: lodashExports.noop,
      getContext: lodashExports.noop,
      getContexts: lodashExports.noop,
      getCache: lodashExports.noop,
      setCache: lodashExports.noop,
      getCaches: lodashExports.noop,
      stopPropagation: lodashExports.noop,
      persistEvent: lodashExports.noop
    };
  }
  constructor(o) {
    this._adapter = { ...BaseFoundation.defaultAdapter, ...o };
  }
  getProp(o) {
    return this._adapter.getProp(o);
  }
  getProps() {
    return this._adapter.getProps();
  }
  getState(o) {
    return this._adapter.getState(o);
  }
  getStates() {
    return this._adapter.getStates();
  }
  setState(o, l) {
    return this._adapter.setState({ ...o }, l);
  }
  getContext(o) {
    return this._adapter.getContext(o);
  }
  /* istanbul ignore next */
  getContexts() {
    return this._adapter.getContexts();
  }
  /* istanbul ignore next */
  getCaches() {
    return this._adapter.getCaches();
  }
  getCache(o) {
    return this._adapter.getCache(o);
  }
  setCache(o, l) {
    return o && this._adapter.setCache(o, l);
  }
  stopPropagation(o) {
    this._adapter.stopPropagation(o);
  }
  // Determine whether a controlled component
  _isControlledComponent(o = "value") {
    const l = this.getProps();
    return o in l;
  }
  // Does the user have incoming props, eg: _isInProps (value)
  _isInProps(o) {
    const l = this.getProps();
    return o in l;
  }
  init(o) {
  }
  destroy() {
  }
  /* istanbul ignore next */
  log(o, ...l) {
    log(o, ...l);
  }
  _persistEvent(o) {
    this._adapter.persistEvent(o);
  }
}
const BaseFoundation$1 = BaseFoundation;
function getDataAttr(s) {
  return Object.keys(s).reduce((o, l) => (l.substr(0, 5) === "data-" && (o[l] = s[l]), o), {});
}
function useConfigContext() {
  return {
    context: inject("ConfigContext", ref$1({}))
  };
}
const Consumer$l = /* @__PURE__ */ defineComponent({
  name: "ConfigContextConsumer",
  setup() {
    const s = useSlots(), {
      context: o
    } = useConfigContext();
    return () => s.default ? s.default(o) : null;
  }
}), {
  hasOwnProperty: hasOwnProperty$3
} = Object.prototype;
function getProps(s) {
  let o = {};
  for (let l in s)
    s[l] !== void 0 && (o[l] = s[l]);
  return o;
}
const useBaseComponent = (s, o) => {
  const l = useAttrs(), u = shallowRef({}), c = shallowRef(null), {
    getProps: m
  } = useHasInProps(), g = (N) => !!(N && s && typeof s == "object" && hasOwnProperty$3.call(S().getProps(), N)), {
    context: v
  } = useConfigContext(), b = getCurrentInstance();
  function S() {
    return {
      getContext: (N) => {
        const O = b.provides;
        let z = {
          ...v.value
        };
        if (Object.keys(O).forEach((Q) => {
          z = {
            ...z,
            ...O[Q].value
          };
        }), z && N)
          return z[N];
      },
      getContexts: () => {
        const N = b.provides;
        let O = {
          ...v.value
        };
        return Object.keys(N).forEach((z) => {
          O = {
            ...O,
            ...N[z].value
          };
        }), O;
      },
      // eslint-disable-line
      getProp: (N) => s[N],
      // eslint-disable-line
      // return all props
      // @ts-ignore
      getProps: () => m(s),
      // eslint-disable-line
      getState: (N) => toRaw(o[N]),
      // eslint-disable-line
      getStates: () => o,
      // eslint-disable-line
      setState: (N, O) => {
        for (let z in N)
          N.hasOwnProperty(z) && (o[z] = N[z]);
      },
      // eslint-disable-line
      getCache: (N) => N && u.value[N],
      // eslint-disable-line
      getCaches: () => u.value,
      // eslint-disable-line
      setCache: (N, O) => N && (u.value[N] = O),
      // eslint-disable-line
      stopPropagation: (N) => {
        try {
          N.stopPropagation(), N && N.stopImmediatePropagation && N.stopImmediatePropagation();
        } catch {
        }
      },
      persistEvent: (N) => {
      }
    };
  }
  function E(N, ...O) {
    return log(N, ...O);
  }
  function P() {
    return getDataAttr({
      ...s,
      ...l
    });
  }
  function T(N) {
    return new Promise((O) => {
      Object.keys(N).forEach((z) => {
        o[z] = N[z];
      }), O();
    });
  }
  return {
    cache: u,
    foundation: c,
    state: o,
    isControlled: g,
    context: v,
    adapter: S,
    log: E,
    getDataAttr: P,
    setStateAsync: T
  };
};
function useHasInProps() {
  const s = getCurrentInstance();
  function o(u) {
    if (s)
      return s.vnode.props && u in s.vnode.props;
  }
  function l(u) {
    if (!s.vnode.props)
      return getProps(u);
    const c = {};
    for (const m in u) {
      u.hasOwnProperty(m) && m in s.vnode.props && (c[m] = u[m]), u.hasOwnProperty(m) && u[m] !== void 0 && u[m] !== !1 && (c[m] = u[m]);
      const g = s.propsOptions[0];
      c[m] === void 0 && g[m].default !== void 0 && (c[m] = g[m].default);
    }
    return c;
  }
  return {
    hasInProps: o,
    getProps: l
  };
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(s) {
  (function() {
    var o = {}.hasOwnProperty;
    function l() {
      for (var m = "", g = 0; g < arguments.length; g++) {
        var v = arguments[g];
        v && (m = c(m, u(v)));
      }
      return m;
    }
    function u(m) {
      if (typeof m == "string" || typeof m == "number")
        return m;
      if (typeof m != "object")
        return "";
      if (Array.isArray(m))
        return l.apply(null, m);
      if (m.toString !== Object.prototype.toString && !m.toString.toString().includes("[native code]"))
        return m.toString();
      var g = "";
      for (var v in m)
        o.call(m, v) && m[v] && (g = c(g, v));
      return g;
    }
    function c(m, g) {
      return g ? m ? m + " " + g : m + g : m;
    }
    s.exports ? (l.default = l, s.exports = l) : window.classNames = l;
  })();
})(classnames);
var classnamesExports = classnames.exports;
const cls = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports), BASE_CLASS_PREFIX$1 = "semi", VALIDATE_STATUS = ["default", "error", "warning", "success"], cssClasses$X = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-button`
}, strings$r = {
  sizes: ["default", "small", "large"],
  iconPositions: ["left", "right"],
  htmlTypes: ["button", "reset", "submit"],
  btnTypes: ["primary", "secondary", "tertiary", "warning", "danger"],
  themes: ["solid", "borderless", "light", "outline"],
  DEFAULT_ICON_SIZE: "default",
  DEFAULT_ICON_POSITION: "left"
};
function noop$1() {
}
const vuePropsType$3l = {
  id: String,
  circle: Boolean,
  className: String,
  icon: [Object, String],
  iconPosition: String,
  loading: Boolean,
  block: {
    type: Boolean,
    default: !1
  },
  htmlType: {
    type: String,
    default: "button"
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  size: {
    type: String,
    default: "default"
  },
  style: Object,
  type: {
    type: String,
    default: "primary"
  },
  theme: {
    type: String,
    default: "light"
  },
  onClick: {
    type: Function,
    default: noop$1
  },
  onMouseDown: {
    type: Function,
    default: noop$1
  },
  onMouseEnter: {
    type: Function,
    default: noop$1
  },
  onMouseLeave: {
    type: Function,
    default: noop$1
  },
  prefixCls: {
    type: String,
    default: cssClasses$X.PREFIX
  },
  autoFocus: {
    type: Boolean,
    default: void 0
  },
  role: String,
  "aria-label": String,
  contentClassName: String
}, Button$4 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3l
  },
  name: "Button",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        block: l,
        loading: u,
        circle: c,
        className: m,
        style: g,
        disabled: v,
        size: b,
        theme: S,
        type: E,
        prefixCls: P,
        iconPosition: T,
        htmlType: N,
        ...O
      } = s, z = {
        type: N,
        ...O,
        class: cls(P, {
          [`${P}-${E}`]: !s.disabled && E,
          [`${P}-disabled`]: s.disabled,
          [`${P}-size-large`]: b === "large",
          [`${P}-size-small`]: b === "small",
          // [`${prefixCls}-loading`]: loading,
          [`${P}-light`]: S === "light",
          [`${P}-block`]: l,
          [`${P}-circle`]: c,
          [`${P}-borderless`]: S === "borderless",
          [`${P}-outline`]: S === "outline",
          [`${P}-${E}-disabled`]: v && E
        }, m)
      };
      return createVNode("button", mergeProps$1(z, {
        onClick: s.onClick,
        onMousedown: s.onMouseDown,
        style: g
      }), [createVNode("span", {
        class: cls(`${P}-content`, s.contentClassName),
        onClick: (Q) => s.disabled && Q.stopPropagation()
      }, [o.default ? o.default() : null])]);
    };
  }
}), BaseButton = Button$4, any$1 = [Array, Object, String, Number, Boolean, Function], array$1 = Array, bool = Boolean, func = Function, number$2 = Number, object$1 = Object, string$3 = String, node$1 = [Array, Object, String, Number], element$2 = [Array, Object, String, Number], symbol = Object;
function oneOfType(s) {
  let o = [];
  return s.map((l) => {
    Array.isArray(l) ? o = [...o, ...l] : o.push(l);
  }), o;
}
function vuePropsMake(s, o) {
  const l = {};
  return Object.keys(s).forEach((u) => {
    if (o.hasOwnProperty(u))
      if (s[u].hasOwnProperty("type"))
        l[u] = {
          // @ts-ignore
          type: s[u].type,
          default: o[u]
        };
      else {
        let c = typeof o[u] == "object" ? () => o[u] : o[u];
        l[u] = {
          type: s[u],
          default: c
        };
      }
    else
      l[u] = {
        type: s[u] === void 0 ? void 0 : s[u].hasOwnProperty("type") ? (
          // @ts-ignore
          s[u].type
        ) : s[u],
        default: void 0
      };
  }), l;
}
function isNullOrUndefined(s) {
  return s == null;
}
let _id = -1;
const VuePropsType$5 = {
  id: Number,
  component: Object,
  size: Number,
  className: String,
  type: String
}, Icon$1 = /* @__PURE__ */ defineComponent({
  props: VuePropsType$5,
  name: "Icon",
  setup(s) {
    const {
      id: o,
      className: l,
      ...u
    } = s;
    let c = o;
    isNullOrUndefined(c) && (_id++, c = _id);
    const m = `linearGradient-${c}`;
    return () => createVNode("svg", mergeProps$1(u, {
      class: l,
      width: "48",
      height: "48",
      viewBox: "0 0 36 36",
      version: "1.1",
      xmlns: "http://www.w3.org/2000/svg"
    }), [createVNode("defs", null, [createVNode("linearGradient", {
      x1: "0%",
      y1: "100%",
      x2: "100%",
      y2: "100%",
      id: m
    }, [createVNode("stop", {
      "stop-color": "currentColor",
      "stop-opacity": "0",
      offset: "0%"
    }, null), createVNode("stop", {
      "stop-color": "currentColor",
      "stop-opacity": "0.50",
      offset: "39.9430698%"
    }, null), createVNode("stop", {
      "stop-color": "currentColor",
      offset: "100%"
    }, null)])]), createVNode("g", {
      id: "Artboard",
      stroke: "none",
      "stroke-width": "1",
      fill: "none",
      "fill-rule": "evenodd"
    }, [createVNode("rect", {
      id: "Rectangle",
      "fill-opacity": "0.01",
      fill: "#FFFFFF",
      x: "0",
      y: "0",
      width: "36",
      height: "36"
    }, null), createVNode("path", {
      d: "M34,18 C34,9.163444 26.836556,2 18,2 C11.6597233,2 6.18078805,5.68784135 3.59122325,11.0354951",
      id: "Path",
      stroke: `url(#${m})`,
      "stroke-width": "4",
      "stroke-linecap": "round"
    }, null)])]);
  }
});
function warning$1(s, o) {
  s && console.warn(`Warning: ${o}`);
}
const escapeRegExpFn = (s) => s.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"), findChunks = ({
  autoEscape: s,
  caseSensitive: o,
  searchWords: l,
  sourceString: u
}) => l.filter((c) => c).reduce((c, m) => {
  s && (m = escapeRegExpFn(m));
  const g = new RegExp(m, o ? "g" : "gi");
  let v;
  for (; v = g.exec(u); ) {
    const b = v.index, S = g.lastIndex;
    S > b && c.push({ highlight: !1, start: b, end: S }), v.index === g.lastIndex && g.lastIndex++;
  }
  return c;
}, []), combineChunks = ({ chunks: s }) => (s = s.sort((o, l) => o.start - l.start).reduce((o, l) => {
  if (o.length === 0)
    return [l];
  {
    const u = o.pop();
    if (l.start <= u.end) {
      const c = Math.max(u.end, l.end);
      o.push({
        highlight: !1,
        start: u.start,
        end: c
      });
    } else
      o.push(u, l);
    return o;
  }
}, []), s), fillInChunks = ({ chunksToHighlight: s, totalLength: o }) => {
  const l = [], u = (c, m, g) => {
    m - c > 0 && l.push({
      start: c,
      end: m,
      highlight: g
    });
  };
  if (s.length === 0)
    u(0, o, !1);
  else {
    let c = 0;
    s.forEach((m) => {
      u(c, m.start, !1), u(m.start, m.end, !0), c = m.end;
    }), u(c, o, !1);
  }
  return l;
}, findAll = ({
  autoEscape: s = !0,
  caseSensitive: o = !1,
  searchWords: l,
  sourceString: u
}) => {
  lodashExports.isString(l) && (l = [l]);
  const c = findChunks({
    autoEscape: s,
    caseSensitive: o,
    searchWords: l,
    sourceString: u
  }), m = combineChunks({ chunks: c });
  return fillInChunks({
    chunksToHighlight: m,
    totalLength: u ? u.length : 0
  });
};
function isElement$1(s) {
  try {
    return s instanceof HTMLElement;
  } catch {
    return typeof s == "object" && s.nodeType === 1 && typeof s.style == "object" && typeof s.ownerDocument == "object";
  }
}
function append(s, ...o) {
  for (const l of o)
    s.appendChild(l);
  return s;
}
function prepend(s, ...o) {
  if (s.children && s.children.length) {
    const l = s.children[0];
    for (const u of o)
      s.insertBefore(u, l);
  } else
    append(s, ...o);
  return s;
}
function convertDOMRectToObject(s) {
  if (s && typeof s == "object")
    return typeof s.toJSON == "function" ? s.toJSON() : ["left", "top", "right", "bottom", "width", "height"].reduce((l, u) => (l[u] = s[u], l), {});
}
function stopPropagation(s, o) {
  s && typeof s.stopPropagation == "function" && s.stopPropagation(), s && typeof s.stopImmediatePropagation == "function" && s.stopImmediatePropagation();
}
function cloneDeep$1(s, o) {
  return lodashExports.cloneDeepWith(s, (l) => {
    if (typeof o == "function")
      return o(l);
    if (typeof l == "function" || isVNode(l) || Object.prototype.toString.call(l) === "[object Error]")
      return l;
    if (Array.isArray(l) && l.length === 0) {
      const u = Object.keys(l);
      if (u.length) {
        const c = [];
        return u.forEach((m) => {
          lodashExports.set(c, m, l[m]);
        }), warning$1(lodashExports.get(process, "env.NODE_ENV") !== "production", `[Semi] You may use an out-of-bounds array. In some cases, your program may not behave as expected.
                    The maximum length of an array is 4294967295.
                    Please check whether the array subscript in your data exceeds the maximum value of the JS array subscript`), c;
      } else
        return;
    }
  });
}
const getHighLightTextHTML = ({
  sourceString: s = "",
  searchWords: o = [],
  option: l = {
    autoEscape: !0,
    caseSensitive: !1
  }
}) => {
  const u = findAll({
    sourceString: s,
    searchWords: o,
    ...l
  }), c = l.highlightTag || "mark", m = l.highlightClassName || "", g = l.highlightStyle || {};
  return u.map((v) => {
    const {
      end: b,
      start: S,
      highlight: E
    } = v, P = s.substr(S, b - S);
    return E ? h(c, {
      style: g,
      className: m
    }, P) : P;
  });
}, registerMediaQuery = (s, {
  match: o,
  unmatch: l,
  callInInit: u = !0
}) => {
  if (typeof window < "u") {
    let m = function(g) {
      g.matches ? o && o(g) : l && l(g);
    };
    const c = window.matchMedia(s);
    return u && m(c), c.addEventListener("change", m), () => c.removeEventListener("change", m);
  }
  return null;
}, isSemiIcon = (s) => {
  var o, l;
  return isVNode(s) && ((l = (o = s.type) == null ? void 0 : o.name) == null ? void 0 : l.indexOf("Icon")) > -1;
};
function getActiveElement() {
  return document ? document.activeElement : null;
}
function getFocusableElements(s) {
  if (!isElement$1(s))
    return [];
  const l = ["input:not([disabled]):not([tabindex='-1'])", "textarea:not([disabled]):not([tabindex='-1'])", "button:not([disabled]):not([tabindex='-1'])", "a[href]:not([tabindex='-1'])", "select:not([disabled]):not([tabindex='-1'])", "area[href]:not([tabindex='-1'])", "iframe:not([tabindex='-1'])", "object:not([tabindex='-1'])", "*[tabindex]:not([tabindex='-1'])", "*[contenteditable]:not([tabindex='-1'])"].join(",");
  return Array.from(s.querySelectorAll(l));
}
async function runAfterTicks(s, o) {
  if (o === 0) {
    await s();
    return;
  } else {
    await new Promise((l) => {
      setTimeout(async () => {
        await runAfterTicks(s, o - 1), l();
      }, 0);
    });
    return;
  }
}
function getFragmentChildren(s) {
  var l;
  const o = (l = s.default) == null ? void 0 : l.call(s);
  if (o && Array.isArray(o) && o.length) {
    const u = [];
    return o.forEach((c) => {
      var m;
      ((m = c.type) == null ? void 0 : m.toString()) === "Symbol(v-fgt)" && Array.isArray(c.children) ? c.children.forEach((g) => {
        u.push(g);
      }) : u.push(c);
    }), u;
  } else
    return o;
}
function getScrollbarWidth() {
  return globalThis && Object.prototype.toString.call(globalThis) === "[object Window]" ? window.innerWidth - document.documentElement.clientWidth : 0;
}
function styleNum(s) {
  return isNaN(+s) ? s : s + "px";
}
function isVNodeTypeNotSymbol(s) {
  return !(["Symbol(v-fgt)", "Symbol(v-cmt)", "Symbol(v-txt)"].indexOf(s.type.toString()) > -1);
}
function getMultinodeToFragment(s) {
  let o = s.default ? s.default() : null;
  if (Array.isArray(o) && o.length === 1)
    return o[0];
  if (Array.isArray(o) && o.length > 1)
    return createVNode(Fragment, null, [o]);
}
const propsType$2 = {
  ...vuePropsType$3l,
  iconStyle: object$1,
  style: object$1,
  loading: bool,
  prefixCls: string$3,
  icon: oneOfType([object$1, string$3, node$1]),
  iconSize: string$3,
  noHorizontalPadding: oneOfType([bool, string$3, array$1]),
  theme: string$3,
  iconPosition: string$3,
  className: string$3,
  onMouseEnter: func,
  onMouseLeave: func,
  class: String,
  role: String,
  contentClassName: String
}, vuePropsType$3k = vuePropsMake(propsType$2, {
  iconPosition: strings$r.DEFAULT_ICON_POSITION,
  prefixCls: cssClasses$X.PREFIX,
  loading: !1,
  noHorizontalPadding: !1,
  //  true same as ['left', 'right']
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop
}), Index$a = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3k
  },
  name: "IconButton",
  setup(s, {
    slots: o
  }) {
    const {
      getProps: l
    } = useHasInProps();
    return () => {
      const {
        iconPosition: u,
        iconSize: c,
        iconStyle: m,
        style: g,
        icon: v,
        noHorizontalPadding: b,
        theme: S,
        className: E,
        prefixCls: P,
        loading: T,
        ...N
      } = l(s), O = g;
      Array.isArray(b) ? (b.includes("left") && (O.paddingLeft = 0), b.includes("right") && (O.paddingRight = 0)) : b === !0 && (O.paddingLeft = 0, O.paddingRight = 0);
      const z = cls({
        [`${P}-content-left`]: u === "right",
        [`${P}-content-right`]: u === "left"
      });
      return createVNode(BaseButton, mergeProps$1(N, {
        className: cls(E, `${P}-with-icon`, {
          [`${P}-with-icon-only`]: !o.default || !o.default(),
          [`${P}-loading`]: T
        }),
        theme: S,
        style: O
      }), {
        default: () => {
          let Q = () => null;
          T && !N.disabled ? Q = () => createVNode(Icon$1, null, null) : isVNode(v) ? Q = () => v : typeof v.setup == "function" && (Q = () => createVNode(v, null, null));
          const W = () => getFragmentChildren(o) ? createVNode("span", {
            class: Q() ? z : ""
          }, [o.default ? o.default() : null]) : null;
          return u === "left" ? createVNode(Fragment, null, [Q(), W ? W() : null]) : createVNode(Fragment, null, [W ? W() : null, Q()]);
        }
      });
    };
  }
}), Button$3 = Index$a, Button$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3l
  },
  name: "Button",
  emits: ["click"],
  setup(s, {
    slots: o,
    emit: l
  }) {
    return () => {
      const u = !!s.icon, c = !!s.loading, m = !!s.disabled;
      return u || c && !m ? createVNode(Button$3, s, {
        default: o.default
      }) : createVNode(BaseButton, s, {
        default: o.default
      });
    };
  }
}), Button$2 = Button$1, prefixCls$X = cssClasses$X.PREFIX, vuePropsType$3j = {
  disabled: Boolean,
  size: {
    type: String,
    default: "default"
  },
  type: {
    type: String,
    default: "primary"
  },
  theme: {
    type: String,
    default: "light"
  },
  "aria-label": String,
  style: Object,
  className: String
}, ButtonGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3j
  },
  name: "ButtonGroup",
  setup(s, {
    slots: o
  }) {
    function l(u) {
      const c = [];
      return u.length > 1 ? (u.slice(0, -1).forEach((m, g) => {
        const v = lodashExports.get(m, "type.elementType") === "Button", b = lodashExports.get(m, "props"), {
          type: S,
          theme: E,
          disabled: P
        } = b ?? {};
        if (v && E !== "outline") {
          const T = cls(`${prefixCls$X}-group-line`, `${prefixCls$X}-group-line-${E ?? "light"}`, `${prefixCls$X}-group-line-${S ?? "primary"}`, {
            [`${prefixCls$X}-group-line-disabled`]: P
          });
          c.push(m, createVNode("span", {
            class: T,
            key: `line-${g}`
          }, null));
        } else
          c.push(m);
      }), c.push(u.slice(-1)), c) : u;
    }
    return () => {
      var O;
      const u = (O = o.default) == null ? void 0 : O.call(o), {
        disabled: c,
        size: m,
        type: g,
        className: v,
        style: b,
        "aria-label": S,
        ...E
      } = s;
      let P, T = [];
      const N = cls(`${prefixCls$X}-group`, v);
      return u && (P = (Array.isArray(u) ? u : [u]).map((z, Q) => isVNode(z) ? cloneVNode(z, {
        disabled: c,
        size: m,
        type: g,
        ...z.props,
        ...E,
        key: z.key ?? Q
      }) : z), T = l(P)), createVNode("div", {
        class: N,
        style: b,
        role: "group",
        "aria-label": S
      }, [T]);
    };
  }
}), ButtonGroup$1 = ButtonGroup;
function buildFormatLongFn$1(s) {
  return function() {
    var o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = o.width ? String(o.width) : s.defaultWidth, u = s.formats[l] || s.formats[s.defaultWidth];
    return u;
  };
}
function buildLocalizeFn$1(s) {
  return function(o, l) {
    var u = l != null && l.context ? String(l.context) : "standalone", c;
    if (u === "formatting" && s.formattingValues) {
      var m = s.defaultFormattingWidth || s.defaultWidth, g = l != null && l.width ? String(l.width) : m;
      c = s.formattingValues[g] || s.formattingValues[m];
    } else {
      var v = s.defaultWidth, b = l != null && l.width ? String(l.width) : s.defaultWidth;
      c = s.values[b] || s.values[v];
    }
    var S = s.argumentCallback ? s.argumentCallback(o) : o;
    return c[S];
  };
}
function buildMatchFn$1(s) {
  return function(o) {
    var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = l.width, c = u && s.matchPatterns[u] || s.matchPatterns[s.defaultMatchWidth], m = o.match(c);
    if (!m)
      return null;
    var g = m[0], v = u && s.parsePatterns[u] || s.parsePatterns[s.defaultParseWidth], b = Array.isArray(v) ? findIndex(v, function(P) {
      return P.test(g);
    }) : findKey(v, function(P) {
      return P.test(g);
    }), S;
    S = s.valueCallback ? s.valueCallback(b) : b, S = l.valueCallback ? l.valueCallback(S) : S;
    var E = o.slice(g.length);
    return {
      value: S,
      rest: E
    };
  };
}
function findKey(s, o) {
  for (var l in s)
    if (s.hasOwnProperty(l) && o(s[l]))
      return l;
}
function findIndex(s, o) {
  for (var l = 0; l < s.length; l++)
    if (o(s[l]))
      return l;
}
function buildMatchPatternFn$1(s) {
  return function(o) {
    var l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, u = o.match(s.matchPattern);
    if (!u) return null;
    var c = u[0], m = o.match(s.parsePattern);
    if (!m) return null;
    var g = s.valueCallback ? s.valueCallback(m[0]) : m[0];
    g = l.valueCallback ? l.valueCallback(g) : g;
    var v = o.slice(c.length);
    return {
      value: g,
      rest: v
    };
  };
}
function _typeof$1(s) {
  "@babel/helpers - typeof";
  return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
    return typeof o;
  } : function(o) {
    return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
  }, _typeof$1(s);
}
function toInteger$1(s) {
  if (s === null || s === !0 || s === !1)
    return NaN;
  var o = Number(s);
  return isNaN(o) ? o : o < 0 ? Math.ceil(o) : Math.floor(o);
}
function requiredArgs$1(s, o) {
  if (o.length < s)
    throw new TypeError(s + " argument" + (s > 1 ? "s" : "") + " required, but only " + o.length + " present");
}
function toDate$2(s) {
  requiredArgs$1(1, arguments);
  var o = Object.prototype.toString.call(s);
  return s instanceof Date || _typeof$1(s) === "object" && o === "[object Date]" ? new Date(s.getTime()) : typeof s == "number" || o === "[object Number]" ? new Date(s) : ((typeof s == "string" || o === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
}
function addMonths(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toInteger$1(o);
  if (isNaN(u))
    return /* @__PURE__ */ new Date(NaN);
  if (!u)
    return l;
  var c = l.getDate(), m = new Date(l.getTime());
  m.setMonth(l.getMonth() + u + 1, 0);
  var g = m.getDate();
  return c >= g ? m : (l.setFullYear(m.getFullYear(), m.getMonth(), c), l);
}
function addMilliseconds$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s).getTime(), u = toInteger$1(o);
  return new Date(l + u);
}
var defaultOptions$3 = {};
function getDefaultOptions$1() {
  return defaultOptions$3;
}
function getTimezoneOffsetInMilliseconds$1(s) {
  var o = new Date(Date.UTC(s.getFullYear(), s.getMonth(), s.getDate(), s.getHours(), s.getMinutes(), s.getSeconds(), s.getMilliseconds()));
  return o.setUTCFullYear(s.getFullYear()), s.getTime() - o.getTime();
}
function startOfDay(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s);
  return o.setHours(0, 0, 0, 0), o;
}
function addYears(s, o) {
  requiredArgs$1(2, arguments);
  var l = toInteger$1(o);
  return addMonths(s, l * 12);
}
var millisecondsInMinute = 6e4, millisecondsInHour = 36e5, millisecondsInSecond = 1e3;
function isSameDay$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = startOfDay(s), u = startOfDay(o);
  return l.getTime() === u.getTime();
}
function isDate$1(s) {
  return requiredArgs$1(1, arguments), s instanceof Date || _typeof$1(s) === "object" && Object.prototype.toString.call(s) === "[object Date]";
}
function isValid$5(s) {
  if (requiredArgs$1(1, arguments), !isDate$1(s) && typeof s != "number")
    return !1;
  var o = toDate$2(s);
  return !isNaN(Number(o));
}
function differenceInCalendarMonths(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toDate$2(o), c = l.getFullYear() - u.getFullYear(), m = l.getMonth() - u.getMonth();
  return c * 12 + m;
}
function differenceInCalendarYears(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toDate$2(o);
  return l.getFullYear() - u.getFullYear();
}
function startOfMonth(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s);
  return o.setDate(1), o.setHours(0, 0, 0, 0), o;
}
function subMilliseconds$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = toInteger$1(o);
  return addMilliseconds$1(s, -l);
}
var MILLISECONDS_IN_DAY = 864e5;
function getUTCDayOfYear$1(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = o.getTime();
  o.setUTCMonth(0, 1), o.setUTCHours(0, 0, 0, 0);
  var u = o.getTime(), c = l - u;
  return Math.floor(c / MILLISECONDS_IN_DAY) + 1;
}
function startOfUTCISOWeek$1(s) {
  requiredArgs$1(1, arguments);
  var o = 1, l = toDate$2(s), u = l.getUTCDay(), c = (u < o ? 7 : 0) + u - o;
  return l.setUTCDate(l.getUTCDate() - c), l.setUTCHours(0, 0, 0, 0), l;
}
function getUTCISOWeekYear$1(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = o.getUTCFullYear(), u = /* @__PURE__ */ new Date(0);
  u.setUTCFullYear(l + 1, 0, 4), u.setUTCHours(0, 0, 0, 0);
  var c = startOfUTCISOWeek$1(u), m = /* @__PURE__ */ new Date(0);
  m.setUTCFullYear(l, 0, 4), m.setUTCHours(0, 0, 0, 0);
  var g = startOfUTCISOWeek$1(m);
  return o.getTime() >= c.getTime() ? l + 1 : o.getTime() >= g.getTime() ? l : l - 1;
}
function startOfUTCISOWeekYear$1(s) {
  requiredArgs$1(1, arguments);
  var o = getUTCISOWeekYear$1(s), l = /* @__PURE__ */ new Date(0);
  l.setUTCFullYear(o, 0, 4), l.setUTCHours(0, 0, 0, 0);
  var u = startOfUTCISOWeek$1(l);
  return u;
}
var MILLISECONDS_IN_WEEK$1 = 6048e5;
function getUTCISOWeek$1(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = startOfUTCISOWeek$1(o).getTime() - startOfUTCISOWeekYear$1(o).getTime();
  return Math.round(l / MILLISECONDS_IN_WEEK$1) + 1;
}
function startOfUTCWeek$1(s, o) {
  var l, u, c, m, g, v, b, S;
  requiredArgs$1(1, arguments);
  var E = getDefaultOptions$1(), P = toInteger$1((l = (u = (c = (m = o == null ? void 0 : o.weekStartsOn) !== null && m !== void 0 ? m : o == null || (g = o.locale) === null || g === void 0 || (v = g.options) === null || v === void 0 ? void 0 : v.weekStartsOn) !== null && c !== void 0 ? c : E.weekStartsOn) !== null && u !== void 0 ? u : (b = E.locale) === null || b === void 0 || (S = b.options) === null || S === void 0 ? void 0 : S.weekStartsOn) !== null && l !== void 0 ? l : 0);
  if (!(P >= 0 && P <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var T = toDate$2(s), N = T.getUTCDay(), O = (N < P ? 7 : 0) + N - P;
  return T.setUTCDate(T.getUTCDate() - O), T.setUTCHours(0, 0, 0, 0), T;
}
function getUTCWeekYear$1(s, o) {
  var l, u, c, m, g, v, b, S;
  requiredArgs$1(1, arguments);
  var E = toDate$2(s), P = E.getUTCFullYear(), T = getDefaultOptions$1(), N = toInteger$1((l = (u = (c = (m = o == null ? void 0 : o.firstWeekContainsDate) !== null && m !== void 0 ? m : o == null || (g = o.locale) === null || g === void 0 || (v = g.options) === null || v === void 0 ? void 0 : v.firstWeekContainsDate) !== null && c !== void 0 ? c : T.firstWeekContainsDate) !== null && u !== void 0 ? u : (b = T.locale) === null || b === void 0 || (S = b.options) === null || S === void 0 ? void 0 : S.firstWeekContainsDate) !== null && l !== void 0 ? l : 1);
  if (!(N >= 1 && N <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var O = /* @__PURE__ */ new Date(0);
  O.setUTCFullYear(P + 1, 0, N), O.setUTCHours(0, 0, 0, 0);
  var z = startOfUTCWeek$1(O, o), Q = /* @__PURE__ */ new Date(0);
  Q.setUTCFullYear(P, 0, N), Q.setUTCHours(0, 0, 0, 0);
  var W = startOfUTCWeek$1(Q, o);
  return E.getTime() >= z.getTime() ? P + 1 : E.getTime() >= W.getTime() ? P : P - 1;
}
function startOfUTCWeekYear$1(s, o) {
  var l, u, c, m, g, v, b, S;
  requiredArgs$1(1, arguments);
  var E = getDefaultOptions$1(), P = toInteger$1((l = (u = (c = (m = o == null ? void 0 : o.firstWeekContainsDate) !== null && m !== void 0 ? m : o == null || (g = o.locale) === null || g === void 0 || (v = g.options) === null || v === void 0 ? void 0 : v.firstWeekContainsDate) !== null && c !== void 0 ? c : E.firstWeekContainsDate) !== null && u !== void 0 ? u : (b = E.locale) === null || b === void 0 || (S = b.options) === null || S === void 0 ? void 0 : S.firstWeekContainsDate) !== null && l !== void 0 ? l : 1), T = getUTCWeekYear$1(s, o), N = /* @__PURE__ */ new Date(0);
  N.setUTCFullYear(T, 0, P), N.setUTCHours(0, 0, 0, 0);
  var O = startOfUTCWeek$1(N, o);
  return O;
}
var MILLISECONDS_IN_WEEK = 6048e5;
function getUTCWeek$1(s, o) {
  requiredArgs$1(1, arguments);
  var l = toDate$2(s), u = startOfUTCWeek$1(l, o).getTime() - startOfUTCWeekYear$1(l, o).getTime();
  return Math.round(u / MILLISECONDS_IN_WEEK) + 1;
}
function addLeadingZeros$1(s, o) {
  for (var l = s < 0 ? "-" : "", u = Math.abs(s).toString(); u.length < o; )
    u = "0" + u;
  return l + u;
}
var formatters$3 = {
  // Year
  y: function(o, l) {
    var u = o.getUTCFullYear(), c = u > 0 ? u : 1 - u;
    return addLeadingZeros$1(l === "yy" ? c % 100 : c, l.length);
  },
  // Month
  M: function(o, l) {
    var u = o.getUTCMonth();
    return l === "M" ? String(u + 1) : addLeadingZeros$1(u + 1, 2);
  },
  // Day of the month
  d: function(o, l) {
    return addLeadingZeros$1(o.getUTCDate(), l.length);
  },
  // AM or PM
  a: function(o, l) {
    var u = o.getUTCHours() / 12 >= 1 ? "pm" : "am";
    switch (l) {
      case "a":
      case "aa":
        return u.toUpperCase();
      case "aaa":
        return u;
      case "aaaaa":
        return u[0];
      case "aaaa":
      default:
        return u === "am" ? "a.m." : "p.m.";
    }
  },
  // Hour [1-12]
  h: function(o, l) {
    return addLeadingZeros$1(o.getUTCHours() % 12 || 12, l.length);
  },
  // Hour [0-23]
  H: function(o, l) {
    return addLeadingZeros$1(o.getUTCHours(), l.length);
  },
  // Minute
  m: function(o, l) {
    return addLeadingZeros$1(o.getUTCMinutes(), l.length);
  },
  // Second
  s: function(o, l) {
    return addLeadingZeros$1(o.getUTCSeconds(), l.length);
  },
  // Fraction of second
  S: function(o, l) {
    var u = l.length, c = o.getUTCMilliseconds(), m = Math.floor(c * Math.pow(10, u - 3));
    return addLeadingZeros$1(m, l.length);
  }
}, dayPeriodEnum = {
  am: "am",
  pm: "pm",
  midnight: "midnight",
  noon: "noon",
  morning: "morning",
  afternoon: "afternoon",
  evening: "evening",
  night: "night"
}, formatters$2 = {
  // Era
  G: function(o, l, u) {
    var c = o.getUTCFullYear() > 0 ? 1 : 0;
    switch (l) {
      case "G":
      case "GG":
      case "GGG":
        return u.era(c, {
          width: "abbreviated"
        });
      case "GGGGG":
        return u.era(c, {
          width: "narrow"
        });
      case "GGGG":
      default:
        return u.era(c, {
          width: "wide"
        });
    }
  },
  // Year
  y: function(o, l, u) {
    if (l === "yo") {
      var c = o.getUTCFullYear(), m = c > 0 ? c : 1 - c;
      return u.ordinalNumber(m, {
        unit: "year"
      });
    }
    return formatters$3.y(o, l);
  },
  // Local week-numbering year
  Y: function(o, l, u, c) {
    var m = getUTCWeekYear$1(o, c), g = m > 0 ? m : 1 - m;
    if (l === "YY") {
      var v = g % 100;
      return addLeadingZeros$1(v, 2);
    }
    return l === "Yo" ? u.ordinalNumber(g, {
      unit: "year"
    }) : addLeadingZeros$1(g, l.length);
  },
  // ISO week-numbering year
  R: function(o, l) {
    var u = getUTCISOWeekYear$1(o);
    return addLeadingZeros$1(u, l.length);
  },
  // Extended year. This is a single number designating the year of this calendar system.
  // The main difference between `y` and `u` localizers are B.C. years:
  // | Year | `y` | `u` |
  // |------|-----|-----|
  // | AC 1 |   1 |   1 |
  // | BC 1 |   1 |   0 |
  // | BC 2 |   2 |  -1 |
  // Also `yy` always returns the last two digits of a year,
  // while `uu` pads single digit years to 2 characters and returns other years unchanged.
  u: function(o, l) {
    var u = o.getUTCFullYear();
    return addLeadingZeros$1(u, l.length);
  },
  // Quarter
  Q: function(o, l, u) {
    var c = Math.ceil((o.getUTCMonth() + 1) / 3);
    switch (l) {
      case "Q":
        return String(c);
      case "QQ":
        return addLeadingZeros$1(c, 2);
      case "Qo":
        return u.ordinalNumber(c, {
          unit: "quarter"
        });
      case "QQQ":
        return u.quarter(c, {
          width: "abbreviated",
          context: "formatting"
        });
      case "QQQQQ":
        return u.quarter(c, {
          width: "narrow",
          context: "formatting"
        });
      case "QQQQ":
      default:
        return u.quarter(c, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone quarter
  q: function(o, l, u) {
    var c = Math.ceil((o.getUTCMonth() + 1) / 3);
    switch (l) {
      case "q":
        return String(c);
      case "qq":
        return addLeadingZeros$1(c, 2);
      case "qo":
        return u.ordinalNumber(c, {
          unit: "quarter"
        });
      case "qqq":
        return u.quarter(c, {
          width: "abbreviated",
          context: "standalone"
        });
      case "qqqqq":
        return u.quarter(c, {
          width: "narrow",
          context: "standalone"
        });
      case "qqqq":
      default:
        return u.quarter(c, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Month
  M: function(o, l, u) {
    var c = o.getUTCMonth();
    switch (l) {
      case "M":
      case "MM":
        return formatters$3.M(o, l);
      case "Mo":
        return u.ordinalNumber(c + 1, {
          unit: "month"
        });
      case "MMM":
        return u.month(c, {
          width: "abbreviated",
          context: "formatting"
        });
      case "MMMMM":
        return u.month(c, {
          width: "narrow",
          context: "formatting"
        });
      case "MMMM":
      default:
        return u.month(c, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone month
  L: function(o, l, u) {
    var c = o.getUTCMonth();
    switch (l) {
      case "L":
        return String(c + 1);
      case "LL":
        return addLeadingZeros$1(c + 1, 2);
      case "Lo":
        return u.ordinalNumber(c + 1, {
          unit: "month"
        });
      case "LLL":
        return u.month(c, {
          width: "abbreviated",
          context: "standalone"
        });
      case "LLLLL":
        return u.month(c, {
          width: "narrow",
          context: "standalone"
        });
      case "LLLL":
      default:
        return u.month(c, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // Local week of year
  w: function(o, l, u, c) {
    var m = getUTCWeek$1(o, c);
    return l === "wo" ? u.ordinalNumber(m, {
      unit: "week"
    }) : addLeadingZeros$1(m, l.length);
  },
  // ISO week of year
  I: function(o, l, u) {
    var c = getUTCISOWeek$1(o);
    return l === "Io" ? u.ordinalNumber(c, {
      unit: "week"
    }) : addLeadingZeros$1(c, l.length);
  },
  // Day of the month
  d: function(o, l, u) {
    return l === "do" ? u.ordinalNumber(o.getUTCDate(), {
      unit: "date"
    }) : formatters$3.d(o, l);
  },
  // Day of year
  D: function(o, l, u) {
    var c = getUTCDayOfYear$1(o);
    return l === "Do" ? u.ordinalNumber(c, {
      unit: "dayOfYear"
    }) : addLeadingZeros$1(c, l.length);
  },
  // Day of week
  E: function(o, l, u) {
    var c = o.getUTCDay();
    switch (l) {
      case "E":
      case "EE":
      case "EEE":
        return u.day(c, {
          width: "abbreviated",
          context: "formatting"
        });
      case "EEEEE":
        return u.day(c, {
          width: "narrow",
          context: "formatting"
        });
      case "EEEEEE":
        return u.day(c, {
          width: "short",
          context: "formatting"
        });
      case "EEEE":
      default:
        return u.day(c, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Local day of week
  e: function(o, l, u, c) {
    var m = o.getUTCDay(), g = (m - c.weekStartsOn + 8) % 7 || 7;
    switch (l) {
      case "e":
        return String(g);
      case "ee":
        return addLeadingZeros$1(g, 2);
      case "eo":
        return u.ordinalNumber(g, {
          unit: "day"
        });
      case "eee":
        return u.day(m, {
          width: "abbreviated",
          context: "formatting"
        });
      case "eeeee":
        return u.day(m, {
          width: "narrow",
          context: "formatting"
        });
      case "eeeeee":
        return u.day(m, {
          width: "short",
          context: "formatting"
        });
      case "eeee":
      default:
        return u.day(m, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Stand-alone local day of week
  c: function(o, l, u, c) {
    var m = o.getUTCDay(), g = (m - c.weekStartsOn + 8) % 7 || 7;
    switch (l) {
      case "c":
        return String(g);
      case "cc":
        return addLeadingZeros$1(g, l.length);
      case "co":
        return u.ordinalNumber(g, {
          unit: "day"
        });
      case "ccc":
        return u.day(m, {
          width: "abbreviated",
          context: "standalone"
        });
      case "ccccc":
        return u.day(m, {
          width: "narrow",
          context: "standalone"
        });
      case "cccccc":
        return u.day(m, {
          width: "short",
          context: "standalone"
        });
      case "cccc":
      default:
        return u.day(m, {
          width: "wide",
          context: "standalone"
        });
    }
  },
  // ISO day of week
  i: function(o, l, u) {
    var c = o.getUTCDay(), m = c === 0 ? 7 : c;
    switch (l) {
      case "i":
        return String(m);
      case "ii":
        return addLeadingZeros$1(m, l.length);
      case "io":
        return u.ordinalNumber(m, {
          unit: "day"
        });
      case "iii":
        return u.day(c, {
          width: "abbreviated",
          context: "formatting"
        });
      case "iiiii":
        return u.day(c, {
          width: "narrow",
          context: "formatting"
        });
      case "iiiiii":
        return u.day(c, {
          width: "short",
          context: "formatting"
        });
      case "iiii":
      default:
        return u.day(c, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM or PM
  a: function(o, l, u) {
    var c = o.getUTCHours(), m = c / 12 >= 1 ? "pm" : "am";
    switch (l) {
      case "a":
      case "aa":
        return u.dayPeriod(m, {
          width: "abbreviated",
          context: "formatting"
        });
      case "aaa":
        return u.dayPeriod(m, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "aaaaa":
        return u.dayPeriod(m, {
          width: "narrow",
          context: "formatting"
        });
      case "aaaa":
      default:
        return u.dayPeriod(m, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // AM, PM, midnight, noon
  b: function(o, l, u) {
    var c = o.getUTCHours(), m;
    switch (c === 12 ? m = dayPeriodEnum.noon : c === 0 ? m = dayPeriodEnum.midnight : m = c / 12 >= 1 ? "pm" : "am", l) {
      case "b":
      case "bb":
        return u.dayPeriod(m, {
          width: "abbreviated",
          context: "formatting"
        });
      case "bbb":
        return u.dayPeriod(m, {
          width: "abbreviated",
          context: "formatting"
        }).toLowerCase();
      case "bbbbb":
        return u.dayPeriod(m, {
          width: "narrow",
          context: "formatting"
        });
      case "bbbb":
      default:
        return u.dayPeriod(m, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // in the morning, in the afternoon, in the evening, at night
  B: function(o, l, u) {
    var c = o.getUTCHours(), m;
    switch (c >= 17 ? m = dayPeriodEnum.evening : c >= 12 ? m = dayPeriodEnum.afternoon : c >= 4 ? m = dayPeriodEnum.morning : m = dayPeriodEnum.night, l) {
      case "B":
      case "BB":
      case "BBB":
        return u.dayPeriod(m, {
          width: "abbreviated",
          context: "formatting"
        });
      case "BBBBB":
        return u.dayPeriod(m, {
          width: "narrow",
          context: "formatting"
        });
      case "BBBB":
      default:
        return u.dayPeriod(m, {
          width: "wide",
          context: "formatting"
        });
    }
  },
  // Hour [1-12]
  h: function(o, l, u) {
    if (l === "ho") {
      var c = o.getUTCHours() % 12;
      return c === 0 && (c = 12), u.ordinalNumber(c, {
        unit: "hour"
      });
    }
    return formatters$3.h(o, l);
  },
  // Hour [0-23]
  H: function(o, l, u) {
    return l === "Ho" ? u.ordinalNumber(o.getUTCHours(), {
      unit: "hour"
    }) : formatters$3.H(o, l);
  },
  // Hour [0-11]
  K: function(o, l, u) {
    var c = o.getUTCHours() % 12;
    return l === "Ko" ? u.ordinalNumber(c, {
      unit: "hour"
    }) : addLeadingZeros$1(c, l.length);
  },
  // Hour [1-24]
  k: function(o, l, u) {
    var c = o.getUTCHours();
    return c === 0 && (c = 24), l === "ko" ? u.ordinalNumber(c, {
      unit: "hour"
    }) : addLeadingZeros$1(c, l.length);
  },
  // Minute
  m: function(o, l, u) {
    return l === "mo" ? u.ordinalNumber(o.getUTCMinutes(), {
      unit: "minute"
    }) : formatters$3.m(o, l);
  },
  // Second
  s: function(o, l, u) {
    return l === "so" ? u.ordinalNumber(o.getUTCSeconds(), {
      unit: "second"
    }) : formatters$3.s(o, l);
  },
  // Fraction of second
  S: function(o, l) {
    return formatters$3.S(o, l);
  },
  // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
  X: function(o, l, u, c) {
    var m = c._originalDate || o, g = m.getTimezoneOffset();
    if (g === 0)
      return "Z";
    switch (l) {
      case "X":
        return formatTimezoneWithOptionalMinutes(g);
      case "XXXX":
      case "XX":
        return formatTimezone(g);
      case "XXXXX":
      case "XXX":
      default:
        return formatTimezone(g, ":");
    }
  },
  // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
  x: function(o, l, u, c) {
    var m = c._originalDate || o, g = m.getTimezoneOffset();
    switch (l) {
      case "x":
        return formatTimezoneWithOptionalMinutes(g);
      case "xxxx":
      case "xx":
        return formatTimezone(g);
      case "xxxxx":
      case "xxx":
      default:
        return formatTimezone(g, ":");
    }
  },
  // Timezone (GMT)
  O: function(o, l, u, c) {
    var m = c._originalDate || o, g = m.getTimezoneOffset();
    switch (l) {
      case "O":
      case "OO":
      case "OOO":
        return "GMT" + formatTimezoneShort(g, ":");
      case "OOOO":
      default:
        return "GMT" + formatTimezone(g, ":");
    }
  },
  // Timezone (specific non-location)
  z: function(o, l, u, c) {
    var m = c._originalDate || o, g = m.getTimezoneOffset();
    switch (l) {
      case "z":
      case "zz":
      case "zzz":
        return "GMT" + formatTimezoneShort(g, ":");
      case "zzzz":
      default:
        return "GMT" + formatTimezone(g, ":");
    }
  },
  // Seconds timestamp
  t: function(o, l, u, c) {
    var m = c._originalDate || o, g = Math.floor(m.getTime() / 1e3);
    return addLeadingZeros$1(g, l.length);
  },
  // Milliseconds timestamp
  T: function(o, l, u, c) {
    var m = c._originalDate || o, g = m.getTime();
    return addLeadingZeros$1(g, l.length);
  }
};
function formatTimezoneShort(s, o) {
  var l = s > 0 ? "-" : "+", u = Math.abs(s), c = Math.floor(u / 60), m = u % 60;
  if (m === 0)
    return l + String(c);
  var g = o;
  return l + String(c) + g + addLeadingZeros$1(m, 2);
}
function formatTimezoneWithOptionalMinutes(s, o) {
  if (s % 60 === 0) {
    var l = s > 0 ? "-" : "+";
    return l + addLeadingZeros$1(Math.abs(s) / 60, 2);
  }
  return formatTimezone(s, o);
}
function formatTimezone(s, o) {
  var l = o || "", u = s > 0 ? "-" : "+", c = Math.abs(s), m = addLeadingZeros$1(Math.floor(c / 60), 2), g = addLeadingZeros$1(c % 60, 2);
  return u + m + l + g;
}
var dateLongFormatter = function(o, l) {
  switch (o) {
    case "P":
      return l.date({
        width: "short"
      });
    case "PP":
      return l.date({
        width: "medium"
      });
    case "PPP":
      return l.date({
        width: "long"
      });
    case "PPPP":
    default:
      return l.date({
        width: "full"
      });
  }
}, timeLongFormatter = function(o, l) {
  switch (o) {
    case "p":
      return l.time({
        width: "short"
      });
    case "pp":
      return l.time({
        width: "medium"
      });
    case "ppp":
      return l.time({
        width: "long"
      });
    case "pppp":
    default:
      return l.time({
        width: "full"
      });
  }
}, dateTimeLongFormatter = function(o, l) {
  var u = o.match(/(P+)(p+)?/) || [], c = u[1], m = u[2];
  if (!m)
    return dateLongFormatter(o, l);
  var g;
  switch (c) {
    case "P":
      g = l.dateTime({
        width: "short"
      });
      break;
    case "PP":
      g = l.dateTime({
        width: "medium"
      });
      break;
    case "PPP":
      g = l.dateTime({
        width: "long"
      });
      break;
    case "PPPP":
    default:
      g = l.dateTime({
        width: "full"
      });
      break;
  }
  return g.replace("{{date}}", dateLongFormatter(c, l)).replace("{{time}}", timeLongFormatter(m, l));
}, longFormatters$1 = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
}, protectedDayOfYearTokens$1 = ["D", "DD"], protectedWeekYearTokens$1 = ["YY", "YYYY"];
function isProtectedDayOfYearToken$1(s) {
  return protectedDayOfYearTokens$1.indexOf(s) !== -1;
}
function isProtectedWeekYearToken$1(s) {
  return protectedWeekYearTokens$1.indexOf(s) !== -1;
}
function throwProtectedError$1(s, o, l) {
  if (s === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(o, "`) for formatting years to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(o, "`) for formatting years to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(o, "`) for formatting days of the month to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(o, "`) for formatting days of the month to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var formatDistanceLocale$1 = {
  lessThanXSeconds: {
    one: "less than a second",
    other: "less than {{count}} seconds"
  },
  xSeconds: {
    one: "1 second",
    other: "{{count}} seconds"
  },
  halfAMinute: "half a minute",
  lessThanXMinutes: {
    one: "less than a minute",
    other: "less than {{count}} minutes"
  },
  xMinutes: {
    one: "1 minute",
    other: "{{count}} minutes"
  },
  aboutXHours: {
    one: "about 1 hour",
    other: "about {{count}} hours"
  },
  xHours: {
    one: "1 hour",
    other: "{{count}} hours"
  },
  xDays: {
    one: "1 day",
    other: "{{count}} days"
  },
  aboutXWeeks: {
    one: "about 1 week",
    other: "about {{count}} weeks"
  },
  xWeeks: {
    one: "1 week",
    other: "{{count}} weeks"
  },
  aboutXMonths: {
    one: "about 1 month",
    other: "about {{count}} months"
  },
  xMonths: {
    one: "1 month",
    other: "{{count}} months"
  },
  aboutXYears: {
    one: "about 1 year",
    other: "about {{count}} years"
  },
  xYears: {
    one: "1 year",
    other: "{{count}} years"
  },
  overXYears: {
    one: "over 1 year",
    other: "over {{count}} years"
  },
  almostXYears: {
    one: "almost 1 year",
    other: "almost {{count}} years"
  }
}, formatDistance$2 = function(o, l, u) {
  var c, m = formatDistanceLocale$1[o];
  return typeof m == "string" ? c = m : l === 1 ? c = m.one : c = m.other.replace("{{count}}", l.toString()), u != null && u.addSuffix ? u.comparison && u.comparison > 0 ? "in " + c : c + " ago" : c;
}, dateFormats$1 = {
  full: "EEEE, MMMM do, y",
  long: "MMMM do, y",
  medium: "MMM d, y",
  short: "MM/dd/yyyy"
}, timeFormats$1 = {
  full: "h:mm:ss a zzzz",
  long: "h:mm:ss a z",
  medium: "h:mm:ss a",
  short: "h:mm a"
}, dateTimeFormats$1 = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: "{{date}}, {{time}}",
  short: "{{date}}, {{time}}"
}, formatLong$2 = {
  date: buildFormatLongFn$1({
    formats: dateFormats$1,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn$1({
    formats: timeFormats$1,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn$1({
    formats: dateTimeFormats$1,
    defaultWidth: "full"
  })
}, formatRelativeLocale$1 = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: "P"
}, formatRelative$2 = function(o, l, u, c) {
  return formatRelativeLocale$1[o];
}, eraValues$1 = {
  narrow: ["B", "A"],
  abbreviated: ["BC", "AD"],
  wide: ["Before Christ", "Anno Domini"]
}, quarterValues$1 = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["Q1", "Q2", "Q3", "Q4"],
  wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
}, monthValues$1 = {
  narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
  abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
  wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
}, dayValues$1 = {
  narrow: ["S", "M", "T", "W", "T", "F", "S"],
  short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
  abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
}, dayPeriodValues$1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }
}, formattingDayPeriodValues$1 = {
  narrow: {
    am: "a",
    pm: "p",
    midnight: "mi",
    noon: "n",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  abbreviated: {
    am: "AM",
    pm: "PM",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  },
  wide: {
    am: "a.m.",
    pm: "p.m.",
    midnight: "midnight",
    noon: "noon",
    morning: "in the morning",
    afternoon: "in the afternoon",
    evening: "in the evening",
    night: "at night"
  }
}, ordinalNumber$1 = function(o, l) {
  var u = Number(o), c = u % 100;
  if (c > 20 || c < 10)
    switch (c % 10) {
      case 1:
        return u + "st";
      case 2:
        return u + "nd";
      case 3:
        return u + "rd";
    }
  return u + "th";
}, localize$2 = {
  ordinalNumber: ordinalNumber$1,
  era: buildLocalizeFn$1({
    values: eraValues$1,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn$1({
    values: quarterValues$1,
    defaultWidth: "wide",
    argumentCallback: function(o) {
      return o - 1;
    }
  }),
  month: buildLocalizeFn$1({
    values: monthValues$1,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn$1({
    values: dayValues$1,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn$1({
    values: dayPeriodValues$1,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues$1,
    defaultFormattingWidth: "wide"
  })
}, matchOrdinalNumberPattern$1 = /^(\d+)(th|st|nd|rd)?/i, parseOrdinalNumberPattern$1 = /\d+/i, matchEraPatterns$1 = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
}, parseEraPatterns$1 = {
  any: [/^b/i, /^(a|c)/i]
}, matchQuarterPatterns$1 = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
}, parseQuarterPatterns$1 = {
  any: [/1/i, /2/i, /3/i, /4/i]
}, matchMonthPatterns$1 = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
}, parseMonthPatterns$1 = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
}, matchDayPatterns$1 = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
}, parseDayPatterns$1 = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
}, matchDayPeriodPatterns$1 = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
}, parseDayPeriodPatterns$1 = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
}, match$2 = {
  ordinalNumber: buildMatchPatternFn$1({
    matchPattern: matchOrdinalNumberPattern$1,
    parsePattern: parseOrdinalNumberPattern$1,
    valueCallback: function(o) {
      return parseInt(o, 10);
    }
  }),
  era: buildMatchFn$1({
    matchPatterns: matchEraPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns$1,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn$1({
    matchPatterns: matchQuarterPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns$1,
    defaultParseWidth: "any",
    valueCallback: function(o) {
      return o + 1;
    }
  }),
  month: buildMatchFn$1({
    matchPatterns: matchMonthPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns$1,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn$1({
    matchPatterns: matchDayPatterns$1,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns$1,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn$1({
    matchPatterns: matchDayPeriodPatterns$1,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns$1,
    defaultParseWidth: "any"
  })
}, locale$1 = {
  code: "en-US",
  formatDistance: formatDistance$2,
  formatLong: formatLong$2,
  formatRelative: formatRelative$2,
  localize: localize$2,
  match: match$2,
  options: {
    weekStartsOn: 0,
    firstWeekContainsDate: 1
  }
}, formattingTokensRegExp$1 = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp$1 = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp$1 = /^'([^]*?)'?$/, doubleQuoteRegExp$1 = /''/g, unescapedLatinCharacterRegExp$1 = /[a-zA-Z]/;
function format$3(s, o, l) {
  var u, c, m, g, v, b, S, E, P, T, N, O, z, Q, W, ue, te, K;
  requiredArgs$1(2, arguments);
  var ve = String(o), ee = getDefaultOptions$1(), Re = (u = (c = l == null ? void 0 : l.locale) !== null && c !== void 0 ? c : ee.locale) !== null && u !== void 0 ? u : locale$1, wt = toInteger$1((m = (g = (v = (b = l == null ? void 0 : l.firstWeekContainsDate) !== null && b !== void 0 ? b : l == null || (S = l.locale) === null || S === void 0 || (E = S.options) === null || E === void 0 ? void 0 : E.firstWeekContainsDate) !== null && v !== void 0 ? v : ee.firstWeekContainsDate) !== null && g !== void 0 ? g : (P = ee.locale) === null || P === void 0 || (T = P.options) === null || T === void 0 ? void 0 : T.firstWeekContainsDate) !== null && m !== void 0 ? m : 1);
  if (!(wt >= 1 && wt <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var yt = toInteger$1((N = (O = (z = (Q = l == null ? void 0 : l.weekStartsOn) !== null && Q !== void 0 ? Q : l == null || (W = l.locale) === null || W === void 0 || (ue = W.options) === null || ue === void 0 ? void 0 : ue.weekStartsOn) !== null && z !== void 0 ? z : ee.weekStartsOn) !== null && O !== void 0 ? O : (te = ee.locale) === null || te === void 0 || (K = te.options) === null || K === void 0 ? void 0 : K.weekStartsOn) !== null && N !== void 0 ? N : 0);
  if (!(yt >= 0 && yt <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (!Re.localize)
    throw new RangeError("locale must contain localize property");
  if (!Re.formatLong)
    throw new RangeError("locale must contain formatLong property");
  var xt = toDate$2(s);
  if (!isValid$5(xt))
    throw new RangeError("Invalid time value");
  var Kt = getTimezoneOffsetInMilliseconds$1(xt), tn = subMilliseconds$1(xt, Kt), ln = {
    firstWeekContainsDate: wt,
    weekStartsOn: yt,
    locale: Re,
    _originalDate: xt
  }, rn = ve.match(longFormattingTokensRegExp$1).map(function(an) {
    var Gt = an[0];
    if (Gt === "p" || Gt === "P") {
      var nn = longFormatters$1[Gt];
      return nn(an, Re.formatLong);
    }
    return an;
  }).join("").match(formattingTokensRegExp$1).map(function(an) {
    if (an === "''")
      return "'";
    var Gt = an[0];
    if (Gt === "'")
      return cleanEscapedString$1(an);
    var nn = formatters$2[Gt];
    if (nn)
      return !(l != null && l.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(an) && throwProtectedError$1(an, o, String(s)), !(l != null && l.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(an) && throwProtectedError$1(an, o, String(s)), nn(tn, an, Re.localize, ln);
    if (Gt.match(unescapedLatinCharacterRegExp$1))
      throw new RangeError("Format string contains an unescaped latin alphabet character `" + Gt + "`");
    return an;
  }).join("");
  return rn;
}
function cleanEscapedString$1(s) {
  var o = s.match(escapedStringRegExp$1);
  return o ? o[1].replace(doubleQuoteRegExp$1, "'") : s;
}
function assign$2(s, o) {
  if (s == null)
    throw new TypeError("assign requires that input parameter not be null or undefined");
  for (var l in o)
    Object.prototype.hasOwnProperty.call(o, l) && (s[l] = o[l]);
  return s;
}
function getDaysInMonth(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = o.getFullYear(), u = o.getMonth(), c = /* @__PURE__ */ new Date(0);
  return c.setFullYear(l, u + 1, 0), c.setHours(0, 0, 0, 0), c.getDate();
}
function getHours(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = o.getHours();
  return l;
}
function lastDayOfMonth(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s), l = o.getMonth();
  return o.setFullYear(o.getFullYear(), l + 1, 0), o.setHours(0, 0, 0, 0), o;
}
function isAfter$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toDate$2(o);
  return l.getTime() > u.getTime();
}
function isBefore$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toDate$2(o);
  return l.getTime() < u.getTime();
}
function isEqual$1(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toDate$2(o);
  return l.getTime() === u.getTime();
}
function _arrayLikeToArray(s, o) {
  (o == null || o > s.length) && (o = s.length);
  for (var l = 0, u = new Array(o); l < o; l++) u[l] = s[l];
  return u;
}
function _unsupportedIterableToArray(s, o) {
  if (s) {
    if (typeof s == "string") return _arrayLikeToArray(s, o);
    var l = Object.prototype.toString.call(s).slice(8, -1);
    if (l === "Object" && s.constructor && (l = s.constructor.name), l === "Map" || l === "Set") return Array.from(s);
    if (l === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(l)) return _arrayLikeToArray(s, o);
  }
}
function _createForOfIteratorHelper(s, o) {
  var l = typeof Symbol < "u" && s[Symbol.iterator] || s["@@iterator"];
  if (!l) {
    if (Array.isArray(s) || (l = _unsupportedIterableToArray(s)) || o) {
      l && (s = l);
      var u = 0, c = function() {
      };
      return {
        s: c,
        n: function() {
          return u >= s.length ? {
            done: !0
          } : {
            done: !1,
            value: s[u++]
          };
        },
        e: function(S) {
          throw S;
        },
        f: c
      };
    }
    throw new TypeError(`Invalid attempt to iterate non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
  }
  var m = !0, g = !1, v;
  return {
    s: function() {
      l = l.call(s);
    },
    n: function() {
      var S = l.next();
      return m = S.done, S;
    },
    e: function(S) {
      g = !0, v = S;
    },
    f: function() {
      try {
        !m && l.return != null && l.return();
      } finally {
        if (g) throw v;
      }
    }
  };
}
function _assertThisInitialized(s) {
  if (s === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return s;
}
function _setPrototypeOf$1(s, o) {
  return _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(u, c) {
    return u.__proto__ = c, u;
  }, _setPrototypeOf$1(s, o);
}
function _inherits(s, o) {
  if (typeof o != "function" && o !== null)
    throw new TypeError("Super expression must either be null or a function");
  s.prototype = Object.create(o && o.prototype, {
    constructor: {
      value: s,
      writable: !0,
      configurable: !0
    }
  }), Object.defineProperty(s, "prototype", {
    writable: !1
  }), o && _setPrototypeOf$1(s, o);
}
function _getPrototypeOf$1(s) {
  return _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, _getPrototypeOf$1(s);
}
function _isNativeReflectConstruct$1() {
  try {
    var s = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
  } catch {
  }
  return (_isNativeReflectConstruct$1 = function() {
    return !!s;
  })();
}
function _possibleConstructorReturn(s, o) {
  if (o && (_typeof$1(o) === "object" || typeof o == "function"))
    return o;
  if (o !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return _assertThisInitialized(s);
}
function _createSuper(s) {
  var o = _isNativeReflectConstruct$1();
  return function() {
    var u = _getPrototypeOf$1(s), c;
    if (o) {
      var m = _getPrototypeOf$1(this).constructor;
      c = Reflect.construct(u, arguments, m);
    } else
      c = u.apply(this, arguments);
    return _possibleConstructorReturn(this, c);
  };
}
function _classCallCheck(s, o) {
  if (!(s instanceof o))
    throw new TypeError("Cannot call a class as a function");
}
function toPrimitive(s, o) {
  if (_typeof$1(s) != "object" || !s) return s;
  var l = s[Symbol.toPrimitive];
  if (l !== void 0) {
    var u = l.call(s, o || "default");
    if (_typeof$1(u) != "object") return u;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (o === "string" ? String : Number)(s);
}
function toPropertyKey(s) {
  var o = toPrimitive(s, "string");
  return _typeof$1(o) == "symbol" ? o : o + "";
}
function _defineProperties(s, o) {
  for (var l = 0; l < o.length; l++) {
    var u = o[l];
    u.enumerable = u.enumerable || !1, u.configurable = !0, "value" in u && (u.writable = !0), Object.defineProperty(s, toPropertyKey(u.key), u);
  }
}
function _createClass(s, o, l) {
  return o && _defineProperties(s.prototype, o), Object.defineProperty(s, "prototype", {
    writable: !1
  }), s;
}
function _defineProperty(s, o, l) {
  return o = toPropertyKey(o), o in s ? Object.defineProperty(s, o, {
    value: l,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : s[o] = l, s;
}
var TIMEZONE_UNIT_PRIORITY = 10, Setter = /* @__PURE__ */ function() {
  function s() {
    _classCallCheck(this, s), _defineProperty(this, "priority", void 0), _defineProperty(this, "subPriority", 0);
  }
  return _createClass(s, [{
    key: "validate",
    value: function(l, u) {
      return !0;
    }
  }]), s;
}(), ValueSetter = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l(u, c, m, g, v) {
    var b;
    return _classCallCheck(this, l), b = o.call(this), b.value = u, b.validateValue = c, b.setValue = m, b.priority = g, v && (b.subPriority = v), b;
  }
  return _createClass(l, [{
    key: "validate",
    value: function(c, m) {
      return this.validateValue(c, this.value, m);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return this.setValue(c, m, this.value, g);
    }
  }]), l;
}(Setter), DateToSystemTimezoneSetter = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", TIMEZONE_UNIT_PRIORITY), _defineProperty(_assertThisInitialized(u), "subPriority", -1), u;
  }
  return _createClass(l, [{
    key: "set",
    value: function(c, m) {
      if (m.timestampIsSet)
        return c;
      var g = /* @__PURE__ */ new Date(0);
      return g.setFullYear(c.getUTCFullYear(), c.getUTCMonth(), c.getUTCDate()), g.setHours(c.getUTCHours(), c.getUTCMinutes(), c.getUTCSeconds(), c.getUTCMilliseconds()), g;
    }
  }]), l;
}(Setter), Parser$1 = /* @__PURE__ */ function() {
  function s() {
    _classCallCheck(this, s), _defineProperty(this, "incompatibleTokens", void 0), _defineProperty(this, "priority", void 0), _defineProperty(this, "subPriority", void 0);
  }
  return _createClass(s, [{
    key: "run",
    value: function(l, u, c, m) {
      var g = this.parse(l, u, c, m);
      return g ? {
        setter: new ValueSetter(g.value, this.validate, this.set, this.priority, this.subPriority),
        rest: g.rest
      } : null;
    }
  }, {
    key: "validate",
    value: function(l, u, c) {
      return !0;
    }
  }]), s;
}(), EraParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 140), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["R", "u", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "G":
        case "GG":
        case "GGG":
          return g.era(c, {
            width: "abbreviated"
          }) || g.era(c, {
            width: "narrow"
          });
        case "GGGGG":
          return g.era(c, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return g.era(c, {
            width: "wide"
          }) || g.era(c, {
            width: "abbreviated"
          }) || g.era(c, {
            width: "narrow"
          });
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return m.era = g, c.setUTCFullYear(g, 0, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/
  // 0 to 9999, -0 to -9999
}, timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};
function mapValue(s, o) {
  return s && {
    value: o(s.value),
    rest: s.rest
  };
}
function parseNumericPattern(s, o) {
  var l = o.match(s);
  return l ? {
    value: parseInt(l[0], 10),
    rest: o.slice(l[0].length)
  } : null;
}
function parseTimezonePattern(s, o) {
  var l = o.match(s);
  if (!l)
    return null;
  if (l[0] === "Z")
    return {
      value: 0,
      rest: o.slice(1)
    };
  var u = l[1] === "+" ? 1 : -1, c = l[2] ? parseInt(l[2], 10) : 0, m = l[3] ? parseInt(l[3], 10) : 0, g = l[5] ? parseInt(l[5], 10) : 0;
  return {
    value: u * (c * millisecondsInHour + m * millisecondsInMinute + g * millisecondsInSecond),
    rest: o.slice(l[0].length)
  };
}
function parseAnyDigitsSigned(s) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, s);
}
function parseNDigits(s, o) {
  switch (s) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, o);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, o);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, o);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, o);
    default:
      return parseNumericPattern(new RegExp("^\\d{1," + s + "}"), o);
  }
}
function parseNDigitsSigned(s, o) {
  switch (s) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, o);
    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, o);
    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, o);
    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, o);
    default:
      return parseNumericPattern(new RegExp("^-?\\d{1," + s + "}"), o);
  }
}
function dayPeriodEnumToHours(s) {
  switch (s) {
    case "morning":
      return 4;
    case "evening":
      return 17;
    case "pm":
    case "noon":
    case "afternoon":
      return 12;
    case "am":
    case "midnight":
    case "night":
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(s, o) {
  var l = o > 0, u = l ? o : 1 - o, c;
  if (u <= 50)
    c = s || 100;
  else {
    var m = u + 50, g = Math.floor(m / 100) * 100, v = s >= m % 100;
    c = s + g - (v ? 100 : 0);
  }
  return l ? c : 1 - c;
}
function isLeapYearIndex$1(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
var YearParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 130), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "u", "w", "I", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      var v = function(S) {
        return {
          year: S,
          isTwoDigitYear: m === "yy"
        };
      };
      switch (m) {
        case "y":
          return mapValue(parseNDigits(4, c), v);
        case "yo":
          return mapValue(g.ordinalNumber(c, {
            unit: "year"
          }), v);
        default:
          return mapValue(parseNDigits(m.length, c), v);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m.isTwoDigitYear || m.year > 0;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      var v = c.getUTCFullYear();
      if (g.isTwoDigitYear) {
        var b = normalizeTwoDigitYear(g.year, v);
        return c.setUTCFullYear(b, 0, 1), c.setUTCHours(0, 0, 0, 0), c;
      }
      var S = !("era" in m) || m.era === 1 ? g.year : 1 - g.year;
      return c.setUTCFullYear(S, 0, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), LocalWeekYearParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 130), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "R", "u", "Q", "q", "M", "L", "I", "d", "D", "i", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      var v = function(S) {
        return {
          year: S,
          isTwoDigitYear: m === "YY"
        };
      };
      switch (m) {
        case "Y":
          return mapValue(parseNDigits(4, c), v);
        case "Yo":
          return mapValue(g.ordinalNumber(c, {
            unit: "year"
          }), v);
        default:
          return mapValue(parseNDigits(m.length, c), v);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m.isTwoDigitYear || m.year > 0;
    }
  }, {
    key: "set",
    value: function(c, m, g, v) {
      var b = getUTCWeekYear$1(c, v);
      if (g.isTwoDigitYear) {
        var S = normalizeTwoDigitYear(g.year, b);
        return c.setUTCFullYear(S, 0, v.firstWeekContainsDate), c.setUTCHours(0, 0, 0, 0), startOfUTCWeek$1(c, v);
      }
      var E = !("era" in m) || m.era === 1 ? g.year : 1 - g.year;
      return c.setUTCFullYear(E, 0, v.firstWeekContainsDate), c.setUTCHours(0, 0, 0, 0), startOfUTCWeek$1(c, v);
    }
  }]), l;
}(Parser$1), ISOWeekYearParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 130), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["G", "y", "Y", "u", "Q", "q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m) {
      return parseNDigitsSigned(m === "R" ? 4 : m.length, c);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      var v = /* @__PURE__ */ new Date(0);
      return v.setUTCFullYear(g, 0, 4), v.setUTCHours(0, 0, 0, 0), startOfUTCISOWeek$1(v);
    }
  }]), l;
}(Parser$1), ExtendedYearParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 130), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["G", "y", "Y", "R", "w", "I", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m) {
      return parseNDigitsSigned(m === "u" ? 4 : m.length, c);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCFullYear(g, 0, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), QuarterParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 120), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "Q":
        case "QQ":
          return parseNDigits(m.length, c);
        case "Qo":
          return g.ordinalNumber(c, {
            unit: "quarter"
          });
        case "QQQ":
          return g.quarter(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.quarter(c, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQQ":
          return g.quarter(c, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return g.quarter(c, {
            width: "wide",
            context: "formatting"
          }) || g.quarter(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.quarter(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 4;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMonth((g - 1) * 3, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), StandAloneQuarterParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 120), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "Q", "M", "L", "w", "I", "d", "D", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "q":
        case "qq":
          return parseNDigits(m.length, c);
        case "qo":
          return g.ordinalNumber(c, {
            unit: "quarter"
          });
        case "qqq":
          return g.quarter(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.quarter(c, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqqq":
          return g.quarter(c, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return g.quarter(c, {
            width: "wide",
            context: "standalone"
          }) || g.quarter(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.quarter(c, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 4;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMonth((g - 1) * 3, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), MonthParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "q", "Q", "L", "w", "I", "D", "i", "e", "c", "t", "T"]), _defineProperty(_assertThisInitialized(u), "priority", 110), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      var v = function(S) {
        return S - 1;
      };
      switch (m) {
        case "M":
          return mapValue(parseNumericPattern(numericPatterns.month, c), v);
        case "MM":
          return mapValue(parseNDigits(2, c), v);
        case "Mo":
          return mapValue(g.ordinalNumber(c, {
            unit: "month"
          }), v);
        case "MMM":
          return g.month(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.month(c, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMMM":
          return g.month(c, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return g.month(c, {
            width: "wide",
            context: "formatting"
          }) || g.month(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.month(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 11;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMonth(g, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), StandAloneMonthParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 110), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "w", "I", "D", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      var v = function(S) {
        return S - 1;
      };
      switch (m) {
        case "L":
          return mapValue(parseNumericPattern(numericPatterns.month, c), v);
        case "LL":
          return mapValue(parseNDigits(2, c), v);
        case "Lo":
          return mapValue(g.ordinalNumber(c, {
            unit: "month"
          }), v);
        case "LLL":
          return g.month(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.month(c, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLLL":
          return g.month(c, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return g.month(c, {
            width: "wide",
            context: "standalone"
          }) || g.month(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.month(c, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 11;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMonth(g, 1), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1);
function setUTCWeek(s, o, l) {
  requiredArgs$1(2, arguments);
  var u = toDate$2(s), c = toInteger$1(o), m = getUTCWeek$1(u, l) - c;
  return u.setUTCDate(u.getUTCDate() - m * 7), u;
}
var LocalWeekParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 100), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "i", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "w":
          return parseNumericPattern(numericPatterns.week, c);
        case "wo":
          return g.ordinalNumber(c, {
            unit: "week"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 53;
    }
  }, {
    key: "set",
    value: function(c, m, g, v) {
      return startOfUTCWeek$1(setUTCWeek(c, g, v), v);
    }
  }]), l;
}(Parser$1);
function setUTCISOWeek(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toInteger$1(o), c = getUTCISOWeek$1(l) - u;
  return l.setUTCDate(l.getUTCDate() - c * 7), l;
}
var ISOWeekParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 100), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "I":
          return parseNumericPattern(numericPatterns.week, c);
        case "Io":
          return g.ordinalNumber(c, {
            unit: "week"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 53;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return startOfUTCISOWeek$1(setUTCISOWeek(c, g));
    }
  }]), l;
}(Parser$1), DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], DateParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "subPriority", 1), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "q", "Q", "w", "I", "D", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "d":
          return parseNumericPattern(numericPatterns.date, c);
        case "do":
          return g.ordinalNumber(c, {
            unit: "date"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      var g = c.getUTCFullYear(), v = isLeapYearIndex$1(g), b = c.getUTCMonth();
      return v ? m >= 1 && m <= DAYS_IN_MONTH_LEAP_YEAR[b] : m >= 1 && m <= DAYS_IN_MONTH[b];
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCDate(g), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), DayOfYearParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "subpriority", 1), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["Y", "R", "q", "Q", "M", "L", "w", "I", "d", "E", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "D":
        case "DD":
          return parseNumericPattern(numericPatterns.dayOfYear, c);
        case "Do":
          return g.ordinalNumber(c, {
            unit: "date"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      var g = c.getUTCFullYear(), v = isLeapYearIndex$1(g);
      return v ? m >= 1 && m <= 366 : m >= 1 && m <= 365;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMonth(0, g), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1);
function setUTCDay(s, o, l) {
  var u, c, m, g, v, b, S, E;
  requiredArgs$1(2, arguments);
  var P = getDefaultOptions$1(), T = toInteger$1((u = (c = (m = (g = l == null ? void 0 : l.weekStartsOn) !== null && g !== void 0 ? g : l == null || (v = l.locale) === null || v === void 0 || (b = v.options) === null || b === void 0 ? void 0 : b.weekStartsOn) !== null && m !== void 0 ? m : P.weekStartsOn) !== null && c !== void 0 ? c : (S = P.locale) === null || S === void 0 || (E = S.options) === null || E === void 0 ? void 0 : E.weekStartsOn) !== null && u !== void 0 ? u : 0);
  if (!(T >= 0 && T <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  var N = toDate$2(s), O = toInteger$1(o), z = N.getUTCDay(), Q = O % 7, W = (Q + 7) % 7, ue = (W < T ? 7 : 0) + O - z;
  return N.setUTCDate(N.getUTCDate() + ue), N;
}
var DayParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["D", "i", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "E":
        case "EE":
        case "EEE":
          return g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEE":
          return g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEE":
        default:
          return g.day(c, {
            width: "wide",
            context: "formatting"
          }) || g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 6;
    }
  }, {
    key: "set",
    value: function(c, m, g, v) {
      return c = setUTCDay(c, g, v), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), LocalDayParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g, v) {
      var b = function(E) {
        var P = Math.floor((E - 1) / 7) * 7;
        return (E + v.weekStartsOn + 6) % 7 + P;
      };
      switch (m) {
        case "e":
        case "ee":
          return mapValue(parseNDigits(m.length, c), b);
        case "eo":
          return mapValue(g.ordinalNumber(c, {
            unit: "day"
          }), b);
        case "eee":
          return g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeee":
          return g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
        case "eeee":
        default:
          return g.day(c, {
            width: "wide",
            context: "formatting"
          }) || g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 6;
    }
  }, {
    key: "set",
    value: function(c, m, g, v) {
      return c = setUTCDay(c, g, v), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), StandAloneLocalDayParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "R", "u", "q", "Q", "M", "L", "I", "d", "D", "E", "i", "e", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g, v) {
      var b = function(E) {
        var P = Math.floor((E - 1) / 7) * 7;
        return (E + v.weekStartsOn + 6) % 7 + P;
      };
      switch (m) {
        case "c":
        case "cc":
          return mapValue(parseNDigits(m.length, c), b);
        case "co":
          return mapValue(g.ordinalNumber(c, {
            unit: "day"
          }), b);
        case "ccc":
          return g.day(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.day(c, {
            width: "short",
            context: "standalone"
          }) || g.day(c, {
            width: "narrow",
            context: "standalone"
          });
        case "ccccc":
          return g.day(c, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return g.day(c, {
            width: "short",
            context: "standalone"
          }) || g.day(c, {
            width: "narrow",
            context: "standalone"
          });
        case "cccc":
        default:
          return g.day(c, {
            width: "wide",
            context: "standalone"
          }) || g.day(c, {
            width: "abbreviated",
            context: "standalone"
          }) || g.day(c, {
            width: "short",
            context: "standalone"
          }) || g.day(c, {
            width: "narrow",
            context: "standalone"
          });
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 6;
    }
  }, {
    key: "set",
    value: function(c, m, g, v) {
      return c = setUTCDay(c, g, v), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1);
function setUTCISODay(s, o) {
  requiredArgs$1(2, arguments);
  var l = toInteger$1(o);
  l % 7 === 0 && (l = l - 7);
  var u = 1, c = toDate$2(s), m = c.getUTCDay(), g = l % 7, v = (g + 7) % 7, b = (v < u ? 7 : 0) + l - m;
  return c.setUTCDate(c.getUTCDate() + b), c;
}
var ISODayParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 90), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["y", "Y", "u", "q", "Q", "M", "L", "w", "d", "D", "E", "e", "c", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      var v = function(S) {
        return S === 0 ? 7 : S;
      };
      switch (m) {
        case "i":
        case "ii":
          return parseNDigits(m.length, c);
        case "io":
          return g.ordinalNumber(c, {
            unit: "day"
          });
        case "iii":
          return mapValue(g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          }), v);
        case "iiiii":
          return mapValue(g.day(c, {
            width: "narrow",
            context: "formatting"
          }), v);
        case "iiiiii":
          return mapValue(g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          }), v);
        case "iiii":
        default:
          return mapValue(g.day(c, {
            width: "wide",
            context: "formatting"
          }) || g.day(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.day(c, {
            width: "short",
            context: "formatting"
          }) || g.day(c, {
            width: "narrow",
            context: "formatting"
          }), v);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 7;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c = setUTCISODay(c, g), c.setUTCHours(0, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), AMPMParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 80), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["b", "B", "H", "k", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "a":
        case "aa":
        case "aaa":
          return g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaaa":
          return g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return g.dayPeriod(c, {
            width: "wide",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCHours(dayPeriodEnumToHours(g), 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), AMPMMidnightParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 80), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["a", "B", "H", "k", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "b":
        case "bb":
        case "bbb":
          return g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbbb":
          return g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return g.dayPeriod(c, {
            width: "wide",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCHours(dayPeriodEnumToHours(g), 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), DayPeriodParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 80), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["a", "b", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "B":
        case "BB":
        case "BBB":
          return g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBBB":
          return g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return g.dayPeriod(c, {
            width: "wide",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "abbreviated",
            context: "formatting"
          }) || g.dayPeriod(c, {
            width: "narrow",
            context: "formatting"
          });
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCHours(dayPeriodEnumToHours(g), 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), Hour1to12Parser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 70), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["H", "K", "k", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "h":
          return parseNumericPattern(numericPatterns.hour12h, c);
        case "ho":
          return g.ordinalNumber(c, {
            unit: "hour"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 12;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      var v = c.getUTCHours() >= 12;
      return v && g < 12 ? c.setUTCHours(g + 12, 0, 0, 0) : !v && g === 12 ? c.setUTCHours(0, 0, 0, 0) : c.setUTCHours(g, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), Hour0to23Parser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 70), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["a", "b", "h", "K", "k", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "H":
          return parseNumericPattern(numericPatterns.hour23h, c);
        case "Ho":
          return g.ordinalNumber(c, {
            unit: "hour"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 23;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCHours(g, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), Hour0To11Parser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 70), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["h", "H", "k", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "K":
          return parseNumericPattern(numericPatterns.hour11h, c);
        case "Ko":
          return g.ordinalNumber(c, {
            unit: "hour"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 11;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      var v = c.getUTCHours() >= 12;
      return v && g < 12 ? c.setUTCHours(g + 12, 0, 0, 0) : c.setUTCHours(g, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), Hour1To24Parser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 70), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["a", "b", "h", "H", "K", "t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "k":
          return parseNumericPattern(numericPatterns.hour24h, c);
        case "ko":
          return g.ordinalNumber(c, {
            unit: "hour"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 1 && m <= 24;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      var v = g <= 24 ? g % 24 : g;
      return c.setUTCHours(v, 0, 0, 0), c;
    }
  }]), l;
}(Parser$1), MinuteParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 60), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "m":
          return parseNumericPattern(numericPatterns.minute, c);
        case "mo":
          return g.ordinalNumber(c, {
            unit: "minute"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 59;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMinutes(g, 0, 0), c;
    }
  }]), l;
}(Parser$1), SecondParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 50), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m, g) {
      switch (m) {
        case "s":
          return parseNumericPattern(numericPatterns.second, c);
        case "so":
          return g.ordinalNumber(c, {
            unit: "second"
          });
        default:
          return parseNDigits(m.length, c);
      }
    }
  }, {
    key: "validate",
    value: function(c, m) {
      return m >= 0 && m <= 59;
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCSeconds(g, 0), c;
    }
  }]), l;
}(Parser$1), FractionOfSecondParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 30), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["t", "T"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m) {
      var g = function(b) {
        return Math.floor(b * Math.pow(10, -m.length + 3));
      };
      return mapValue(parseNDigits(m.length, c), g);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return c.setUTCMilliseconds(g), c;
    }
  }]), l;
}(Parser$1), ISOTimezoneWithZParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 10), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["t", "T", "x"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m) {
      switch (m) {
        case "X":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, c);
        case "XX":
          return parseTimezonePattern(timezonePatterns.basic, c);
        case "XXXX":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, c);
        case "XXXXX":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, c);
        case "XXX":
        default:
          return parseTimezonePattern(timezonePatterns.extended, c);
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return m.timestampIsSet ? c : new Date(c.getTime() - g);
    }
  }]), l;
}(Parser$1), ISOTimezoneParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 10), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", ["t", "T", "X"]), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c, m) {
      switch (m) {
        case "x":
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, c);
        case "xx":
          return parseTimezonePattern(timezonePatterns.basic, c);
        case "xxxx":
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, c);
        case "xxxxx":
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, c);
        case "xxx":
        default:
          return parseTimezonePattern(timezonePatterns.extended, c);
      }
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return m.timestampIsSet ? c : new Date(c.getTime() - g);
    }
  }]), l;
}(Parser$1), TimestampSecondsParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 40), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", "*"), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c) {
      return parseAnyDigitsSigned(c);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return [new Date(g * 1e3), {
        timestampIsSet: !0
      }];
    }
  }]), l;
}(Parser$1), TimestampMillisecondsParser = /* @__PURE__ */ function(s) {
  _inherits(l, s);
  var o = _createSuper(l);
  function l() {
    var u;
    _classCallCheck(this, l);
    for (var c = arguments.length, m = new Array(c), g = 0; g < c; g++)
      m[g] = arguments[g];
    return u = o.call.apply(o, [this].concat(m)), _defineProperty(_assertThisInitialized(u), "priority", 20), _defineProperty(_assertThisInitialized(u), "incompatibleTokens", "*"), u;
  }
  return _createClass(l, [{
    key: "parse",
    value: function(c) {
      return parseAnyDigitsSigned(c);
    }
  }, {
    key: "set",
    value: function(c, m, g) {
      return [new Date(g), {
        timestampIsSet: !0
      }];
    }
  }]), l;
}(Parser$1), parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
}, formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, escapedStringRegExp = /^'([^]*?)'?$/, doubleQuoteRegExp = /''/g, notWhitespaceRegExp = /\S/, unescapedLatinCharacterRegExp = /[a-zA-Z]/;
function parse$2(s, o, l, u) {
  var c, m, g, v, b, S, E, P, T, N, O, z, Q, W, ue, te, K, ve;
  requiredArgs$1(3, arguments);
  var ee = String(s), Re = String(o), wt = getDefaultOptions$1(), yt = (c = (m = u == null ? void 0 : u.locale) !== null && m !== void 0 ? m : wt.locale) !== null && c !== void 0 ? c : locale$1;
  if (!yt.match)
    throw new RangeError("locale must contain match property");
  var xt = toInteger$1((g = (v = (b = (S = u == null ? void 0 : u.firstWeekContainsDate) !== null && S !== void 0 ? S : u == null || (E = u.locale) === null || E === void 0 || (P = E.options) === null || P === void 0 ? void 0 : P.firstWeekContainsDate) !== null && b !== void 0 ? b : wt.firstWeekContainsDate) !== null && v !== void 0 ? v : (T = wt.locale) === null || T === void 0 || (N = T.options) === null || N === void 0 ? void 0 : N.firstWeekContainsDate) !== null && g !== void 0 ? g : 1);
  if (!(xt >= 1 && xt <= 7))
    throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
  var Kt = toInteger$1((O = (z = (Q = (W = u == null ? void 0 : u.weekStartsOn) !== null && W !== void 0 ? W : u == null || (ue = u.locale) === null || ue === void 0 || (te = ue.options) === null || te === void 0 ? void 0 : te.weekStartsOn) !== null && Q !== void 0 ? Q : wt.weekStartsOn) !== null && z !== void 0 ? z : (K = wt.locale) === null || K === void 0 || (ve = K.options) === null || ve === void 0 ? void 0 : ve.weekStartsOn) !== null && O !== void 0 ? O : 0);
  if (!(Kt >= 0 && Kt <= 6))
    throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
  if (Re === "")
    return ee === "" ? toDate$2(l) : /* @__PURE__ */ new Date(NaN);
  var tn = {
    firstWeekContainsDate: xt,
    weekStartsOn: Kt,
    locale: yt
  }, ln = [new DateToSystemTimezoneSetter()], rn = Re.match(longFormattingTokensRegExp).map(function(_n) {
    var Nn = _n[0];
    if (Nn in longFormatters$1) {
      var Un = longFormatters$1[Nn];
      return Un(_n, yt.formatLong);
    }
    return _n;
  }).join("").match(formattingTokensRegExp), an = [], Gt = _createForOfIteratorHelper(rn), nn;
  try {
    var vt = function() {
      var Nn = nn.value;
      !(u != null && u.useAdditionalWeekYearTokens) && isProtectedWeekYearToken$1(Nn) && throwProtectedError$1(Nn, Re, s), !(u != null && u.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken$1(Nn) && throwProtectedError$1(Nn, Re, s);
      var Un = Nn[0], Xn = parsers[Un];
      if (Xn) {
        var zn = Xn.incompatibleTokens;
        if (Array.isArray(zn)) {
          var jn = an.find(function(Yn) {
            return zn.includes(Yn.token) || Yn.token === Un;
          });
          if (jn)
            throw new RangeError("The format string mustn't contain `".concat(jn.fullToken, "` and `").concat(Nn, "` at the same time"));
        } else if (Xn.incompatibleTokens === "*" && an.length > 0)
          throw new RangeError("The format string mustn't contain `".concat(Nn, "` and any other token at the same time"));
        an.push({
          token: Un,
          fullToken: Nn
        });
        var kn = Xn.run(ee, Nn, yt.match, tn);
        if (!kn)
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
        ln.push(kn.setter), ee = kn.rest;
      } else {
        if (Un.match(unescapedLatinCharacterRegExp))
          throw new RangeError("Format string contains an unescaped latin alphabet character `" + Un + "`");
        if (Nn === "''" ? Nn = "'" : Un === "'" && (Nn = cleanEscapedString(Nn)), ee.indexOf(Nn) === 0)
          ee = ee.slice(Nn.length);
        else
          return {
            v: /* @__PURE__ */ new Date(NaN)
          };
      }
    };
    for (Gt.s(); !(nn = Gt.n()).done; ) {
      var Et = vt();
      if (_typeof$1(Et) === "object") return Et.v;
    }
  } catch (_n) {
    Gt.e(_n);
  } finally {
    Gt.f();
  }
  if (ee.length > 0 && notWhitespaceRegExp.test(ee))
    return /* @__PURE__ */ new Date(NaN);
  var Qt = ln.map(function(_n) {
    return _n.priority;
  }).sort(function(_n, Nn) {
    return Nn - _n;
  }).filter(function(_n, Nn, Un) {
    return Un.indexOf(_n) === Nn;
  }).map(function(_n) {
    return ln.filter(function(Nn) {
      return Nn.priority === _n;
    }).sort(function(Nn, Un) {
      return Un.subPriority - Nn.subPriority;
    });
  }).map(function(_n) {
    return _n[0];
  }), un = toDate$2(l);
  if (isNaN(un.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var gn = subMilliseconds$1(un, getTimezoneOffsetInMilliseconds$1(un)), dn = {}, yn = _createForOfIteratorHelper(Qt), vn;
  try {
    for (yn.s(); !(vn = yn.n()).done; ) {
      var Pn = vn.value;
      if (!Pn.validate(gn, tn))
        return /* @__PURE__ */ new Date(NaN);
      var On = Pn.set(gn, dn, tn);
      Array.isArray(On) ? (gn = On[0], assign$2(dn, On[1])) : gn = On;
    }
  } catch (_n) {
    yn.e(_n);
  } finally {
    yn.f();
  }
  return gn;
}
function cleanEscapedString(s) {
  return s.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}
function startOfSecond(s) {
  requiredArgs$1(1, arguments);
  var o = toDate$2(s);
  return o.setMilliseconds(0), o;
}
function isSameSecond(s, o) {
  requiredArgs$1(2, arguments);
  var l = startOfSecond(s), u = startOfSecond(o);
  return l.getTime() === u.getTime();
}
function isWithinInterval(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s).getTime(), u = toDate$2(o.start).getTime(), c = toDate$2(o.end).getTime();
  if (!(u <= c))
    throw new RangeError("Invalid interval");
  return l >= u && l <= c;
}
function parseISO(s, o) {
  var l;
  requiredArgs$1(1, arguments);
  var u = toInteger$1((l = void 0) !== null && l !== void 0 ? l : 2);
  if (u !== 2 && u !== 1 && u !== 0)
    throw new RangeError("additionalDigits must be 0, 1 or 2");
  if (!(typeof s == "string" || Object.prototype.toString.call(s) === "[object String]"))
    return /* @__PURE__ */ new Date(NaN);
  var c = splitDateString(s), m;
  if (c.date) {
    var g = parseYear(c.date, u);
    m = parseDate(g.restDateString, g.year);
  }
  if (!m || isNaN(m.getTime()))
    return /* @__PURE__ */ new Date(NaN);
  var v = m.getTime(), b = 0, S;
  if (c.time && (b = parseTime(c.time), isNaN(b)))
    return /* @__PURE__ */ new Date(NaN);
  if (c.timezone) {
    if (S = parseTimezone(c.timezone), isNaN(S))
      return /* @__PURE__ */ new Date(NaN);
  } else {
    var E = new Date(v + b), P = /* @__PURE__ */ new Date(0);
    return P.setFullYear(E.getUTCFullYear(), E.getUTCMonth(), E.getUTCDate()), P.setHours(E.getUTCHours(), E.getUTCMinutes(), E.getUTCSeconds(), E.getUTCMilliseconds()), P;
  }
  return new Date(v + b + S);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
}, dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/, timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/, timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;
function splitDateString(s) {
  var o = {}, l = s.split(patterns.dateTimeDelimiter), u;
  if (l.length > 2)
    return o;
  if (/:/.test(l[0]) ? u = l[0] : (o.date = l[0], u = l[1], patterns.timeZoneDelimiter.test(o.date) && (o.date = s.split(patterns.timeZoneDelimiter)[0], u = s.substr(o.date.length, s.length))), u) {
    var c = patterns.timezone.exec(u);
    c ? (o.time = u.replace(c[1], ""), o.timezone = c[1]) : o.time = u;
  }
  return o;
}
function parseYear(s, o) {
  var l = new RegExp("^(?:(\\d{4}|[+-]\\d{" + (4 + o) + "})|(\\d{2}|[+-]\\d{" + (2 + o) + "})$)"), u = s.match(l);
  if (!u) return {
    year: NaN,
    restDateString: ""
  };
  var c = u[1] ? parseInt(u[1]) : null, m = u[2] ? parseInt(u[2]) : null;
  return {
    year: m === null ? c : m * 100,
    restDateString: s.slice((u[1] || u[2]).length)
  };
}
function parseDate(s, o) {
  if (o === null) return /* @__PURE__ */ new Date(NaN);
  var l = s.match(dateRegex);
  if (!l) return /* @__PURE__ */ new Date(NaN);
  var u = !!l[4], c = parseDateUnit(l[1]), m = parseDateUnit(l[2]) - 1, g = parseDateUnit(l[3]), v = parseDateUnit(l[4]), b = parseDateUnit(l[5]) - 1;
  if (u)
    return validateWeekDate(o, v, b) ? dayOfISOWeekYear(o, v, b) : /* @__PURE__ */ new Date(NaN);
  var S = /* @__PURE__ */ new Date(0);
  return !validateDate(o, m, g) || !validateDayOfYearDate(o, c) ? /* @__PURE__ */ new Date(NaN) : (S.setUTCFullYear(o, m, Math.max(c, g)), S);
}
function parseDateUnit(s) {
  return s ? parseInt(s) : 1;
}
function parseTime(s) {
  var o = s.match(timeRegex);
  if (!o) return NaN;
  var l = parseTimeUnit(o[1]), u = parseTimeUnit(o[2]), c = parseTimeUnit(o[3]);
  return validateTime(l, u, c) ? l * millisecondsInHour + u * millisecondsInMinute + c * 1e3 : NaN;
}
function parseTimeUnit(s) {
  return s && parseFloat(s.replace(",", ".")) || 0;
}
function parseTimezone(s) {
  if (s === "Z") return 0;
  var o = s.match(timezoneRegex);
  if (!o) return 0;
  var l = o[1] === "+" ? -1 : 1, u = parseInt(o[2]), c = o[3] && parseInt(o[3]) || 0;
  return validateTimezone(u, c) ? l * (u * millisecondsInHour + c * millisecondsInMinute) : NaN;
}
function dayOfISOWeekYear(s, o, l) {
  var u = /* @__PURE__ */ new Date(0);
  u.setUTCFullYear(s, 0, 4);
  var c = u.getUTCDay() || 7, m = (o - 1) * 7 + l + 1 - c;
  return u.setUTCDate(u.getUTCDate() + m), u;
}
var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
function isLeapYearIndex(s) {
  return s % 400 === 0 || s % 4 === 0 && s % 100 !== 0;
}
function validateDate(s, o, l) {
  return o >= 0 && o <= 11 && l >= 1 && l <= (daysInMonths[o] || (isLeapYearIndex(s) ? 29 : 28));
}
function validateDayOfYearDate(s, o) {
  return o >= 1 && o <= (isLeapYearIndex(s) ? 366 : 365);
}
function validateWeekDate(s, o, l) {
  return o >= 1 && o <= 53 && l >= 0 && l <= 6;
}
function validateTime(s, o, l) {
  return s === 24 ? o === 0 && l === 0 : l >= 0 && l < 60 && o >= 0 && o < 60 && s >= 0 && s < 25;
}
function validateTimezone(s, o) {
  return o >= 0 && o <= 59;
}
function setMonth(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toInteger$1(o), c = l.getFullYear(), m = l.getDate(), g = /* @__PURE__ */ new Date(0);
  g.setFullYear(c, u, 15), g.setHours(0, 0, 0, 0);
  var v = getDaysInMonth(g);
  return l.setMonth(u, Math.min(m, v)), l;
}
function set$1(s, o) {
  if (requiredArgs$1(2, arguments), _typeof$1(o) !== "object" || o === null)
    throw new RangeError("values parameter must be an object");
  var l = toDate$2(s);
  return isNaN(l.getTime()) ? /* @__PURE__ */ new Date(NaN) : (o.year != null && l.setFullYear(o.year), o.month != null && (l = setMonth(l, o.month)), o.date != null && l.setDate(toInteger$1(o.date)), o.hours != null && l.setHours(toInteger$1(o.hours)), o.minutes != null && l.setMinutes(toInteger$1(o.minutes)), o.seconds != null && l.setSeconds(toInteger$1(o.seconds)), o.milliseconds != null && l.setMilliseconds(toInteger$1(o.milliseconds)), l);
}
function setYear(s, o) {
  requiredArgs$1(2, arguments);
  var l = toDate$2(s), u = toInteger$1(o);
  return isNaN(l.getTime()) ? /* @__PURE__ */ new Date(NaN) : (l.setFullYear(u), l);
}
function subMonths(s, o) {
  requiredArgs$1(2, arguments);
  var l = toInteger$1(o);
  return addMonths(s, -l);
}
function subYears(s, o) {
  requiredArgs$1(2, arguments);
  var l = toInteger$1(o);
  return addYears(s, -l);
}
function isSameUTCWeek(s, o, l) {
  requiredArgs$1(2, arguments);
  var u = startOfUTCWeek$1(s, l), c = startOfUTCWeek$1(o, l);
  return u.getTime() === c.getTime();
}
var formatDistanceLocale = {
  lessThanXSeconds: {
    one: "不到 1 秒",
    other: "不到 {{count}} 秒"
  },
  xSeconds: {
    one: "1 秒",
    other: "{{count}} 秒"
  },
  halfAMinute: "半分钟",
  lessThanXMinutes: {
    one: "不到 1 分钟",
    other: "不到 {{count}} 分钟"
  },
  xMinutes: {
    one: "1 分钟",
    other: "{{count}} 分钟"
  },
  xHours: {
    one: "1 小时",
    other: "{{count}} 小时"
  },
  aboutXHours: {
    one: "大约 1 小时",
    other: "大约 {{count}} 小时"
  },
  xDays: {
    one: "1 天",
    other: "{{count}} 天"
  },
  aboutXWeeks: {
    one: "大约 1 个星期",
    other: "大约 {{count}} 个星期"
  },
  xWeeks: {
    one: "1 个星期",
    other: "{{count}} 个星期"
  },
  aboutXMonths: {
    one: "大约 1 个月",
    other: "大约 {{count}} 个月"
  },
  xMonths: {
    one: "1 个月",
    other: "{{count}} 个月"
  },
  aboutXYears: {
    one: "大约 1 年",
    other: "大约 {{count}} 年"
  },
  xYears: {
    one: "1 年",
    other: "{{count}} 年"
  },
  overXYears: {
    one: "超过 1 年",
    other: "超过 {{count}} 年"
  },
  almostXYears: {
    one: "将近 1 年",
    other: "将近 {{count}} 年"
  }
}, formatDistance$1 = function(o, l, u) {
  var c, m = formatDistanceLocale[o];
  return typeof m == "string" ? c = m : l === 1 ? c = m.one : c = m.other.replace("{{count}}", String(l)), u != null && u.addSuffix ? u.comparison && u.comparison > 0 ? c + "内" : c + "前" : c;
}, dateFormats = {
  full: "y'年'M'月'd'日' EEEE",
  long: "y'年'M'月'd'日'",
  medium: "yyyy-MM-dd",
  short: "yy-MM-dd"
}, timeFormats = {
  full: "zzzz a h:mm:ss",
  long: "z a h:mm:ss",
  medium: "a h:mm:ss",
  short: "a h:mm"
}, dateTimeFormats = {
  full: "{{date}} {{time}}",
  long: "{{date}} {{time}}",
  medium: "{{date}} {{time}}",
  short: "{{date}} {{time}}"
}, formatLong$1 = {
  date: buildFormatLongFn$1({
    formats: dateFormats,
    defaultWidth: "full"
  }),
  time: buildFormatLongFn$1({
    formats: timeFormats,
    defaultWidth: "full"
  }),
  dateTime: buildFormatLongFn$1({
    formats: dateTimeFormats,
    defaultWidth: "full"
  })
};
function checkWeek(s, o, l) {
  var u = "eeee p";
  return isSameUTCWeek(s, o, l) ? u : s.getTime() > o.getTime() ? "'下个'" + u : "'上个'" + u;
}
var formatRelativeLocale = {
  lastWeek: checkWeek,
  // days before yesterday, maybe in this week or last week
  yesterday: "'昨天' p",
  today: "'今天' p",
  tomorrow: "'明天' p",
  nextWeek: checkWeek,
  // days after tomorrow, maybe in this week or next week
  other: "PP p"
}, formatRelative$1 = function(o, l, u, c) {
  var m = formatRelativeLocale[o];
  return typeof m == "function" ? m(l, u, c) : m;
}, eraValues = {
  narrow: ["前", "公元"],
  abbreviated: ["前", "公元"],
  wide: ["公元前", "公元"]
}, quarterValues = {
  narrow: ["1", "2", "3", "4"],
  abbreviated: ["第一季", "第二季", "第三季", "第四季"],
  wide: ["第一季度", "第二季度", "第三季度", "第四季度"]
}, monthValues = {
  narrow: ["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"],
  abbreviated: ["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"],
  wide: ["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"]
}, dayValues = {
  narrow: ["日", "一", "二", "三", "四", "五", "六"],
  short: ["日", "一", "二", "三", "四", "五", "六"],
  abbreviated: ["周日", "周一", "周二", "周三", "周四", "周五", "周六"],
  wide: ["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"]
}, dayPeriodValues = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
}, formattingDayPeriodValues = {
  narrow: {
    am: "上",
    pm: "下",
    midnight: "凌晨",
    noon: "午",
    morning: "早",
    afternoon: "下午",
    evening: "晚",
    night: "夜"
  },
  abbreviated: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  },
  wide: {
    am: "上午",
    pm: "下午",
    midnight: "凌晨",
    noon: "中午",
    morning: "早晨",
    afternoon: "中午",
    evening: "晚上",
    night: "夜间"
  }
}, ordinalNumber = function(o, l) {
  var u = Number(o);
  switch (l == null ? void 0 : l.unit) {
    case "date":
      return u.toString() + "日";
    case "hour":
      return u.toString() + "时";
    case "minute":
      return u.toString() + "分";
    case "second":
      return u.toString() + "秒";
    default:
      return "第 " + u.toString();
  }
}, localize$1 = {
  ordinalNumber,
  era: buildLocalizeFn$1({
    values: eraValues,
    defaultWidth: "wide"
  }),
  quarter: buildLocalizeFn$1({
    values: quarterValues,
    defaultWidth: "wide",
    argumentCallback: function(o) {
      return o - 1;
    }
  }),
  month: buildLocalizeFn$1({
    values: monthValues,
    defaultWidth: "wide"
  }),
  day: buildLocalizeFn$1({
    values: dayValues,
    defaultWidth: "wide"
  }),
  dayPeriod: buildLocalizeFn$1({
    values: dayPeriodValues,
    defaultWidth: "wide",
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: "wide"
  })
}, matchOrdinalNumberPattern = /^(第\s*)?\d+(日|时|分|秒)?/i, parseOrdinalNumberPattern = /\d+/i, matchEraPatterns = {
  narrow: /^(前)/i,
  abbreviated: /^(前)/i,
  wide: /^(公元前|公元)/i
}, parseEraPatterns = {
  any: [/^(前)/i, /^(公元)/i]
}, matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^第[一二三四]刻/i,
  wide: /^第[一二三四]刻钟/i
}, parseQuarterPatterns = {
  any: [/(1|一)/i, /(2|二)/i, /(3|三)/i, /(4|四)/i]
}, matchMonthPatterns = {
  narrow: /^(一|二|三|四|五|六|七|八|九|十[二一])/i,
  abbreviated: /^(一|二|三|四|五|六|七|八|九|十[二一]|\d|1[12])月/i,
  wide: /^(一|二|三|四|五|六|七|八|九|十[二一])月/i
}, parseMonthPatterns = {
  narrow: [/^一/i, /^二/i, /^三/i, /^四/i, /^五/i, /^六/i, /^七/i, /^八/i, /^九/i, /^十(?!(一|二))/i, /^十一/i, /^十二/i],
  any: [/^一|1/i, /^二|2/i, /^三|3/i, /^四|4/i, /^五|5/i, /^六|6/i, /^七|7/i, /^八|8/i, /^九|9/i, /^十(?!(一|二))|10/i, /^十一|11/i, /^十二|12/i]
}, matchDayPatterns = {
  narrow: /^[一二三四五六日]/i,
  short: /^[一二三四五六日]/i,
  abbreviated: /^周[一二三四五六日]/i,
  wide: /^星期[一二三四五六日]/i
}, parseDayPatterns = {
  any: [/日/i, /一/i, /二/i, /三/i, /四/i, /五/i, /六/i]
}, matchDayPeriodPatterns = {
  any: /^(上午?|下午?|午夜|[中正]午|早上?|下午|晚上?|凌晨|)/i
}, parseDayPeriodPatterns = {
  any: {
    am: /^上午?/i,
    pm: /^下午?/i,
    midnight: /^午夜/i,
    noon: /^[中正]午/i,
    morning: /^早上/i,
    afternoon: /^下午/i,
    evening: /^晚上?/i,
    night: /^凌晨/i
  }
}, match$1 = {
  ordinalNumber: buildMatchPatternFn$1({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function(o) {
      return parseInt(o, 10);
    }
  }),
  era: buildMatchFn$1({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseEraPatterns,
    defaultParseWidth: "any"
  }),
  quarter: buildMatchFn$1({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: "any",
    valueCallback: function(o) {
      return o + 1;
    }
  }),
  month: buildMatchFn$1({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: "any"
  }),
  day: buildMatchFn$1({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: "wide",
    parsePatterns: parseDayPatterns,
    defaultParseWidth: "any"
  }),
  dayPeriod: buildMatchFn$1({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: "any",
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: "any"
  })
}, locale = {
  code: "zh-CN",
  formatDistance: formatDistance$1,
  formatLong: formatLong$1,
  formatRelative: formatRelative$1,
  localize: localize$1,
  match: match$1,
  options: {
    weekStartsOn: 1,
    firstWeekContainsDate: 4
  }
};
const local = {
  code: "zh-CN",
  dateFnsLocale: locale,
  // locale code to dateFns locale
  Pagination: {
    pageSize: "每页条数：${pageSize}",
    total: "总页数：${total}",
    jumpTo: "跳至",
    page: "页"
  },
  Modal: {
    confirm: "确定",
    cancel: "取消"
  },
  Tabs: {
    more: "更多"
  },
  TimePicker: {
    placeholder: {
      time: "请选择时间",
      timeRange: "请选择时间范围"
    },
    begin: "开始时间",
    end: "结束时间",
    hour: "时",
    minute: "分",
    second: "秒",
    AM: "上午",
    PM: "下午"
  },
  DatePicker: {
    placeholder: {
      date: "请选择日期",
      dateTime: "请选择日期及时间",
      dateRange: ["开始日期", "结束日期"],
      dateTimeRange: ["开始日期", "结束日期"],
      monthRange: ["开始月份", "结束月份"]
    },
    presets: "快捷选择",
    footer: {
      confirm: "确定",
      cancel: "取消"
    },
    selectDate: "返回选择日期",
    selectTime: "选择时间",
    year: "年",
    month: "月",
    day: "日",
    monthText: "${year}年 ${month}",
    // 此处不使用标准token是因为需要做replace，月份M这个Token可能会被误伤，例如May
    months: {
      1: "1月",
      2: "2月",
      3: "3月",
      4: "4月",
      5: "5月",
      6: "6月",
      7: "7月",
      8: "8月",
      9: "9月",
      10: "10月",
      11: "11月",
      12: "12月"
    },
    // timepicker scrollwheel里只需要展示[1、2……]，所以这里的fullMonths根据UI定制了
    fullMonths: {
      1: "1",
      2: "2",
      3: "3",
      4: "4",
      5: "5",
      6: "6",
      7: "7",
      8: "8",
      9: "9",
      10: "10",
      11: "11",
      12: "12"
    },
    weeks: {
      Mon: "一",
      Tue: "二",
      Wed: "三",
      Thu: "四",
      Fri: "五",
      Sat: "六",
      Sun: "日"
    },
    localeFormatToken: {
      FORMAT_SWITCH_DATE: "yyyy-MM-dd"
    }
  },
  Navigation: {
    collapseText: "收起侧边栏",
    expandText: "展开侧边栏"
  },
  Popconfirm: {
    confirm: "确定",
    cancel: "取消"
  },
  Table: {
    emptyText: "暂无数据",
    pageText: "显示第 ${currentStart} 条-第 ${currentEnd} 条，共 ${total} 条"
  },
  Select: {
    emptyText: "暂无数据",
    createText: "创建"
  },
  Cascader: {
    emptyText: "暂无数据"
  },
  Tree: {
    emptyText: "暂无数据",
    searchPlaceholder: "搜索"
  },
  List: {
    emptyText: "暂无数据"
  },
  Calendar: {
    allDay: "全天",
    AM: "上午${time}时",
    PM: "下午${time}时",
    datestring: "日",
    remaining: "还有${remained}项"
  },
  Upload: {
    mainText: "点击上传文件或拖拽文件到这里",
    illegalTips: "不支持此类型文件",
    legalTips: "松手开始上传",
    retry: "重试",
    replace: "替换文件",
    clear: "清空",
    selectedFiles: "已选择文件",
    illegalSize: "文件尺寸不合法",
    fail: "上传失败"
  },
  TreeSelect: {
    searchPlaceholder: "搜索"
  },
  Typography: {
    copy: "复制",
    copied: "复制成功",
    expand: "展开",
    collapse: "收起"
  },
  Transfer: {
    emptyLeft: "暂无数据",
    emptySearch: "无搜索结果",
    emptyRight: "暂无内容，可从左侧勾选",
    placeholder: "搜索",
    clear: "清空",
    selectAll: "全选",
    clearSelectAll: "取消全选",
    total: "总个数：${total}",
    selected: "已选个数：${total}"
  },
  Form: {
    optional: "（可选）"
  },
  Image: {
    preview: "预览",
    loading: "加载中",
    loadError: "加载失败",
    prevTip: "上一张",
    nextTip: "下一张",
    zoomInTip: "放大",
    zoomOutTip: "缩小",
    rotateTip: "旋转",
    downloadTip: "下载",
    adaptiveTip: "适应页面",
    originTip: "原始尺寸"
  }
}, vuePropsType$3i = {
  value: Object
}, Provider$k = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3i
  },
  name: "ConfigProviderProvider",
  setup(s, {
    slots: o
  }) {
    const l = ref$1(s.value);
    return watch(() => s.value, () => {
      l.value = s.value;
    }, {
      deep: !0
    }), provide("ConfigContext", l), () => o.default ? o.default(l.value) : null;
  }
}), ConfigContext = {
  Provider: Provider$k,
  Consumer: Consumer$l
}, vuePropsType$3h = {
  locale: {
    type: Object,
    default: local
  },
  timeZone: String,
  getPopupContainer: Function,
  direction: {
    type: String,
    default: "ltr"
  }
}, ConfigProvider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3h
  },
  name: "ConfigProvider",
  setup(s, {
    slots: o
  }) {
    function l() {
      const {
        direction: u
      } = s;
      return u === "rtl" ? createVNode("div", {
        class: `${BASE_CLASS_PREFIX$1}-rtl`
      }, [o.default ? o.default() : null]) : o.default ? o.default() : null;
    }
    return () => {
      const {
        direction: u,
        ...c
      } = s;
      return createVNode(ConfigContext.Provider, {
        value: {
          direction: u,
          ...c
        }
      }, {
        default: l
      });
    };
  }
}), ConfigProvider$1 = ConfigProvider, cssClasses$W = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-tooltip`
}, strings$q = {
  POSITION_SET: [
    "top",
    "topLeft",
    "topRight",
    "left",
    "leftTop",
    "leftBottom",
    "right",
    "rightTop",
    "rightBottom",
    "bottom",
    "bottomLeft",
    "bottomRight",
    "leftTopOver",
    "rightTopOver",
    "leftBottomOver",
    "rightBottomOver"
  ],
  TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"],
  STATUS_DISABLED: "disabled",
  STATUS_LOADING: "loading"
}, numbers$h = {
  ARROW_BOUNDING: {
    offsetX: 0,
    offsetY: 2,
    width: 24,
    height: 7
  },
  DEFAULT_Z_INDEX: 1060,
  MOUSE_ENTER_DELAY: 50,
  MOUSE_LEAVE_DELAY: 50,
  SPACING: 8,
  // Values are consistent with spacing-tight in scss
  MARGIN: 0
}, cssClasses$V = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-dropdown`,
  SELECTED: `${BASE_CLASS_PREFIX$1}-dropdown-item-selected`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-dropdown-item-disabled`
}, strings$p = {
  POSITION_SET: strings$q.POSITION_SET,
  TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"],
  DEFAULT_LEAVE_DELAY: 100,
  ITEM_TYPE: ["primary", "secondary", "tertiary", "warning", "danger"]
}, numbers$g = {
  SPACING: 4,
  NESTED_SPACING: 2
};
let Event$1 = class {
  constructor() {
    this._eventMap = /* @__PURE__ */ new Map();
  }
  on(o, l) {
    return o && typeof l == "function" && (this._eventMap.has(o) || this._eventMap.set(o, []), this._eventMap.get(o).push(l)), this;
  }
  once(o, l) {
    if (o && typeof l == "function") {
      const u = (...c) => {
        l(...c), this.off(o, u);
      };
      this.on(o, u);
    }
  }
  off(o, l) {
    if (o)
      if (typeof l == "function") {
        const u = this._eventMap.get(o);
        if (Array.isArray(u) && u.length) {
          let c = -1;
          for (; (c = u.findIndex((m) => m === l)) > -1; )
            u.splice(c, 1);
        }
      } else isNullOrUndefined(l) && this._eventMap.delete(o);
    return this;
  }
  emit(o, ...l) {
    return this._eventMap.has(o) ? ([...this._eventMap.get(o)].forEach((c) => c(...l)), !0) : !1;
  }
};
function handlePrevent(s) {
  s.stopPropagation(), s.preventDefault();
}
function setFocusToItem(s, o) {
  for (let l = 0; l < s.length; l++)
    s[l] === o ? (s[l].tabIndex = 0, s[l].focus()) : s[l].tabIndex = -1;
}
function setFocusToFirstItem(s) {
  s.length > 0 && setFocusToItem(s, s[0]);
}
function setFocusToLastItem(s) {
  s.length > 0 && setFocusToItem(s, s[s.length - 1]);
}
const REGS = {
  TOP: /top/i,
  RIGHT: /right/i,
  BOTTOM: /bottom/i,
  LEFT: /left/i
}, defaultRect = {
  left: 0,
  top: 0,
  height: 0,
  width: 0,
  scrollLeft: 0,
  scrollTop: 0
};
let Tooltip$2 = class extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.removePortal = () => {
      this._adapter.removePortal();
    }, this.setDisplayNone = (l, u) => {
      this._adapter.setDisplayNone(l, u);
    }, this.updateStateIfCursorOnTrigger = (l) => {
      var u, c;
      if ((u = l == null ? void 0 : l.matches) != null && u.call(l, ":hover")) {
        const m = this._adapter.getEventName(), g = this.getState("triggerEventSet");
        (c = g[m.mouseEnter]) == null || c.call(g);
      }
    }, this.onResize = () => {
      this.calcPosition();
    }, this.delayShow = () => {
      const l = this.getProp("mouseEnterDelay");
      this.clearDelayTimer(), l > 0 ? this._timer = setTimeout(() => {
        this.show(), this.clearDelayTimer();
      }, l) : this.show();
    }, this.show = () => {
      const l = this.getProp("content"), u = this.getProp("trigger"), c = this.getProp("clickTriggerToHide"), { visible: m, displayNone: g } = this.getStates();
      if (g && this.setDisplayNone(!1), !m) {
        if (this.clearDelayTimer(), this._adapter.on("portalInserted", () => {
          this.calcPosition();
        }), u === "hover") {
          const v = () => {
            const b = this._adapter.getTriggerDOM();
            u && !b.matches(":hover") && this.hide(), this._adapter.off("portalInserted", v);
          };
          this._adapter.on("portalInserted", v);
        }
        this._adapter.on("positionUpdated", () => {
          this._togglePortalVisible(!0);
        }), this._adapter.insertPortal(l, { left: -9999, top: -9999 }), u === "custom" && this._adapter.registerClickOutsideHandler(() => {
        }), (u === "click" || c || u === "contextMenu") && this._adapter.registerClickOutsideHandler(this.hide), this._bindScrollEvent(), this._bindResizeEvent();
      }
    }, this.calcPosition = (l, u, c, m = !0) => {
      l = (lodashExports.isEmpty(l) ? this._adapter.getTriggerBounding() : l) || { ...defaultRect }, c = (lodashExports.isEmpty(c) ? this._adapter.getPopupContainerRect() : c) || {
        ...defaultRect
      }, u = (lodashExports.isEmpty(u) ? this._adapter.getWrapperBounding() : u) || { ...defaultRect };
      let g = this.calcPosStyle({ triggerRect: l, wrapperRect: u, containerRect: c }), v = this.getProp("position");
      if (this.getProp("autoAdjustOverflow")) {
        const { position: b, isHeightOverFlow: S, isWidthOverFlow: E } = this.adjustPosIfNeed(v, g, l, u, c);
        (v !== b || S || E) && (v = b, g = this.calcPosStyle({ triggerRect: l, wrapperRect: u, containerRect: c, position: v, spacing: null, isOverFlow: [S, E] }));
      }
      return m && this._mounted && this._adapter.setPosition({ ...g, position: v }), g;
    }, this.delayHide = () => {
      const l = this.getProp("mouseLeaveDelay");
      this.clearDelayTimer(), l > 0 ? this._timer = setTimeout(() => {
        this.hide(), this.clearDelayTimer();
      }, l) : this.hide();
    }, this.hide = () => {
      this.clearDelayTimer(), this._togglePortalVisible(!1), this._adapter.off("portalInserted"), this._adapter.off("positionUpdated");
    }, this.handleContainerKeydown = (l) => {
      const { guardFocus: u, closeOnEsc: c } = this.getProps();
      switch (l && l.key) {
        case "Escape":
          c && this._handleEscKeyDown(l);
          break;
        case "Tab":
          if (u) {
            const m = this._adapter.getContainer(), g = this._adapter.getFocusableElements(m);
            g.length && (l.shiftKey ? this._handleContainerShiftTabKeyDown(g, l) : this._handleContainerTabKeyDown(g, l));
          }
          break;
      }
    }, this._timer = null;
  }
  init() {
    const { wrapperId: o } = this.getProps();
    this._mounted = !0, this._bindEvent(), this._shouldShow(), this._initContainerPosition(), o || this._adapter.setId();
  }
  destroy() {
    this._mounted = !1, this.unBindEvent();
  }
  _bindEvent() {
    const o = this.getProp("trigger"), { triggerEventSet: l, portalEventSet: u } = this._generateEvent(o);
    this._bindTriggerEvent(l), this._bindPortalEvent(u), this._bindResizeEvent();
  }
  unBindEvent() {
    this._adapter.unregisterClickOutsideHandler(), this.unBindResizeEvent(), this.unBindScrollEvent(), clearTimeout(this._timer);
  }
  _bindTriggerEvent(o) {
    this._adapter.registerTriggerEvent(o);
  }
  _bindPortalEvent(o) {
    this._adapter.registerPortalEvent(o);
  }
  _bindResizeEvent() {
    this._adapter.registerResizeHandler(this.onResize);
  }
  unBindResizeEvent() {
    this._adapter.unregisterResizeHandler(this.onResize);
  }
  _adjustPos(o = "", l = !1, u = "reverse", c) {
    switch (u) {
      case "reverse":
        return this._reversePos(o, l);
      case "expand":
        return this._expandPos(o, c);
      case "reduce":
        return this._reducePos(o);
      default:
        return this._reversePos(o, l);
    }
  }
  _reversePos(o = "", l = !1) {
    if (l) {
      if (REGS.TOP.test(o))
        return o.replace("top", "bottom").replace("Top", "Bottom");
      if (REGS.BOTTOM.test(o))
        return o.replace("bottom", "top").replace("Bottom", "Top");
    } else {
      if (REGS.LEFT.test(o))
        return o.replace("left", "right").replace("Left", "Right");
      if (REGS.RIGHT.test(o))
        return o.replace("right", "left").replace("Right", "Left");
    }
    return o;
  }
  _expandPos(o = "", l) {
    return o.concat(l);
  }
  _reducePos(o = "") {
    const l = ["Top", "Bottom", "Left", "Right"].find((u) => o.endsWith(u));
    return l ? o.replace(l, "") : o;
  }
  clearDelayTimer() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
  _generateEvent(o) {
    const l = this._adapter.getEventName(), u = {
      // bind esc keydown on trigger for a11y
      [l.keydown]: (m) => {
        this._handleTriggerKeydown(m);
      }
    };
    let c = {};
    switch (o) {
      case "focus":
        u[l.focus] = () => {
          this.delayShow();
        }, u[l.blur] = () => {
          this.delayHide();
        }, c = u;
        break;
      case "click":
        u[l.click] = () => {
          this.show();
        }, c = {};
        break;
      case "hover":
        u[l.mouseEnter] = () => {
          this.setCache("isClickToHide", !1), this.delayShow();
        }, u[l.mouseLeave] = () => {
          this.delayHide();
        }, u[l.focus] = () => {
          const { disableFocusListener: m } = this.getProps();
          !m && this.delayShow();
        }, u[l.blur] = () => {
          const { disableFocusListener: m } = this.getProps();
          !m && this.delayHide();
        }, c = { ...u }, this.getProp("clickToHide") && (c[l.click] = () => {
          this.setCache("isClickToHide", !0), this.hide();
        }, c[l.mouseEnter] = () => {
          this.getCache("isClickToHide") || this.delayShow();
        });
        break;
      case "custom":
        break;
      case "contextMenu":
        u[l.contextMenu] = (m) => {
          m.preventDefault(), this.show();
        };
        break;
    }
    return { triggerEventSet: u, portalEventSet: c };
  }
  _shouldShow() {
    this.getProp("visible") && this.show();
  }
  _togglePortalVisible(o) {
    this.getState("visible") !== o && this._adapter.togglePortalVisible(o, () => {
      o && this._adapter.setInitialFocus(), this._adapter.notifyVisibleChange(o);
    });
  }
  _roundPixel(o) {
    return typeof o == "number" ? Math.round(o) : o;
  }
  calcTransformOrigin(o, l, u, c) {
    if (o && l && u != null && c != null) {
      if (this.getProp("transformFromCenter")) {
        if (["topLeft", "bottomLeft"].includes(o))
          return `${this._roundPixel(l.width / 2)}px ${-c * 100}%`;
        if (["topRight", "bottomRight"].includes(o))
          return `calc(100% - ${this._roundPixel(l.width / 2)}px) ${-c * 100}%`;
        if (["leftTop", "rightTop"].includes(o))
          return `${-u * 100}% ${this._roundPixel(l.height / 2)}px`;
        if (["leftBottom", "rightBottom"].includes(o))
          return `${-u * 100}% calc(100% - ${this._roundPixel(l.height / 2)}px)`;
      }
      return `${-u * 100}% ${-c * 100}%`;
    }
    return null;
  }
  calcPosStyle(o) {
    var _n;
    const { spacing: l, isOverFlow: u } = o, { innerWidth: c } = window, m = (lodashExports.isEmpty(o.triggerRect) ? o.triggerRect : this._adapter.getTriggerBounding()) || { ...defaultRect }, g = (lodashExports.isEmpty(o.containerRect) ? o.containerRect : this._adapter.getPopupContainerRect()) || {
      ...defaultRect
    }, v = (lodashExports.isEmpty(o.wrapperRect) ? o.wrapperRect : this._adapter.getWrapperBounding()) || { ...defaultRect }, b = o.position != null ? o.position : this.getProp("position"), S = l ?? this.getProp("spacing"), { arrowPointAtCenter: E, showArrow: P, arrowBounding: T } = this.getProps(), N = P && E;
    let O = S, z = 0;
    if (typeof S != "number") {
      const Nn = b.includes("top") || b.includes("bottom");
      O = Nn ? S.y : S.x, z = Nn ? S.x : S.y;
    }
    const Q = lodashExports.get(T, "width", 24), W = lodashExports.get(T, "width", 24), ue = lodashExports.get(T, "offsetY", 0), te = 6, K = 6;
    let ve, ee, Re = 0, wt = 0;
    const yt = m.left + m.width / 2, xt = m.top + m.height / 2, Kt = te + Q / 2, tn = K + W / 2, ln = v.height - g.height, rn = v.width - g.width, an = ln > 0 ? ln : 0, Gt = rn > 0 ? rn : 0, nn = u && u[0], vt = u && u[1], Et = yt - g.left < g.right - yt, Qt = xt - g.top < g.bottom - xt, un = v.width > c, gn = Math.abs((v == null ? void 0 : v.width) - ((_n = this._adapter.getContainer()) == null ? void 0 : _n.clientWidth)) > 1;
    switch (gn && (O = O * v.width / this._adapter.getContainer().clientWidth), b) {
      case "top":
        ve = vt ? Et ? g.left + v.width / 2 : g.right - v.width / 2 + Gt : yt + z, ee = nn ? g.bottom + an : m.top - O, Re = -0.5, wt = -1;
        break;
      case "topLeft":
        ve = vt ? un ? g.left : g.right - v.width : N ? yt - Kt + z : m.left + z, ee = nn ? g.bottom + an : m.top - O, wt = -1;
        break;
      case "topRight":
        ve = vt ? g.right + Gt : N ? yt + Kt + z : m.right + z, ee = nn ? g.bottom + an : m.top - O, wt = -1, Re = -1;
        break;
      case "left":
        ve = vt ? g.right + Gt - O + Kt : m.left - O, ee = nn ? Qt ? g.top + v.height / 2 : g.bottom - v.height / 2 + an : xt + z, Re = -1, wt = -0.5;
        break;
      case "leftTop":
        ve = vt ? g.right + Gt - O + Kt : m.left - O, ee = nn ? g.top : N ? xt - tn + z : m.top + z, Re = -1;
        break;
      case "leftBottom":
        ve = vt ? g.right + Gt - O + Kt : m.left - O, ee = nn ? g.bottom + an : N ? xt + tn + z : m.bottom + z, Re = -1, wt = -1;
        break;
      case "bottom":
        ve = vt ? Et ? g.left + v.width / 2 : g.right - v.width / 2 + Gt : yt + z, ee = nn ? g.top + tn - O : m.top + m.height + O, Re = -0.5;
        break;
      case "bottomLeft":
        ve = vt ? un ? g.left : g.right - v.width : N ? yt - Kt + z : m.left + z, ee = nn ? g.top + tn - O : m.top + m.height + O;
        break;
      case "bottomRight":
        ve = vt ? g.right + Gt : N ? yt + Kt + z : m.right + z, ee = nn ? g.top + tn - O : m.top + m.height + O, Re = -1;
        break;
      case "right":
        ve = vt ? g.left - O + Kt : m.right + O, ee = nn ? Qt ? g.top + v.height / 2 : g.bottom - v.height / 2 + an : xt + z, wt = -0.5;
        break;
      case "rightTop":
        ve = vt ? g.left - O + Kt : m.right + O, ee = nn ? g.top : N ? xt - tn + z : m.top + z;
        break;
      case "rightBottom":
        ve = vt ? g.left - O + Kt : m.right + O, ee = nn ? g.bottom + an : N ? xt + tn + z : m.bottom + z, wt = -1;
        break;
      case "leftTopOver":
        ve = m.left - O, ee = m.top - O;
        break;
      case "rightTopOver":
        ve = m.right + O, ee = m.top - O, Re = -1;
        break;
      case "leftBottomOver":
        ve = m.left - O, ee = m.bottom + O, wt = -1;
        break;
      case "rightBottomOver":
        ve = m.right + O, ee = m.bottom + O, Re = -1, wt = -1;
        break;
    }
    const dn = this.calcTransformOrigin(b, m, Re, wt), yn = this._adapter.containerIsBody();
    if (ve = ve - g.left, ee = ee - g.top, gn && (ve /= v.width / this._adapter.getContainer().clientWidth), gn && (ee /= v.height / this._adapter.getContainer().clientHeight), yn && !this._adapter.containerIsRelativeOrAbsolute()) {
      const Nn = this._adapter.getDocumentElementBounding();
      ve += g.left - Nn.left, ee += g.top - Nn.top;
    }
    ve = yn ? ve : ve + g.scrollLeft, ee = yn ? ee : ee + g.scrollTop;
    const vn = m.height;
    if (this.getProp("showArrow") && !E && vn <= (W / 2 + ue) * 2) {
      const Nn = vn / 2 - (ue + W / 2);
      (b.includes("Top") || b.includes("Bottom")) && !b.includes("Over") && (ee = b.includes("Top") ? ee + Nn : ee - Nn);
    }
    const Pn = {
      left: this._roundPixel(ve),
      top: this._roundPixel(ee)
    };
    let On = "";
    return Re != null && (On += `translateX(${Re * 100}%) `, Object.defineProperty(Pn, "translateX", {
      enumerable: !1,
      value: Re
    })), wt != null && (On += `translateY(${wt * 100}%) `, Object.defineProperty(Pn, "translateY", {
      enumerable: !1,
      value: wt
    })), dn != null && (Pn.transformOrigin = dn), On && (Pn.transform = On), Pn;
  }
  isLR(o = "") {
    return o.includes("left") || o.includes("right");
  }
  isTB(o = "") {
    return o.includes("top") || o.includes("bottom");
  }
  isReverse(o, l, u) {
    return o < u && l > u;
  }
  isOverFlow(o, l, u) {
    return o < u && l < u;
  }
  isHalfOverFlow(o, l, u) {
    return o < u || l < u;
  }
  isHalfAllEnough(o, l, u) {
    return o >= u || l >= u;
  }
  getReverse(o, l, u, c) {
    return o && c || u;
  }
  // place the dom correctly
  adjustPosIfNeed(o, l, u, c, m) {
    const { innerWidth: g, innerHeight: v } = window, { margin: b } = this.getProps(), S = typeof b == "number" ? b : b.marginLeft, E = typeof b == "number" ? b : b.marginTop, P = typeof b == "number" ? b : b.marginRight, T = typeof b == "number" ? b : b.marginBottom;
    let N = !1, O = !1;
    const z = this.getProp("spacing");
    let Q = z, W = 0;
    if (typeof z != "number") {
      const ue = o.includes("top") || o.includes("bottom");
      Q = ue ? z.y : z.x, W = ue ? z.x : z.y;
    }
    if (c.width > 0 && c.height > 0) {
      const ue = u.left, te = u.right, K = u.top, ve = u.bottom, ee = g - ue, Re = v - K, wt = g - te, yt = v - ve, xt = c.width > u.width, Kt = c.height > u.height, tn = K - E < c.height + Q && yt - T > c.height + Q, ln = ue - S < c.width + Q && wt - P > c.width + Q, rn = yt - T < c.height + Q && K - E > c.height + Q, an = wt - P < c.width + Q && ue - S > c.width + Q;
      Re - T < c.height + Q && ve - E > c.height + Q, ve - E < c.height + Q && Re - T > c.height + Q;
      const Gt = Re < c.height + W && ve > c.height + W, nn = ve < c.height + W && Re > c.height + W, vt = ee < c.width + W && te > c.width + W, Et = te < c.width + W && ee > c.width + W, Qt = Re < c.height + Q && ve > c.height + Q, un = ve < c.height + Q && Re > c.height + Q, gn = ee < c.width && te > c.width, dn = te < c.width && ee > c.width, yn = K - m.top, vn = ue - m.left, Pn = yn + u.height, On = vn + u.width, _n = m.bottom - ve, Nn = m.right - te, Un = _n + u.height, Xn = Nn + u.width, zn = this.isReverse(yn - E, _n - T, c.height + Q), jn = this.isReverse(vn - S, Nn - P, c.width + Q), kn = this.isReverse(_n - T, yn - E, c.height + Q), Yn = this.isReverse(Nn - P, vn - S, c.width + Q);
      this.isReverse(Un - T, Pn - E, c.height + Q), this.isReverse(Pn - E, Un - T, c.height + Q);
      const Zn = this.isReverse(Un, Pn, c.height + W), er = this.isReverse(Pn, Un, c.height + W), bn = this.isReverse(Xn, On, c.width + W), Ln = this.isReverse(On, Xn, c.width + W), Kn = u.height / 2, Bn = u.width / 2, Fn = this.isOverFlow(K - E, yt - T, c.height + Q), Gn = this.isOverFlow(ue - S, wt - P, c.width + Q), Wn = this.isOverFlow(ve - E, Re - T, c.height + Q), Mn = this.isOverFlow(te - S, ee - P, c.width + Q), Tn = this.isHalfOverFlow(ve - Kn, Re - Kn, (c.height + W) / 2), Rn = this.isHalfOverFlow(te - Bn, ee - Bn, (c.width + W) / 2), hn = this.isHalfAllEnough(ve - Kn, Re - Kn, (c.height + W) / 2), Qn = this.isHalfAllEnough(te - Bn, ee - Bn, (c.width + W) / 2), rr = this.isOverFlow(yn - E, _n - T, c.height + Q), tr = this.isOverFlow(vn - S, Nn - P, c.width + Q), Cr = this.isOverFlow(Pn - E, Un - T, c.height + Q), Fr = this.isOverFlow(On - S, Xn - P, c.width + Q), An = this.isHalfOverFlow(Pn - Kn, Un - Kn, (c.height + W) / 2), Hn = this.isHalfOverFlow(On - Bn, Xn - Bn, (c.width + W) / 2), ir = this.isHalfAllEnough(Pn - Kn, Un - Kn, (c.height + W) / 2), dr = this.isHalfAllEnough(On - Bn, Xn - Bn, (c.width + W) / 2), ar = this.getReverse(Fn, rr, tn, zn), Or = this.getReverse(Gn, tr, ln, jn), Sr = this.getReverse(Fn, rr, rn, kn), kr = this.getReverse(Gn, tr, an, Yn), Nr = this.getReverse(Wn, Cr, Gt, Zn), Ur = this.getReverse(Wn, Cr, nn, er), _r = this.getReverse(Mn, Fr, vt, bn), Zr = this.getReverse(Mn, Fr, Et, Ln), Jr = Tn && An, ii = Rn && Hn;
      switch (o) {
        case "top":
          ar && (o = this._adjustPos(o, !0)), ii && (_r || Zr) && (o = this._adjustPos(o, !0, "expand", _r ? "Right" : "Left"));
          break;
        case "topLeft":
          ar && (o = this._adjustPos(o, !0)), _r && xt && (o = this._adjustPos(o)), O && (Qn || dr) && (o = this._adjustPos(o, !0, "reduce"));
          break;
        case "topRight":
          ar && (o = this._adjustPos(o, !0)), Zr && xt && (o = this._adjustPos(o)), O && (Qn || dr) && (o = this._adjustPos(o, !0, "reduce"));
          break;
        case "left":
          Or && (o = this._adjustPos(o)), Jr && (Nr || Ur) && (o = this._adjustPos(o, !1, "expand", Nr ? "Bottom" : "Top"));
          break;
        case "leftTop":
          Or && (o = this._adjustPos(o)), Nr && Kt && (o = this._adjustPos(o, !0)), N && (hn || ir) && (o = this._adjustPos(o, !1, "reduce"));
          break;
        case "leftBottom":
          Or && (o = this._adjustPos(o)), Ur && Kt && (o = this._adjustPos(o, !0)), N && (hn || ir) && (o = this._adjustPos(o, !1, "reduce"));
          break;
        case "bottom":
          Sr && (o = this._adjustPos(o, !0)), ii && (_r || Zr) && (o = this._adjustPos(o, !0, "expand", _r ? "Right" : "Left"));
          break;
        case "bottomLeft":
          Sr && (o = this._adjustPos(o, !0)), _r && xt && (o = this._adjustPos(o)), O && (Qn || dr) && (o = this._adjustPos(o, !0, "reduce"));
          break;
        case "bottomRight":
          Sr && (o = this._adjustPos(o, !0)), Zr && xt && (o = this._adjustPos(o)), O && (Qn || dr) && (o = this._adjustPos(o, !0, "reduce"));
          break;
        case "right":
          kr && (o = this._adjustPos(o)), Jr && (Nr || Ur) && (o = this._adjustPos(o, !1, "expand", Nr ? "Bottom" : "Top"));
          break;
        case "rightTop":
          kr && (o = this._adjustPos(o)), Nr && Kt && (o = this._adjustPos(o, !0)), N && (hn || ir) && (o = this._adjustPos(o, !1, "reduce"));
          break;
        case "rightBottom":
          kr && (o = this._adjustPos(o)), Ur && Kt && (o = this._adjustPos(o, !0)), N && (hn || ir) && (o = this._adjustPos(o, !1, "reduce"));
          break;
        case "leftTopOver":
          Qt && (o = this._adjustPos(o, !0)), gn && (o = this._adjustPos(o));
          break;
        case "leftBottomOver":
          un && (o = this._adjustPos(o, !0)), gn && (o = this._adjustPos(o));
          break;
        case "rightTopOver":
          Qt && (o = this._adjustPos(o, !0)), dn && (o = this._adjustPos(o));
          break;
        case "rightBottomOver":
          un && (o = this._adjustPos(o, !0)), dn && (o = this._adjustPos(o));
          break;
      }
      this.isTB(o) && (N = Fn && rr, o === "top" || o === "bottom" ? O = Rn && Hn || te < 0 || wt < 0 : O = Mn && Fr || te < 0 || wt < 0), this.isLR(o) && (O = Gn && tr, o === "left" || o === "right" ? N = Tn && An || K < 0 || Re < 0 : N = Wn && Cr || K < 0 || Re < 0);
    }
    return { position: o, isHeightOverFlow: N, isWidthOverFlow: O };
  }
  _bindScrollEvent() {
    this._adapter.registerScrollHandler(() => this.calcPosition());
  }
  unBindScrollEvent() {
    this._adapter.unregisterScrollHandler();
  }
  _initContainerPosition() {
    this._adapter.updateContainerPosition();
  }
  _handleTriggerKeydown(o) {
    const { closeOnEsc: l, disableArrowKeyDown: u } = this.getProps(), c = this._adapter.getContainer(), m = this._adapter.getFocusableElements(c), g = m.length;
    switch (o && o.key) {
      case "Escape":
        handlePrevent(o), l && this._handleEscKeyDown(o);
        break;
      case "ArrowUp":
        !u && g && this._handleTriggerArrowUpKeydown(m, o);
        break;
      case "ArrowDown":
        !u && g && this._handleTriggerArrowDownKeydown(m, o);
        break;
    }
  }
  /**
   * focus trigger 
   * 
   * when trigger is 'focus' or 'hover', onFocus is bind to show popup
   * if we focus trigger, popup will show again
   * 
   * 如果 trigger 是 focus 或者 hover，则它绑定了 onFocus，这里我们如果重新 focus 的话，popup 会再次打开
   * 因此 returnFocusOnClose 只支持 click trigger
   */
  focusTrigger() {
    const { trigger: o, returnFocusOnClose: l, preventScroll: u } = this.getProps();
    if (l && o !== "custom") {
      const c = this._adapter.getTriggerNode();
      c && "focus" in c && c.focus({ preventScroll: u });
    }
  }
  _handleEscKeyDown(o) {
    const { trigger: l } = this.getProps();
    l !== "custom" && (this.focusTrigger(), this.hide()), this._adapter.notifyEscKeydown(o);
  }
  _handleContainerTabKeyDown(o, l) {
    const { preventScroll: u } = this.getProps(), c = this._adapter.getActiveElement();
    o[o.length - 1] === c && (o[0].focus({ preventScroll: u }), l.preventDefault());
  }
  _handleContainerShiftTabKeyDown(o, l) {
    const { preventScroll: u } = this.getProps(), c = this._adapter.getActiveElement();
    o[0] === c && (o[o.length - 1].focus({ preventScroll: u }), l.preventDefault());
  }
  _handleTriggerArrowDownKeydown(o, l) {
    const { preventScroll: u } = this.getProps();
    o[0].focus({ preventScroll: u }), l.preventDefault();
  }
  _handleTriggerArrowUpKeydown(o, l) {
    const { preventScroll: u } = this.getProps();
    o[o.length - 1].focus({ preventScroll: u }), l.preventDefault();
  }
};
function isElement(s) {
  return isVNode(s);
}
function isEmptyChildren(s) {
  return s().length === 0;
}
function getUuid(s) {
  return `${s}-${(/* @__PURE__ */ new Date()).getTime()}-${Math.random()}`;
}
function getUuidv4() {
  var s;
  try {
    return ((s = crypto == null ? void 0 : crypto.randomUUID) == null ? void 0 : s.call(crypto)) ?? String(9987e3 + -1e11).replace(
      /[018]/g,
      (o) => (Number(o) ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> Number(o) / 4).toString(16)
    );
  } catch {
    return getUuid("semi");
  }
}
function getUuidShort(s = {}) {
  const { prefix: o = "", length: l = 7 } = s, u = "0123456789abcdefghijklmnopqrstuvwxyz", c = u.length;
  let m = "";
  for (let g = 0; g < l; g++) {
    const v = Math.floor(Math.random() * c);
    m += u.charAt(v);
  }
  return o ? `${o}-${m}` : m;
}
const defaultGetContainer$1 = () => document.body, vuePropsType$3g = {
  style: [Object, String],
  prefixCls: {
    type: String,
    default: `${BASE_CLASS_PREFIX$1}-portal`
  },
  className: String,
  getPopupContainer: Function,
  didUpdate: Function
}, Index$9 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3g
  },
  name: "Portal",
  setup(s, {
    slots: o
  }) {
    const {
      context: l
    } = useConfigContext();
    let u;
    const c = reactive({
      container: void 0
    });
    onMounted(() => {
      const b = m(l.value);
      b !== c.container && (c.container = b);
    });
    function m(b, S = !1) {
      try {
        let E;
        if (!u || !c.container || !Array.from(c.container.childNodes).includes(u)) {
          u = document.createElement("div");
          const T = (s.getPopupContainer || b.getPopupContainer || defaultGetContainer$1)();
          return T.appendChild(u), g(s.style), v(s.prefixCls, b, s.className), E = T, E;
        }
      } catch (E) {
        if (!S)
          throw E;
      }
      return c == null ? void 0 : c.container;
    }
    watch(() => s, (b, S) => {
      const {
        didUpdate: E
      } = s;
      E && E(S);
    }), onBeforeUnmount(() => {
      c.container && c.container.removeChild(u);
    });
    const g = (b = {}) => {
      if (u)
        for (const S of Object.keys(b))
          u.style[S] = b[S];
    }, v = (b, S = l.value, ...E) => {
      const {
        direction: P
      } = S, T = cls(b, ...E, {
        [`${b}-rtl`]: P === "rtl"
      });
      u && (u.className = T);
    };
    return () => c.container ? createVNode(Teleport, {
      to: u
    }, {
      default: o.default
    }) : null;
  }
}), vuePropsType$3f = {
  name: String,
  className: String,
  style: [String, Object]
}, TriangleArrow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3f
  },
  name: "TriangleArrow",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        className: l,
        style: u,
        ...c
      } = s;
      return createVNode("svg", mergeProps$1({
        class: l,
        style: u
      }, c, {
        width: "24",
        height: "7",
        viewBox: "0 0 24 7",
        fill: "currentColor",
        xmlns: "http://www.w3.org/2000/svg"
      }), [createVNode("path", {
        d: "M24 0V1C20 1 18.5 2 16.5 4C14.5 6 14 7 12 7C10 7 9.5 6 7.5 4C5.5 2 4 1 0 1V0H24Z"
      }, null)]);
    };
  }
}), vuePropsType$3e = {
  name: String,
  className: String,
  style: [String, Object]
}, TriangleArrowVertical = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3e
  },
  name: "TriangleArrowVertical",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        className: l,
        style: u,
        ...c
      } = s;
      return createVNode("svg", mergeProps$1({
        class: l,
        style: u
      }, c, {
        width: "7",
        height: "24",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "currentColor"
      }), [createVNode("path", {
        d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z"
      }, null)]);
    };
  }
}), vuePropsType$3d = {
  startClassName: String,
  endClassName: String,
  children: {
    type: [Function, Object],
    required: !0
  },
  animationState: {
    type: String,
    required: !0
  },
  onAnimationEnd: Function,
  onAnimationStart: Function,
  motion: {
    type: [bool, func, object$1],
    default: !0
  },
  replayKey: {
    type: String,
    default: ""
  },
  fillMode: String
}, CSSAnimation = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3d
  },
  name: "CSSAnimation",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      currentClassName: s.startClassName,
      extraStyle: {
        animationFillMode: s.fillMode
      },
      isAnimating: !0
    });
    onMounted(() => {
      var c, m;
      (c = s.onAnimationStart) == null || c.call(s), s.motion || ((m = s.onAnimationEnd) == null || m.call(s, !1), o.isAnimating = !1);
    }), watch(() => s.animationState, () => {
    }), watch([() => s.startClassName, () => s.replayKey, () => s.motion], () => {
      o.currentClassName = s.startClassName, o.extraStyle = {
        animationFillMode: s.fillMode
      }, o.isAnimating = !0, nextTick(() => {
        var c, m;
        (c = s.onAnimationStart) == null || c.call(s), s.motion || ((m = s.onAnimationEnd) == null || m.call(s, o.isAnimating), o.isAnimating = !1);
      });
    });
    const l = () => {
      var c;
      (c = s.onAnimationStart) == null || c.call(s);
    }, u = () => {
      o.currentClassName = s.startClassName, o.extraStyle = {
        animationFillMode: s.fillMode
      }, o.isAnimating = !1, nextTick(() => {
        var c;
        (c = s.onAnimationEnd) == null || c.call(s, !1);
      });
    };
    return () => s.motion ? s.children({
      animationClassName: o.currentClassName ?? "",
      animationStyle: o.extraStyle,
      animationEventsNeedBind: {
        onAnimationstart: l,
        onAnimationend: u
      },
      isAnimating: o.isAnimating
    }) : s.children({
      animationClassName: "",
      animationStyle: {},
      animationEventsNeedBind: {},
      isAnimating: o.isAnimating
    });
  }
}), prefix$5 = cssClasses$W.PREFIX, blockDisplays = ["flex", "block", "table", "flow-root", "grid"], defaultGetContainer = () => document.body, propTypes$1J = {
  // children: PropTypes.node,
  motion: oneOfType([bool, object$1, func]),
  autoAdjustOverflow: bool,
  position: String,
  getPopupContainer: func,
  mouseEnterDelay: number$2,
  mouseLeaveDelay: number$2,
  trigger: [Boolean, String],
  className: string$3,
  wrapperClassName: string$3,
  clickToHide: bool,
  // used with trigger === hover, private
  clickTriggerToHide: bool,
  visible: bool,
  style: object$1,
  content: oneOfType([node$1, func]),
  prefixCls: string$3,
  onVisibleChange: func,
  onClickOutSide: func,
  spacing: oneOfType([number$2, object$1]),
  margin: oneOfType([number$2, object$1]),
  showArrow: oneOfType([bool, node$1]),
  zIndex: number$2,
  rePosKey: [String, Number, Boolean],
  arrowBounding: Object,
  transformFromCenter: bool,
  // Whether to change from the center of the trigger (for dynamic effects)
  arrowPointAtCenter: bool,
  stopPropagation: bool,
  // private
  role: string$3,
  wrapWhenSpecial: bool,
  // when trigger has special status such as "disabled" or "loading", wrap span
  guardFocus: bool,
  returnFocusOnClose: bool,
  preventScroll: bool,
  disableFocusListener: bool,
  // name: String,
  // cancelText: String,
  // okText: String,
  // contentClassName: String,
  closeOnEsc: {
    type: Boolean,
    default: !1
  },
  onEscKeyDown: {
    type: Function,
    default: lodashExports.noop
  },
  wrapperId: String,
  disableArrowKeyDown: Boolean,
  afterClose: Function,
  keepDOM: Boolean
}, defaultProps$1E = {
  arrowBounding: numbers$h.ARROW_BOUNDING,
  autoAdjustOverflow: !0,
  arrowPointAtCenter: !0,
  trigger: "hover",
  transformFromCenter: !0,
  position: "top",
  prefixCls: prefix$5,
  role: "tooltip",
  mouseEnterDelay: numbers$h.MOUSE_ENTER_DELAY,
  mouseLeaveDelay: numbers$h.MOUSE_LEAVE_DELAY,
  motion: !0,
  onVisibleChange: lodashExports.noop,
  onClickOutSide: lodashExports.noop,
  spacing: numbers$h.SPACING,
  margin: numbers$h.MARGIN,
  showArrow: !0,
  wrapWhenSpecial: !0,
  zIndex: numbers$h.DEFAULT_Z_INDEX,
  closeOnEsc: !1,
  guardFocus: !1,
  returnFocusOnClose: !1,
  onEscKeyDown: lodashExports.noop,
  disableFocusListener: !1,
  disableArrowKeyDown: !1,
  keepDOM: !1
}, vuePropsType$3c = vuePropsMake(propTypes$1J, defaultProps$1E), Tooltip = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3c
  },
  name: "Tooltip",
  setup(s, {
    expose: o
  }) {
    const l = useSlots(), u = ref$1(new Event$1());
    let c = ref$1();
    const m = ref$1(), g = ref$1(), v = ref$1();
    let b, S, E, P, T;
    const N = reactive({
      visible: !1,
      /**
       *
       * Note: The transitionState parameter is equivalent to isInsert
       */
      transitionState: "",
      triggerEventSet: {},
      portalEventSet: {},
      containerStyle: {
        // zIndex: props.zIndex,
      },
      isInsert: !1,
      placement: s.position || "top",
      transitionStyle: {},
      isPositionUpdated: !1,
      id: s.wrapperId,
      // auto generate id, will be used by children.aria-describedby & content.id, improve a11y
      displayNone: !1
    }), {
      adapter: O,
      context: z
    } = useBaseComponent(s, N), Q = W();
    function W() {
      return {
        ...O(),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        on: (...Et) => u.value.on(...Et),
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        off: (...Et) => u.value.off(...Et),
        insertPortal: (Et, {
          position: Qt,
          ...un
        }) => {
          N.isInsert = !0, N.transitionState = "enter", N.containerStyle = {
            ...N.containerStyle,
            containerStyle: un
          }, nextTick(() => {
            setTimeout(() => {
              u.value.emit("portalInserted");
            }, 0);
          });
        },
        removePortal: () => {
          N.isInsert = !1, N.isPositionUpdated = !1;
        },
        getEventName: () => ({
          mouseEnter: "onMouseenter",
          mouseLeave: "onMouseleave",
          mouseOut: "onMouseout",
          mouseOver: "onMouseover",
          click: "onClick",
          focus: "onFocus",
          blur: "onBlur",
          keydown: "onKeydown",
          contextMenu: "onContextmenu"
        }),
        registerTriggerEvent: (Et) => {
          N.triggerEventSet = Et;
        },
        registerPortalEvent: (Et) => {
          N.portalEventSet = Et;
        },
        getTriggerBounding: () => {
          var Qt;
          const Et = Q.getTriggerNode();
          return c.value = Et, Et && ((Qt = Et.getBoundingClientRect) == null ? void 0 : Qt.call(Et));
        },
        // Gets the outer size of the specified container
        getPopupContainerRect: () => {
          const Et = E();
          let Qt = null;
          return Et && isElement$1(Et) && (Qt = {
            ...convertDOMRectToObject(Et.getBoundingClientRect()),
            scrollLeft: Et.scrollLeft,
            scrollTop: Et.scrollTop
          }), Qt;
        },
        containerIsBody: () => E() === document.body,
        containerIsRelative: () => {
          const Et = E();
          return window.getComputedStyle(Et).getPropertyValue("position") === "relative";
        },
        containerIsRelativeOrAbsolute: () => ["relative", "absolute"].includes(P),
        // Get the size of the pop-up layer
        getWrapperBounding: () => {
          const Et = m.value;
          return Et && Et.getBoundingClientRect();
        },
        getDocumentElementBounding: () => document.documentElement.getBoundingClientRect(),
        setPosition: ({
          position: Et,
          ...Qt
        }) => {
          N.containerStyle = {
            ...N.containerStyle,
            ...Qt
          }, N.placement = Et, N.isPositionUpdated = !0, nextTick(() => {
            u.value.emit("positionUpdated");
          });
        },
        setDisplayNone: (Et, Qt) => {
          N.displayNone = Et, nextTick(() => {
            Qt == null || Qt();
          });
        },
        updatePlacementAttr: (Et) => {
          N.placement = Et;
        },
        togglePortalVisible: (Et, Qt) => {
          const un = {};
          un.transitionState = Et ? "enter" : "leave", un.visible = Et, b && (N.transitionState = un.transitionState, N.visible = un.visible, nextTick(() => {
            Qt();
          }));
        },
        registerClickOutsideHandler: (Et) => {
          T && Q.unregisterClickOutsideHandler(), T = (Qt) => {
            if (!b)
              return !1;
            let un = c.value, gn = m.value;
            const dn = Qt.target, yn = Qt.composedPath && Qt.composedPath() || [dn], vn = s.clickTriggerToHide ? un && un.contains(dn) || yn.includes(un) : !1;
            (un && !un.contains(dn) && gn && !gn.contains(dn) && !(yn.includes(gn) || yn.includes(un)) || vn) && (s.onClickOutSide(Qt), Et());
          }, document.addEventListener("mousedown", T, {
            capture: !0
          });
        },
        unregisterClickOutsideHandler: () => {
          T && (document.removeEventListener("mousedown", T, {
            capture: !0
          }), T = null);
        },
        registerResizeHandler: (Et) => {
          v.value && Q.unregisterResizeHandler(), v.value = lodashExports.throttle((Qt) => {
            if (!b)
              return !1;
            Et(Qt);
          }, 10), window.addEventListener("resize", v.value, !1);
        },
        unregisterResizeHandler: () => {
          v.value && (window.removeEventListener("resize", v.value, !1), v.value = null);
        },
        notifyVisibleChange: (Et) => {
          s.onVisibleChange(Et);
        },
        registerScrollHandler: (Et) => {
          S && Q.unregisterScrollHandler(), S = lodashExports.throttle((Qt) => {
            if (!b)
              return !1;
            const un = Q.getTriggerNode();
            if (Qt.target.contains(un)) {
              const dn = {
                x: Qt.target.scrollLeft,
                y: Qt.target.scrollTop
              };
              Et(dn);
            }
          }, 10), window.addEventListener("scroll", S, !0);
        },
        unregisterScrollHandler: () => {
          S && (window.removeEventListener("scroll", S, !0), S = null);
        },
        canMotion: () => !!s.motion,
        updateContainerPosition: () => {
          const Et = E();
          Et && isElement$1(Et) && (P = window.getComputedStyle(Et).getPropertyValue("position"));
        },
        getContainerPosition: () => P,
        getContainer: () => m.value,
        getTriggerNode: () => {
          let Et = c.value;
          return isElement$1(c.value) || (Et = c.value), Et;
        },
        getFocusableElements: (Et) => getFocusableElements(Et),
        getActiveElement: () => getActiveElement(),
        setInitialFocus: () => {
          const {
            preventScroll: Et
          } = s, Qt = g.value;
          Qt && "focus" in Qt && Qt.focus({
            preventScroll: Et
          });
        },
        notifyEscKeydown: (Et) => {
          s.onEscKeyDown(Et);
        },
        setId: () => {
          N.id = getUuidShort();
        },
        getTriggerDOM: () => c.value ? c.value : null
      };
    }
    const ue = new Tooltip$2(Q);
    onMounted(() => {
      b = !0, E = s.getPopupContainer || z.value.getPopupContainer || defaultGetContainer, ue.init(), runAfterTicks(() => {
        let Et = c.value;
        Et && (Et instanceof HTMLElement || (Et = Et.$el)), ue.updateStateIfCursorOnTrigger(Et);
      }, 1);
    }), onUnmounted(() => {
      b = !1, ue.destroy();
    });
    function te() {
      ue.focusTrigger();
    }
    const K = (Et) => {
      if (isElement$1(Et))
        return !!Et.disabled;
      if (isVNode(Et)) {
        if (lodashExports.get(Et, "props.disabled"))
          return strings$q.STATUS_DISABLED;
        const un = lodashExports.get(Et, "props.loading"), gn = !lodashExports.isEmpty(Et) && !lodashExports.isEmpty(Et.type) && Et.type.name === "Button" || Et.type.name === "IconButton";
        if (un && gn)
          return strings$q.STATUS_LOADING;
      }
      return !1;
    }, ve = () => {
      s.keepDOM ? ue.setDisplayNone(!0) : ue.removePortal(), ue.unBindEvent();
    };
    function ee() {
      return ue.calcPosition();
    }
    watch([() => s.mouseLeaveDelay, () => s.mouseEnterDelay], () => {
      warning$1(s.mouseLeaveDelay < s.mouseEnterDelay, "[Semi Tooltip] 'mouseLeaveDelay' cannot be less than 'mouseEnterDelay', which may cause the dropdown layer to not be hidden.");
    }), watch(() => s.visible, () => {
      ["hover", "focus"].includes(s.trigger) ? s.visible ? ue.delayShow() : ue.delayHide() : s.visible ? ue.show() : ue.hide();
    }), watch(() => s.rePosKey, () => {
      nextTick(() => {
        ee();
      });
    }, {});
    const Re = () => {
      const {
        placement: Et
      } = N, {
        showArrow: Qt,
        prefixCls: un,
        style: gn
      } = s;
      let dn = null;
      const yn = cls([`${un}-icon-arrow`]), vn = lodashExports.get(gn, "backgroundColor"), Pn = Et != null && Et.includes("left") || Et != null && Et.includes("right") ? createVNode(TriangleArrowVertical, null, null) : createVNode(TriangleArrow, null, null);
      return Qt && (isVNode(Qt) ? dn = Qt : dn = cloneVNode(Pn, {
        class: yn,
        style: {
          color: vn,
          fill: "currentColor"
        }
      })), dn;
    }, wt = (Et) => {
      s.clickToHide && ue.hide(), s.stopPropagation && stopPropagation(Et);
    }, yt = (Et) => {
      s.stopPropagation && stopPropagation(Et);
    }, xt = (Et) => {
      s.stopPropagation && stopPropagation(Et);
    }, Kt = (Et) => {
      s.stopPropagation && stopPropagation(Et);
    }, tn = (Et) => {
      ue.handleContainerKeydown(Et);
    }, ln = (Et) => {
      const Qt = {
        initialFocusRef: g
      };
      return lodashExports.isFunction(Et) ? Et(Qt) : Et;
    }, rn = () => {
      const {
        containerStyle: Et = {},
        visible: Qt,
        portalEventSet: un,
        placement: gn,
        displayNone: dn,
        transitionState: yn,
        id: vn,
        isPositionUpdated: Pn
      } = N, {
        prefixCls: On,
        content: _n,
        showArrow: Nn,
        style: Un,
        motion: Xn,
        role: zn,
        zIndex: jn
      } = s, kn = ln(_n), {
        className: Yn
      } = s, Zn = z.value.direction, er = cls(Yn, {
        [`${On}-wrapper`]: !0,
        [`${On}-wrapper-show`]: Qt,
        [`${On}-with-arrow`]: !!Nn,
        [`${On}-rtl`]: Zn === "rtl"
      }), bn = Re();
      let Ln = lodashExports.omit(Et, Xn ? ["transformOrigin"] : void 0);
      const Kn = lodashExports.get(Et, "transformOrigin"), Bn = lodashExports.get(Un, "opacity", null), Fn = Bn || 1;
      Ln = {
        ...Ln,
        left: Ln.left + "px",
        top: Ln.top + "px"
      };
      const Gn = createVNode(CSSAnimation, {
        fillMode: "forwards",
        animationState: yn,
        motion: Xn && Pn,
        startClassName: yn === "enter" ? `${prefix$5}-animation-show` : `${prefix$5}-animation-hide`,
        onAnimationEnd: () => {
          var Wn;
          yn === "leave" && (ve(), (Wn = s.afterClose) == null || Wn.call(s));
        },
        children: ({
          animationStyle: Wn,
          animationClassName: Mn,
          animationEventsNeedBind: Tn
        }) => createVNode("div", mergeProps$1({
          class: cls(er, Mn),
          style: {
            ...Wn,
            ...dn ? {
              display: "none"
            } : {},
            transformOrigin: Kn,
            ...Un,
            ...Bn ? {
              opacity: Pn ? Fn : "0"
            } : {}
          }
        }, un, Tn, {
          role: zn,
          "x-placement": gn,
          id: vn
        }), [createVNode("div", {
          class: `${prefix$5}-content`
        }, [kn]), bn])
      }, null);
      return createVNode(Index$9, {
        getPopupContainer: s.getPopupContainer,
        style: {
          zIndex: jn
        }
      }, {
        default: () => [createVNode("div", {
          tabindex: -1,
          class: `${BASE_CLASS_PREFIX$1}-portal-inner`,
          style: Ln,
          ref: m,
          onClick: wt,
          onFocus: xt,
          onBlur: Kt,
          onMousedown: yt,
          onKeydown: tn
        }, [Gn])]
      });
    }, an = (Et) => {
      const {
        wrapperClassName: Qt
      } = s, un = lodashExports.get(Et, "props.style.display"), gn = lodashExports.get(Et, "props.block"), dn = typeof Et == "string", yn = {};
      return dn || (yn.display = "inline-block"), (gn || blockDisplays.includes(un)) && (yn.width = "100%"), createVNode("span", {
        class: Qt,
        style: yn
      }, [Et]);
    }, Gt = (Et, Qt) => {
      const un = {};
      return lodashExports.each(Qt, (gn, dn) => {
        typeof gn == "function" && (un[dn] = (...yn) => {
          gn(...yn), Et && typeof Et[dn] == "function" && Et[dn](...yn);
        });
      }), un;
    }, nn = () => N.id, vt = getCurrentInstance();
    return o({
      getPopupId: nn,
      focusTrigger: te,
      // 当组件内部使用了expose时，使用ref得到的内容只有expose的那部分
      getRef() {
        return vt;
      }
    }), () => {
      var On;
      const {
        wrapWhenSpecial: Et,
        role: Qt,
        trigger: un
      } = s;
      let gn = getMultinodeToFragment(l);
      const dn = {
        ...lodashExports.get(gn, "props.style")
      }, yn = {};
      if (Et) {
        const _n = K(gn);
        _n ? (dn.pointerEvents = "none", _n === strings$q.STATUS_DISABLED && (yn.cursor = "not-allowed"), gn = cloneVNode(gn, {
          style: dn
        }), un !== "custom" && (gn = an(gn))) : isVNodeTypeNotSymbol(gn) || (gn = an(gn));
      }
      let vn = {};
      Qt === "dialog" ? (vn["aria-expanded"] = N.visible ? "true" : "false", vn["aria-haspopup"] = "dialog", vn["aria-controls"] = N.id) : vn["aria-describedby"] = N.id;
      const Pn = cloneVNode(gn, {
        ...vn,
        ...gn.props,
        ...Gt(gn.props, N.triggerEventSet),
        style: {
          ...lodashExports.get(gn, "props.style"),
          ...yn
        },
        class: cls(
          lodashExports.get(gn, "props.class")
          // `${prefixCls}-trigger`
        ),
        // to maintain refs with callback
        ref: (_n) => {
          c.value = _n && (_n.content || _n.$el || _n);
          const {
            ref: Nn
          } = gn;
          Nn && (typeof Nn.r == "function" ? Nn.r(_n) : Nn.r && typeof Nn.r == "object" && isRef(Nn.r) && (Nn.r.value = _n));
        },
        tabIndex: ((On = gn.props) == null ? void 0 : On.tabIndex) || 0,
        // a11y keyboard, in some condition select's tabindex need to -1 or 0
        "data-popupid": N.id
      });
      return createVNode(Fragment, null, [N.isInsert ? rn() : null, Pn]);
    };
  }
}), Tooltip$1 = Tooltip;
class DropdownFoundation extends BaseFoundation$1 {
  handleVisibleChange(o) {
    this._adapter.setPopVisible(o), this._adapter.notifyVisibleChange(o);
    const { trigger: l } = this.getProps();
    if (o && l === "click") {
      const u = this._adapter.getPopupId();
      this.setFocusToFirstMenuItem(u);
    }
  }
  getMenuItemNodes(o) {
    const l = document.getElementById(o);
    return l ? Array.from(l.getElementsByTagName("li")).filter((u) => u.ariaDisabled === "false") : null;
  }
  setFocusToFirstMenuItem(o) {
    const l = this.getMenuItemNodes(o);
    l && setFocusToFirstItem(l);
  }
  setFocusToLastMenuItem(o) {
    const l = this.getMenuItemNodes(o);
    l && setFocusToLastItem(l);
  }
  handleKeyDown(o) {
    var c, m;
    const l = (m = (c = o.target) == null ? void 0 : c.attributes["data-popupid"]) == null ? void 0 : m.value, { visible: u } = this._adapter.getStates();
    switch (o.key) {
      case " ":
      case "Enter":
        o.target.click();
        break;
      case "ArrowDown":
        this.setFocusToFirstMenuItem(l), u && handlePrevent(o);
        break;
      case "ArrowUp":
        this.setFocusToLastMenuItem(l), u && handlePrevent(o);
        break;
    }
  }
}
const prefixCls$W = cssClasses$V.PREFIX, vuePropsType$3b = {
  style: Object,
  className: String
}, DropdownMenu = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3b
  },
  name: "DropdownMenu",
  setup(s, {
    slots: o
  }) {
    const {
      className: l,
      style: u,
      ...c
    } = s;
    return () => createVNode("ul", mergeProps$1(c, {
      class: cls(`${prefixCls$W}-menu`, l),
      style: u
    }), [o.default ? o.default() : null]);
  }
}), DropdownMenu$1 = DropdownMenu, BASE_CLASS_PREFIX = "semi", vuePropsType$3a = {
  size: String,
  spin: Boolean,
  rotate: Number,
  prefixCls: String,
  type: String,
  className: String,
  style: Object,
  svg: Object,
  onClick: Function,
  role: String,
  tabIndex: Number,
  onKeypress: Function
}, Icon = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => {
  const {
    svg: l,
    spin: u = !1,
    rotate: c,
    style: m,
    className: g,
    prefixCls: v = BASE_CLASS_PREFIX,
    type: b,
    size: S = "default",
    ...E
  } = s, P = cls(`${v}-icon`, {
    [`${v}-icon-extra-small`]: S === "extra-small",
    // 8x8
    [`${v}-icon-small`]: S === "small",
    // 12x12
    [`${v}-icon-default`]: S === "default",
    // 16x16
    [`${v}-icon-large`]: S === "large",
    // 20x20
    [`${v}-icon-extra-large`]: S === "extra-large",
    // 24x24
    [`${v}-icon-spinning`]: u,
    [`${v}-icon-${b}`]: !!b
  }, g), T = {};
  return Number.isSafeInteger(c) && (T.transform = `rotate(${c}deg)`), Object.assign(T, m), createVNode("span", mergeProps$1({
    role: "img",
    ref: ref$1,
    class: P,
    style: T
  }, E), [o.default ? o.default() : l]);
}, {
  props: vuePropsType$3a,
  name: "Icon"
}), ConvertIcon = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => (onActivated(() => {
}), () => {
  const l = {};
  return Object.keys(s).forEach((u) => {
    s[u] && (l[u] = s[u]);
  }), createVNode(Icon, mergeProps$1({
    type: s.iconType,
    ref: ref$1
  }, l), {
    default: () => o.default ? o.default() : null
  });
}), {
  props: {
    ...vuePropsType$3a,
    svg: Object,
    iconType: String
  },
  name: "ConvertIcon"
}), SvgComponent$K = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M23 12C23 18.0751 18.0751 23 12 23C5.92487 23 1 18.0751 1 12C1 5.92487 5.92487 1 12 1C18.0751 1 23 5.92487 23 12ZM13.5 17.5C13.5 16.6716 12.8284 16 12 16C11.1716 16 10.5 16.6716 10.5 17.5C10.5 18.3284 11.1716 19 12 19C12.8284 19 13.5 18.3284 13.5 17.5ZM12 5C10.9138 5 10.0507 5.91244 10.1109 6.99692L10.4168 12.5023C10.4635 13.3426 11.1584 14 12 14C12.8416 14 13.5365 13.3426 13.5832 12.5023L13.8891 6.99692C13.9493 5.91244 13.0862 5 12 5Z",
  fill: "currentColor"
}, null)])), IconComponent$K = /* @__PURE__ */ defineComponent({
  name: "IconAlertCircle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "alert_circle"
    }, s), {
      default: () => createVNode(SvgComponent$K, null, null)
    });
  }
});
IconComponent$K.props = vuePropsType$3a;
const SvgComponent$J = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M10.2268 2.3986L1.52616 19.0749C0.831449 20.4064 1.79747 22 3.29933 22H20.7007C22.2025 22 23.1686 20.4064 22.4739 19.0749L13.7732 2.3986C13.0254 0.965441 10.9746 0.965442 10.2268 2.3986ZM13.1415 14.0101C13.0603 14.5781 12.5739 15 12.0001 15C11.4263 15 10.9398 14.5781 10.8586 14.0101L10.2829 9.97992C10.1336 8.93495 10.9445 8.00002 12.0001 8.00002C13.0556 8.00002 13.8665 8.93495 13.7172 9.97992L13.1415 14.0101ZM13.5001 18.5C13.5001 19.3284 12.8285 20 12.0001 20C11.1716 20 10.5001 19.3284 10.5001 18.5C10.5001 17.6716 11.1716 17 12.0001 17C12.8285 17 13.5001 17.6716 13.5001 18.5Z",
  fill: "currentColor"
}, null)])), IconComponent$J = /* @__PURE__ */ defineComponent({
  name: "IconAlertTriangle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "alert_triangle"
    }, s), {
      default: () => createVNode(SvgComponent$J, null, null)
    });
  }
});
IconComponent$J.props = vuePropsType$3a;
const SvgComponent$I = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M23 12C23 12.8284 22.3284 13.5 21.5 13.5L6.12132 13.5L12.5607 19.9393C13.1464 20.5251 13.1464 21.4749 12.5607 22.0607C11.9749 22.6464 11.0251 22.6464 10.4393 22.0607L1.43934 13.0607C0.853554 12.4749 0.853554 11.5251 1.43934 10.9393L10.4393 1.93934C11.0251 1.35355 11.9749 1.35355 12.5607 1.93934C13.1464 2.52513 13.1464 3.47487 12.5607 4.06066L6.12132 10.5L21.5 10.5C22.3284 10.5 23 11.1716 23 12Z",
  fill: "currentColor"
}, null)])), IconComponent$I = /* @__PURE__ */ defineComponent({
  name: "IconArrowLeft",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "arrow_left"
    }, s), {
      default: () => createVNode(SvgComponent$I, null, null)
    });
  }
});
IconComponent$I.props = vuePropsType$3a;
const SvgComponent$H = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M1 12C1 11.1716 1.67157 10.5 2.5 10.5L17.8787 10.5L11.4393 4.06066C10.8536 3.47487 10.8536 2.52513 11.4393 1.93934C12.0251 1.35355 12.9749 1.35355 13.5607 1.93934L22.5607 10.9393C23.1464 11.5251 23.1464 12.4749 22.5607 13.0607L13.5607 22.0607C12.9749 22.6464 12.0251 22.6464 11.4393 22.0607C10.8536 21.4749 10.8536 20.5251 11.4393 19.9393L17.8787 13.5L2.5 13.5C1.67157 13.5 1 12.8284 1 12Z",
  fill: "currentColor"
}, null)])), IconComponent$H = /* @__PURE__ */ defineComponent({
  name: "IconArrowRight",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "arrow_right"
    }, s), {
      default: () => createVNode(SvgComponent$H, null, null)
    });
  }
});
IconComponent$H.props = vuePropsType$3a;
const SvgComponent$G = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M4 20V8H20V20H4ZM2 4C2 2.89543 2.89543 2 4 2H20C21.1046 2 22 2.89543 22 4V20C22 21.1046 21.1046 22 20 22H4C2.89543 22 2 21.1046 2 20V4ZM6 10.5C6 10.2239 6.22386 10 6.5 10H8.5C8.77614 10 9 10.2239 9 10.5V12.5C9 12.7761 8.77614 13 8.5 13H6.5C6.22386 13 6 12.7761 6 12.5V10.5ZM6.5 15C6.22386 15 6 15.2239 6 15.5V17.5C6 17.7761 6.22386 18 6.5 18H8.5C8.77614 18 9 17.7761 9 17.5V15.5C9 15.2239 8.77614 15 8.5 15H6.5ZM10.5 10.5C10.5 10.2239 10.7239 10 11 10H13C13.2761 10 13.5 10.2239 13.5 10.5V12.5C13.5 12.7761 13.2761 13 13 13H11C10.7239 13 10.5 12.7761 10.5 12.5V10.5ZM11 15C10.7239 15 10.5 15.2239 10.5 15.5V17.5C10.5 17.7761 10.7239 18 11 18H13C13.2761 18 13.5 17.7761 13.5 17.5V15.5C13.5 15.2239 13.2761 15 13 15H11ZM15 10.5C15 10.2239 15.2239 10 15.5 10H17.5C17.7761 10 18 10.2239 18 10.5V12.5C18 12.7761 17.7761 13 17.5 13H15.5C15.2239 13 15 12.7761 15 12.5V10.5ZM15.5 15C15.2239 15 15 15.2239 15 15.5V17.5C15 17.7761 15.2239 18 15.5 18H17.5C17.7761 18 18 17.7761 18 17.5V15.5C18 15.2239 17.7761 15 17.5 15H15.5Z",
  fill: "currentColor"
}, null)])), IconComponent$G = /* @__PURE__ */ defineComponent({
  name: "IconCalendar",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "calendar"
    }, s), {
      default: () => createVNode(SvgComponent$G, null, null)
    });
  }
});
IconComponent$G.props = vuePropsType$3a;
const SvgComponent$F = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M2 5V19C2 20.6569 3.34315 22 5 22H12.101C11.5151 21.4259 11.0297 20.7496 10.6736 20H6C4.89543 20 4 19.1046 4 18V8C4 7.44772 4.44772 7 5 7H19C19.5523 7 20 7.44772 20 8V10.6736C20.7496 11.0297 21.4259 11.5151 22 12.101V5C22 3.34315 20.6569 2 19 2H5C3.34315 2 2 3.34315 2 5Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M16 10H17C16.4614 10 15.9369 10.0608 15.4332 10.176C15.5943 10.065 15.7896 10 16 10Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M13.4981 10.9376C13.4659 10.4144 13.0313 10 12.5 10H11.5C10.9477 10 10.5 10.4477 10.5 11V12C10.5 12.4742 10.83 12.8712 11.2729 12.9741C11.857 12.1446 12.6168 11.4478 13.4981 10.9376Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M7 10C6.44772 10 6 10.4477 6 11V12C6 12.5523 6.44772 13 7 13H8C8.55228 13 9 12.5523 9 12V11C9 10.4477 8.55228 10 8 10H7Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M6 16C6 15.4477 6.44772 15 7 15H8C8.55228 15 9 15.4477 9 16V17C9 17.5523 8.55228 18 8 18H7C6.44772 18 6 17.5523 6 17V16Z",
  fill: "currentColor"
}, null), createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M22 17C22 19.7614 19.7614 22 17 22C14.2386 22 12 19.7614 12 17C12 14.2386 14.2386 12 17 12C19.7614 12 22 14.2386 22 17ZM18 15C18 14.4477 17.5523 14 17 14C16.4477 14 16 14.4477 16 15V17C16 17.2652 16.1054 17.5196 16.2929 17.7071L17.7929 19.2071C18.1834 19.5976 18.8166 19.5976 19.2071 19.2071C19.5976 18.8166 19.5976 18.1834 19.2071 17.7929L18 16.5858V15Z",
  fill: "currentColor"
}, null)])), IconComponent$F = /* @__PURE__ */ defineComponent({
  name: "IconCalendarClock",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "calendar_clock"
    }, s), {
      default: () => createVNode(SvgComponent$F, null, null)
    });
  }
});
IconComponent$F.props = vuePropsType$3a;
const SvgComponent$E = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M17.549 15.659L12.753 21.139C12.6591 21.2464 12.5434 21.3325 12.4135 21.3915C12.2836 21.4505 12.1427 21.481 12 21.481C11.8574 21.481 11.7164 21.4505 11.5865 21.3915C11.4566 21.3325 11.3409 21.2464 11.247 21.139L6.45101 15.659C5.88501 15.011 6.34501 14 7.20401 14H16.796C17.656 14 18.115 15.012 17.549 15.659Z",
  fill: "currentColor"
}, null)])), IconComponent$E = /* @__PURE__ */ defineComponent({
  name: "IconCaretdown",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "caretdown"
    }, s), {
      default: () => createVNode(SvgComponent$E, null, null)
    });
  }
});
IconComponent$E.props = vuePropsType$3a;
const SvgComponent$D = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M6.45096 8.34102L11.247 2.86102C11.3408 2.75361 11.4566 2.66753 11.5865 2.60854C11.7163 2.54956 11.8573 2.51904 12 2.51904C12.1426 2.51904 12.2836 2.54956 12.4135 2.60854C12.5433 2.66753 12.6591 2.75361 12.753 2.86102L17.549 8.34102C18.115 8.98802 17.655 10 16.796 10H7.20396C6.34396 10 5.88496 8.98802 6.45096 8.34102Z",
  fill: "currentColor"
}, null)])), IconComponent$D = /* @__PURE__ */ defineComponent({
  name: "IconCaretup",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "caretup"
    }, s), {
      default: () => createVNode(SvgComponent$D, null, null)
    });
  }
});
IconComponent$D.props = vuePropsType$3a;
const SvgComponent$C = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M5 12.5C5 11.6716 5.67157 11 6.5 11H17.5C18.3284 11 19 11.6716 19 12.5C19 13.3284 18.3284 14 17.5 14H6.5C5.67157 14 5 13.3284 5 12.5Z",
  fill: "currentColor"
}, null)])), IconComponent$C = /* @__PURE__ */ defineComponent({
  name: "IconCheckboxIndeterminate",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "checkbox_indeterminate"
    }, s), {
      default: () => createVNode(SvgComponent$C, null, null)
    });
  }
});
IconComponent$C.props = vuePropsType$3a;
const SvgComponent$B = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M17.4111 7.30848C18.0692 7.81171 18.1947 8.75312 17.6915 9.41119L11.1915 17.9112C10.909 18.2806 10.4711 18.4981 10.0061 18.5C9.54105 18.5019 9.10143 18.288 8.81592 17.9209L5.31592 13.4209C4.80731 12.767 4.92512 11.8246 5.57904 11.316C6.23296 10.8074 7.17537 10.9252 7.68398 11.5791L9.98988 14.5438L15.3084 7.58884C15.8116 6.93077 16.7531 6.80525 17.4111 7.30848Z",
  fill: "currentColor"
}, null)])), IconComponent$B = /* @__PURE__ */ defineComponent({
  name: "IconCheckboxTick",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "checkbox_tick"
    }, s), {
      default: () => createVNode(SvgComponent$B, null, null)
    });
  }
});
IconComponent$B.props = vuePropsType$3a;
const SvgComponent$A = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M4.08045 7.59809C4.66624 7.01231 5.61599 7.01231 6.20177 7.59809L11.8586 13.2549L17.5155 7.59809C18.1013 7.01231 19.051 7.01231 19.6368 7.59809C20.2226 8.18388 20.2226 9.13363 19.6368 9.71941L12.9193 16.4369C12.3335 17.0227 11.3838 17.0227 10.798 16.4369L4.08045 9.71941C3.49467 9.13363 3.49467 8.18388 4.08045 7.59809Z",
  fill: "currentColor"
}, null)])), IconComponent$A = /* @__PURE__ */ defineComponent({
  name: "IconChevronDown",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "chevron_down"
    }, s), {
      default: () => createVNode(SvgComponent$A, null, null)
    });
  }
});
IconComponent$A.props = vuePropsType$3a;
const SvgComponent$z = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M16.2782 4.23933C16.864 4.82511 16.864 5.77486 16.2782 6.36065L10.6213 12.0175L16.2782 17.6744C16.864 18.2601 16.864 19.2099 16.2782 19.7957C15.6924 20.3815 14.7426 20.3815 14.1569 19.7957L7.43934 13.0782C6.85355 12.4924 6.85355 11.5426 7.43934 10.9568L14.1569 4.23933C14.7426 3.65354 15.6924 3.65354 16.2782 4.23933Z",
  fill: "currentColor"
}, null)])), IconComponent$z = /* @__PURE__ */ defineComponent({
  name: "IconChevronLeft",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "chevron_left"
    }, s), {
      default: () => createVNode(SvgComponent$z, null, null)
    });
  }
});
IconComponent$z.props = vuePropsType$3a;
const SvgComponent$y = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M7.43934 19.7957C6.85355 19.2099 6.85355 18.2601 7.43934 17.6744L13.0962 12.0175L7.43934 6.36065C6.85355 5.77486 6.85355 4.82511 7.43934 4.23933C8.02513 3.65354 8.97487 3.65354 9.56066 4.23933L16.2782 10.9568C16.864 11.5426 16.864 12.4924 16.2782 13.0782L9.56066 19.7957C8.97487 20.3815 8.02513 20.3815 7.43934 19.7957Z",
  fill: "currentColor"
}, null)])), IconComponent$y = /* @__PURE__ */ defineComponent({
  name: "IconChevronRight",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "chevron_right"
    }, s), {
      default: () => createVNode(SvgComponent$y, null, null)
    });
  }
});
IconComponent$y.props = vuePropsType$3a;
const SvgComponent$x = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M19.637 16.4369C19.0513 17.0227 18.1015 17.0227 17.5157 16.4369L11.8589 10.7801L6.20202 16.4369C5.61623 17.0227 4.66648 17.0227 4.0807 16.4369C3.49491 15.8511 3.49491 14.9014 4.0807 14.3156L10.7982 7.59809C11.384 7.01231 12.3337 7.01231 12.9195 7.59809L19.637 14.3156C20.2228 14.9014 20.2228 15.8511 19.637 16.4369Z",
  fill: "currentColor"
}, null)])), IconComponent$x = /* @__PURE__ */ defineComponent({
  name: "IconChevronUp",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "chevron_up"
    }, s), {
      default: () => createVNode(SvgComponent$x, null, null)
    });
  }
});
IconComponent$x.props = vuePropsType$3a;
const SvgComponent$w = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM17.0352 16.8626C16.4597 17.4585 15.5101 17.4751 14.9142 16.8996L12.0368 14.121L9.25822 16.9984C8.68274 17.5943 7.73314 17.6109 7.13722 17.0354C6.5413 16.4599 6.52472 15.5103 7.1002 14.9144L9.87883 12.037L7.00147 9.2584C6.40555 8.68293 6.38897 7.73332 6.96445 7.1374C7.53992 6.54148 8.48953 6.52491 9.08545 7.10038L11.9628 9.87901L14.7414 7.00165C15.3169 6.40573 16.2665 6.38916 16.8624 6.96463C17.4584 7.54011 17.4749 8.48971 16.8995 9.08563L14.1208 11.963L16.9982 14.7416C17.5941 15.3171 17.6107 16.2667 17.0352 16.8626Z",
  fill: "currentColor"
}, null)])), IconComponent$w = /* @__PURE__ */ defineComponent({
  name: "IconClear",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "clear"
    }, s), {
      default: () => createVNode(SvgComponent$w, null, null)
    });
  }
});
IconComponent$w.props = vuePropsType$3a;
const SvgComponent$v = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM13.5 6.5V11.3787L17.0607 14.9393C17.6464 15.5251 17.6464 16.4749 17.0607 17.0607C16.4749 17.6464 15.5251 17.6464 14.9393 17.0607L10.9393 13.0607C10.658 12.7794 10.5 12.3978 10.5 12V6.5C10.5 5.67157 11.1716 5 12 5C12.8284 5 13.5 5.67157 13.5 6.5Z",
  fill: "currentColor"
}, null)])), IconComponent$v = /* @__PURE__ */ defineComponent({
  name: "IconClock",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "clock"
    }, s), {
      default: () => createVNode(SvgComponent$v, null, null)
    });
  }
});
IconComponent$v.props = vuePropsType$3a;
const SvgComponent$u = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M17.6568 19.7782C18.2426 20.3639 19.1924 20.3639 19.7782 19.7782C20.3639 19.1924 20.3639 18.2426 19.7782 17.6568L14.1213 12L19.7782 6.34313C20.3639 5.75734 20.3639 4.8076 19.7782 4.22181C19.1924 3.63602 18.2426 3.63602 17.6568 4.22181L12 9.87866L6.34313 4.22181C5.75734 3.63602 4.8076 3.63602 4.22181 4.22181C3.63602 4.8076 3.63602 5.75734 4.22181 6.34313L9.87866 12L4.22181 17.6568C3.63602 18.2426 3.63602 19.1924 4.22181 19.7782C4.8076 20.3639 5.75734 20.3639 6.34313 19.7782L12 14.1213L17.6568 19.7782Z",
  fill: "currentColor"
}, null)])), IconComponent$u = /* @__PURE__ */ defineComponent({
  name: "IconClose",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "close"
    }, s), {
      default: () => createVNode(SvgComponent$u, null, null)
    });
  }
});
IconComponent$u.props = vuePropsType$3a;
const SvgComponent$t = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M7 4C7 2.89543 7.89543 2 9 2H20C21.1046 2 22 2.89543 22 4V15C22 16.1046 21.1046 17 20 17H19V8C19 6 18 5 16 5H7V4Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M5 7C3.89543 7 3 7.89543 3 9V19C3 20.1046 3.89543 21 5 21H15C16.1046 21 17 20.1046 17 19V9C17 7.89543 16.1046 7 15 7H5Z",
  fill: "currentColor"
}, null)])), IconComponent$t = /* @__PURE__ */ defineComponent({
  name: "IconCopy",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "copy"
    }, s), {
      default: () => createVNode(SvgComponent$t, null, null)
    });
  }
});
IconComponent$t.props = vuePropsType$3a;
const SvgComponent$s = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12.6185 4.39653C13.1272 4.92524 13.1272 5.78245 12.6185 6.31116L7.14483 12L12.6185 17.6888C13.1272 18.2176 13.1272 19.0748 12.6185 19.6035C12.1098 20.1322 11.285 20.1322 10.7763 19.6035L4.38153 12.9573C3.87282 12.4286 3.87282 11.5714 4.38153 11.0427L10.7763 4.39653C11.285 3.86782 12.1098 3.86782 12.6185 4.39653Z",
  fill: "currentColor"
}, null), createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M19.6185 4.39653C20.1272 4.92524 20.1272 5.78245 19.6185 6.31116L14.1448 12L19.6185 17.6888C20.1272 18.2176 20.1272 19.0748 19.6185 19.6035C19.1098 20.1322 18.285 20.1322 17.7763 19.6035L11.3815 12.9573C10.8728 12.4286 10.8728 11.5714 11.3815 11.0427L17.7763 4.39653C18.285 3.86782 19.1098 3.86782 19.6185 4.39653Z",
  fill: "currentColor"
}, null)])), IconComponent$s = /* @__PURE__ */ defineComponent({
  name: "IconDoubleChevronLeft",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "double_chevron_left"
    }, s), {
      default: () => createVNode(SvgComponent$s, null, null)
    });
  }
});
IconComponent$s.props = vuePropsType$3a;
const SvgComponent$r = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M4.38153 4.39653C4.89024 3.86782 5.71502 3.86782 6.22373 4.39653L12.6185 11.0427C13.1272 11.5714 13.1272 12.4286 12.6185 12.9573L6.22373 19.6035C5.71502 20.1322 4.89024 20.1322 4.38153 19.6035C3.87282 19.0748 3.87282 18.2176 4.38153 17.6888L9.85517 12L4.38153 6.31116C3.87282 5.78245 3.87282 4.92524 4.38153 4.39653Z",
  fill: "currentColor"
}, null), createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M11.3815 4.39653C11.8902 3.86782 12.715 3.86782 13.2237 4.39653L19.6185 11.0427C20.1272 11.5714 20.1272 12.4286 19.6185 12.9573L13.2237 19.6035C12.715 20.1322 11.8902 20.1322 11.3815 19.6035C10.8728 19.0748 10.8728 18.2176 11.3815 17.6888L16.8552 12L11.3815 6.31116C10.8728 5.78245 10.8728 4.92524 11.3815 4.39653Z",
  fill: "currentColor"
}, null)])), IconComponent$r = /* @__PURE__ */ defineComponent({
  name: "IconDoubleChevronRight",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "double_chevron_right"
    }, s), {
      default: () => createVNode(SvgComponent$r, null, null)
    });
  }
});
IconComponent$r.props = vuePropsType$3a;
const SvgComponent$q = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M17.8395 8.05827C17.1837 5.16226 14.5944 3 11.5 3C7.91015 3 5 5.91015 5 9.5C5 10.0204 5.06115 10.5264 5.17665 11.0114C2.84229 11.1772 1 13.1234 1 15.5C1 17.9853 3.01469 20 5.49995 20H17C20.3137 20 23 17.3137 23 14C23 10.9712 20.7558 8.46659 17.8395 8.05827ZM11.6799 17.7333C11.8653 17.8878 12.1347 17.8878 12.3201 17.7333L17.4695 13.4421C17.6492 13.2924 17.5433 13 17.3095 13H14V9.5C14 9.22386 13.7761 9 13.5 9H10.5C10.2239 9 10 9.22386 10 9.5V13H6.69051C6.45669 13 6.35084 13.2924 6.53047 13.4421L11.6799 17.7333Z",
  fill: "currentColor"
}, null)])), IconComponent$q = /* @__PURE__ */ defineComponent({
  name: "IconDownload",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "download"
    }, s), {
      default: () => createVNode(SvgComponent$q, null, null)
    });
  }
});
IconComponent$q.props = vuePropsType$3a;
const SvgComponent$p = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M21.7071 3.70711C22.0976 3.31658 22.0976 2.68342 21.7071 2.29289C21.3166 1.90237 20.6834 1.90237 20.2929 2.29289L17.3135 5.27233C15.8114 4.50566 14.0321 4 12 4C5 4 1 10 1 12C1 13.1757 2.38219 15.7335 4.94345 17.6423L2.29289 20.2929C1.90237 20.6834 1.90237 21.3166 2.29289 21.7071C2.68342 22.0976 3.31658 22.0976 3.70711 21.7071L21.7071 3.70711ZM7.8284 14.7574L9.29237 13.2934C9.10495 12.9018 9 12.4631 9 12C9 10.3431 10.3431 9 12 9C12.4631 9 12.9018 9.10495 13.2934 9.29237L14.7574 7.8284C13.967 7.30488 13.0191 7 12 7C9.23858 7 7 9.23858 7 12C7 13.0191 7.30488 13.967 7.8284 14.7574Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M12 20C10.7789 20 9.64914 19.8174 8.61594 19.5054L11.1871 16.9342C11.4516 16.9775 11.7232 17 12 17C14.7614 17 17 14.7614 17 12C17 11.7232 16.9775 11.4516 16.9342 11.1871L20.5032 7.61808C22.1342 9.27317 23 11.0695 23 12C23 14 19 20 12 20Z",
  fill: "currentColor"
}, null)])), IconComponent$p = /* @__PURE__ */ defineComponent({
  name: "IconEyeClosedSolid",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "eye_closed_solid"
    }, s), {
      default: () => createVNode(SvgComponent$p, null, null)
    });
  }
});
IconComponent$p.props = vuePropsType$3a;
const SvgComponent$o = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 4C5 4 1 10 1 12C1 14 5 20 12 20C19 20 23 14 23 12C23 10 19 4 12 4ZM17 12C17 14.7614 14.7614 17 12 17C9.23858 17 7 14.7614 7 12C7 9.23858 9.23858 7 12 7C14.7614 7 17 9.23858 17 12ZM12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z",
  fill: "currentColor"
}, null)])), IconComponent$o = /* @__PURE__ */ defineComponent({
  name: "IconEyeOpened",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "eye_opened"
    }, s), {
      default: () => createVNode(SvgComponent$o, null, null)
    });
  }
});
IconComponent$o.props = vuePropsType$3a;
const SvgComponent$n = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 2C12 1.44772 11.5523 1 11 1H6C4.89543 1 4 1.89543 4 3V21C4 22.1046 4.89543 23 6 23H18C19.1046 23 20 22.1046 20 21V10C20 9.44772 19.5523 9 19 9H14C12.8954 9 12 8.10457 12 7V2ZM7 8C7 7.44772 7.44772 7 8 7H9C9.55228 7 10 7.44772 10 8C10 8.55228 9.55228 9 9 9H8C7.44772 9 7 8.55228 7 8ZM7 13C7 12.4477 7.44772 12 8 12H16C16.5523 12 17 12.4477 17 13C17 13.5523 16.5523 14 16 14H8C7.44772 14 7 13.5523 7 13ZM8 17C7.44772 17 7 17.4477 7 18C7 18.5523 7.44772 19 8 19H16C16.5523 19 17 18.5523 17 18C17 17.4477 16.5523 17 16 17H8ZM19.0686 7.49999H14.5C13.9477 7.49999 13.5 7.05228 13.5 6.49999V1.93136C13.5 1.21864 14.3617 0.861707 14.8657 1.36568L19.6343 6.13431C20.1383 6.63828 19.7814 7.49999 19.0686 7.49999Z",
  fill: "currentColor"
}, null)])), IconComponent$n = /* @__PURE__ */ defineComponent({
  name: "IconFile",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "file"
    }, s), {
      default: () => createVNode(SvgComponent$n, null, null)
    });
  }
});
IconComponent$n.props = vuePropsType$3a;
const SvgComponent$m = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M1.0929 2.57912C1.25675 2.22596 1.61069 2 2.00001 2H22C22.3893 2 22.7433 2.22596 22.9071 2.57912C23.071 2.93229 23.015 3.34845 22.7636 3.64573L14.5654 12.8261V21C14.5654 21.3466 14.386 21.6684 14.0911 21.8507C13.7963 22.0329 13.4282 22.0494 13.1182 21.8944L10.0528 19.8944C9.71401 19.725 9.5 19.3788 9.5 19V12.8261L1.23644 3.64573C0.985045 3.34845 0.929036 2.93229 1.0929 2.57912Z",
  fill: "currentColor"
}, null)])), IconComponent$m = /* @__PURE__ */ defineComponent({
  name: "IconFilter",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "filter"
    }, s), {
      default: () => createVNode(SvgComponent$m, null, null)
    });
  }
});
IconComponent$m.props = vuePropsType$3a;
const SvgComponent$l = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M5 2C3.34315 2 2 3.34315 2 5V8H22C22 6 21 4 19 4H12.5523C11.8711 4 11.2102 3.76816 10.6783 3.34261L9.54783 2.43826C9.1932 2.15456 8.75258 2 8.29844 2H5Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M22 10H2V19C2 20.6569 3.34315 22 5 22H19C20.6569 22 22 20.6569 22 19V10Z",
  fill: "currentColor"
}, null)])), IconComponent$l = /* @__PURE__ */ defineComponent({
  name: "IconFolder",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "folder"
    }, s), {
      default: () => createVNode(SvgComponent$l, null, null)
    });
  }
});
IconComponent$l.props = vuePropsType$3a;
const SvgComponent$k = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M2 5C2 3.34315 3.34315 2 5 2H8.29844C8.75258 2 9.1932 2.15456 9.54783 2.43826L10.6783 3.34261C11.2102 3.76816 11.8711 4 12.5523 4H18C20 4 21 6 21 8H7.53361C6.62889 8 5.83683 8.60735 5.6021 9.48109L2.57151 20.7617C2.21202 20.2671 2 19.6583 2 19V5ZM22.1667 10H9.5C8.61111 10 7.82889 10.5867 7.58 11.44L4.87333 20.72C4.68667 21.36 5.16667 22 5.83333 22H18.5C19.3889 22 20.1711 21.4133 20.42 20.56L23.1267 11.28C23.3133 10.64 22.8333 10 22.1667 10Z",
  fill: "currentColor"
}, null)])), IconComponent$k = /* @__PURE__ */ defineComponent({
  name: "IconFolderOpen",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "folder_open"
    }, s), {
      default: () => createVNode(SvgComponent$k, null, null)
    });
  }
});
IconComponent$k.props = vuePropsType$3a;
const SvgComponent$j = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M9 7C10.1046 7 11 6.10457 11 5C11 3.89543 10.1046 3 9 3C7.89543 3 7 3.89543 7 5C7 6.10457 7.89543 7 9 7Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M9 14C10.1046 14 11 13.1046 11 12C11 10.8954 10.1046 10 9 10C7.89543 10 7 10.8954 7 12C7 13.1046 7.89543 14 9 14Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M11 19C11 20.1046 10.1046 21 9 21C7.89543 21 7 20.1046 7 19C7 17.8954 7.89543 17 9 17C10.1046 17 11 17.8954 11 19Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M15 7C16.1046 7 17 6.10457 17 5C17 3.89543 16.1046 3 15 3C13.8954 3 13 3.89543 13 5C13 6.10457 13.8954 7 15 7Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M17 12C17 13.1046 16.1046 14 15 14C13.8954 14 13 13.1046 13 12C13 10.8954 13.8954 10 15 10C16.1046 10 17 10.8954 17 12Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M15 21C16.1046 21 17 20.1046 17 19C17 17.8954 16.1046 17 15 17C13.8954 17 13 17.8954 13 19C13 20.1046 13.8954 21 15 21Z",
  fill: "currentColor"
}, null)])), IconComponent$j = /* @__PURE__ */ defineComponent({
  name: "IconHandle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "handle"
    }, s), {
      default: () => createVNode(SvgComponent$j, null, null)
    });
  }
});
IconComponent$j.props = vuePropsType$3a;
const SvgComponent$i = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM11.8281 14.6094C10.9688 14.6094 10.5391 14.0723 10.5391 13.3691C10.5391 12.3242 11.0566 11.6504 12.2676 10.7324C12.2894 10.7158 12.3111 10.6993 12.3326 10.6829C13.1573 10.0555 13.7324 9.61807 13.7324 8.82812C13.7324 7.93945 12.9023 7.42188 11.9746 7.42188C11.2129 7.42188 10.627 7.70508 10.168 8.30078C9.83594 8.64258 9.57227 8.82812 9.12305 8.82812C8.38086 8.82812 8 8.31055 8 7.71484C8 7.10938 8.3418 6.49414 8.87891 6.02539C9.60156 5.40039 10.7539 5 12.2773 5C14.9922 5 16.8965 6.33789 16.8965 8.64258C16.8965 10.3223 15.8906 11.1328 14.709 11.9531C13.9082 12.5391 13.5273 12.8809 13.2246 13.5742L13.2238 13.5756C12.8922 14.1609 12.638 14.6094 11.8281 14.6094ZM11.8086 18.7695C10.8711 18.7695 10.0996 18.1641 10.0996 17.2266C10.0996 16.2891 10.8711 15.6836 11.8086 15.6836C12.7461 15.6836 13.5078 16.2891 13.5078 17.2266C13.5078 18.1641 12.7461 18.7695 11.8086 18.7695Z",
  fill: "currentColor"
}, null)])), IconComponent$i = /* @__PURE__ */ defineComponent({
  name: "IconHelpCircle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "help_circle"
    }, s), {
      default: () => createVNode(SvgComponent$i, null, null)
    });
  }
});
IconComponent$i.props = vuePropsType$3a;
const SvgComponent$h = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM14 7C14 8.10457 13.1046 9 12 9C10.8954 9 10 8.10457 10 7C10 5.89543 10.8954 5 12 5C13.1046 5 14 5.89543 14 7ZM9 10.75C9 10.3358 9.33579 10 9.75 10H12.5C13.0523 10 13.5 10.4477 13.5 11V16.5H14.25C14.6642 16.5 15 16.8358 15 17.25C15 17.6642 14.6642 18 14.25 18H9.75C9.33579 18 9 17.6642 9 17.25C9 16.8358 9.33579 16.5 9.75 16.5H10.5V11.5H9.75C9.33579 11.5 9 11.1642 9 10.75Z",
  fill: "currentColor"
}, null)])), IconComponent$h = /* @__PURE__ */ defineComponent({
  name: "IconInfoCircle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "info_circle"
    }, s), {
      default: () => createVNode(SvgComponent$h, null, null)
    });
  }
});
IconComponent$h.props = vuePropsType$3a;
const SvgComponent$g = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M2 12C2 11.1716 2.67157 10.5 3.5 10.5H20.5C21.3284 10.5 22 11.1716 22 12C22 12.8284 21.3284 13.5 20.5 13.5H3.5C2.67157 13.5 2 12.8284 2 12Z",
  fill: "currentColor"
}, null)])), IconComponent$g = /* @__PURE__ */ defineComponent({
  name: "IconMinus",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "minus"
    }, s), {
      default: () => createVNode(SvgComponent$g, null, null)
    });
  }
});
IconComponent$g.props = vuePropsType$3a;
const SvgComponent$f = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M7 12C7 13.3807 5.88071 14.5 4.5 14.5C3.11929 14.5 2 13.3807 2 12C2 10.6193 3.11929 9.5 4.5 9.5C5.88071 9.5 7 10.6193 7 12Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M14.5 12C14.5 13.3807 13.3807 14.5 12 14.5C10.6193 14.5 9.5 13.3807 9.5 12C9.5 10.6193 10.6193 9.5 12 9.5C13.3807 9.5 14.5 10.6193 14.5 12Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M19.5 14.5C20.8807 14.5 22 13.3807 22 12C22 10.6193 20.8807 9.5 19.5 9.5C18.1193 9.5 17 10.6193 17 12C17 13.3807 18.1193 14.5 19.5 14.5Z",
  fill: "currentColor"
}, null)])), IconComponent$f = /* @__PURE__ */ defineComponent({
  name: "IconMore",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "more"
    }, s), {
      default: () => createVNode(SvgComponent$f, null, null)
    });
  }
});
IconComponent$f.props = vuePropsType$3a;
const SvgComponent$e = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M20.5 13.5C21.3284 13.5 22 12.8284 22 12C22 11.1716 21.3284 10.5 20.5 10.5L13.5 10.5L13.5 3.5C13.5 2.67157 12.8284 2 12 2C11.1716 2 10.5 2.67157 10.5 3.5L10.5 10.5L3.5 10.5C2.67157 10.5 2 11.1716 2 12C2 12.8284 2.67157 13.5 3.5 13.5L10.5 13.5V20.5C10.5 21.3284 11.1716 22 12 22C12.8284 22 13.5 21.3284 13.5 20.5V13.5L20.5 13.5Z",
  fill: "currentColor"
}, null)])), IconComponent$e = /* @__PURE__ */ defineComponent({
  name: "IconPlus",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "plus"
    }, s), {
      default: () => createVNode(SvgComponent$e, null, null)
    });
  }
});
IconComponent$e.props = vuePropsType$3a;
const SvgComponent$d = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("circle", {
  cx: 12,
  cy: 12,
  r: 5,
  fill: "currentColor"
}, null)])), IconComponent$d = /* @__PURE__ */ defineComponent({
  name: "IconRadio",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "radio"
    }, s), {
      default: () => createVNode(SvgComponent$d, null, null)
    });
  }
});
IconComponent$d.props = vuePropsType$3a;
const SvgComponent$c = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M1 6C1 4.89543 1.89543 4 3 4H21C22.1046 4 23 4.89543 23 6V18C23 19.1046 22.1046 20 21 20H3C1.89543 20 1 19.1046 1 18V6ZM21 6L3 6V18H21V6ZM5 9C5 8.44772 5.44772 8 6 8H7.5C8.05228 8 8.5 8.44772 8.5 9V15C8.5 15.5523 8.05228 16 7.5 16C6.94772 16 6.5 15.5523 6.5 15V10H6C5.44772 10 5 9.55228 5 9ZM16 8C15.4477 8 15 8.44772 15 9C15 9.55228 15.4477 10 16 10H16.5V15C16.5 15.5523 16.9477 16 17.5 16C18.0523 16 18.5 15.5523 18.5 15V9C18.5 8.44772 18.0523 8 17.5 8H16ZM13 10C13 10.5523 12.5523 11 12 11C11.4477 11 11 10.5523 11 10C11 9.44772 11.4477 9 12 9C12.5523 9 13 9.44772 13 10ZM12 15C12.5523 15 13 14.5523 13 14C13 13.4477 12.5523 13 12 13C11.4477 13 11 13.4477 11 14C11 14.5523 11.4477 15 12 15Z",
  fill: "currentColor"
}, null)])), IconComponent$c = /* @__PURE__ */ defineComponent({
  name: "IconRealSizeStroked",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "real_size_stroked"
    }, s), {
      default: () => createVNode(SvgComponent$c, null, null)
    });
  }
});
IconComponent$c.props = vuePropsType$3a;
const SvgComponent$b = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M4.49993 11.9998C4.49993 7.85775 7.85775 4.49993 11.9998 4.49993C14.6403 4.49993 16.9645 5.86506 18.3012 7.9305L16.2939 7.52902C15.4815 7.36656 14.6913 7.89337 14.5288 8.7057C14.3664 9.51803 14.8932 10.3083 15.7055 10.4707L20.7055 11.4707C21.4643 11.6225 22.214 11.1721 22.4363 10.4309L23.9363 5.43095C24.1744 4.63747 23.7241 3.80126 22.9307 3.56321C22.1372 3.32517 21.301 3.77543 21.0629 4.56891L20.6287 6.01635C18.7332 3.28781 15.5765 1.49998 11.9998 1.49998C6.20092 1.49998 1.49998 6.20092 1.49998 11.9998C1.49998 17.7987 6.20092 22.4997 11.9998 22.4997C16.5739 22.4997 20.4611 19.5757 21.9018 15.4996C22.1779 14.7186 21.7685 13.8616 20.9874 13.5855C20.2064 13.3095 19.3494 13.7189 19.0733 14.4999C18.0431 17.4149 15.263 19.4997 11.9998 19.4997C7.85775 19.4997 4.49993 16.1419 4.49993 11.9998Z",
  fill: "currentColor"
}, null)])), IconComponent$b = /* @__PURE__ */ defineComponent({
  name: "IconRefresh",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "refresh"
    }, s), {
      default: () => createVNode(SvgComponent$b, null, null)
    });
  }
});
IconComponent$b.props = vuePropsType$3a;
const SvgComponent$a = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M14.2071 2.20711C14.5976 1.81658 14.5976 1.18342 14.2071 0.792893C13.8166 0.402369 13.1834 0.402369 12.7929 0.792893L10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L12.7929 7.20711C13.1834 7.59763 13.8166 7.59763 14.2071 7.20711C14.5976 6.81658 14.5976 6.18342 14.2071 5.79289L13.4142 5H16C18.7614 5 21 7.23858 21 10V12C21 12.5523 21.4477 13 22 13C22.5523 13 23 12.5523 23 12V10C23 6.13401 19.866 3 16 3H13.4142L14.2071 2.20711Z",
  fill: "currentColor"
}, null), createVNode("path", {
  d: "M3 10C3 8.89543 3.89543 8 5 8H17C18.1046 8 19 8.89543 19 10V20C19 21.1046 18.1046 22 17 22H5C3.89543 22 3 21.1046 3 20V10Z",
  fill: "currentColor"
}, null)])), IconComponent$a = /* @__PURE__ */ defineComponent({
  name: "IconRotate",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "rotate"
    }, s), {
      default: () => createVNode(SvgComponent$a, null, null)
    });
  }
});
IconComponent$a.props = vuePropsType$3a;
const SvgComponent$9 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M10.5 2C5.80558 2 2 5.80558 2 10.5C2 15.1944 5.80558 19 10.5 19C12.3054 19 13.9794 18.4371 15.356 17.4773L19.4393 21.5606C20.0251 22.1464 20.9749 22.1464 21.5606 21.5606C22.1464 20.9749 22.1464 20.0251 21.5606 19.4393L17.4773 15.356C18.4371 13.9794 19 12.3054 19 10.5C19 5.80558 15.1944 2 10.5 2ZM5 10.5C5 7.46243 7.46243 5 10.5 5C13.5376 5 16 7.46243 16 10.5C16 13.5376 13.5376 16 10.5 16C7.46243 16 5 13.5376 5 10.5Z",
  fill: "currentColor"
}, null)])), IconComponent$9 = /* @__PURE__ */ defineComponent({
  name: "IconSearch",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "search"
    }, s), {
      default: () => createVNode(SvgComponent$9, null, null)
    });
  }
});
IconComponent$9.props = vuePropsType$3a;
const SvgComponent$8 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M5 2H19C20.6569 2 22 3.34315 22 5V19C22 20.6569 20.6569 22 19 22H5C3.34315 22 2 20.6569 2 19V5C2 3.34315 3.34315 2 5 2ZM6 4C5.44772 4 5 4.44772 5 5V19C5 19.5523 5.44772 20 6 20H9C9.55229 20 10 19.5523 10 19V5C10 4.44772 9.55229 4 9 4H6Z",
  fill: "currentColor"
}, null)])), IconComponent$8 = /* @__PURE__ */ defineComponent({
  name: "IconSidebar",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "sidebar"
    }, s), {
      default: () => createVNode(SvgComponent$8, null, null)
    });
  }
});
IconComponent$8.props = vuePropsType$3a;
const SvgComponent$7 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M10.7525 1.90411C11.1451 0.698628 12.8549 0.698631 13.2475 1.90411L15.2395 8.01946H21.6858C22.9565 8.01946 23.4848 9.64143 22.4568 10.3865L17.2417 14.1659L19.2337 20.2813C19.6263 21.4868 18.2431 22.4892 17.2151 21.7442L12 17.9647L6.78489 21.7442C5.75687 22.4892 4.37368 21.4868 4.76635 20.2813L6.75834 14.1659L1.54323 10.3865C0.515206 9.64142 1.04354 8.01946 2.31425 8.01946H8.76048L10.7525 1.90411Z",
  fill: "currentColor"
}, null)])), IconComponent$7 = /* @__PURE__ */ defineComponent({
  name: "IconStar",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "star"
    }, s), {
      default: () => createVNode(SvgComponent$7, null, null)
    });
  }
});
IconComponent$7.props = vuePropsType$3a;
const SvgComponent$6 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M21.3516 4.2652C22.0336 4.73552 22.2052 5.66964 21.7348 6.35162L11.7348 20.8516C11.4765 21.2262 11.0622 21.4632 10.6084 21.4961C10.1546 21.529 9.71041 21.3541 9.40082 21.0207L2.90082 14.0207C2.33711 13.4136 2.37226 12.4645 2.97933 11.9008C3.5864 11.3371 4.53549 11.3723 5.0992 11.9793L10.3268 17.6091L19.2652 4.64842C19.7355 3.96644 20.6696 3.79487 21.3516 4.2652Z",
  fill: "currentColor"
}, null)])), IconComponent$6 = /* @__PURE__ */ defineComponent({
  name: "IconTick",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "tick"
    }, s), {
      default: () => createVNode(SvgComponent$6, null, null)
    });
  }
});
IconComponent$6.props = vuePropsType$3a;
const SvgComponent$5 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M12 23C18.0751 23 23 18.0751 23 12C23 5.92487 18.0751 1 12 1C5.92487 1 1 5.92487 1 12C1 18.0751 5.92487 23 12 23ZM17.8831 9.82235L11.6854 17.4112C11.4029 17.7806 10.965 17.9981 10.5 18C10.035 18.0019 9.59533 17.788 9.30982 17.421L5.81604 13.4209C5.30744 12.767 5.42524 11.8246 6.07916 11.316C6.73308 10.8074 7.67549 10.9252 8.1841 11.5791L10.4838 14.0439L15.5 8C16.0032 7.34193 16.9446 7.21641 17.6027 7.71964C18.2608 8.22287 18.3863 9.16428 17.8831 9.82235Z",
  fill: "currentColor"
}, null)])), IconComponent$5 = /* @__PURE__ */ defineComponent({
  name: "IconTickCircle",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "tick_circle"
    }, s), {
      default: () => createVNode(SvgComponent$5, null, null)
    });
  }
});
IconComponent$5.props = vuePropsType$3a;
const SvgComponent$4 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M20.5598 9.65618L12.7546 18.6322C12.3559 19.0906 11.644 19.0906 11.2453 18.6322L3.4401 9.65618C2.8773 9.00895 3.33701 8 4.19471 8L19.8052 8C20.6629 8 21.1226 9.00895 20.5598 9.65618Z",
  fill: "currentColor"
}, null)])), IconComponent$4 = /* @__PURE__ */ defineComponent({
  name: "IconTreeTriangleDown",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "tree_triangle_down"
    }, s), {
      default: () => createVNode(SvgComponent$4, null, null)
    });
  }
});
IconComponent$4.props = vuePropsType$3a;
const SvgComponent$3 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  d: "M9.65618 3.44015L18.6322 11.2454C19.0906 11.644 19.0906 12.356 18.6322 12.7546L9.65618 20.5598C9.00895 21.1226 8 20.6629 8 19.8052V4.19475C8 3.33705 9.00895 2.87734 9.65618 3.44015Z",
  fill: "currentColor"
}, null)])), IconComponent$3 = /* @__PURE__ */ defineComponent({
  name: "IconTreeTriangleRight",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "tree_triangle_right"
    }, s), {
      default: () => createVNode(SvgComponent$3, null, null)
    });
  }
});
IconComponent$3.props = vuePropsType$3a;
const SvgComponent$2 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M17.8395 8.05827C17.1837 5.16226 14.5944 3 11.5 3C7.91015 3 5 5.91015 5 9.5C5 10.0204 5.06115 10.5264 5.17665 11.0114C2.84229 11.1772 1 13.1234 1 15.5C1 17.9853 3.01469 20 5.49995 20H17C20.3137 20 23 17.3137 23 14C23 10.9712 20.7558 8.46659 17.8395 8.05827ZM12.3201 8.26674C12.1347 8.11222 11.8653 8.11222 11.6799 8.26674L6.53047 12.5579C6.35084 12.7076 6.45669 13 6.69051 13H10V17.5C10 17.7761 10.2239 18 10.5 18H13.5C13.7761 18 14 17.7761 14 17.5V13H17.3095C17.5433 13 17.6492 12.7076 17.4695 12.5579L12.3201 8.26674Z",
  fill: "currentColor"
}, null)])), IconComponent$2 = /* @__PURE__ */ defineComponent({
  name: "IconUpload",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "upload"
    }, s), {
      default: () => createVNode(SvgComponent$2, null, null)
    });
  }
});
IconComponent$2.props = vuePropsType$3a;
const SvgComponent$1 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M22.9998 12.0001C22.9998 18.0753 18.0749 23.0001 11.9998 23.0001C5.92463 23.0001 0.999756 18.0753 0.999756 12.0001C0.999756 5.92499 5.92463 1.00012 11.9998 1.00012C18.0749 1.00012 22.9998 5.92499 22.9998 12.0001ZM13.4998 17.5C13.4998 16.6718 12.8282 16.0001 11.9998 16.0001C11.1713 16.0001 10.4998 16.6718 10.4998 17.5C10.4998 18.3285 11.1713 19 11.9998 19C12.8282 19 13.4998 18.3285 13.4998 17.5ZM11.9998 5.00011C10.9136 5.00011 10.0505 5.91257 10.1107 6.99704L10.4166 12.5024C10.4632 13.3427 11.1582 14.0001 11.9998 14.0001C12.8413 14.0001 13.5363 13.3427 13.583 12.5024L13.8888 6.99704C13.9491 5.91257 13.0859 5.00011 11.9998 5.00011Z",
  fill: "currentColor"
}, null)])), IconComponent$1 = /* @__PURE__ */ defineComponent({
  name: "IconUploadError",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "upload_error"
    }, s), {
      default: () => createVNode(SvgComponent$1, null, null)
    });
  }
});
IconComponent$1.props = vuePropsType$3a;
const SvgComponent = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => () => createVNode("svg", mergeProps$1({
  viewBox: "0 0 24 24",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  width: "1em",
  height: "1em",
  focusable: !1,
  "aria-hidden": !0
}, s), [createVNode("path", {
  "fill-rule": "evenodd",
  "clip-rule": "evenodd",
  d: "M14 3C14 2.44772 14.4477 2 15 2H21C21.5523 2 22 2.44772 22 3V9C22 9.55229 21.5523 10 21 10C20.4477 10 20 9.55229 20 9V4H15C14.4477 4 14 3.55229 14 3ZM10 21C10 21.5523 9.55229 22 9 22H3C2.44772 22 2 21.5523 2 21V15C2 14.4477 2.44772 14 3 14C3.55228 14 4 14.4477 4 15L4 20H9C9.55229 20 10 20.4477 10 21ZM2 9C2 9.55228 2.44772 10 3 10C3.55229 10 4 9.55228 4 9L4 4L9 4C9.55229 4 10 3.55228 10 3C10 2.44771 9.55229 2 9 2H3C2.44772 2 2 2.44772 2 3V9ZM21 14C21.5523 14 22 14.4477 22 15V21C22 21.5523 21.5523 22 21 22H15C14.4477 22 14 21.5523 14 21C14 20.4477 14.4477 20 15 20H20V15C20 14.4477 20.4477 14 21 14ZM8.5 7.5C7.94772 7.5 7.5 7.94772 7.5 8.5V15.5C7.5 16.0523 7.94772 16.5 8.5 16.5H15.5C16.0523 16.5 16.5 16.0523 16.5 15.5V8.5C16.5 7.94772 16.0523 7.5 15.5 7.5H8.5ZM9.5 14.5V9.5H14.5V14.5H9.5Z",
  fill: "currentColor"
}, null)])), IconComponent = /* @__PURE__ */ defineComponent({
  name: "IconWindowAdaptionStroked",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(ConvertIcon, mergeProps$1({
      iconType: "window_adaption_stroked"
    }, s), {
      default: () => createVNode(SvgComponent, null, null)
    });
  }
});
IconComponent.props = vuePropsType$3a;
function useDropdownContext() {
  return {
    context: inject("DropdownContext", ref$1({
      level: 0
    }))
  };
}
const vuePropsType$39 = {
  name: String
}, Consumer$k = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$39
  },
  name: "DropdownConsumer",
  setup() {
    const s = useSlots(), {
      context: o
    } = useDropdownContext();
    return () => s.default ? s.default(o) : null;
  }
}), prefixCls$V = cssClasses$V.PREFIX, propTypes$1I = {
  name: string$3,
  disabled: bool,
  selected: bool,
  onClick: func,
  onMouseenter: func,
  onMouseleave: func,
  onContextmenu: func,
  className: string$3,
  style: object$1,
  forwardRef: [object$1, func],
  type: String,
  active: bool,
  icon: node$1,
  onKeyDown: func,
  showTick: bool,
  /** internal prop, please do not use  */
  hover: bool
}, defaultProps$1D = {
  disabled: !1,
  divided: !1,
  selected: !1,
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop,
  forwardRef: lodashExports.noop
}, vuePropsType$38 = vuePropsMake(propTypes$1I, defaultProps$1D), DropdownItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$38
  },
  name: "DropdownItem",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    const {
      context: u
    } = useDropdownContext();
    return () => {
      var K;
      const {
        disabled: c,
        className: m,
        forwardRef: g,
        style: v,
        type: b,
        active: S,
        icon: E,
        onKeyDown: P,
        showTick: T,
        hover: N
      } = s, {
        showTick: O
      } = u.value, z = O ?? T, Q = cls(m, {
        [`${prefixCls$V}-item`]: !0,
        [`${prefixCls$V}-item-disabled`]: c,
        [`${prefixCls$V}-item-hover`]: N,
        [`${prefixCls$V}-item-withTick`]: z,
        [`${prefixCls$V}-item-${b}`]: b,
        [`${prefixCls$V}-item-active`]: S
      }), W = {};
      c || ["onClick", "onMouseenter", "onMouseleave", "onContextmenu"].forEach((ve) => {
        u.value.level !== 1 && ve === "onClick" ? W.onMouseDown = (Re) => {
          var wt;
          Re.button === 0 && ((wt = s[ve]) == null || wt.call(s, Re));
        } : W[ve] = s[ve];
      });
      let ue = null;
      switch (!0) {
        case (z && S):
          ue = createVNode(IconComponent$6, null, null);
          break;
        case (z && !S):
          ue = createVNode(IconComponent$6, {
            style: {
              color: "transparent"
            }
          }, null);
          break;
        default:
          ue = null;
          break;
      }
      let te = null;
      return E && (te = createVNode("div", {
        class: `${prefixCls$V}-item-icon`
      }, [E])), createVNode("li", mergeProps$1({
        role: "menuitem",
        tabindex: -1,
        "aria-disabled": c
      }, W, {
        onKeydown: P,
        ref: g,
        class: Q,
        style: v
      }, getDataAttr({
        ...s,
        ...l
      })), [ue, te, (K = o.default) == null ? void 0 : K.call(o)]);
    };
  }
}), DropdownItem$1 = DropdownItem, prefixCls$U = cssClasses$V.PREFIX, vuePropsType$37 = {
  style: Object,
  className: String
}, DropdownDivider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$37
  },
  name: "DropdownDivider",
  setup(s, {
    slots: o
  }) {
    const {
      style: l,
      className: u
    } = s;
    return () => createVNode("div", {
      class: cls(`${prefixCls$U}-divider`, u),
      style: l
    }, null);
  }
}), DropdownDivider$1 = DropdownDivider, prefixCls$T = cssClasses$V.PREFIX, vuePropsType$36 = {
  style: [Object, String],
  className: String
}, DropdownTitle = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$36
  },
  name: "DropdownTitle",
  setup(s, {
    slots: o
  }) {
    const {
      context: l
    } = useDropdownContext();
    return () => {
      const {
        className: u,
        style: c
      } = s, m = cls({
        [`${prefixCls$T}-title`]: !0,
        [`${prefixCls$T}-title-withTick`]: l.value.showTick
      }, u);
      return createVNode("div", {
        class: m,
        style: c
      }, [o.default ? o.default() : null]);
    };
  }
}), DropdownTitle$1 = DropdownTitle, vuePropsType$35 = {
  value: Object
}, Provider$j = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$35
  },
  name: "DropdownProvider",
  setup(s, {
    slots: o
  }) {
    const l = ref$1(s.value);
    return watch(() => s.value, () => {
      l.value = s.value;
    }), provide("DropdownContext", l), () => o.default ? o.default(l.value) : null;
  }
}), DropdownContext = {
  Consumer: Consumer$k,
  Provider: Provider$j
};
function _isSlot$O(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$1H = {
  ...vuePropsType$3c,
  onFilter: func,
  onFilterDropdownVisibleChange: func,
  onSelect: func,
  onHeaderCell: func,
  onGroupedRow: func,
  render: [node$1, func, object$1],
  visible: bool,
  position: string$3,
  getPopupContainer: func,
  mouseEnterDelay: number$2,
  mouseLeaveDelay: number$2,
  trigger: string$3,
  zIndex: number$2,
  motion: oneOfType([bool, func, object$1]),
  className: string$3,
  contentClassName: oneOfType([string$3, array$1]),
  style: object$1,
  onVisibleChange: func,
  rePosKey: oneOfType([string$3, number$2]),
  showTick: bool,
  prefixCls: string$3,
  spacing: oneOfType([number$2, object$1]),
  menu: array$1,
  name: String
}, DropdownVuePropsType = propTypes$1H, defaultProps$1C = {
  onVisibleChange: lodashExports.noop,
  prefixCls: cssClasses$V.PREFIX,
  zIndex: numbers$h.DEFAULT_Z_INDEX,
  motion: !0,
  trigger: "hover",
  position: "bottom",
  mouseLeaveDelay: strings$p.DEFAULT_LEAVE_DELAY,
  showTick: !1,
  closeOnEsc: !0,
  onEscKeyDown: lodashExports.noop
}, vuePropsType$34 = vuePropsMake(propTypes$1H, defaultProps$1C), Dropdown = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$34
  },
  name: "Dropdown",
  setup(s, {
    slots: o,
    expose: l
  }) {
    const {
      getProps: u
    } = useHasInProps(), c = reactive({
      popVisible: s.visible
    }), m = ref$1(), {
      adapter: g
    } = useBaseComponent(s, c), b = function() {
      return {
        ...g(),
        setPopVisible: (Q) => c.popVisible = Q,
        notifyVisibleChange: (Q) => s.onVisibleChange(Q),
        getPopupId: () => m.value.getPopupId()
      };
    }(), S = new DropdownFoundation(b), E = (Q) => {
      S.handleVisibleChange(Q);
    }, {
      context: P
    } = useDropdownContext(), {
      level: T = 0
    } = P.value;
    function N() {
      const {
        render: Q,
        menu: W,
        contentClassName: ue,
        style: te,
        showTick: K,
        prefixCls: ve,
        trigger: ee
      } = s, Re = cls(ve, ue), wt = {
        showTick: K,
        level: T + 1,
        trigger: ee
      };
      let yt = null;
      return isVNode(Q) ? yt = Q : Array.isArray(W) && (yt = O()), createVNode(DropdownContext.Provider, {
        value: wt
      }, {
        default: () => [createVNode("div", {
          class: Re,
          style: te
        }, [createVNode("div", {
          class: `${ve}-content`,
          "x-semi-prop": "render"
        }, [yt])])]
      });
    }
    function O() {
      const {
        menu: Q
      } = s, W = Q.map((ue, te) => {
        switch (ue.node) {
          case "title": {
            const {
              name: K,
              node: ve,
              ...ee
            } = ue;
            return createVNode(DropdownTitle$1, mergeProps$1(ee, {
              key: ve + K + te
            }), {
              default: () => K
            });
          }
          case "item": {
            const {
              node: K,
              name: ve,
              ...ee
            } = ue;
            return createVNode(DropdownItem$1, mergeProps$1(ee, {
              key: K + ve + te
            }), {
              default: () => ve
            });
          }
          case "divider":
            return createVNode(DropdownDivider$1, {
              key: ue.node + te
            }, null);
          default:
            return null;
        }
      });
      return createVNode(DropdownMenu$1, null, {
        default: () => W
      });
    }
    function z() {
      const {
        render: Q,
        contentClassName: W,
        style: ue,
        showTick: te,
        prefixCls: K
      } = s, ve = cls(K, W), {
        level: ee = 0
      } = P.value, Re = {
        showTick: te,
        level: ee + 1
      };
      return createVNode(DropdownContext.Provider, {
        value: Re
      }, {
        default: () => [createVNode("div", {
          class: ve,
          style: ue
        }, [createVNode("div", {
          class: `${K}-content`
        }, [Q])])]
      });
    }
    return l({
      renderPopCard: z
    }), () => {
      let Q;
      const {
        position: W,
        trigger: ue,
        onVisibleChange: te,
        zIndex: K,
        className: ve,
        motion: ee,
        style: Re,
        prefixCls: wt,
        render: yt,
        menu: xt,
        showTick: Kt,
        //
        onFilter: tn,
        onFilterDropdownVisibleChange: ln,
        onSelect: rn,
        onHeaderCell: an,
        onGroupedRow: Gt,
        name: nn,
        contentClassName: vt,
        ...Et
      } = u(s);
      let {
        spacing: Qt
      } = s;
      const {
        level: un
      } = P.value, {
        popVisible: gn
      } = c, dn = N();
      un > 0 ? Qt = typeof Qt == "number" ? Qt : numbers$g.NESTED_SPACING : (Qt === null || typeof Qt > "u") && (Qt = numbers$g.SPACING);
      let yn = o.default ? o.default()[0] : null;
      return createVNode(Tooltip$1, mergeProps$1({
        zIndex: K,
        motion: ee,
        content: dn,
        className: ve,
        prefixCls: wt,
        spacing: Qt,
        position: W,
        trigger: ue,
        onVisibleChange: E,
        showArrow: !1,
        returnFocusOnClose: !0,
        ref: m
      }, Et), _isSlot$O(Q = cloneVNode(yn, {
        className: cls(lodashExports.get(yn, "props.class"), {
          [`${wt}-showing`]: gn
        }),
        "aria-haspopup": !0,
        "aria-expanded": gn,
        onKeyDown: (vn) => {
          S.handleKeyDown(vn);
          const Pn = lodashExports.get(yn, "props.onKeyDown");
          Pn && Pn(vn);
        }
      })) ? Q : {
        default: () => [Q]
      });
    };
  }
}), BaseDropdown = Dropdown;
BaseDropdown.Menu = DropdownMenu$1;
BaseDropdown.Item = DropdownItem$1;
BaseDropdown.Divider = DropdownDivider$1;
BaseDropdown.Title = DropdownTitle$1;
const cssClasses$U = {
  PREFIX: `${BASE_CLASS_PREFIX$1}`
}, responsiveArray = ["xxl", "xl", "lg", "md", "sm", "xs"], responsiveMap$1 = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
}, vuePropsType$33 = {
  type: String,
  align: String,
  justify: String,
  className: String,
  style: [String, Object],
  gutter: [Number, Array],
  prefixCls: {
    type: String,
    default: cssClasses$U.PREFIX
  }
}, Row = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$33
  },
  name: "Row",
  setup(s, {
    slots: o
  }) {
    const l = reactive({
      screens: {
        xs: !0,
        sm: !0,
        md: !0,
        lg: !0,
        xl: !0,
        xxl: !0
      }
    });
    let u = [];
    onMounted(() => {
      u = Object.keys(responsiveMap$1).map((m) => registerMediaQuery(responsiveMap$1[m], {
        match: () => {
          typeof s.gutter == "object" && (l.screens[m] = !0);
        },
        unmatch: () => {
          typeof s.gutter == "object" && (l.screens[m] = !0);
        }
      }));
    }), onUnmounted(() => {
      u.forEach((m) => m());
    });
    function c() {
      const {
        gutter: m = 0
      } = s, g = [0, 0];
      return (Array.isArray(m) ? m.slice(0, 2) : [m, 0]).forEach((b, S) => {
        if (typeof b == "object")
          for (let E = 0; E < responsiveArray.length; E++) {
            const P = responsiveArray[E];
            if (l.screens[P] && b[P] !== void 0) {
              g[S] = b[P];
              break;
            }
          }
        else
          g[S] = b || 0;
      }), g;
    }
    return provide("gutters", c()), () => {
      const {
        prefixCls: m,
        type: g,
        justify: v,
        align: b,
        className: S,
        style: E,
        ...P
      } = s, T = c(), N = `${m}-row`, O = cls({
        [N]: g !== "flex",
        [`${N}-${g}`]: g,
        [`${N}-${g}-${v}`]: g && v,
        [`${N}-${g}-${b}`]: g && b
      }, S), z = {
        ...T[0] > 0 ? {
          marginLeft: T[0] / -2,
          marginRight: T[0] / -2
        } : {},
        ...T[1] > 0 ? {
          marginTop: T[1] / -2,
          marginBottom: T[1] / -2
        } : {},
        ...E
      }, Q = {
        ...P
      };
      return delete Q.gutter, createVNode("div", mergeProps$1(Q, {
        class: O,
        style: z
      }), [o.default ? o.default() : null]);
    };
  }
}), Row$1 = Row, vuePropsType$32 = {
  span: Number,
  order: Number,
  offset: Number,
  push: Number,
  pull: Number,
  className: String,
  prefixCls: {
    type: String,
    default: cssClasses$U.PREFIX
  },
  style: [Object, String],
  xs: [Number, Object],
  sm: [Number, Object],
  md: [Number, Object],
  lg: [Number, Object],
  xl: [Number, Object],
  xxl: [Number, Object]
}, Col = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$32
  },
  name: "Col",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        prefixCls: l,
        span: u,
        order: c,
        offset: m,
        push: g,
        pull: v,
        className: b,
        ...S
      } = s;
      let E = {};
      const P = `${l}-col`;
      ["xs", "sm", "md", "lg", "xl", "xxl"].forEach((z) => {
        let Q = {};
        typeof s[z] == "number" ? Q.span = s[z] : typeof s[z] == "object" && (Q = s[z] || {}), delete S[z], E = {
          ...E,
          [`${P}-${z}-${Q.span}`]: Q.span !== void 0,
          [`${P}-${z}-order-${Q.order}`]: Q.order || Q.order === 0,
          [`${P}-${z}-offset-${Q.offset}`]: Q.offset || Q.offset === 0,
          [`${P}-${z}-push-${Q.push}`]: Q.push || Q.push === 0,
          [`${P}-${z}-pull-${Q.pull}`]: Q.pull || Q.pull === 0
        };
      });
      const T = cls(P, {
        [`${P}-${u}`]: u !== void 0,
        [`${P}-order-${c}`]: c,
        [`${P}-offset-${m}`]: m,
        [`${P}-push-${g}`]: g,
        [`${P}-pull-${v}`]: v
      }, b, E);
      let {
        style: N
      } = S;
      const O = inject("gutters", []);
      return N = {
        ...O[0] > 0 ? {
          paddingLeft: O[0] / 2 + "px",
          paddingRight: O[0] / 2 + "px"
        } : {},
        ...O[1] > 0 ? {
          paddingTop: O[1] / 2 + "px",
          paddingBottom: O[1] / 2 + "px"
        } : {},
        ...N
      }, createVNode("div", mergeProps$1(S, {
        style: N,
        class: T
      }), [o.default ? o.default() : null]);
    };
  }
}), Col$1 = Col, cssClasses$T = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-layout`
}, vuePropsType$31 = {
  value: Object
}, Provider$i = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("LayoutContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$31
  },
  name: "LayoutProvider"
});
function useLayoutContext() {
  return {
    context: inject("LayoutContext", ref$1({
      siderHook: {
        addSider: noop$1,
        removeSider: noop$1
      }
    }))
  };
}
const vuePropsType$30 = {
  name: String
}, Consumer$j = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useLayoutContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$30
  },
  name: "LayoutConsumer"
}), LayoutContext = {
  Provider: Provider$i,
  Consumer: Consumer$j
}, responsiveMap = {
  xs: "(max-width: 575px)",
  sm: "(min-width: 576px)",
  md: "(min-width: 768px)",
  lg: "(min-width: 992px)",
  xl: "(min-width: 1200px)",
  xxl: "(min-width: 1600px)"
}, generateId = /* @__PURE__ */ (() => {
  let s = 0;
  return () => (s += 1, `${cssClasses$T.PREFIX}-sider-${s}`);
})(), vuePropsType$2$ = {
  prefixCls: {
    type: String,
    default: cssClasses$T.PREFIX
  },
  style: [String, Object],
  className: String,
  breakpoint: Array,
  // onBreakpoin: Function as PropType<SiderProps['onBreakpoin']>,
  "aria-label": String,
  role: String,
  onBreakpoint: Function
}, Sider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2$
  },
  name: "LayoutSider",
  setup(s, {
    slots: o
  }) {
    const l = generateId(), {
      context: u
    } = useLayoutContext();
    onMounted(() => {
      const {
        breakpoint: m
      } = s;
      Object.keys(responsiveMap).filter((v) => m && m.indexOf(v) !== -1).map((v) => registerMediaQuery(responsiveMap[v], {
        match: () => {
          c(v, !0);
        },
        unmatch: () => {
          c(v, !1);
        }
      })), u.value.siderHook && u.value.siderHook.addSider(l);
    });
    function c(m, g) {
      const {
        onBreakpoint: v
      } = s;
      v && v(m, g);
    }
    return () => {
      const {
        prefixCls: m,
        className: g,
        style: v,
        ...b
      } = s, S = cls(g, {
        [`${m}-sider`]: !0
      });
      return createVNode("aside", mergeProps$1({
        class: S,
        "aria-label": s["aria-label"],
        style: v
      }, getDataAttr(b)), [createVNode("div", {
        class: `${m}-sider-children`
      }, [o.default ? o.default() : null])]);
    };
  }
}), htmlTag = {
  Header: "header",
  Footer: "footer",
  Content: "main",
  Layout: "section"
}, basicVuePropsType = {
  prefixCls: {
    type: String,
    default: cssClasses$T.PREFIX
  },
  style: [String, Object],
  className: String,
  tagName: String,
  type: String
}, Basic = /* @__PURE__ */ defineComponent({
  props: {
    ...basicVuePropsType
  },
  name: "Basic",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        prefixCls: l,
        type: u,
        className: c,
        tagName: m,
        ...g
      } = s, v = cls(c, `${l}-${u}`);
      return h(m, {
        className: v,
        ...g
      }, o.default ? o.default() : null);
    };
  }
});
function generator$1(s) {
  const o = htmlTag[s], l = s.toLowerCase();
  return (u) => /* @__PURE__ */ defineComponent((c, {
    slots: m
  }) => () => createVNode(u, mergeProps$1({
    role: c.role,
    "aria-label": c["aria-label"],
    type: l,
    tagName: o
  }, c), {
    default: () => [m.default ? m.default() : null]
  }));
}
const LayoutHeader = generator$1("Header")(Basic), LayoutFooter = generator$1("Footer")(Basic), LayoutContent = generator$1("Content")(Basic), LayoutSider = Sider, vuePropsType$2_ = {
  prefixCls: {
    type: String,
    default: cssClasses$T.PREFIX
  },
  style: [String, Object],
  className: String,
  hasSider: Boolean,
  tagName: {
    type: String,
    default: "section"
  }
}, Layout = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2_
  },
  name: "Layout",
  setup(s, {
    slots: o
  }) {
    const l = reactive({
      siders: []
    });
    function u() {
      return {
        addSider: (c) => {
          l.siders = [...l.siders, c];
        },
        removeSider: (c) => {
          l.siders = l.siders.filter((m) => m !== c);
        }
      };
    }
    return () => {
      var N;
      const c = ((N = o.default) == null ? void 0 : N.call(o)) || [], {
        prefixCls: m,
        className: g,
        hasSider: v,
        tagName: b,
        ...S
      } = s, {
        siders: E
      } = l, P = cls(g, m, {
        [`${m}-has-sider`]: typeof v == "boolean" && v || E.length > 0 || c.some((O) => isVNode(O) && O.type && O.type.name === "Layout.Sider")
      }), T = b;
      return createVNode(LayoutContext.Provider, {
        value: {
          siderHook: u()
        }
      }, {
        default: () => [createVNode(T, mergeProps$1({
          className: P
        }, S), {
          default: () => {
            var O;
            return [(O = o.default) == null ? void 0 : O.call(o)];
          }
        })]
      });
    };
  }
}), BaseLayout = Layout;
BaseLayout.Header = LayoutHeader;
BaseLayout.Footer = LayoutFooter;
BaseLayout.Content = LayoutContent;
BaseLayout.Sider = LayoutSider;
const BaseLayout$1 = BaseLayout, cssClasses$S = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-popover`,
  ARROW: `${BASE_CLASS_PREFIX$1}-popover-icon-arrow`
}, strings$o = {
  POSITION_SET: [
    "top",
    "topLeft",
    "topRight",
    "left",
    "leftTop",
    "leftBottom",
    "right",
    "rightTop",
    "rightBottom",
    "bottom",
    "bottomLeft",
    "bottomRight",
    "leftTopOver",
    "rightTopOver"
  ],
  TRIGGER_SET: ["hover", "focus", "click", "custom", "contextMenu"],
  DEFAULT_ARROW_STYLE: {
    borderOpacity: "1",
    backgroundColor: "var(--semi-color-bg-3)",
    // borderColor: 'var(--semi-color-shadow)',
    borderColor: "var(--semi-color-border)"
  }
}, numbers$f = {
  ARROW_BOUNDING: {
    ...numbers$h.ARROW_BOUNDING,
    offsetY: 6,
    offsetX: 0,
    height: 8
  },
  SPACING: 4,
  SPACING_WITH_ARROW: 10,
  DEFAULT_Z_INDEX: 1030
}, vuePropsType$2Z = {
  position: String,
  className: String,
  arrowStyle: [String, Object],
  popStyle: [String, Object]
}, Arrow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2Z
  },
  name: "Arrow",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        position: l = "",
        className: u,
        arrowStyle: c,
        popStyle: m,
        ...g
      } = s, v = l.indexOf("top") === 0 || l.indexOf("bottom") === 0, b = cls(u, cssClasses$S.ARROW), S = lodashExports.get(c, "borderOpacity", strings$o.DEFAULT_ARROW_STYLE.borderOpacity), E = lodashExports.get(c, "backgroundColor", lodashExports.get(m, "backgroundColor", strings$o.DEFAULT_ARROW_STYLE.backgroundColor)), P = lodashExports.get(c, "borderColor", lodashExports.get(m, "borderColor", strings$o.DEFAULT_ARROW_STYLE.borderColor)), T = {
        ...g,
        width: numbers$f.ARROW_BOUNDING.width,
        height: numbers$f.ARROW_BOUNDING.height,
        xmlns: "http://www.w3.org/2000/svg",
        class: b
      };
      return v ? createVNode("svg", T, [createVNode("path", {
        d: "M0 0.5L0 1.5C4 1.5, 5.5 3, 7.5 5S10,8 12,8S14.5 7, 16.5 5S20,1.5 24,1.5L24 0.5L0 0.5z",
        fill: P,
        opacity: S
      }, null), createVNode("path", {
        d: "M0 0L0 1C4 1, 5.5 2, 7.5 4S10,7 12,7S14.5  6, 16.5 4S20,1 24,1L24 0L0 0z",
        fill: E
      }, null)]) : createVNode("svg", T, [createVNode("path", {
        d: "M0.5 0L1.5 0C1.5 4, 3 5.5, 5 7.5S8,10 8,12S7 14.5, 5 16.5S1.5,20 1.5,24L0.5 24L0.5 0z",
        fill: P,
        opacity: S
      }, null), createVNode("path", {
        d: "M0 0L1 0C1 4, 2 5.5, 4 7.5S7,10 7,12S6 14.5, 4 16.5S1,20 1,24L0 24L0 0z",
        fill: E
      }, null)]);
    };
  }
}), propTypes$1G = {
  // children: PropTypes.node,
  content: oneOfType([node$1, func]),
  visible: bool,
  autoAdjustOverflow: bool,
  motion: bool,
  position: string$3,
  // getPopupContainer: PropTypes.func,
  mouseEnterDelay: number$2,
  mouseLeaveDelay: number$2,
  trigger: [Boolean, String],
  contentClassName: oneOfType([string$3, array$1]),
  onVisibleChange: func,
  onClickOutSide: func,
  style: object$1,
  spacing: oneOfType([number$2, object$1]),
  zIndex: number$2,
  showArrow: bool,
  arrowStyle: Object,
  arrowPointAtCenter: bool,
  arrowBounding: object$1,
  prefixCls: string$3,
  guardFocus: bool,
  disableArrowKeyDown: bool,
  className: String,
  class: String,
  stopPropagation: [Boolean, String],
  rePosKey: [String, Number, Boolean],
  getPopupContainer: Function,
  cancelText: {
    type: String,
    default: "No"
  },
  okText: {
    type: String,
    default: "Yes"
  },
  role: String,
  afterClose: Function,
  disableFocusListener: Boolean,
  keepDOM: Boolean,
  margin: [number$2, object$1],
  closeOnEsc: Boolean,
  returnFocusOnClose: Boolean,
  onEscKeyDown: Function,
  clickToHide: Boolean
}, defaultProps$1B = {
  arrowBounding: numbers$f.ARROW_BOUNDING,
  showArrow: !1,
  autoAdjustOverflow: !0,
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  motion: !0,
  trigger: "hover",
  cancelText: "No",
  okText: "Yes",
  position: "bottom",
  prefixCls: cssClasses$S.PREFIX,
  onClickOutSide: lodashExports.noop,
  onEscKeyDown: lodashExports.noop,
  closeOnEsc: !0,
  returnFocusOnClose: !0,
  guardFocus: !0,
  disableFocusListener: !0
}, vuePropsType$2Y = vuePropsMake(propTypes$1G, defaultProps$1B), Popover = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2Y
  },
  name: "Popover",
  setup(s, {
    slots: o,
    expose: l
  }) {
    const {
      context: u
    } = useConfigContext(), c = ref$1();
    function m() {
      var S;
      (S = c.value) == null || S.focusTrigger();
    }
    const g = getCurrentInstance();
    l({
      focusTrigger: m,
      // 当组件内部使用了expose时，使用ref得到的内容只有expose的那部分
      getRef() {
        return g;
      }
    });
    function v({
      initialFocusRef: S
    }) {
      const {
        content: E,
        contentClassName: P,
        prefixCls: T
      } = s, {
        direction: N
      } = u.value, O = cls(T, P, {
        // @ts-ignore
        [`${T}-rtl`]: N === "rtl"
      }), z = b({
        initialFocusRef: S,
        content: E
      });
      return createVNode("div", {
        class: O
      }, [createVNode("div", {
        class: `${T}-content`
      }, [z])]);
    }
    const b = (S) => {
      const {
        initialFocusRef: E,
        content: P
      } = S, T = {
        initialFocusRef: E
      };
      return lodashExports.isFunction(P) ? P(T) : P;
    };
    return () => {
      const {
        prefixCls: S,
        showArrow: E,
        arrowStyle: P = {},
        arrowBounding: T,
        position: N,
        style: O,
        trigger: z,
        contentClassName: Q,
        cancelText: W,
        okText: ue,
        ...te
      } = s;
      let {
        spacing: K
      } = s;
      const ee = E ? createVNode(Arrow, {
        position: N,
        className: "",
        popStyle: O,
        arrowStyle: P
      }, null) : !1;
      return typeof K != "number" && (K = E ? numbers$f.SPACING_WITH_ARROW : numbers$f.SPACING), isNullOrUndefined(K) && (K = E ? numbers$f.SPACING_WITH_ARROW : numbers$f.SPACING), createVNode(Tooltip$1, mergeProps$1({
        guardFocus: !0,
        ref: c
      }, te, {
        trigger: z,
        position: N,
        style: O,
        content: v,
        prefixCls: S,
        spacing: K,
        showArrow: ee,
        arrowBounding: T,
        role: z === "click" || z === "custom" ? "dialog" : "tooltip"
      }), {
        default: o.default
      });
    };
  }
}), Popover$1 = Popover, cssClasses$R = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-space`
}, strings$n = {
  ALIGN_SET: ["start", "end", "center", "baseline"],
  SPACING_LOOSE: "loose",
  SPACING_MEDIUM: "medium",
  SPACING_TIGHT: "tight"
}, VUE_FRAGMENT_TYPE = "Symbol(Fragment)", flatten = (s) => {
  let o = [];
  return s.forEach((l) => {
    l != null && (Array.isArray(l) ? o = o.concat(flatten(l)) : isVNode(l) && l.type && l.type.toString() === VUE_FRAGMENT_TYPE && l.props ? o = o.concat(flatten(l.props.children)) : o.push(l));
  }), o;
}, prefixCls$S = cssClasses$R.PREFIX, vuePropsType$2X = {
  wrap: {
    type: Boolean,
    default: !1
  },
  align: {
    type: String,
    default: "center"
  },
  vertical: {
    type: Boolean,
    default: !1
  },
  spacing: {
    type: [Number, Array, String],
    default: "tight"
  },
  style: [String, Object],
  className: String
}, Index$8 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2X
  },
  name: "Space",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        style: l,
        className: u,
        spacing: c,
        wrap: m,
        align: g,
        vertical: v
      } = s, b = m && v ? !1 : m, S = {
        ...l
      };
      let E = "", P = "";
      lodashExports.isString(c) ? (E = c, P = c) : lodashExports.isNumber(c) ? (S.rowGap = c + "px", S.columnGap = c + "px") : lodashExports.isArray(c) && (lodashExports.isString(c[0]) ? E = c[0] : lodashExports.isNumber(c[0]) && (S.columnGap = `${c[0]}px`), lodashExports.isString(c[1]) ? P = c[1] : lodashExports.isNumber(c[1]) && (S.rowGap = `${c[1]}px`));
      const T = cls(prefixCls$S, u, {
        [`${prefixCls$S}-align-${g}`]: g,
        [`${prefixCls$S}-vertical`]: v,
        [`${prefixCls$S}-horizontal`]: !v,
        [`${prefixCls$S}-wrap`]: b,
        [`${prefixCls$S}-tight-horizontal`]: E === strings$n.SPACING_TIGHT,
        [`${prefixCls$S}-tight-vertical`]: P === strings$n.SPACING_TIGHT,
        [`${prefixCls$S}-medium-horizontal`]: E === strings$n.SPACING_MEDIUM,
        [`${prefixCls$S}-medium-vertical`]: P === strings$n.SPACING_MEDIUM,
        [`${prefixCls$S}-loose-horizontal`]: E === strings$n.SPACING_LOOSE,
        [`${prefixCls$S}-loose-vertical`]: P === strings$n.SPACING_LOOSE
      }), N = o.default ? flatten(o.default()) : null, O = getDataAttr(s);
      return createVNode("div", mergeProps$1(O, {
        class: T,
        style: S,
        "x-semi-prop": "children"
      }), [N]);
    };
  }
}), Space = Index$8, PREFIX$2 = `${BASE_CLASS_PREFIX$1}-spin`, cssClasses$Q = {
  PREFIX: PREFIX$2
};
class SpinFoundation extends BaseFoundation$1 {
  static get spinDefaultAdapter() {
    return {
      getProp: () => {
      },
      setLoading: (o) => {
      }
    };
  }
  constructor(o) {
    super({ ...SpinFoundation.spinDefaultAdapter, ...o });
  }
  updateLoadingIfNeedDelay() {
    const { spinning: o, delay: l } = this._adapter.getProps(), { delay: u } = this._adapter.getStates();
    if (u) {
      const c = this;
      this._timer = setTimeout(() => {
        c._adapter.setState({
          loading: o,
          delay: 0
        });
      }, l);
    }
  }
  destroy() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
}
const prefixCls$R = cssClasses$Q.PREFIX, VuePropsType$4 = {
  size: {
    type: String,
    default: "middle"
  },
  spinning: {
    type: Boolean,
    default: !0
  },
  indicator: Object,
  delay: {
    type: Number,
    default: 0
  },
  tip: [Object, String],
  wrapperClassName: String,
  style: Object,
  childStyle: Object
}, Index$7 = /* @__PURE__ */ defineComponent({
  props: VuePropsType$4,
  name: "Spin",
  setup(s, {
    slots: o
  }) {
    const {
      getProps: l
    } = useHasInProps(), u = reactive({
      delay: s.delay,
      loading: !0
    });
    function c(E) {
      return E.delay ? E.spinning === !1 ? {
        delay: 0,
        loading: !1
      } : {
        delay: E.delay
      } : {
        loading: E.spinning
      };
    }
    watch(() => s, (E) => {
      const P = c({
        ...l(s)
      });
      P && Object.keys(P).forEach((T) => {
        u[T] = P[T];
      });
    }, {
      deep: !0,
      immediate: !0
    });
    const {
      adapter: m,
      getDataAttr: g
    } = useBaseComponent(s, u);
    function v() {
      return {
        ...m(),
        setLoading: (E) => {
          u.loading = E;
        }
      };
    }
    const b = ref$1(new SpinFoundation(v()));
    onUnmounted(() => {
      b.value.destroy();
    });
    function S() {
      const {
        indicator: E,
        tip: P
      } = s, {
        loading: T
      } = u, N = cls({
        [`${prefixCls$R}-animate`]: T
      });
      return u.loading ? createVNode("div", {
        class: `${prefixCls$R}-wrapper`
      }, [E ? createVNode("div", {
        class: N,
        "x-semi-prop": "indicator"
      }, [E]) : createVNode(Icon$1, null, null), P ? createVNode("div", {
        "x-semi-prop": "tip"
      }, [P]) : null]) : null;
    }
    return () => {
      b.value.updateLoadingIfNeedDelay();
      const {
        style: E,
        wrapperClassName: P,
        childStyle: T,
        size: N,
        ...O
      } = l(s), {
        loading: z
      } = u;
      return createVNode("div", mergeProps$1({
        class: cls(prefixCls$R, P, {
          [`${prefixCls$R}-${N}`]: N,
          [`${prefixCls$R}-block`]: o.default,
          [`${prefixCls$R}-hidden`]: !z
        }),
        style: E
      }, g()), [S(), createVNode("div", {
        class: `${prefixCls$R}-children`,
        style: T,
        "x-semi-prop": "children"
      }, [o.default ? o.default() : null])]);
    };
  }
}), Spin = Index$7, prefixCls$Q = cssClasses$X.PREFIX, vuePropsType$2W = {
  style: Object,
  className: String
}, SplitButtonGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2W
  },
  name: "SplitButtonGroup",
  setup(s, {
    slots: o
  }) {
    const l = ref$1();
    let u = null;
    return onMounted(() => {
      const c = () => {
        const m = l.value.querySelectorAll("button"), g = m[0], v = m[m.length - 1];
        g != null && g.classList.contains(`${prefixCls$Q}-first`) || g == null || g.classList.add(`${prefixCls$Q}-first`), v != null && v.classList.contains(`${prefixCls$Q}-last`) || v == null || v.classList.add(`${prefixCls$Q}-last`);
      };
      if (l.value) {
        c();
        const m = new MutationObserver((g, v) => {
          for (const b of g)
            (b.type === "attributes" && b.attributeName === "class" || b.type === "childList" && Array.from(b.addedNodes).some((S) => S.nodeName === "BUTTON")) && c();
        });
        m.observe(l.value, {
          attributes: !0,
          childList: !0,
          subtree: !0
        }), u = m;
      }
    }), onUnmounted(() => {
      u == null || u.disconnect();
    }), () => {
      const {
        style: c,
        className: m
      } = s, g = cls(`${prefixCls$Q}-split`, m);
      return createVNode("div", {
        ref: l,
        class: g,
        style: c,
        role: "group",
        "aria-label": s["aria-label"]
      }, [o.default ? o.default() : null]);
    };
  }
}), SplitButtonGroup$1 = SplitButtonGroup, vuePropsType$2V = {}, Consumer$i = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), o = inject("LocalContext", ref$1(null));
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$2V
  },
  name: "LocaleContextConsumer"
}), vuePropsType$2U = {
  value: Object
}, Provider$h = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }), provide("LocalContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$2U
  },
  name: "LocalContextProvider"
}), LocaleContext = {
  Consumer: Consumer$i,
  Provider: Provider$h
}, vuePropsType$2T = {
  locale: {
    type: Object,
    default: local
  }
}, LocaleProvider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2T
  },
  name: "LocaleProvider",
  setup(s, {
    slots: o
  }) {
    return () => createVNode(LocaleContext.Provider, {
      value: s.locale
    }, {
      default: () => {
        var l;
        return [(l = o.default) == null ? void 0 : l.call(o)];
      }
    });
  }
}), LocaleProvider$1 = LocaleProvider, cssClasses$P = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-typography`
}, strings$m = {
  WEIGHT: ["light", "regular", "medium", "semibold", "bold", "default"],
  TYPE: ["primary", "secondary", "danger", "warning", "success", "tertiary", "quaternary"],
  SIZE: ["normal", "small", "inherit"],
  SPACING: ["normal", "extended"],
  HEADING: [1, 2, 3, 4, 5, 6],
  RULE: ["text", "numbers", "bytes-decimal", "bytes-binary", "percentages", "exponential"],
  TRUNCATE: ["ceil", "floor", "round"]
}, prefixCls$P = cssClasses$P.PREFIX, vuePropsType$2S = {
  component_: {
    type: [String, Array, Boolean, Object, Number],
    default: "article"
  },
  style: [String, Object],
  className: String,
  forwardRef: Object
}, Typography$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2S
  },
  name: "Typography",
  setup(s, {
    slots: o
  }) {
    return () => {
      const {
        component_: l,
        className: u,
        forwardRef: c,
        ...m
      } = s, g = cls(prefixCls$P, u), v = o.default ? o.default() : null;
      return h(l, {
        class: g,
        ref: c,
        ...m
      }, v);
    };
  }
});
function copyTextToClipboard(s, { target: o = document.body } = {}) {
  if (typeof s != "string")
    throw new TypeError(`Expected parameter \`text\` to be a \`string\`, got \`${typeof s}\`.`);
  const l = document.createElement("textarea"), u = document.activeElement;
  l.value = s, l.setAttribute("readonly", ""), l.style.contain = "strict", l.style.position = "absolute", l.style.left = "-9999px", l.style.fontSize = "12pt";
  const c = document.getSelection(), m = c.rangeCount > 0 && c.getRangeAt(0);
  o.append(l), l.select(), l.selectionStart = 0, l.selectionEnd = s.length;
  let g = !1;
  try {
    g = document.execCommand("copy");
  } catch {
  }
  return l.remove(), m && (c.removeAllRanges(), c.addRange(m)), u && u.focus(), g;
}
function LocaleConsumerFunc() {
  return /* @__PURE__ */ defineComponent({
    props: {
      ...{
        componentName: {
          type: String,
          default: "",
          required: !0
        }
        // children: [String, Boolean,Object,Array],
      }
    },
    name: "LocaleConsumer",
    setup(l, {
      slots: u
    }) {
      function c(m, g) {
        const {
          componentName: v
        } = l;
        let b = m;
        m != null && m.code || (b = local);
        const S = lodashExports.get(local, "dateFnsLocale"), E = lodashExports.get(b, "dateFnsLocale", S);
        return g == null ? void 0 : g(b[v], b.code, E);
      }
      return () => createVNode(ConfigContext.Consumer, null, {
        default: (m) => createVNode(LocaleContext.Consumer, null, {
          default: (g) => c(m.value.locale || g.value, u.default)
        })
      });
    }
  });
}
const LocaleConsumer$5 = LocaleConsumerFunc(), LocaleConsumer$6 = LocaleConsumer$5, keyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,
  /**
   * BACKSPACE
   */
  BACKSPACE: 8,
  /**
   * TAB
   */
  TAB: 9,
  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,
  // NUMLOCK on FF/Safari Mac
  /**
   * ENTER
   */
  ENTER: 13,
  /**
   * SHIFT
   */
  SHIFT: 16,
  /**
   * CTRL
   */
  CTRL: 17,
  /**
   * ALT
   */
  ALT: 18,
  /**
   * PAUSE
   */
  PAUSE: 19,
  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,
  /**
   * ESC
   */
  ESC: 27,
  /**
   * SPACE
   */
  SPACE: 32,
  /**
   * PAGE_UP
   */
  PAGE_UP: 33,
  // also NUM_NORTH_EAST
  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,
  // also NUM_SOUTH_EAST
  /**
   * END
   */
  END: 35,
  // also NUM_SOUTH_WEST
  /**
   * HOME
   */
  HOME: 36,
  // also NUM_NORTH_WEST
  /**
   * LEFT
   */
  LEFT: 37,
  // also NUM_WEST
  /**
   * UP
   */
  UP: 38,
  // also NUM_NORTH
  /**
   * RIGHT
   */
  RIGHT: 39,
  // also NUM_EAST
  /**
   * DOWN
   */
  DOWN: 40,
  // also NUM_SOUTH
  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,
  /**
   * INSERT
   */
  INSERT: 45,
  // also NUM_INSERT
  /**
   * DELETE
   */
  DELETE: 46,
  // also NUM_DELETE
  /**
   * ZERO
   */
  ZERO: 48,
  /**
   * ONE
   */
  ONE: 49,
  /**
   * TWO
   */
  TWO: 50,
  /**
   * THREE
   */
  THREE: 51,
  /**
   * FOUR
   */
  FOUR: 52,
  /**
   * FIVE
   */
  FIVE: 53,
  /**
   * SIX
   */
  SIX: 54,
  /**
   * SEVEN
   */
  SEVEN: 55,
  /**
   * EIGHT
   */
  EIGHT: 56,
  /**
   * NINE
   */
  NINE: 57,
  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,
  // needs localization
  /**
   * A
   */
  A: 65,
  /**
   * B
   */
  B: 66,
  /**
   * C
   */
  C: 67,
  /**
   * D
   */
  D: 68,
  /**
   * E
   */
  E: 69,
  /**
   * F
   */
  F: 70,
  /**
   * G
   */
  G: 71,
  /**
   * H
   */
  H: 72,
  /**
   * I
   */
  I: 73,
  /**
   * J
   */
  J: 74,
  /**
   * K
   */
  K: 75,
  /**
   * L
   */
  L: 76,
  /**
   * M
   */
  M: 77,
  /**
   * N
   */
  N: 78,
  /**
   * O
   */
  O: 79,
  /**
   * P
   */
  P: 80,
  /**
   * Q
   */
  Q: 81,
  /**
   * R
   */
  R: 82,
  /**
   * S
   */
  S: 83,
  /**
   * T
   */
  T: 84,
  /**
   * U
   */
  U: 85,
  /**
   * V
   */
  V: 86,
  /**
   * W
   */
  W: 87,
  /**
   * X
   */
  X: 88,
  /**
   * Y
   */
  Y: 89,
  /**
   * Z
   */
  Z: 90,
  /**
   * META
   */
  META: 91,
  // WIN_KEY_LEFT
  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,
  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,
  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,
  /**
   * NUM_ONE
   */
  NUM_ONE: 97,
  /**
   * NUM_TWO
   */
  NUM_TWO: 98,
  /**
   * NUM_THREE
   */
  NUM_THREE: 99,
  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,
  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,
  /**
   * NUM_SIX
   */
  NUM_SIX: 102,
  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,
  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,
  /**
   * NUM_NINE
   */
  NUM_NINE: 105,
  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,
  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,
  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,
  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,
  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,
  /**
   * F1
   */
  F1: 112,
  /**
   * F2
   */
  F2: 113,
  /**
   * F3
   */
  F3: 114,
  /**
   * F4
   */
  F4: 115,
  /**
   * F5
   */
  F5: 116,
  /**
   * F6
   */
  F6: 117,
  /**
   * F7
   */
  F7: 118,
  /**
   * F8
   */
  F8: 119,
  /**
   * F9
   */
  F9: 120,
  /**
   * F10
   */
  F10: 121,
  /**
   * F11
   */
  F11: 122,
  /**
   * F12
   */
  F12: 123,
  /**
   * NUMLOCK
   */
  NUMLOCK: 144,
  /**
   * SEMICOLON
   */
  SEMICOLON: 186,
  // needs localization
  /**
   * DASH
   */
  DASH: 189,
  // needs localization
  /**
   * EQUALS
   */
  EQUALS: 187,
  // needs localization
  /**
   * COMMA
   */
  COMMA: 188,
  // needs localization
  /**
   * PERIOD
   */
  PERIOD: 190,
  // needs localization
  /**
   * SLASH
   */
  SLASH: 191,
  // needs localization
  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,
  // needs localization
  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,
  // needs localization
  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,
  // needs localization
  /**
   * BACKSLASH
   */
  BACKSLASH: 220,
  // needs localization
  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,
  // needs localization
  /**
   * WIN_KEY
   */
  WIN_KEY: 224,
  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,
  // Firefox (Gecko) fires this for the meta key instead of 91
  /**
   * WIN_IME
   */
  WIN_IME: 229
}, ENTER_KEY = "Enter", ESC_KEY = "Escape", KeyCode = keyCode;
function isEnterPress(s) {
  return lodashExports.get(s, "key") === ENTER_KEY;
}
function _isSlot$N(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$O = cssClasses$P.PREFIX, vuePropsType$2R = {
  forwardRef: Object,
  content: {
    type: String,
    default: ""
  },
  onCopy: {
    type: Function,
    default: noop$1
  },
  duration: {
    type: Number,
    default: 3
  },
  style: {
    type: [Object, String],
    default: {}
  },
  className: {
    type: String,
    default: ""
  },
  copyTip: node$1,
  successTip: node$1,
  icon: node$1
}, Copyable = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2R
  },
  name: "Copyable",
  setup(s, {
    slots: o
  }) {
    let l;
    const u = reactive({
      copied: !1,
      item: ""
    });
    onUnmounted(() => {
      l && (clearTimeout(l), l = null);
    });
    const c = (S) => {
      const {
        content: E,
        duration: P,
        onCopy: T
      } = s, N = copyTextToClipboard(E);
      T && T(S, E, N), m(E, P);
    }, m = (S, E) => {
      u.copied = !0, u.item = S, l = setTimeout(() => {
        g();
      }, E * 1e3);
    }, g = () => {
      l && (clearTimeout(l), l = null, u.copied = !1, u.item = "");
    }, v = () => {
      const {
        successTip: S
      } = s;
      return typeof S < "u" ? S : createVNode(LocaleConsumer$6, {
        componentName: "Typography"
      }, {
        default: (E) => createVNode("span", null, [createVNode(IconComponent$6, null, null), E.copied])
      });
    }, b = () => {
      const {
        icon: S
      } = s, E = {
        role: "button",
        tabIndex: 0,
        onClick: c,
        onKeyPress: (T) => isEnterPress(T) && c(T)
      }, P = (
        // eslint-disable-next-line jsx-a11y/anchor-is-valid
        createVNode("a", {
          class: `${prefixCls$O}-action-copy-icon`
        }, [createVNode(IconComponent$t, mergeProps$1({
          onClick: c
        }, E), null)])
      );
      return isVNode(S) ? cloneVNode(S, E) : P;
    };
    return () => {
      const {
        style: S,
        className: E,
        forwardRef: P,
        copyTip: T
      } = s, {
        copied: N
      } = u, O = cls(E, {
        [`${prefixCls$O}-action-copy`]: !N,
        [`${prefixCls$O}-action-copied`]: N
      });
      return createVNode(LocaleConsumer$6, {
        componentName: "Typography"
      }, {
        default: (z) => {
          let Q;
          return createVNode("span", {
            style: {
              marginLeft: "4px",
              ...S
            },
            class: O,
            ref: P
          }, [N ? v() : createVNode(Tooltip$1, {
            content: typeof T < "u" ? T : z.copy
          }, _isSlot$N(Q = b()) ? Q : {
            default: () => [Q]
          })]);
        }
      });
    };
  }
});
let ellipsisContainer, ellipsisApp;
function pxToNumber(s) {
  if (!s)
    return 0;
  const o = s.match(/^\d*(\.\d*)?/);
  return o ? Number(o[0]) : 0;
}
function styleToString(s) {
  return Array.prototype.slice.apply(s).map((l) => `${l}: ${s.getPropertyValue(l)};`).join("");
}
const getRenderText = (s, o, l = "", u, c, m, g) => {
  if (l.length === 0)
    return "";
  ellipsisContainer || (ellipsisContainer = document.createElement("div"), ellipsisContainer.setAttribute("aria-hidden", "true"), document.body.appendChild(ellipsisContainer));
  const v = window.getComputedStyle(s), b = styleToString(v), S = pxToNumber(v.lineHeight), E = Math.round(S * (o + 1) + pxToNumber(v.paddingTop) + pxToNumber(v.paddingBottom));
  ellipsisContainer.setAttribute("style", b), ellipsisContainer.style.position = "fixed", ellipsisContainer.style.left = "0", ellipsisContainer.style.height = "auto", ellipsisContainer.style.top = "-999999px", ellipsisContainer.style.zIndex = "-1000", ellipsisContainer.style.textOverflow = "clip", ellipsisContainer.style.webkitLineClamp = "none", ellipsisApp && ellipsisApp.unmount(), ellipsisApp = createApp(() => h("div")), ellipsisApp.mount(ellipsisContainer);
  function P() {
    const ue = ellipsisContainer.scrollWidth <= ellipsisContainer.offsetWidth, te = ellipsisContainer.scrollHeight < E;
    return o === 1 ? ue && te : te;
  }
  const T = document.createElement("span"), N = document.createTextNode(l);
  if (T.appendChild(N), m.length > 0) {
    const ue = document.createTextNode(m);
    T.appendChild(ue);
  }
  ellipsisContainer.appendChild(T), Object.values(lodashExports.omit(u, "expand")).map((ue) => ue && ellipsisContainer.appendChild(ue.cloneNode(!0)));
  function O() {
    ellipsisContainer.innerHTML = "", ellipsisContainer.appendChild(T), Object.values(u).map((ue) => ue && ellipsisContainer.appendChild(ue.cloneNode(!0)));
  }
  function z(ue, te) {
    const K = ue.length;
    return te ? g === "end" ? ue.slice(0, te) + c : ue.slice(0, te) + c + ue.slice(K - te, K) : c;
  }
  function Q(ue, te, K = 0, ve = te.length, ee = 0) {
    const Re = Math.floor((K + ve) / 2), wt = z(te, Re);
    if (ue.textContent = wt, K >= ve - 1 && ve > 0)
      for (let yt = ve; yt >= K; yt -= 1) {
        const xt = z(te, yt);
        if (ue.textContent = xt, P())
          return xt;
      }
    else if (ve === 0)
      return c;
    return P() ? Q(ue, te, Re, ve, Re) : Q(ue, te, K, Re, ee);
  }
  let W = l;
  return P() || (O(), W = Q(N, l, 0, g === "middle" ? Math.floor(l.length / 2) : l.length)), ellipsisContainer.innerHTML = "", W;
};
let ObserverProperty = /* @__PURE__ */ function(s) {
  return s.Width = "width", s.Height = "height", s.All = "all", s;
}({});
const propTypes$1F = {
  onResize: func,
  observeParent: bool,
  observerProperty: string$3,
  delayTick: number$2,
  style: object$1,
  className: string$3
}, defaultProps$1A = {
  onResize: () => {
  },
  // eslint-disable-line
  observeParent: !1,
  observerProperty: "all",
  delayTick: 0
}, vuePropsType$2Q = vuePropsMake(propTypes$1F, defaultProps$1A), ReactResizeObserver = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2Q
  },
  name: "ReactResizeObserver",
  setup(s, {}) {
    const o = useSlots();
    let l;
    globalThis.ResizeObserver && (l = new ResizeObserver(b));
    let u, c, m, g = /* @__PURE__ */ new Map();
    onMounted(() => {
      globalThis.ResizeObserver && S();
    }), watch(() => s.observeParent, (P, T) => {
      globalThis.ResizeObserver && S(P !== T);
    }), onBeforeUnmount(() => {
      l && (l.disconnect(), l = null, c = null);
    });
    const v = () => {
      try {
        return u;
      } catch {
        return null;
      }
    };
    function b(P) {
      var T, N;
      if (s.observerProperty === ObserverProperty.All)
        (T = s.onResize) == null || T.call(s, P);
      else {
        const O = [];
        for (const z of P)
          g.has(z.target) ? z.contentRect[s.observerProperty] !== g.get(z.target) && (g.set(z.target, z.contentRect[s.observerProperty]), O.push(z)) : (g.set(z.target, z.contentRect[s.observerProperty]), O.push(z));
        O.length > 0 && ((N = s.onResize) == null || N.call(s, O));
      }
    }
    function S(P = !1) {
      const T = v();
      if (l || (l = new ResizeObserver(b)), !(T && T instanceof Element)) {
        l.disconnect();
        return;
      }
      T === c && !P || (l.disconnect(), c = T, l.observe(T), s.observeParent && T.parentNode && T.parentNode.ownerDocument && T.parentNode.ownerDocument.defaultView && T.parentNode instanceof T.parentNode.ownerDocument.defaultView.HTMLElement && (m = T.parentNode, l.observe(m)));
    }
    const E = (P, T) => {
      u = T, typeof P == "function" ? P(T) : typeof P == "object" && P && "current" in P && (P.current = T);
    };
    return () => {
      var N;
      const P = (N = o.default) == null ? void 0 : N.call(o), {
        ref: T
      } = P == null ? void 0 : P[0];
      return cloneVNode(P[0], {
        ref: (O) => E(T == null ? void 0 : T.r, O)
      });
    };
  }
}), vuePropsType$2P = {
  value: String
}, Provider$g = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("TypographyBaseSize", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$2P
  },
  name: "TypographyBaseSizeProvider"
});
function useTypographyBaseSizeContext() {
  return {
    context: inject("TypographyBaseSize", ref$1("normal"))
  };
}
const vuePropsType$2O = {
  name: String
}, Consumer$h = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useTypographyBaseSizeContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$2O
  },
  name: "TypographyBaseSizeConsumer"
}), Context$2 = {
  Provider: Provider$g,
  Consumer: Consumer$h
};
function _isSlot$M(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$N = cssClasses$P.PREFIX, ELLIPSIS_STR = "...", propTypes$1E = {
  copyable: oneOfType([object$1(), bool]),
  delete: bool,
  disabled: bool,
  // editable: PropTypes.bool,
  ellipsis: oneOfType([object$1, bool]),
  mark: bool,
  underline: bool,
  link: [object$1, bool, string$3],
  spacing: string$3,
  strong: bool,
  size: string$3,
  type: string$3,
  style: object$1,
  className: string$3,
  icon: oneOfType([node$1, string$3]),
  heading: string$3,
  component: string$3,
  weight: [string$3, number$2],
  children: [Object, Array, Function, String],
  class: {
    type: String,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  "x-semi-prop": {
    type: String,
    default: ""
  },
  code: Boolean,
  component_: [String, Array, Boolean, Object, Number]
}, defaultProps$1z = {
  copyable: !1,
  delete: !1,
  disabled: !1,
  // editable: false,
  ellipsis: !1,
  icon: "",
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  spacing: "normal",
  size: "normal",
  style: {},
  className: ""
}, vuePropsType$2N = vuePropsMake(propTypes$1E, defaultProps$1z), wrapperDecorations = (s, o) => {
  const {
    mark: l,
    code: u,
    underline: c,
    strong: m,
    link: g,
    disabled: v
  } = s;
  let b = o;
  const S = (E, P) => {
    let T = {};
    E && (typeof E == "object" && (T = {
      ...E
    }), b = h(P, T, b));
  };
  return S(l, "mark"), S(u, "code"), S(c && !g, "u"), S(m, "strong"), S(s.delete, "del"), S(g, v ? "span" : "a"), b;
}, Base = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2N
  },
  name: "Base",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useTypographyBaseSizeContext(), l = ref$1(null), u = ref$1(null), c = ref$1(null);
    let m, g, v, b = !1;
    const S = reactive({
      editable: !1,
      copied: !1,
      // ellipsis
      // if text is overflow in container
      isOverflowed: !1,
      ellipsisContent: s.children,
      expanded: !1,
      // if text is truncated with js
      isTruncated: !1,
      prevChildren: null
    });
    onMounted(() => {
      s.ellipsis && P().then(() => runAfterTicks(() => b = !0, 1));
    });
    function E(tn, ln) {
      const {
        prevChildren: rn
      } = ln, an = {}, Gt = tn.children;
      return an.prevChildren = Gt, tn.ellipsis && rn !== Gt && (an.isOverflowed = !1, an.ellipsisContent = tn.children, an.expanded = !1, an.isTruncated = !1), an;
    }
    watch(() => s.ellipsis, (tn) => {
      const ln = E({
        ...s
      }, {
        ...S
      });
      ln && Object.keys(ln).forEach((rn) => {
        S[rn] = ln[rn];
      });
    }), watch(() => s.children, () => {
      s.ellipsis && P();
    }), onUnmounted(() => {
      m && window.cancelAnimationFrame(m);
    });
    const P = async (tn) => (m && window.cancelAnimationFrame(m), new Promise((ln) => {
      m = window.requestAnimationFrame(async () => {
        await W(), ln();
      });
    }));
    function T() {
      const {
        copyable: tn
      } = s, {
        expandable: ln,
        expandText: rn,
        pos: an,
        suffix: Gt
      } = te();
      return !ln && lodashExports.isUndefined(rn) && !tn && an === "end" && !Gt.length;
    }
    const N = (tn) => !tn || tn < 1 ? !1 : tn <= 1 ? O() : l.value.scrollHeight > l.value.offsetHeight;
    function O() {
      if (!(document && document.createRange))
        return !1;
      const tn = l.value, ln = tn == null ? void 0 : tn.getBoundingClientRect().width, rn = Array.from((tn == null ? void 0 : tn.childNodes) || []), an = document.createRange(), Gt = rn.reduce((nn, vt) => (an.selectNodeContents(vt), nn + (an.getBoundingClientRect().width ?? 0)), 0);
      return an.detach(), Gt > ln;
    }
    const z = () => {
      var dn, yn;
      const {
        isOverflowed: tn,
        isTruncated: ln,
        expanded: rn
      } = S, {
        showTooltip: an,
        expandable: Gt,
        expandText: nn
      } = te(), vt = T(), Et = !rn && (vt ? tn : ln), un = !Gt && lodashExports.isUndefined(nn) && Et && an;
      if (!un)
        return un;
      const gn = {
        type: "tooltip"
      };
      return typeof an == "object" ? an.type && an.type.toLowerCase() === "popover" ? lodashExports.merge({
        opts: {
          // style: {width: '240px'},
          showArrow: !0
        }
      }, an, {
        opts: {
          className: cls({
            [`${prefixCls$N}-ellipsis-popover`]: !0,
            [(dn = an == null ? void 0 : an.opts) == null ? void 0 : dn.className]: !!((yn = an == null ? void 0 : an.opts) != null && yn.className)
          })
        }
      }) : {
        ...gn,
        ...an
      } : gn;
    }, Q = () => {
      if (T()) {
        const {
          rows: ln,
          suffix: rn,
          pos: an
        } = te(), Gt = N(ln);
        S.isOverflowed = Gt, S.isTruncated = !1;
        return;
      }
    };
    function W() {
      const {
        rows: tn,
        suffix: ln,
        pos: rn
      } = te(), an = s.children[0].children;
      if (!l || !l.value)
        return P(), !1;
      const {
        expanded: Gt
      } = S;
      if (T())
        return;
      if (lodashExports.isNull(an))
        return new Promise((un) => {
          S.isOverflowed = !1, S.isTruncated = !1, nextTick(() => {
            un();
          });
        });
      if (warning$1("children" in s && typeof an != "string", "[Semi Typography] Only children with pure text could be used with ellipsis at this moment."), !tn || tn < 0 || Gt)
        return;
      const vt = {
        expand: u.value,
        copy: c && c.value
      }, Et = Array.isArray(an) ? an.join("") : String(an), Qt = getRenderText(
        l.value,
        tn,
        // Perform type conversion on children to prevent component crash due to non-string type of children
        Et,
        vt,
        ELLIPSIS_STR,
        ln,
        rn
      );
      return new Promise((un) => {
        S.isOverflowed = !1, S.ellipsisContent = Qt, S.isTruncated = Et !== Qt, nextTick(() => {
          un();
        });
      });
    }
    const ue = (tn) => {
      const {
        onExpand: ln,
        expandable: rn,
        collapsible: an
      } = te(), {
        expanded: Gt
      } = S;
      ln && ln(!Gt, tn), (rn && !Gt || an && Gt) && (S.expanded = !Gt);
    }, te = () => {
      const {
        ellipsis: tn
      } = s;
      return tn ? {
        rows: 1,
        expandable: !1,
        pos: "end",
        suffix: "",
        showTooltip: !1,
        collapsible: !1,
        expandText: tn.expandable ? g : void 0,
        collapseText: tn.collapsible ? v : void 0,
        ...typeof tn == "object" ? tn : null
      } : {};
    }, K = () => {
      const {
        expanded: tn,
        isTruncated: ln
      } = S;
      if (!ln) return null;
      const {
        expandText: rn,
        expandable: an,
        collapseText: Gt,
        collapsible: nn
      } = te(), vt = !an && lodashExports.isUndefined(rn), Et = !nn && lodashExports.isUndefined(Gt);
      let Qt;
      return !tn && !vt ? Qt = rn : tn && !Et && (Qt = Gt), !vt || !Et ? (
        // TODO: replace `a` tag with `span` in next major version
        // NOTE: may have effect on style
        // eslint-disable-next-line jsx-a11y/anchor-is-valid
        createVNode("a", {
          role: "button",
          tabindex: 0,
          class: `${prefixCls$N}-ellipsis-expand`,
          key: "expand",
          ref: u,
          "aria-label": Qt,
          onClick: ue,
          onKeypress: (un) => isEnterPress(un) && ue(un)
        }, [Qt])
      ) : null;
    }, ve = () => {
      const {
        ellipsis: tn,
        component_: ln
      } = s;
      if (!tn)
        return {
          ellipsisCls: "",
          ellipsisStyle: {}
          // ellipsisAttr: {}
        };
      const {
        rows: rn
      } = te(), {
        expanded: an,
        isTruncated: Gt
      } = S, nn = !an && T(), vt = cls({
        [`${prefixCls$N}-ellipsis`]: !0,
        [`${prefixCls$N}-ellipsis-single-line`]: rn === 1,
        [`${prefixCls$N}-ellipsis-multiple-line`]: rn > 1,
        // component === 'span', Text component, It should be externally displayed inline
        [`${prefixCls$N}-ellipsis-multiple-line-text`]: rn > 1 && ln === "span",
        [`${prefixCls$N}-ellipsis-overflow-ellipsis`]: rn === 1 && nn,
        // component === 'span', Text component, It should be externally displayed inline
        [`${prefixCls$N}-ellipsis-overflow-ellipsis-text`]: rn === 1 && nn && ln === "span"
      }), Et = nn && rn > 1 ? {
        WebkitLineClamp: rn
      } : {};
      return {
        ellipsisCls: vt,
        ellipsisStyle: Et
      };
    }, ee = (tn) => {
      const {
        suffix: ln
      } = tn, rn = s.children, {
        isTruncated: an,
        expanded: Gt,
        isOverflowed: nn,
        ellipsisContent: vt
      } = S;
      return Gt || !an ? createVNode("span", {
        onMouseenter: Q
      }, [rn, ln && ln.length ? ln : null]) : createVNode("span", {
        onMouseenter: Q
      }, [vt, ln]);
    };
    function Re() {
      return createVNode(Fragment, null, [K(), wt()]);
    }
    function wt() {
      const {
        copyable: tn
      } = s, ln = s.children;
      if (!tn)
        return null;
      const rn = (tn == null ? void 0 : tn.content) ?? ln;
      let an, Gt = !1;
      Array.isArray(rn) ? (an = "", rn.forEach((vt) => {
        typeof vt.children == "object" && vt.type.toString() !== "Symbol(v-txt)" && (Gt = !0), an += String(vt.children);
      })) : (typeof rn != "object" || (Gt = !0), an = String(rn)), warning$1(Gt, "Content to be copied in Typography is a object, it will case a [object Object] mistake when copy to clipboard.");
      const nn = {
        content: an,
        duration: 3,
        ...typeof tn == "object" ? tn : null
      };
      return createVNode(Copyable, mergeProps$1(nn, {
        forwardRef: c
      }), null);
    }
    function yt() {
      const {
        icon: tn,
        size: ln
      } = s, rn = ln === "inherit" ? o.value : ln;
      if (!tn)
        return null;
      const an = rn === "small" ? "small" : "default";
      return createVNode("span", {
        class: `${prefixCls$N}-icon`,
        "x-semi-prop": "icon"
      }, [isSemiIcon(tn) ? cloneVNode(tn, {
        size: an
      }) : tn]);
    }
    function xt() {
      const {
        component_: tn,
        component: ln,
        className: rn,
        type: an,
        spacing: Gt,
        disabled: nn,
        style: vt,
        ellipsis: Et,
        icon: Qt,
        size: un,
        link: gn,
        heading: dn,
        weight: yn,
        ...vn
      } = s, Pn = s.children, On = lodashExports.omit(vn, [
        "strong",
        "editable",
        "mark",
        "copyable",
        "underline",
        "code",
        // 'link',
        "delete",
        "children"
      ]), _n = un === "inherit" ? o.value : un, Nn = yt(), Un = te(), {
        ellipsisCls: Xn,
        ellipsisStyle: zn
      } = ve();
      let jn = Et ? ee(Un) : Pn;
      const kn = cls({
        [`${prefixCls$N}-link-text`]: gn,
        [`${prefixCls$N}-link-underline`]: s.underline && gn
      });
      let Yn = wrapperDecorations(s, createVNode(Fragment, null, [Nn, s.link ? createVNode("span", {
        class: kn
      }, [jn]) : jn]));
      const Zn = /^h[1-6]$/, er = lodashExports.isString(dn) && Zn.test(dn), bn = cls(rn, Xn, {
        // [`${prefixCls}-primary`]: !type || type === 'primary',
        [`${prefixCls$N}-${an}`]: an && !gn,
        [`${prefixCls$N}-${_n}`]: _n,
        [`${prefixCls$N}-link`]: gn,
        [`${prefixCls$N}-disabled`]: nn,
        [`${prefixCls$N}-${Gt}`]: Gt,
        [`${prefixCls$N}-${dn}`]: er,
        [`${prefixCls$N}-${dn}-weight-${yn}`]: er && yn && isNaN(Number(yn))
      }), Ln = {
        ...isNaN(Number(yn)) ? {} : {
          fontWeight: yn
        },
        ...vt
      };
      return createVNode(Typography$1, {
        className: bn,
        style: {
          ...Ln,
          ...zn
        },
        component_: tn,
        forwardRef: l,
        ...On
      }, {
        default: () => createVNode(Fragment, null, [Yn, Re()])
      });
    }
    function Kt() {
      const tn = s.children, ln = z(), rn = xt();
      if (ln) {
        const {
          type: an,
          opts: Gt,
          renderTooltip: nn
        } = ln;
        return lodashExports.isFunction(nn) ? nn(tn, rn) : an.toLowerCase() === "popover" ? createVNode(Popover$1, mergeProps$1({
          content: tn ? tn[0] : null,
          position: "top"
        }, Gt), _isSlot$M(rn) ? rn : {
          default: () => [rn]
        }) : createVNode(Tooltip$1, mergeProps$1({
          content: tn ? tn[0] : null,
          position: "top"
        }, Gt), _isSlot$M(rn) ? rn : {
          default: () => [rn]
        });
      } else
        return rn;
    }
    return () => {
      const {
        size: tn
      } = s, ln = tn === "inherit" ? o.value : tn, rn = createVNode(Context$2.Provider, {
        value: ln
      }, {
        default: () => [createVNode(LocaleConsumer$6, {
          componentName: "Typography"
        }, {
          default: (an) => (g = an.expand, v = an.collapse, Kt())
        })]
      });
      return s.ellipsis ? createVNode(ReactResizeObserver, {
        onResize: (...an) => {
          b && P(...an);
        },
        observeParent: !0,
        observerProperty: ObserverProperty.Width
      }, _isSlot$M(rn) ? rn : {
        default: () => [rn]
      }) : rn;
    };
  }
}), vuePropsType$2M = {
  copyable: {
    type: [Object, Boolean],
    default: !1
  },
  delete: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  icon: {
    type: [Object, String],
    default: ""
  },
  // editable: false,
  ellipsis: {
    type: [Object, Boolean],
    default: !1
  },
  mark: {
    type: Boolean,
    default: !1
  },
  underline: {
    type: Boolean,
    default: !1
  },
  strong: {
    type: Boolean,
    default: !1
  },
  link: {
    type: [Boolean, Object, String],
    default: !1
  },
  type: {
    type: String,
    default: "primary"
  },
  style: {
    type: Object,
    default: {}
  },
  size: {
    type: String,
    default: "normal"
  },
  className: {
    type: String,
    default: ""
  },
  component_: {
    type: [Object, String, Function]
  },
  weight: Number,
  code: Boolean
}, Text = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2M
  },
  name: "Text",
  setup(s, {
    slots: o
  }) {
    return () => {
      var l;
      return createVNode(Base, mergeProps$1({
        children: (l = o.default) == null ? void 0 : l.call(o)
      }, {
        ...s,
        component_: s.component_ || "span"
      }), {
        default: o.default
      });
    };
  }
}), TypographyText = Text, vuePropsType$2L = {
  className: {
    type: String,
    default: ""
  },
  class: {
    type: String,
    default: ""
  },
  id: {
    type: String,
    default: ""
  },
  "x-semi-prop": {
    type: String,
    default: ""
  },
  component_: [String, Array, Boolean, Object, Number],
  copyable: {
    type: [Object, Boolean],
    default: !1
  },
  delete: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  ellipsis: {
    type: [Object, Boolean],
    default: !1
  },
  heading: {
    type: [String, Array, Boolean, Object, Number],
    default: 1
  },
  link: {
    type: [Object, Boolean, String],
    default: !1
  },
  mark: {
    type: Boolean,
    default: !1
  },
  strong: {
    type: Boolean,
    default: !1
  },
  style: {
    type: [String, Object],
    default: {}
  },
  type: {
    type: String,
    default: "primary"
  },
  underline: Boolean,
  weight: [String, Number]
}, Title$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2L
  },
  name: "Title",
  setup(s, {
    slots: o
  }) {
    return () => {
      var g;
      const {
        heading: l,
        component_: u,
        ...c
      } = s, m = strings$m.HEADING.indexOf(l) !== -1 ? `h${l}` : "h1";
      return createVNode(Base, mergeProps$1({
        children: (g = o.default) == null ? void 0 : g.call(o),
        component_: u || m,
        heading: m
      }, c), {
        default: o.default
      });
    };
  }
}), TypographyTitle = Title$1, prefixCls$M = cssClasses$P.PREFIX, vuePropsType$2K = {
  copyable: {
    type: [Object, Boolean],
    default: !1
  },
  delete: {
    type: Boolean,
    default: !1
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  // editable: false,
  ellipsis: {
    type: [Object, Boolean],
    default: !1
  },
  mark: {
    type: Boolean,
    default: !1
  },
  underline: {
    type: Boolean,
    default: !1
  },
  strong: {
    type: Boolean,
    default: !1
  },
  link: {
    type: [Boolean, Object, String],
    default: !1
  },
  type: {
    type: String,
    default: "primary"
  },
  size: {
    type: String,
    default: "normal"
  },
  spacing: {
    type: String,
    default: "normal"
  },
  style: {
    type: Object,
    default: {}
  },
  className: {
    type: String,
    default: ""
  },
  component_: {
    type: [Object, String, Function]
  }
}, paragraph$2 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2K
  },
  name: "Paragraph",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    const {
      className: u
    } = s, c = cls(u, `${prefixCls$M}-paragraph`);
    return () => {
      var m;
      return createVNode(Base, mergeProps$1({
        children: (m = o.default) == null ? void 0 : m.call(o)
      }, {
        ...s,
        component_: s.component_ || "p"
      }, l, {
        className: c
      }), null);
    };
  }
}), Paragraph$1 = paragraph$2;
class FormatNumeral {
  constructor(o, l, u, c, m) {
    this.ruleMethods = {
      "bytes-decimal": (g) => {
        const v = ["B", "KB", "MB", "GB", "TB", "PB", "EB", "ZB", "YB"];
        let b = 0;
        for (; g >= 1e3; )
          g /= 1e3, b++;
        return `${this.truncatePrecision(g)} ${v[b]}`;
      },
      "bytes-binary": (g) => {
        const v = ["B", "KiB", "MiB", "GiB", "TiB", "PiB", "EiB", "ZiB", "YiB"];
        let b = 0;
        for (; g >= 1024; )
          g /= 1024, b++;
        return `${this.truncatePrecision(g)} ${v[b]}`;
      },
      percentages: (g) => `${this.truncatePrecision(g * 100)}%`,
      exponential: (g) => {
        const b = g.toExponential(this.precision + 2).split("e");
        return `${this.truncatePrecision(Number(b[0]))}e${b[1]}`;
      }
    }, this.truncateMethods = {
      ceil: Math.ceil,
      floor: Math.floor,
      round: Math.round
    }, this.isDiyParser = typeof m < "u", this.content = o, this.rule = l, this.precision = u, this.truncate = c, this.parser = m;
  }
  // Formatting numbers within a string.
  format() {
    return this.isDiyParser ? this.parser(this.content) : this.rule === "text" ? extractNumbers(this.content).map((o) => checkIsNumeral(o) ? this.truncatePrecision(o) : o).join("") : this.rule === "numbers" ? extractNumbers(this.content).filter((o) => checkIsNumeral(o)).map((o) => this.truncatePrecision(o)).join(",") : extractNumbers(this.content).map((o) => checkIsNumeral(o) ? this.ruleMethods[this.rule](Number(o)) : o).join("");
  }
  truncatePrecision(o) {
    const l = this.truncateMethods[this.truncate](Number(o) * Math.pow(10, this.precision)) / Math.pow(10, this.precision), u = l.toString().split(".");
    if (u.length === 1)
      return l.toFixed(this.precision);
    const c = u[1].length;
    return c < this.precision ? `${u[0]}.${u[1]}${"0".repeat(this.precision - c)}` : l.toString();
  }
}
function extractNumbers(s) {
  const o = /(-?[0-9]*\.?[0-9]+([eE]-?[0-9]+)?)|([^-\d\.]+)/g;
  return s.match(o) || [];
}
function checkIsNumeral(s) {
  return !(isNaN(Number(s)) || s.replace(/\s+/g, "") === "");
}
const propTypes$1D = {
  rule: string$3,
  precision: number$2,
  truncate: string$3,
  parser: func,
  copyable: oneOfType([object$1, bool]),
  delete: bool,
  disabled: bool,
  icon: oneOfType([node$1, string$3]),
  mark: bool,
  underline: bool,
  link: [object$1, bool, string$3],
  strong: bool,
  type: string$3,
  size: string$3,
  style: object$1,
  className: string$3,
  code: bool,
  component_: [string$3, node$1]
}, defaultProps$1y = {
  rule: "text",
  precision: 0,
  truncate: "round",
  parser: void 0,
  copyable: !1,
  delete: !1,
  icon: "",
  mark: !1,
  underline: !1,
  strong: !1,
  link: !1,
  type: "primary",
  style: {},
  size: "normal",
  className: ""
}, vuePropsType$2J = vuePropsMake(propTypes$1D, defaultProps$1y), Numeral = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2J
  },
  name: "Numeral",
  setup(s, {}) {
    const o = useSlots();
    function l(u) {
      return Array.isArray(u) || (u = [u]), u = u.map((c) => {
        if (typeof c == "string" || typeof c == "number")
          return new FormatNumeral(String(c), s.rule, s.precision, s.truncate, s.parser).format();
        if (typeof c == "function")
          return l(c());
        if (typeof c == "object" && "children" in c) {
          let g = function() {
            return Array.isArray(m) ? m : typeof m == "object" ? [m] : c.ctx && c.type !== Text$1 ? [h(Text$1, m)] : m;
          }, m = l(c.children);
          return {
            ...c,
            props: {
              ...c.props
            },
            children: g()
          };
        }
        return c;
      }), u.length === 1 ? u[0] : u;
    }
    return () => {
      const u = Object.assign({}, s);
      return delete u.rule, delete u.parser, u.children = l(getFragmentChildren(o)), createVNode(Base, {
        ...lodashExports.omit(u, "precision", "truncate", "component_"),
        component_: u.component_ || "span"
      }, null);
    };
  }
}), Numeral$1 = Numeral, Typography = Typography$1;
Typography.Text = TypographyText;
Typography.Title = TypographyTitle;
Typography.Paragraph = Paragraph$1;
Typography.Numeral = Numeral$1;
const cssClasses$O = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-input`
}, strings$l = {
  SIZE: ["small", "large", "default"],
  DEFAULT_SIZE: "default",
  STATUS: ["default", "error", "warning", "success"],
  CLEARBTN_CLICKED_EVENT_FLAG: "__fromClearBtn",
  MODE: ["password"]
}, numbers$e = {};
let InputFoundation$1 = class $x extends BaseFoundation$1 {
  static get inputDefaultAdapter() {
    return {
      notifyChange: lodashExports.noop,
      setValue: lodashExports.noop
      // toggleAllowClear: noop,
    };
  }
  constructor(o) {
    super({ ...$x.inputDefaultAdapter, ...o });
  }
  destroy() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
  setDisable() {
  }
  setValue(o) {
    this._adapter.setValue(o);
  }
  handleChange(o, l) {
    const { maxLength: u, minLength: c, getValueLength: m } = this._adapter.getProps();
    let g = o;
    u && lodashExports.isFunction(m) && (g = this.handleVisibleMaxLength(o)), c && lodashExports.isFunction(m) && this.handleVisibleMinLength(g), this._isControlledComponent() ? this._adapter.notifyChange(g, l) : (this._adapter.setValue(g), this._adapter.notifyChange(g, l));
  }
  /**
   * Modify minLength to trigger browser check for minimum length
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMinLength(o) {
    const { minLength: l, getValueLength: u } = this._adapter.getProps(), { minLength: c } = this._adapter.getStates();
    if (lodashExports.isNumber(l) && l >= 0 && lodashExports.isFunction(u) && lodashExports.isString(o)) {
      const m = u(o);
      if (m < l) {
        const g = o.length + (l - m);
        g !== c && this._adapter.setMinLength(g);
      } else
        c !== l && this._adapter.setMinLength(l);
    }
  }
  /**
   * Handle input emoji characters beyond maxLength
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMaxLength(o) {
    const { maxLength: l, getValueLength: u } = this._adapter.getProps();
    if (lodashExports.isNumber(l) && l >= 0 && lodashExports.isFunction(u) && lodashExports.isString(o))
      return u(o) > l ? (console.warn("[Semi Input] The input character is truncated because the input length exceeds the maximum length limit"), this.handleTruncateValue(o, l)) : o;
  }
  /**
   * Truncate input values based on maximum length
   * @param {String} value
   * @param {Number} maxLength
   * @returns {String}
   */
  handleTruncateValue(o, l) {
    const { getValueLength: u } = this._adapter.getProps();
    if (lodashExports.isFunction(u)) {
      let c = "";
      for (let m = 1, g = o.length; m <= g; m++) {
        const v = o.slice(0, m);
        if (u(v) > l)
          return c;
        c = v;
      }
      return c;
    } else
      return o.slice(0, l);
  }
  handleClear(o) {
    let l = o;
    const u = "";
    this._isControlledComponent("value") ? this._adapter.setState({
      isFocus: !1
    }) : this._adapter.setState({
      value: "",
      isFocus: !1
    }), (!l || typeof l != "object") && (l = {}), lodashExports.set(l, strings$l.CLEARBTN_CLICKED_EVENT_FLAG, !0), this._adapter.notifyChange(u, l), this._adapter.notifyClear(l), l && this.stopPropagation(l);
  }
  /**
   * trigger when click input wrapper
   * @param {Event} e
   */
  handleClick(o) {
    const { disabled: l } = this._adapter.getProps(), { isFocus: u } = this._adapter.getStates();
    l || u || this._adapter.isEventTarget(o) && (this._adapter.focusInput(), this._adapter.toggleFocusing(!0));
  }
  handleModeChange(o) {
    o === "password" ? this._adapter.setEyeClosed(!0) : this._adapter.setEyeClosed(!1);
  }
  handleClickEye(o) {
    const l = this._adapter.getState("eyeClosed");
    this._adapter.focusInput(), this._adapter.toggleFocusing(!0), this._adapter.setEyeClosed(!l);
  }
  handleInputType(o) {
    const l = this._adapter.getProp("mode"), u = this._adapter.getState("eyeClosed");
    return l === "password" ? u ? "password" : "text" : o;
  }
  handleMouseDown(o) {
    o.preventDefault();
  }
  handleMouseUp(o) {
    o.preventDefault();
  }
  handleBlur(o) {
    const { value: l } = this.getStates();
    this._adapter.toggleFocusing(!1), this._adapter.notifyBlur(l, o);
  }
  handleFocus(o) {
    const { value: l } = this.getStates();
    this._adapter.toggleFocusing(!0), this._adapter.notifyFocus(l, o);
  }
  handleInput(o) {
    this._adapter.notifyInput(o);
  }
  handleKeyDown(o) {
    this._adapter.notifyKeyDown(o);
  }
  handleKeyUp(o) {
    this._adapter.notifyKeyUp(o);
  }
  handleKeyPress(o) {
    this._adapter.notifyKeyPress(o), o.key === ENTER_KEY && this._adapter.notifyEnterPress(o);
  }
  isAllowClear() {
    const { value: o, isFocus: l, isHovering: u } = this._adapter.getStates(), { showClear: c, disabled: m, showClearIgnoreDisabled: g } = this._adapter.getProps();
    return o && c && (!m || g) && (l || u);
  }
  handleClickPrefixOrSuffix(o) {
    const { disabled: l } = this._adapter.getProps(), { isFocus: u } = this._adapter.getStates();
    !l && !u && (this._adapter.focusInput(), this._adapter.toggleFocusing(!0));
  }
  /**
   * Blocking mousedown events prevents input from losing focus
   * @param {Event} e
   */
  handlePreventMouseDown(o) {
    o && lodashExports.isFunction(o.preventDefault) && o.preventDefault();
  }
  /**
   * A11y: simulate password button click
   */
  handleModeEnterPress(o) {
    ["Enter", " "].includes(o == null ? void 0 : o.key) && (this.handlePreventMouseDown(o), this.handleClickEye(o));
  }
};
const prefixCls$L = cssClasses$O.PREFIX, propTypes$1C = {
  role: string$3,
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-invalid": [bool, string$3],
  "aria-errormessage": string$3,
  "aria-describedby": string$3,
  "aria-required": bool,
  addonBefore: node$1,
  addonAfter: node$1,
  clearIcon: node$1,
  prefix: node$1,
  suffix: node$1,
  mode: String,
  value: any$1,
  defaultValue: any$1,
  disabled: bool,
  readonly: bool,
  autoFocus: bool,
  type: string$3,
  showClear: bool,
  hideSuffix: bool,
  placeholder: any$1,
  size: String,
  className: string$3,
  style: object$1,
  validateStatus: String,
  onClear: func,
  onChange: func,
  onBlur: func,
  onFocus: func,
  onPaste: func,
  onInput: func,
  onKeyDown: func,
  onKeyUp: func,
  onKeyPress: func,
  onEnterPress: func,
  insetLabel: node$1,
  insetLabelId: string$3,
  inputStyle: object$1,
  getValueLength: func,
  preventScroll: bool,
  borderless: bool,
  onlyBorder: number$2,
  minlength: Number,
  maxlength: Number,
  forwardRef: [object$1, func],
  showClearIgnoreDisabled: bool,
  onCompositionstart: func,
  onCompositionend: func
}, defaultProps$1x = {
  addonBefore: "",
  addonAfter: "",
  prefix: "",
  suffix: "",
  readonly: !1,
  type: "text",
  showClear: !1,
  hideSuffix: !1,
  placeholder: "",
  size: "default",
  className: "",
  onClear: lodashExports.noop,
  onChange: lodashExports.noop,
  onBlur: lodashExports.noop,
  onFocus: lodashExports.noop,
  onPaste: lodashExports.noop,
  onInput: lodashExports.noop,
  onKeyDown: lodashExports.noop,
  onKeyUp: lodashExports.noop,
  onKeyPress: lodashExports.noop,
  onEnterPress: lodashExports.noop,
  validateStatus: "default",
  borderless: !1
}, VuePropsType$3 = vuePropsMake(propTypes$1C, defaultProps$1x), Input = /* @__PURE__ */ defineComponent({
  props: {
    ...VuePropsType$3
  },
  name: "Input",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    const {
      getProps: u
    } = useHasInProps(), c = "value" in u(s) ? s.value : s.defaultValue, m = reactive({
      value: c,
      cachedValue: s.value,
      // Cache current props.value value
      disabled: !1,
      props: {},
      paddingLeft: "",
      isFocus: !1,
      isHovering: !1,
      eyeClosed: s.mode === "password",
      minlength: s.minlength,
      maxlength: s.maxlength
    }), {
      adapter: g
    } = useBaseComponent(s, m), v = b();
    function b() {
      return {
        ...g(),
        setValue: (rn) => {
          m.value = rn;
        },
        setEyeClosed: (rn) => m.eyeClosed = rn,
        toggleFocusing: (rn) => {
          m.isFocus = rn;
        },
        focusInput: () => {
          const {
            preventScroll: rn
          } = s, an = S && S.value;
          an && an.focus({
            preventScroll: rn
          });
        },
        toggleHovering: (rn) => m.isHovering = rn,
        getIfFocusing: () => m.isFocus,
        notifyChange: (rn, an) => {
          s.onChange(rn, an);
        },
        notifyBlur: (rn, an) => s.onBlur(an),
        notifyFocus: (rn, an) => s.onFocus(an),
        notifyInput: (rn) => s.onInput(rn),
        notifyKeyPress: (rn) => s.onKeyPress(rn),
        notifyKeyDown: (rn) => s.onKeyDown(rn),
        notifyKeyUp: (rn) => s.onKeyUp(rn),
        notifyEnterPress: (rn) => s.onEnterPress(rn),
        notifyClear: (rn) => s.onClear(rn),
        setMinLength: (rn) => m.minlength,
        isEventTarget: (rn) => rn && rn.target === rn.currentTarget
      };
    }
    let S = ref$1(null);
    ref$1(null), ref$1(null);
    let E = new InputFoundation$1(v);
    function P(rn, an) {
      const Gt = {};
      return rn.value !== an.cachedValue && (Gt.value = rn.value, Gt.cachedValue = rn.value), Gt;
    }
    watch(() => s.value, (rn) => {
      const an = P({
        ...u(s)
      }, {
        ...m
      });
      an && Object.keys(an).forEach((Gt) => {
        m[Gt] = an[Gt];
      });
    }, {
      immediate: !0
    }), watch(() => s.mode, (rn, an) => {
      rn !== an && Q(an);
    }), onMounted(() => {
      E.init();
      const {
        disabled: rn,
        autoFocus: an,
        preventScroll: Gt
      } = s;
      !rn && (s.autoFocus || l.autofocus) && S.value.focus({
        preventScroll: Gt
      });
    });
    const T = (rn) => {
      E.handleClear(rn);
    }, N = (rn) => {
      E.handleClick(rn);
    }, O = (rn) => {
      m.isHovering = !0;
    }, z = (rn) => {
      m.isHovering = !1;
    }, Q = (rn) => {
      E.handleModeChange(rn);
    }, W = (rn) => {
      E.handleClickEye(rn);
    }, ue = (rn) => {
      E.handleMouseDown(rn);
    }, te = (rn) => {
      E.handleMouseUp(rn);
    }, K = (rn) => {
      E.handleModeEnterPress(rn);
    }, ve = (rn) => {
      E.handleClickPrefixOrSuffix(rn);
    }, ee = (rn) => {
      E.handlePreventMouseDown(rn);
    };
    function Re() {
      const {
        addonBefore: rn
      } = s;
      if (rn) {
        const an = cls({
          [`${prefixCls$L}-prepend`]: !0,
          [`${prefixCls$L}-prepend-text`]: rn && lodashExports.isString(rn),
          [`${prefixCls$L}-prepend-icon`]: isSemiIcon(rn)
        });
        return createVNode("div", {
          class: an,
          "x-semi-prop": "addonBefore"
        }, [rn]);
      }
      return null;
    }
    function wt() {
      const {
        addonAfter: rn
      } = s;
      if (rn) {
        const an = cls({
          [`${prefixCls$L}-append`]: !0,
          [`${prefixCls$L}-append-text`]: rn && lodashExports.isString(rn),
          [`${prefixCls$L}-append-icon`]: isSemiIcon(rn)
        });
        return createVNode("div", {
          class: an,
          "x-semi-prop": "addonAfter"
        }, [rn]);
      }
      return null;
    }
    function yt() {
      const rn = cls(`${prefixCls$L}-clearbtn`), {
        clearIcon: an
      } = s;
      return E.isAllowClear() ? createVNode("div", {
        class: rn,
        onMousedown: T
      }, [an || createVNode(IconComponent$w, null, null)]) : null;
    }
    function xt() {
      const {
        eyeClosed: rn
      } = m, {
        mode: an,
        disabled: Gt
      } = s, nn = cls(`${prefixCls$L}-modebtn`), vt = rn ? createVNode(IconComponent$p, null, null) : createVNode(IconComponent$o, null, null), Et = an === "password" && !Gt, Qt = rn ? "Show password" : "Hidden password";
      return Et ? createVNode("div", {
        role: "button",
        tabindex: 0,
        "aria-label": Qt,
        class: nn,
        onClick: W,
        onMousedown: ue,
        onMouseup: te,
        onKeypress: K
      }, [vt]) : null;
    }
    function Kt() {
      const {
        prefix: rn,
        insetLabel: an,
        insetLabelId: Gt
      } = s, nn = rn || an;
      if (!nn)
        return null;
      const vt = cls({
        [`${prefixCls$L}-prefix`]: !0,
        [`${prefixCls$L}-inset-label`]: an,
        [`${prefixCls$L}-prefix-text`]: nn && lodashExports.isString(nn),
        [`${prefixCls$L}-prefix-icon`]: isSemiIcon(nn)
      });
      return createVNode("div", {
        class: vt,
        onMousedown: ee,
        onClick: ve,
        id: Gt,
        "x-semi-prop": "prefix,insetLabel"
      }, [nn]);
    }
    function tn(rn) {
      const {
        suffix: an,
        hideSuffix: Gt
      } = s;
      if (!an)
        return null;
      const nn = cls({
        [`${prefixCls$L}-suffix`]: !0,
        [`${prefixCls$L}-suffix-text`]: an && lodashExports.isString(an),
        [`${prefixCls$L}-suffix-icon`]: isSemiIcon(an),
        [`${prefixCls$L}-suffix-hidden`]: rn && !!Gt
      });
      return createVNode("div", {
        class: nn,
        onMousedown: ee,
        onClick: ve,
        "x-semi-prop": "suffix"
      }, [an]);
    }
    function ln() {
      const {
        forwardRef: rn
      } = s;
      if (!lodashExports.isUndefined(rn)) {
        if (typeof rn == "function")
          return (an) => {
            rn(an), S.value = an;
          };
        if (Object.prototype.toString.call(rn) === "[object Object]")
          return S = rn, rn;
      }
      return S;
    }
    return () => {
      const {
        addonAfter: rn,
        addonBefore: an,
        autoFocus: Gt,
        className: nn,
        disabled: vt,
        placeholder: Et,
        prefix: Qt,
        mode: un,
        insetLabel: gn,
        insetLabelId: dn,
        validateStatus: yn,
        type: vn,
        readonly: Pn,
        size: On,
        suffix: _n,
        style: Nn,
        showClear: Un,
        onEnterPress: Xn,
        onClear: zn,
        hideSuffix: jn,
        inputStyle: kn,
        forwardRef: Yn,
        maxlength: Zn,
        getValueLength: er,
        defaultValue: bn,
        preventScroll: Ln,
        borderless: Kn,
        showClearIgnoreDisabled: Bn,
        onlyBorder: Fn,
        ...Gn
      } = u(s), {
        value: Wn,
        isFocus: Mn,
        minlength: Tn
      } = m, Rn = E.isAllowClear(), hn = isSemiIcon(_n), Qn = ln(), rr = `${prefixCls$L}-wrapper`, tr = cls(rr, nn, {
        [`${prefixCls$L}-wrapper__with-prefix`]: Qt || gn,
        [`${prefixCls$L}-wrapper__with-suffix`]: _n,
        [`${prefixCls$L}-wrapper__with-suffix-hidden`]: Rn && !!jn,
        [`${prefixCls$L}-wrapper__with-suffix-icon`]: hn,
        [`${prefixCls$L}-wrapper__with-append`]: an,
        [`${prefixCls$L}-wrapper__with-prepend`]: rn,
        [`${prefixCls$L}-wrapper__with-append-only`]: an && !rn,
        [`${prefixCls$L}-wrapper__with-prepend-only`]: !an && rn,
        [`${rr}-readonly`]: Pn,
        [`${rr}-disabled`]: vt,
        [`${rr}-warning`]: yn === "warning",
        [`${rr}-error`]: yn === "error",
        [`${rr}-focus`]: Mn,
        [`${rr}-clearable`]: Un,
        [`${rr}-modebtn`]: un === "password",
        [`${rr}-hidden`]: vn === "hidden",
        [`${rr}-${On}`]: On,
        [`${prefixCls$L}-borderless`]: Kn,
        [`${prefixCls$L}-only_border`]: Fn != null
      }), Cr = cls(prefixCls$L, {
        [`${prefixCls$L}-${On}`]: On,
        [`${prefixCls$L}-disabled`]: vt,
        [`${prefixCls$L}-sibling-clearbtn`]: E.isAllowClear(),
        [`${prefixCls$L}-sibling-modebtn`]: un === "password"
      }), Fr = Wn ?? "", An = {
        ...l,
        ...Gn,
        style: {
          ...kn
        },
        autofocus: Gt,
        class: Cr,
        disabled: vt,
        readonly: Pn,
        type: E.handleInputType(vn),
        placeholder: Et,
        onInput: (ir) => {
          E.handleChange(ir.target.value, ir);
        },
        onChange: (ir) => {
        },
        onFocus: (ir) => E.handleFocus(ir),
        onPaste: s.onPaste,
        onBlur: (ir) => E.handleBlur(ir),
        onKeyup: (ir) => E.handleKeyUp(ir),
        onKeydown: (ir) => E.handleKeyDown(ir),
        onKeypress: (ir) => E.handleKeyPress(ir),
        value: Fr
      };
      lodashExports.isFunction(er) || (An.maxlength = Zn), Tn && (An.minlength = Tn), yn === "error" && (An["aria-invalid"] = "true");
      let Hn = {
        ...Nn
      };
      return Fn !== void 0 && (Hn = {
        borderWidth: styleNum(Fn),
        ...Nn
      }), // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
      createVNode("div", {
        class: tr,
        style: Hn,
        onMouseenter: (ir) => O(),
        onMouseleave: (ir) => z(),
        onClick: (ir) => N(ir)
      }, [Re(), Kt(), createVNode("input", mergeProps$1(An, {
        ref: Qn
      }), null), yt(), tn(Rn), xt(), wt()]);
    };
  }
}), Input$1 = Input;
let hiddenTextarea = null;
const HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
}, forceHiddenStyles = (s) => {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach((o) => {
    s.style.setProperty(
      o,
      HIDDEN_TEXTAREA_STYLE[o],
      "important"
    );
  });
}, getContentHeight = (s, o) => {
  const l = s.scrollHeight;
  return o.sizingStyle.boxSizing === "border-box" ? l + o.borderSize : l - o.paddingSize;
};
function calculateNodeHeight(s, o, l = 1, u = 1 / 0) {
  hiddenTextarea || (hiddenTextarea = document.createElement("textarea"), hiddenTextarea.setAttribute("tab-index", "-1"), hiddenTextarea.setAttribute("aria-hidden", "true"), forceHiddenStyles(hiddenTextarea)), hiddenTextarea.parentNode === null && document.body.appendChild(hiddenTextarea);
  const { paddingSize: c, borderSize: m, sizingStyle: g } = s, { boxSizing: v } = g;
  Object.keys(g).forEach((T) => {
    hiddenTextarea.style[T] = g[T];
  }), forceHiddenStyles(hiddenTextarea), hiddenTextarea.value = o;
  let b = getContentHeight(hiddenTextarea, s);
  hiddenTextarea.value = "x";
  const S = getContentHeight(hiddenTextarea, s) - c - m;
  let E = S * l;
  v === "border-box" && (E = E + c + m), b = Math.max(E, b);
  let P = S * u;
  return v === "border-box" && (P = P + c + m), b = Math.min(P, b), b;
}
const SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width"
], getSizingData = (s) => {
  const o = window.getComputedStyle(s);
  if (o === null)
    return null;
  const l = lodashExports.pick(o, SIZING_STYLE), { boxSizing: u } = l;
  if (u === "")
    return null;
  const c = parseFloat(l.paddingBottom) + parseFloat(l.paddingTop), m = parseFloat(l.borderBottomWidth) + parseFloat(l.borderTopWidth);
  return {
    sizingStyle: l,
    paddingSize: c,
    borderSize: m
  };
};
class TextAreaFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({
      ...TextAreaFoundation.textAreaDefaultAdapter,
      ...o
    }), this.resizeTextarea = () => {
      const { height: l } = this.getStates(), { rows: u, autosize: c } = this.getProps(), m = this._adapter.getRef(), g = getSizingData(m);
      if (!g)
        return;
      const [v, b] = c !== null && typeof c == "object" ? [
        (c == null ? void 0 : c.minRows) ?? u,
        c == null ? void 0 : c.maxRows
      ] : [u], S = calculateNodeHeight(
        g,
        m.value || m.placeholder || "x",
        v,
        b
      );
      if (l !== S) {
        this._adapter.notifyHeightUpdate(S), m.style.height = `${S}px`;
        return;
      }
    };
  }
  static get textAreaDefaultAdapter() {
    return {
      notifyChange: lodashExports.noop,
      setValue: lodashExports.noop,
      toggleFocusing: lodashExports.noop,
      toggleHovering: lodashExports.noop,
      notifyFocus: lodashExports.noop,
      notifyBlur: lodashExports.noop,
      notifyKeyDown: lodashExports.noop,
      notifyEnterPress: lodashExports.noop
    };
  }
  destroy() {
  }
  handleValueChange(o) {
    this._adapter.setValue(o);
  }
  handleChange(o, l) {
    const { maxLength: u, minLength: c, getValueLength: m } = this._adapter.getProps();
    let g = o;
    u && lodashExports.isFunction(m) && (g = this.handleVisibleMaxLength(o)), c && lodashExports.isFunction(m) && this.handleVisibleMinLength(g), this._isControlledComponent() ? this._adapter.notifyChange(g, l) : (this._adapter.setValue(g), this._adapter.notifyChange(g, l));
  }
  /**
   * Modify minLength to trigger browser check for minimum length
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMinLength(o) {
    const { minLength: l, getValueLength: u } = this._adapter.getProps(), { minLength: c } = this._adapter.getStates();
    if (lodashExports.isNumber(l) && l >= 0 && lodashExports.isFunction(u) && lodashExports.isString(o)) {
      const m = u(o);
      if (m < l) {
        const g = o.length + (l - m);
        g !== c && this._adapter.setMinLength(g);
      } else
        c !== l && this._adapter.setMinLength(l);
    }
  }
  /**
   * Handle input emoji characters beyond maxLength
   * Controlled mode is not checked
   * @param {String} value
   */
  handleVisibleMaxLength(o) {
    const { maxLength: l, getValueLength: u } = this._adapter.getProps();
    if (lodashExports.isNumber(l) && l >= 0 && lodashExports.isString(o)) {
      if (lodashExports.isFunction(u)) {
        if (u(o) > l)
          return console.warn("[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit"), this.handleTruncateValue(o, l);
      } else if (o.length > l)
        return console.warn("[Semi TextArea] The input character is truncated because the input length exceeds the maximum length limit"), o.slice(0, l);
      return o;
    }
  }
  /**
   * Truncate textarea values based on maximum length
   * @param {String} value
   * @param {Number} maxLength
   * @returns {String}
   */
  handleTruncateValue(o, l) {
    const { getValueLength: u } = this._adapter.getProps();
    if (lodashExports.isFunction(u)) {
      let c = "";
      for (let m = 1, g = o.length; m <= g; m++) {
        const v = o.slice(0, m);
        if (u(v) > l)
          return c;
        c = v;
      }
      return c;
    } else
      return o.slice(0, l);
  }
  handleFocus(o) {
    const { value: l } = this.getStates();
    this._adapter.toggleFocusing(!0), this._adapter.notifyFocus(l, o);
  }
  handleBlur(o) {
    const { value: l } = this.getStates(), { maxLength: u } = this.getProps();
    let c = l;
    u && (c = this.handleVisibleMaxLength(l), c !== l && (this._isControlledComponent() || this._adapter.setValue(c), this._adapter.notifyChange(c, o))), this._adapter.toggleFocusing(!1), this._adapter.notifyBlur(c, o);
  }
  handleKeyDown(o) {
    this._adapter.notifyKeyDown(o), o.keyCode === 13 && this._adapter.notifyPressEnter(o);
  }
  // e: MouseEvent
  handleMouseEnter(o) {
    this._adapter.toggleHovering(!0);
  }
  // e: MouseEvent
  handleMouseLeave(o) {
    this._adapter.toggleHovering(!1);
  }
  isAllowClear() {
    const { value: o, isFocus: l, isHover: u } = this._adapter.getStates(), { showClear: c, disabled: m, readonly: g } = this._adapter.getProps();
    return o && c && !m && (l || u) && !g;
  }
  handleClear(o) {
    const { isFocus: l } = this.getStates();
    this._isControlledComponent("value") ? this._adapter.setState({
      isFocus: !1
    }) : this._adapter.setState({
      value: "",
      isFocus: !1
    }), l && this._adapter.notifyBlur("", o), this._adapter.notifyChange("", o), this._adapter.notifyClear(o), this.stopPropagation(o);
  }
}
const prefixCls$K = cssClasses$O.PREFIX, propTypes$1B = {
  autosize: [bool, object$1],
  borderless: bool,
  placeholder: string$3,
  value: string$3,
  rows: number$2,
  cols: number$2,
  maxCount: number$2,
  onEnterPress: func,
  validateStatus: string$3,
  className: string$3,
  style: object$1,
  showClear: bool,
  onClear: func,
  onResize: func,
  getValueLength: func,
  // TODO
  // resize: PropTypes.bool,
  class: {
    type: String,
    default: ""
  },
  defaultValue: {
    type: [String, Boolean, Object, Array, void 0],
    // @ts-ignore
    default: void 0
  },
  disabled: Boolean,
  readonly: Boolean,
  autoFocus: Boolean,
  showCounter: {
    type: Boolean,
    default: !1
  },
  minlength: Number,
  maxlength: Number,
  "onUpdate:value": Function,
  onChange: {
    type: Function,
    default: lodashExports.noop
  },
  onBlur: {
    type: Function,
    default: lodashExports.noop
  },
  onFocus: {
    type: Function,
    default: lodashExports.noop
  },
  onInput: {
    type: Function,
    default: lodashExports.noop
  },
  onKeyDown: {
    type: Function,
    default: lodashExports.noop
  },
  onKeyUp: {
    type: Function,
    default: lodashExports.noop
  },
  onKeyPress: {
    type: Function,
    default: lodashExports.noop
  },
  onPressEnter: {
    type: Function,
    default: lodashExports.noop
  },
  forwardRef: {
    type: Function,
    default: lodashExports.noop
  }
}, defaultProps$1w = {
  autosize: !1,
  borderless: !1,
  rows: 4,
  cols: 20,
  showCounter: !1,
  showClear: !1,
  onEnterPress: lodashExports.noop,
  onChange: lodashExports.noop,
  onBlur: lodashExports.noop,
  onFocus: lodashExports.noop,
  onKeyDown: lodashExports.noop,
  onResize: lodashExports.noop,
  onClear: lodashExports.noop
  // resize: false,
}, VuePropsType$2 = vuePropsMake(propTypes$1B, defaultProps$1w), TextArea = /* @__PURE__ */ defineComponent({
  props: VuePropsType$2,
  name: "TextArea",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    const {
      getProps: u
    } = useHasInProps();
    let c = ref$1(null);
    const m = s["onUpdate:value"], g = "value" in u(s) ? s.value : s.defaultValue, v = reactive({
      value: g,
      isFocus: !1,
      maxlength: 0,
      isHover: !1,
      height: 0,
      minlength: s.minlength,
      cachedValue: s.value
    }), {
      adapter: b
    } = useBaseComponent(s, v), S = E();
    watch(() => v.value, () => {
      s.autosize && Q.resizeTextarea();
    });
    function E() {
      return {
        ...b(),
        setValue: (ue) => {
          m && m(ue), v.value = ue;
        },
        getRef: () => c.value,
        toggleFocusing: (ue) => v.isFocus = ue,
        toggleHovering: (ue) => v.isHover = ue,
        notifyChange: (ue, te) => {
          s.onChange(ue, te);
        },
        notifyClear: (ue) => s.onClear(ue),
        notifyBlur: (ue, te) => s.onBlur(te),
        notifyFocus: (ue, te) => s.onFocus(te),
        notifyKeyDown: (ue) => {
          s.onKeyDown(ue);
        },
        notifyHeightUpdate: (ue) => {
          v.height = ue, s.onResize({
            height: ue
          });
        },
        notifyPressEnter: (ue) => {
          s.onEnterPress && s.onEnterPress(ue);
        },
        setMinLength: (ue) => v.minlength = ue
      };
    }
    function P(ue, te) {
      const K = {};
      return ue.value !== te.cachedValue && (K.value = ue.value, K.cachedValue = ue.value), K;
    }
    watch(() => s.value, (ue) => {
      const te = P({
        ...s
      }, {
        ...v
      });
      te && Object.keys(te).forEach((K) => {
        v[K] = te[K];
      });
    }, {
      immediate: !0
    }), onMounted(() => {
      var ue;
      W && ((ue = W == null ? void 0 : W.cancel) == null || ue.call(W), W = null);
    }), watch([() => s.value, () => s.autosize, () => s.placeholder], (ue, [te, K, ve]) => {
      (s.value !== te || s.placeholder !== ve) && s.autosize && Q.resizeTextarea();
    });
    const T = (ue) => {
      Q.handleClear(ue);
    };
    function N() {
      const {
        showClear: ue
      } = s, te = Q.isAllowClear(), K = cls(`${prefixCls$K}-clearbtn`, {
        [`${prefixCls$K}-clearbtn-hidden`]: !te
      });
      return ue ? createVNode("div", {
        class: K,
        onClick: T
      }, [createVNode(IconComponent$w, null, null)]) : null;
    }
    function O() {
      let ue, te, K, ve;
      const {
        showCounter: ee,
        maxCount: Re,
        getValueLength: wt
      } = s;
      if (ee || Re) {
        const {
          value: yt
        } = v;
        te = yt ? lodashExports.isFunction(wt) ? wt(yt) : yt.length : 0, K = Re || null, ve = cls(`${prefixCls$K}-textarea-counter`, {
          [`${prefixCls$K}-textarea-counter-exceed`]: te > K
        }), ue = createVNode("div", {
          class: ve
        }, [te, K ? "/" : null, K]);
      } else
        ue = null;
      return ue;
    }
    const z = (ue) => {
      c.value = ue;
      const {
        forwardRef: te
      } = s;
      typeof te == "function" ? te(ue) : te && typeof te == "object" && (te.current = ue);
    };
    let Q = new TextAreaFoundation(S), W = lodashExports.throttle(Q.resizeTextarea, 10);
    return () => {
      const {
        autosize: ue,
        placeholder: te,
        onEnterPress: K,
        onResize: ve,
        // resize,
        disabled: ee,
        readonly: Re,
        class: wt,
        showCounter: yt,
        validateStatus: xt,
        maxCount: Kt,
        defaultValue: tn,
        style: ln,
        forwardRef: rn,
        autoFocus: an,
        getValueLength: Gt,
        maxlength: nn,
        minlength: vt,
        showClear: Et,
        borderless: Qt,
        ...un
      } = s, {
        isFocus: gn,
        value: dn,
        minlength: yn
      } = v, vn = cls(wt, `${prefixCls$K}-textarea-wrapper`, {
        [`${prefixCls$K}-textarea-borderless`]: Qt,
        [`${prefixCls$K}-textarea-wrapper-disabled`]: ee,
        [`${prefixCls$K}-textarea-wrapper-readonly`]: Re,
        [`${prefixCls$K}-textarea-wrapper-${xt}`]: !!xt,
        [`${prefixCls$K}-textarea-wrapper-focus`]: gn
        // [`${prefixCls}-textarea-wrapper-resize`]: !autosize && resize,
      }), Pn = cls(`${prefixCls$K}-textarea`, {
        [`${prefixCls$K}-textarea-disabled`]: ee,
        [`${prefixCls$K}-textarea-readonly`]: Re,
        [`${prefixCls$K}-textarea-autosize`]: typeof ue != "boolean" ? lodashExports.isUndefined(ue == null ? void 0 : ue.maxRows) : ue,
        [`${prefixCls$K}-textarea-showClear`]: Et
      }), On = {
        ...l,
        ...lodashExports.omit(un, "insetLabel", "insetLabelId", "getValueLength", "onClear", "showClear"),
        class: Pn,
        disabled: ee,
        autofocus: an || l.autofocus,
        readonly: Re,
        placeholder: te || null,
        onInput: (_n) => {
          Q.handleChange(_n.target.value, _n);
        },
        onChange: (_n) => {
        },
        onFocus: (_n) => Q.handleFocus(_n),
        onBlur: (_n) => Q.handleBlur(_n),
        onKeydown: (_n) => {
          Q.handleKeyDown(_n);
        },
        value: dn ?? ""
      };
      return lodashExports.isFunction(Gt) || (On.maxLength = nn), yn && (On.minLength = yn), createVNode("div", {
        class: vn,
        style: ln,
        onMouseenter: (_n) => Q.handleMouseEnter(_n),
        onMouseleave: (_n) => Q.handleMouseLeave(_n)
      }, [ue ? createVNode(ReactResizeObserver, {
        onResize: W
      }, {
        default: () => [createVNode("textarea", mergeProps$1(On, {
          ref: z
        }), null)]
      }) : createVNode("textarea", mergeProps$1(On, {
        ref: z
      }), null), N(), O()]);
    };
  }
}), TextArea$1 = TextArea, radioClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-radio`,
  INNER: `${BASE_CLASS_PREFIX$1}-radio-inner`,
  TEXT: `${BASE_CLASS_PREFIX$1}-radio-text`,
  INPUT: `${BASE_CLASS_PREFIX$1}-radio-input`,
  CHECKED: `${BASE_CLASS_PREFIX$1}-radio-checked`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-radio-disabled`,
  BUTTON: `${BASE_CLASS_PREFIX$1}-radio-button`
}, radioGroupClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-radioGroup`,
  INNER: `${BASE_CLASS_PREFIX$1}-radioGroup-inner`,
  TEXT: `${BASE_CLASS_PREFIX$1}-radioGroup-text`,
  INPUT: `${BASE_CLASS_PREFIX$1}-radioGroup-input`,
  CHECKED: `${BASE_CLASS_PREFIX$1}-radioGroup-checked`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-radioGroup-disabled`
}, strings$k = {
  DIRECTION_SET: ["horizontal", "vertical"],
  DEFAULT_DIRECTION: "horizontal",
  MODE: ["advanced", ""],
  TYPE_DEFAULT: "default",
  TYPE_BUTTON: "button",
  TYPE_CARD: "card",
  TYPE_PURECARD: "pureCard",
  BUTTON_SIZE: ["middle", "small", "large"]
};
class RadioGroupFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    const o = this._getDisplayValue();
    this._setValue(o);
  }
  _getDisplayValue() {
    const { value: o, defaultValue: l } = this.getProps();
    let u;
    return "value" in this.getProps() ? u = o : "defaultValue" in this.getProps() && (u = l), u;
  }
  handleChange(o) {
    const l = this.getProp("mode"), u = this.getState("value"), { checked: c, value: m } = o.target, g = this._adapter.isInProps("value"), v = {
      ...o,
      target: {
        ...o.target,
        value: m
      }
    };
    l === "advanced" && !c && (v.target.value = void 0), g || (l === "advanced" && !c ? this._setValue(void 0) : this._setValue(m)), (l === "advanced" || u !== m) && this._adapter.notifyChange(v);
  }
  // call when prop.value change
  handlePropValueChange(o) {
    this._setValue(o);
  }
  _setValue(o) {
    this._adapter.setValue(o);
  }
  destroy() {
  }
}
class RadioFoundation extends BaseFoundation$1 {
  constructor() {
    super(...arguments), this.handleFocusVisible = (o) => {
      const { target: l } = o;
      try {
        l.matches(":focus-visible") && this._adapter.setFocusVisible(!0);
      } catch {
        warning$1(!0, "Warning: [Semi Radio] The current browser does not support the focus-visible");
      }
    }, this.handleBlur = () => {
      this._adapter.setFocusVisible(!1);
    };
  }
  init() {
    const { children: o, extra: l, extraId: u, addonId: c } = this._adapter.getProps();
    o && !c && this._adapter.setAddonId(), l && !u && this._adapter.setExtraId();
  }
  setHover(o) {
    this._adapter.setHover(o);
  }
  setChecked(o) {
    this._adapter.setChecked(o);
  }
}
class RadioInnerFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    const o = this._adapter.getProp("checked"), l = this._adapter.getProp("defaultChecked");
    this.setChecked(o || l);
  }
  setChecked(o) {
    this._adapter.setNativeControlChecked(o);
  }
  getChecked() {
    return this._adapter.getProp("checked");
  }
  handleChange(o) {
    const l = "checked" in this.getProps(), { checked: u } = o.target, c = () => {
      o.stopPropagation();
    }, m = () => {
      o.preventDefault();
    }, g = {
      target: {
        ...this.getProps(),
        checked: u
      },
      stopPropagation: c,
      preventDefault: m
    };
    l ? this._adapter.notifyChange(g) : (this.setChecked(u), this._adapter.notifyChange(g));
  }
  destroy() {
  }
}
const vuePropsType$2I = {
  checked: {
    type: Boolean,
    // @ts-ignore
    default: void 0
  },
  disabled: Boolean,
  isButtonRadio: {
    type: Boolean,
    default: !1
  },
  onChange: {
    type: Function,
    default: lodashExports.noop
  },
  mode: String,
  autoFocus: Boolean,
  name: String,
  prefixCls: String,
  // ref: [Object, String],
  isPureCardRadioGroup: Boolean,
  addonId: String,
  extraId: String,
  "aria-label": String,
  className: String,
  // TODO 区别
  defaultChecked: {
    type: Boolean,
    default: !1
  },
  value: [String, Boolean, Number],
  type: {
    type: String,
    default: "default"
  },
  focusInner: Boolean,
  onInputFocus: Function,
  onInputBlur: Function,
  preventScroll: Boolean,
  style: Object
}, RadioInner = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2I
  },
  name: "RadioInner",
  setup(s, {
    slots: o
  }) {
    let l;
    const u = reactive({
      checked: !1
    }), {
      adapter: c
    } = useBaseComponent(s, u), m = g();
    function g() {
      return {
        ...c(),
        setNativeControlChecked: (S) => {
          u.checked = S;
        },
        notifyChange: (S) => {
          s.onChange(S);
        }
      };
    }
    l = new RadioInnerFoundation(m), onMounted(() => {
      l.init();
    }), watch(() => s.checked, (S, E) => {
      S !== E && l.setChecked(s.checked);
    }), onUnmounted(() => {
      l.destroy();
    });
    const v = ref$1(symbol());
    function b(S) {
      l.handleChange(S), v.value = symbol();
    }
    return () => {
      const {
        disabled: S,
        mode: E,
        autoFocus: P,
        name: T,
        isButtonRadio: N,
        isPureCardRadioGroup: O,
        addonId: z,
        extraId: Q,
        "aria-label": W,
        focusInner: ue,
        onInputFocus: te,
        onInputBlur: K
      } = s, {
        checked: ve
      } = u, ee = s.prefixCls || radioClasses.PREFIX, Re = cls({
        [`${ee}-inner`]: !0,
        [`${ee}-inner-checked`]: !!ve,
        [`${ee}-inner-buttonRadio`]: N,
        [`${ee}-inner-pureCardRadio`]: O
      }), wt = cls({
        [`${ee}-focus`]: ue,
        [`${ee}-focus-border`]: ue && !ve,
        [`${ee}-inner-display`]: !N
      });
      return createVNode("span", {
        class: Re,
        style: {
          opacity: 1
        }
      }, [createVNode("input", {
        ref: (yt) => {
        },
        key: v.value,
        autofocus: P,
        type: E === "advanced" ? "checkbox" : "radio",
        checked: !!ve,
        disabled: S,
        onChange: b,
        name: T,
        "aria-label": W,
        "aria-labelledby": z,
        "aria-describedby": Q,
        onFocus: te,
        onBlur: K
      }, null), createVNode("span", {
        class: wt
      }, [ve ? createVNode(IconComponent$d, null, null) : null])]);
    };
  }
}), vuePropsType$2H = {
  autoFocus: {
    type: Boolean,
    default: !1
  },
  checked: {
    type: [Boolean],
    // @ts-ignore
    default: void 0
  },
  defaultChecked: {
    type: Boolean,
    default: !1
  },
  value: [String, Number],
  disabled: Boolean,
  prefixCls: String,
  displayMode: String,
  onChange: Function,
  onMouseEnter: {
    type: Function,
    default: lodashExports.noop
  },
  onMouseLeave: {
    type: Function,
    default: lodashExports.noop
  },
  mode: {
    type: String,
    default: ""
  },
  extra: [Object, String],
  style: [Object, String],
  className: String,
  addonStyle: [Object, String],
  addonClassName: String,
  type: {
    type: String,
    default: "default"
  },
  "aria-label": String,
  addonId: String,
  extraId: String,
  name: String,
  preventScroll: Boolean
}, Radio = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2H
  },
  name: "Radio",
  setup(s, {
    slots: o
  }) {
    let l, u;
    const c = reactive({
      hover: !1,
      addonId: s.addonId,
      extraId: s.extraId,
      checked: s.checked || s.defaultChecked || !1
    }), {
      adapter: m,
      getDataAttr: g
    } = useBaseComponent(s, c);
    l = inject("RadioContextValue", ref$1(null));
    const v = b();
    function b() {
      return {
        ...m(),
        setHover: (z) => {
          c.hover = z;
        },
        setAddonId: () => {
          c.addonId = getUuidShort({
            prefix: "addon"
          });
        },
        setChecked: (z) => {
          c.checked = z;
        },
        setExtraId: () => {
          c.extraId = getUuidShort({
            prefix: "extra"
          });
        },
        setFocusVisible: (z) => {
          c.focusVisible = z;
        }
      };
    }
    u = new RadioFoundation(v);
    function S() {
      return l && l.value && l.value.radioGroup;
    }
    const E = (z) => {
      const {
        onChange: Q
      } = s;
      if (S()) {
        const {
          radioGroup: W
        } = l.value;
        W.onChange && W.onChange(z);
      }
      Q && Q(z);
    }, P = (z) => {
      s.onMouseEnter(z), u.setHover(!0);
    }, T = (z) => {
      s.onMouseLeave(z), u.setHover(!1);
    }, N = (z) => {
      u.handleFocusVisible(z);
    }, O = (z) => {
      u.handleBlur();
    };
    return () => {
      const {
        addonClassName: z,
        addonStyle: Q,
        checked: W,
        disabled: ue,
        style: te,
        className: K,
        prefixCls: ve,
        displayMode: ee,
        extra: Re,
        mode: wt,
        type: yt,
        value: xt,
        name: Kt,
        ...tn
      } = s, ln = o.default ? o.default() : null;
      let rn, an, Gt, nn, vt, Et, Qt, un, gn;
      const {
        hover: dn,
        addonId: yn,
        extraId: vn,
        focusVisible: Pn
      } = c;
      let On = {};
      S() ? (rn = l.value.radioGroup.value === xt, an = ue || l.value.radioGroup.disabled, Gt = l.value.mode, nn = l.value.radioGroup.isButtonRadio, vt = l.value.radioGroup.isCardRadio, Et = l.value.radioGroup.isPureCardRadio, un = l.value.radioGroup.buttonSize, gn = ve || l.value.radioGroup.prefixCls, On = {
        checked: rn,
        disabled: an
      }) : (rn = W, an = ue, Gt = wt, Qt = yt === "button", gn = ve);
      const _n = typeof nn > "u" ? Qt : nn, Nn = gn || radioClasses.PREFIX, Un = vt || Et || _n, Xn = cls(Nn, {
        [`${Nn}-disabled`]: an,
        [`${Nn}-checked`]: rn,
        [`${Nn}-${ee}`]: !!ee,
        [`${Nn}-buttonRadioComponent`]: Qt,
        [`${Nn}-buttonRadioGroup`]: nn,
        [`${Nn}-buttonRadioGroup-${un}`]: nn && un,
        [`${Nn}-cardRadioGroup`]: vt,
        [`${Nn}-cardRadioGroup_disabled`]: an && vt,
        [`${Nn}-cardRadioGroup_checked`]: vt && rn && !an,
        [`${Nn}-cardRadioGroup_checked_disabled`]: vt && rn && an,
        [`${Nn}-cardRadioGroup_hover`]: vt && !rn && dn && !an,
        [K]: !!K,
        [`${Nn}-focus`]: Pn && (vt || Et)
      }), zn = S() && l.value.radioGroup.name, jn = cls({
        [`${Nn}-addon`]: !_n,
        [`${Nn}-addon-buttonRadio`]: _n,
        [`${Nn}-addon-buttonRadio-checked`]: _n && rn,
        [`${Nn}-addon-buttonRadio-disabled`]: _n && an,
        [`${Nn}-addon-buttonRadio-hover`]: _n && !rn && !an && dn,
        [`${Nn}-addon-buttonRadio-${un}`]: _n && un,
        [`${Nn}-focus`]: Pn && _n
      }, z), kn = () => createVNode(Fragment, null, [ln ? createVNode("span", {
        class: jn,
        style: Q,
        id: yn
      }, [ln]) : null, Re && !_n ? createVNode("div", {
        class: `${Nn}-extra`,
        id: vn
      }, [Re]) : null]);
      return createVNode("label", mergeProps$1({
        style: te,
        class: Xn,
        onMouseenter: P,
        onMouseleave: T
      }, g()), [createVNode(RadioInner, mergeProps$1(s, On, {
        mode: Gt,
        name: Kt ?? zn,
        isButtonRadio: _n,
        isPureCardRadioGroup: Et,
        onChange: E,
        ref: (Yn) => {
        },
        addonId: ln && yn,
        extraId: Re && vn,
        focusInner: Pn && !Un,
        onInputFocus: N,
        onInputBlur: O
      }), null), vt ? createVNode("div", {
        class: `${Nn}-isCardRadioGroup_content`
      }, [kn()]) : kn()]);
    };
  }
}), Radio$1 = Radio, vuePropsType$2G = {
  value: Object
}, RadioContext = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2G
  },
  name: "RadioContext",
  setup(s, {
    slots: o
  }) {
    const l = ref$1(s.value);
    return watch(() => JSON.parse(JSON.stringify(s.value)), (u) => {
      l.value = s.value;
    }), provide("RadioContextValue", l), () => o.default ? o.default() : null;
  }
});
function _isSlot$L(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const vuePropsType$2F = {
  "onUpdate:value": Function,
  defaultValue: {
    type: [String, Number],
    // @ts-ignore
    default: void 0
  },
  disabled: {
    type: Boolean,
    default: !1
  },
  name: String,
  options: [Object, Array],
  value: {
    type: [String, Number],
    // @ts-ignore
    default: void 0
  },
  onChange: {
    type: Function,
    default: lodashExports.noop
  },
  className: String,
  style: [Object, String],
  direction: {
    type: [String, Object, Array, Boolean],
    default: strings$k.DEFAULT_DIRECTION
  },
  mode: {
    type: String,
    default: ""
  },
  type: {
    type: String,
    default: strings$k.TYPE_DEFAULT
  },
  buttonSize: {
    type: String,
    default: "middle"
  },
  prefixCls: String,
  "aria-label": String,
  "aria-describedby": String,
  "aria-errormessage": String,
  "aria-invalid": [bool, string$3],
  "aria-labelledby": String,
  "aria-required": [String, Boolean],
  id: String
}, RadioGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2F
  },
  name: "RadioGroup",
  setup(s, {
    slots: o
  }) {
    const l = s["onUpdate:value"];
    let u;
    const c = reactive({
      value: void 0
    }), {
      adapter: m,
      getDataAttr: g
    } = useBaseComponent(s, c), v = b();
    function b() {
      return {
        ...m(),
        setValue: (P) => {
          c.value = P;
        },
        // getProps: () => props,
        isInProps: (P) => P in s && s[P] !== void 0,
        notifyChange: (P) => {
          s.onChange && s.onChange(P);
        }
      };
    }
    u = new RadioGroupFoundation(v), onMounted(() => {
      u.init();
    }), watch(() => s.value, (P, T) => {
      P !== T && u.handlePropValueChange(s.value);
    }), onUnmounted(() => {
      u.destroy();
    });
    const S = (P) => {
      l && l(P.target.value), u.handleChange(P);
    }, E = () => s.name || "default";
    return () => {
      const P = o.default ? o.default() : null, {
        options: T,
        mode: N,
        prefixCls: O,
        className: z,
        style: Q,
        direction: W,
        type: ue,
        buttonSize: te,
        id: K,
        ...ve
      } = s, ee = ue === strings$k.TYPE_BUTTON, Re = ue === strings$k.TYPE_PURECARD, wt = ue === strings$k.TYPE_CARD || Re, yt = ue === strings$k.TYPE_DEFAULT, xt = O || radioGroupClasses.PREFIX, Kt = cls(z, {
        [xt]: !0,
        [`${xt}-wrapper`]: !0,
        [`${xt}-${W}`]: W && !ee,
        [`${xt}-${W}-default`]: W && yt,
        [`${xt}-${W}-card`]: W && wt,
        [`${xt}-buttonRadio`]: ee
      }), tn = c.value;
      let ln;
      return T ? ln = (T || []).map((rn, an) => typeof rn == "string" ? createVNode(Radio$1, {
        key: an,
        disabled: s.disabled,
        value: rn
      }, _isSlot$L(rn) ? rn : {
        default: () => [rn]
      }) : createVNode(Radio$1, {
        key: an,
        disabled: rn.disabled || s.disabled,
        value: rn.value,
        extra: rn.extra,
        className: rn.className,
        style: rn.style
      }, {
        default: () => [rn.label]
      })) : P && (ln = P.map((rn, an) => isVNode(rn) ? cloneVNode(rn, {
        key: an
      }) : null)), createVNode("div", mergeProps$1({
        class: Kt,
        style: Q,
        id: K,
        "aria-label": s["aria-label"],
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-required": s["aria-required"]
      }, g()), [createVNode(RadioContext, {
        value: {
          radioGroup: {
            onChange: S,
            value: tn,
            disabled: s.disabled,
            name: E(),
            isButtonRadio: ee,
            isCardRadio: wt,
            isPureCardRadio: Re,
            buttonSize: te,
            prefixCls: O
          },
          mode: N
        }
      }, {
        default: () => ln
      })]);
    };
  }
}), RadioGroup$1 = RadioGroup, cssClasses$N = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-autocomplete`,
  PREFIX_OPTION: `${BASE_CLASS_PREFIX$1}-autoComplete-option`,
  PREFIX_GROUP: `${BASE_CLASS_PREFIX$1}-autoComplete-group`
};
class AutoCompleteFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.isPanelOpen = !1;
  }
  init() {
    this._setDropdownWidth();
    const { defaultOpen: o, data: l, defaultValue: u, value: c } = this.getProps();
    if (l && l.length) {
      const g = this._generateList(l);
      this._adapter.updateOptionList(g);
    }
    o && this.openDropdown();
    let m;
    typeof u < "u" && (m = u), typeof c < "u" && (m = c), typeof m < "u" && this.handleValueChange(m);
  }
  destroy() {
    this._adapter.unregisterClickOutsideHandler();
  }
  _setDropdownWidth() {
    const { style: o, dropdownMatchSelectWidth: l } = this.getProps();
    let u;
    l && (o && lodashExports.isNumber(o.width) || o && lodashExports.isString(o.width) && !o.width.includes("%") ? u = o.width : u = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(u));
  }
  handleInputClick(o) {
    this.getStates();
    const { disabled: l } = this.getProps();
    l || (this.isPanelOpen ? this.closeDropdown() : this.openDropdown());
  }
  openDropdown() {
    this.isPanelOpen = !0, this._adapter.toggleListVisible(!0), this._setDropdownWidth(), this._adapter.registerClickOutsideHandler((o) => this.closeDropdown(o)), this._adapter.notifyDropdownVisibleChange(!0), this._modifyFocusIndexOnPanelOpen();
  }
  closeDropdown(o) {
    this.isPanelOpen = !1, this._adapter.toggleListVisible(!1), this._adapter.unregisterClickOutsideHandler(), this._adapter.notifyDropdownVisibleChange(!1);
  }
  // props.data => optionList
  _generateList(o) {
    const { renderItem: l } = this.getProps(), u = [];
    return o && o.length && o.forEach((c, m) => {
      const g = String((/* @__PURE__ */ new Date()).getTime()) + m;
      let v = {};
      lodashExports.isString(c) || lodashExports.isNumber(c) ? v = { value: c, key: g, label: c, show: !0 } : lodashExports.isObject(c) && !lodashExports.isUndefined(c.value) && (v = { show: !0, ...c }), l && typeof l == "function" && (v.label = l(c)), u.push(v);
    }), u;
  }
  handleSearch(o) {
    this._adapter.updateInputValue(o), this._adapter.notifySearch(o), this._adapter.notifyChange(o), this._modifyFocusIndex(o), this.isPanelOpen || this.openDropdown();
  }
  handleSelect(o, l) {
    const { renderSelectedItem: u } = this.getProps();
    let c = "";
    u && typeof u == "function" ? (c = u(o), warning$1(
      typeof c != "string",
      "Warning: [Semi AutoComplete] renderSelectedItem must return string, please check your function return"
    )) : c = o.value, this._isControlledComponent() ? (this.closeDropdown(), this.notifySelect(o)) : (this._adapter.updateInputValue(c), this.updateSelection(o), this.notifySelect(o), this.closeDropdown()), this._adapter.notifyChange(c), this._adapter.updateFocusIndex(l);
  }
  updateSelection(o) {
    const l = /* @__PURE__ */ new Map();
    o && l.set(o.label, o), this._adapter.updateSelection(l);
  }
  notifySelect(o) {
    this._backwardLabelInValue() ? this._adapter.notifySelect(o) : this._adapter.notifySelect(o.value);
  }
  _backwardLabelInValue() {
    const o = this.getProps();
    let { onSelectWithObject: l } = o;
    return l;
  }
  handleDataChange(o) {
    const l = this._generateList(o);
    this._adapter.updateOptionList(l), this._adapter.rePositionDropdown();
  }
  handleValueChange(o) {
    let { data: l, defaultActiveFirstOption: u } = this.getProps(), c = "";
    this._backwardLabelInValue() && Object.prototype.toString.call(o) === "[object Object]" ? c = o.value : c = o;
    let m = this._getRenderSelectedItem();
    const g = this._generateList(l);
    let v = g.length ? g.filter((P) => m(P) === c) : [];
    const b = v.length, S = g.findIndex((P) => m(P) === c);
    let E = "";
    if (b)
      v = v[0], E = m(v);
    else {
      const P = this._backwardLabelInValue() ? o : { label: c, value: c };
      E = m(P);
    }
    this._adapter.updateInputValue(E), this.updateSelection(b ? v : null), S === -1 && u ? this._adapter.updateFocusIndex(0) : this._adapter.updateFocusIndex(S);
  }
  _modifyFocusIndex(o) {
    let { focusIndex: l } = this.getStates(), { data: u, defaultActiveFirstOption: c } = this.getProps(), m = -1;
    if (o) {
      let g = this._getRenderSelectedItem();
      m = this._generateList(u).findIndex((b) => g(b) === o);
    }
    m === -1 && c ? l !== 0 && this._adapter.updateFocusIndex(0) : m !== l && this._adapter.updateFocusIndex(m);
  }
  _modifyFocusIndexOnPanelOpen() {
    let { inputValue: o } = this.getStates();
    this._modifyFocusIndex(o);
  }
  _getRenderSelectedItem() {
    let { renderSelectedItem: o } = this.getProps();
    return typeof o > "u" && (o = (l) => l == null ? void 0 : l.value), o;
  }
  handleClear() {
    this._adapter.notifyClear();
  }
  bindKeyBoardEvent() {
    this._keydownHandler = (o) => {
      this._handleKeyDown(o);
    }, this._adapter.registerKeyDown(this._keydownHandler);
  }
  // unBindKeyBoardEvent() {
  //     if (this._keydownHandler) {
  //         this._adapter.unregisterKeyDown(this._keydownHandler);
  //     }
  // }
  _handleKeyDown(o) {
    const l = o.keyCode;
    switch (this.getStates(), l) {
      case KeyCode.UP:
        o.preventDefault(), this._handleArrowKeyDown(-1);
        break;
      case KeyCode.DOWN:
        o.preventDefault(), this._handleArrowKeyDown(1);
        break;
      case KeyCode.ENTER:
        o.preventDefault(), this._handleEnterKeyDown();
        break;
      case KeyCode.ESC:
        this.closeDropdown();
        break;
      case KeyCode.TAB:
        this.closeDropdown();
        break;
    }
    this._adapter.notifyKeyDown(o);
  }
  _getEnableFocusIndex(o) {
    const { focusIndex: l, options: u } = this.getStates(), c = u.filter((v) => v.show), m = c.length;
    let g = l + o;
    if (g < 0 && (g = m - 1), g >= m && (g = 0), o > 0) {
      let v = -1;
      for (let b = 0; b < c.length && (!c[b].disabled && (v = b), !(v >= g)); b++)
        ;
      g = v;
    } else {
      let v = c.length;
      for (let b = m - 1; b >= 0 && (!c[b].disabled && (v = b), !(v <= g)); b--)
        ;
      g = v;
    }
    this._adapter.updateFocusIndex(g);
  }
  _handleArrowKeyDown(o) {
    const { visible: l } = this.getStates();
    l ? this._getEnableFocusIndex(o) : this.openDropdown();
  }
  _handleEnterKeyDown() {
    const { visible: o, options: l, focusIndex: u } = this.getStates();
    if (!o)
      this.openDropdown();
    else if (u !== void 0 && u !== -1 && l.length !== 0) {
      const m = l.filter((g) => g.show)[u];
      this.handleSelect(m, u);
    } else
      this.closeDropdown();
  }
  handleOptionMouseEnter(o) {
    this._adapter.updateFocusIndex(o);
  }
  handleFocus(o) {
    this.bindKeyBoardEvent(), this._adapter.notifyFocus(o);
  }
  handleBlur(o) {
    this._persistEvent(o), this._adapter.notifyBlur(o);
  }
}
const vuePropsType$2E = {
  triggerRender: Function,
  componentName: String,
  componentProps: Object,
  value: [Object, Number, String, Array],
  inputValue: String,
  placeholder: [String, Array],
  className: String,
  style: [Object],
  showClearIgnoreDisabled: Boolean,
  onChange: {
    type: Function
  },
  onClear: Function,
  disabled: Boolean,
  onSearch: Function,
  onRemove: Function
}, Index$6 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2E
  },
  name: "Trigger",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    return () => {
      const {
        triggerRender: u,
        componentName: c,
        ...m
      } = s;
      return u({
        ...l,
        ...m
      });
    };
  }
}), LocaleConsumer$4 = LocaleConsumerFunc(), propTypes$1A = {
  children: node$1,
  disabled: bool,
  value: oneOfType([string$3, number$2]),
  selected: bool,
  label: node$1,
  empty: bool,
  emptyContent: node$1,
  onSelect: func,
  focused: bool,
  showTick: bool,
  className: string$3,
  style: object$1,
  onMouseEnter: func,
  prefixCls: string$3,
  renderOptionItem: func,
  inputValue: string$3,
  option: object$1
}, defaultProps$1v = {
  prefixCls: cssClasses$N.PREFIX_OPTION
}, vuePropsType$2D = vuePropsMake(propTypes$1A, defaultProps$1v), Option$2 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2D
  },
  name: "Option",
  setup(s, {}) {
    const o = useSlots();
    function l({
      value: c,
      label: m,
      children: g,
      ...v
    }, b) {
      s.disabled || s.onSelect({
        ...v,
        value: c,
        label: m || g
      }, b);
    }
    function u({
      config: c,
      children: m,
      inputValue: g,
      prefixCls: v
    }) {
      return lodashExports.isString(m) && g ? getHighLightTextHTML(c) : m;
    }
    return () => {
      const c = getFragmentChildren(o), {
        disabled: m,
        value: g,
        selected: v,
        label: b,
        empty: S,
        emptyContent: E,
        onSelect: P,
        focused: T,
        showTick: N,
        className: O,
        style: z,
        onMouseEnter: Q,
        prefixCls: W,
        renderOptionItem: ue,
        inputValue: te,
        ...K
      } = s, ve = {
        ...K,
        ...s.option
      }, ee = cls(W, {
        [`${W}-disabled`]: m,
        [`${W}-selected`]: v,
        [`${W}-focused`]: T,
        [`${W}-empty`]: S,
        [O]: O
      }), Re = cls([`${W}-icon`]);
      if (S)
        return E === null ? null : createVNode(LocaleConsumer$4, {
          componentName: "Select"
        }, {
          default: (yt) => createVNode("div", {
            class: ee,
            "x-semi-prop": "emptyContent"
          }, [E || yt.emptyText])
        });
      if (typeof ue == "function")
        return ue({
          disabled: m,
          focused: T,
          selected: v,
          style: z,
          label: b,
          value: g,
          inputValue: te,
          onMouseEnter: (yt) => Q(yt),
          onClick: (yt) => l({
            value: g,
            label: b,
            children: c,
            ...ve
          }, yt),
          ...ve
        });
      const wt = {
        searchWords: te,
        sourceString: c,
        option: {
          highlightClassName: `${W}-keyword`
        }
      };
      return (
        // eslint-disable-next-line jsx-a11y/interactive-supports-focus,jsx-a11y/click-events-have-key-events
        createVNode("div", {
          class: ee,
          onClick: (yt) => {
            l({
              value: g,
              label: b,
              children: c,
              ...ve
            }, yt);
          },
          onMouseenter: (yt) => Q && Q(yt),
          role: "option",
          "aria-selected": v ? "true" : "false",
          "aria-disabled": m ? "true" : "false",
          style: z
        }, [N ? createVNode("div", {
          class: Re
        }, [createVNode(IconComponent$6, null, null)]) : null, lodashExports.isString(c) ? createVNode("div", {
          class: `${W}-text`
        }, [u({
          children: c,
          config: wt,
          inputValue: te,
          prefixCls: W
        })]) : c])
      );
    };
  }
});
Option$2.isSelectOption = !0;
function _isSlot$K(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$J = cssClasses$N.PREFIX;
function AutoCompleteFunc() {
  const s = AutoCompleteFuncVueProps();
  return /* @__PURE__ */ defineComponent({
    props: s,
    name: "AutoComplete",
    setup(o, {}) {
      useSlots();
      const u = reactive({
        dropdownMinWidth: null,
        inputValue: "",
        // option list
        options: [],
        // popover visible
        visible: !1,
        // current focus option index
        focusIndex: o.defaultActiveFirstOption ? 0 : -1,
        // current selected options
        selection: /* @__PURE__ */ new Map(),
        rePosKey: 1
      });
      let c = null;
      const {
        adapter: m,
        getDataAttr: g
      } = useBaseComponent(o, u);
      function v() {
        const ee = {
          registerKeyDown: (Re) => {
            const wt = {
              onKeyDown: Re
            };
            u.keyboardEventSet = wt;
          },
          unregisterKeyDown: (Re) => {
            u.keyboardEventSet = {};
          },
          updateFocusIndex: (Re) => {
            u.focusIndex = Re;
          }
        };
        return {
          ...m(),
          ...ee,
          getTriggerWidth: () => {
            const Re = E.value;
            return Re && Re.getBoundingClientRect().width;
          },
          setOptionWrapperWidth: (Re) => {
            u.dropdownMinWidth = Re;
          },
          updateInputValue: (Re) => {
            u.inputValue = Re;
          },
          toggleListVisible: (Re) => {
            u.visible = Re;
          },
          updateOptionList: (Re) => {
            u.options = Re;
          },
          updateSelection: (Re) => {
            u.selection = Re;
          },
          notifySearch: (Re) => {
            o.onSearch(Re);
          },
          notifyChange: (Re) => {
            o.onChange(Re);
          },
          notifySelect: (Re) => {
            o.onSelect(Re);
          },
          notifyDropdownVisibleChange: (Re) => {
            o.onDropdownVisibleChange(Re);
          },
          notifyClear: () => {
            o.onClear();
          },
          notifyFocus: (Re) => {
            o.onFocus(Re);
          },
          notifyBlur: (Re) => {
            o.onBlur(Re);
          },
          notifyKeyDown: (Re) => {
            o.onKeyDown(Re);
          },
          rePositionDropdown: () => {
            let {
              rePosKey: Re
            } = u;
            Re = Re + 1, u.rePosKey = Re;
          },
          registerClickOutsideHandler: (Re) => {
            c = (yt) => {
              var an, Gt;
              const xt = P && ((Gt = (an = P.value).getRef) == null ? void 0 : Gt.call(an).vnode.el), Kt = E && E.value, tn = xt, ln = yt.target, rn = yt.composedPath && yt.composedPath() || [ln];
              tn && (!tn.contains(ln) || !tn.contains(ln.parentNode)) && Kt && !Kt.contains(ln) && !(rn.includes(Kt) || rn.includes(tn)) && Re(yt);
            }, document.addEventListener("mousedown", c, !1);
          },
          unregisterClickOutsideHandler: () => {
            c && document.removeEventListener("mousedown", c, !1);
          }
        };
      }
      const b = v(), S = new AutoCompleteFoundation(b), E = ref$1(), P = ref$1();
      warning$1("triggerRender" in o && typeof o.triggerRender == "function", `[Semi AutoComplete]
            - If you are using the following props: 'suffix', 'prefix', 'showClear', 'validateStatus', and 'size',
            please notice that they will be removed in the next major version.
            Please use 'componentProps' to retrieve these props instead.
            - If you are using 'onBlur', 'onFocus', please try to avoid using them and look for changes in the future.`), onMounted(() => {
        S.init();
      }), onUnmounted(() => {
        S.destroy();
      }), watch(() => o.value, (ee, Re, wt) => {
        ee !== Re && S.handleValueChange(o.value);
      }), watch(() => o.data, (ee, Re, wt) => {
        lodashExports.isEqual(ee, Re) || S.handleDataChange(o.data);
      }, {
        deep: !0
      });
      const T = (ee, Re, wt) => {
        S.handleSelect(ee, Re);
      }, N = (ee, Re) => {
        S.handleSearch(ee);
      }, O = (ee) => S.handleBlur(ee), z = (ee) => S.handleFocus(ee), Q = () => S.handleClear(), W = (ee) => S.handleInputClick(ee);
      function ue() {
        const {
          size: ee,
          prefix: Re,
          insetLabel: wt,
          insetLabelId: yt,
          suffix: xt,
          placeholder: Kt,
          style: tn,
          className: ln,
          showClear: rn,
          disabled: an,
          triggerRender: Gt,
          validateStatus: nn,
          autoFocus: vt,
          value: Et,
          id: Qt
        } = o, {
          inputValue: un,
          keyboardEventSet: gn,
          selection: dn
        } = u, vn = {
          style: tn,
          className: typeof Gt == "function" ? cls(ln) : cls({
            [prefixCls$J]: !0,
            [`${prefixCls$J}-disabled`]: an
          }, ln),
          onClick: W,
          ref: E,
          id: Qt,
          ...gn,
          // tooltip give tabindex 0 to children by default, autoComplete just need the input get focus, so outer div's tabindex set to -1
          tabIndex: -1,
          ...g()
        }, Pn = {
          disabled: an,
          placeholder: Kt,
          autoFocus: vt,
          // @ts-ignore
          onChange: N,
          onClear: Q,
          "aria-label": o["aria-label"],
          "aria-labelledby": o["aria-labelledby"],
          "aria-invalid": o["aria-invalid"],
          "aria-errormessage": o["aria-errormessage"],
          "aria-describedby": o["aria-describedby"],
          "aria-required": o["aria-required"],
          // TODO: remove in next major version
          suffix: xt,
          // @ts-ignore
          prefix: Re || wt,
          insetLabelId: yt,
          showClear: rn,
          validateStatus: nn,
          size: ee,
          onBlur: O,
          onFocus: z
        };
        return createVNode("div", vn, [typeof Gt == "function" ? createVNode(Index$6, mergeProps$1(Pn, {
          inputValue: typeof Et < "u" ? Et : un,
          value: Array.from(dn.values()),
          triggerRender: Gt,
          componentName: "AutoComplete",
          componentProps: {
            ...o
          }
        }), null) : createVNode(Input$1, mergeProps$1(Pn, {
          value: typeof Et < "u" ? Et : un
        }), null)]);
      }
      function te() {
        const ee = `${prefixCls$J}-loading-wrapper`;
        return createVNode("div", {
          class: ee
        }, [createVNode(Spin, null, null)]);
      }
      function K(ee, Re) {
        const {
          focusIndex: wt
        } = u;
        return createVNode(Option$2, {
          showTick: !1,
          onSelect: (xt, Kt) => T(xt, Re),
          focused: Re === wt,
          onMouseEnter: () => S.handleOptionMouseEnter(Re),
          key: ee.key || ee.label + ee.value + Re,
          option: ee
        }, {
          default: () => [ee.label]
        });
      }
      function ve() {
        const {
          maxHeight: ee,
          dropdownStyle: Re,
          dropdownClassName: wt,
          loading: yt,
          emptyContent: xt
        } = o, {
          options: Kt,
          dropdownMinWidth: tn
        } = u, ln = cls({
          [`${prefixCls$J}-option-list`]: !0
        }, wt);
        let rn;
        Kt.length === 0 ? rn = xt == null ? void 0 : xt() : rn = Kt.filter((Gt) => Gt.show).map((Gt, nn) => K(Gt, nn));
        const an = {
          maxHeight: styleNum(ee),
          minWidth: styleNum(tn),
          ...Re
        };
        return createVNode("div", {
          class: ln,
          role: "listbox",
          style: an
        }, [yt ? te() : rn]);
      }
      return () => {
        const {
          position: ee,
          motion: Re,
          zIndex: wt,
          mouseEnterDelay: yt,
          mouseLeaveDelay: xt,
          autoAdjustOverflow: Kt,
          stopPropagation: tn,
          getPopupContainer: ln
        } = o, {
          visible: rn,
          rePosKey: an
        } = u, Gt = ue(), nn = ve();
        return createVNode(Popover$1, {
          mouseEnterDelay: yt,
          mouseLeaveDelay: xt,
          autoAdjustOverflow: Kt,
          trigger: "custom",
          motion: Re,
          visible: rn,
          content: nn,
          position: ee,
          ref: P,
          zIndex: wt,
          stopPropagation: tn,
          getPopupContainer: ln,
          rePosKey: an
        }, _isSlot$K(Gt) ? Gt : {
          default: () => [Gt]
        });
      };
    }
  });
}
function AutoCompleteFuncVueProps() {
  const s = {
    "aria-label": string$3,
    "aria-labelledby": string$3,
    "aria-invalid": [bool, string$3],
    "aria-errormessage": string$3,
    "aria-describedby": string$3,
    "aria-required": bool,
    autoFocus: bool,
    autoAdjustOverflow: bool,
    className: string$3,
    children: node$1,
    data: array$1,
    defaultOpen: bool,
    defaultValue: oneOfType([string$3, number$2]),
    defaultActiveFirstOption: bool,
    disabled: bool,
    dropdownMatchSelectWidth: bool,
    dropdownClassName: string$3,
    dropdownStyle: object$1,
    emptyContent: func,
    id: string$3,
    insetLabel: node$1,
    insetLabelId: string$3,
    onSearch: func,
    onSelect: func,
    onClear: func,
    onBlur: func,
    onFocus: func,
    onChange: func,
    onKeyDown: func,
    position: String,
    placeholder: string$3,
    prefix: node$1,
    onChangeWithObject: bool,
    onSelectWithObject: bool,
    onDropdownVisibleChange: func,
    renderItem: func,
    renderSelectedItem: func,
    suffix: node$1,
    showClear: bool,
    size: String,
    style: object$1,
    stopPropagation: oneOfType([bool, string$3]),
    maxHeight: oneOfType([string$3, number$2]),
    mouseEnterDelay: number$2,
    mouseLeaveDelay: number$2,
    motion: oneOfType([bool, func, object$1]),
    getPopupContainer: func,
    triggerRender: func,
    value: oneOfType([string$3, number$2]),
    validateStatus: String,
    zIndex: number$2,
    loading: bool
  }, o = {
    stopPropagation: !0,
    motion: !0,
    zIndex: numbers$f.DEFAULT_Z_INDEX,
    position: "bottomLeft",
    data: [],
    showClear: !1,
    size: "default",
    onFocus: lodashExports.noop,
    onSearch: lodashExports.noop,
    onClear: lodashExports.noop,
    onBlur: lodashExports.noop,
    onSelect: lodashExports.noop,
    onChange: lodashExports.noop,
    onSelectWithObject: !1,
    onDropdownVisibleChange: lodashExports.noop,
    defaultActiveFirstOption: !1,
    dropdownMatchSelectWidth: !0,
    loading: !1,
    maxHeight: 300,
    validateStatus: "default",
    autoFocus: !1,
    emptyContent: lodashExports.noop,
    onKeyDown: lodashExports.noop
    // onPressEnter: () => undefined,
    // defaultOpen: false,
  };
  return vuePropsMake(s, o);
}
AutoCompleteFuncVueProps();
const AutoComplete = AutoCompleteFunc(), cssClasses$M = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-avatar`
}, strings$j = {
  SHAPE: ["circle", "square"],
  SIZE: ["extra-extra-small", "extra-small", "small", "default", "medium", "large", "extra-large"],
  COLOR: [
    "grey",
    "red",
    "pink",
    "purple",
    "violet",
    "indigo",
    "blue",
    "light-blue",
    "cyan",
    "teal",
    "green",
    "light-green",
    "lime",
    "yellow",
    "amber",
    "orange",
    "white"
  ],
  OVERLAP_FROM: ["start", "end"]
};
class AvatarFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleFocusVisible = (l) => {
      const { target: u } = l;
      try {
        u.matches(":focus-visible") && this._adapter.setFocusVisible(!0);
      } catch {
        warning$1(!0, "Warning: [Semi Avatar] The current browser does not support the focus-visible");
      }
    }, this.handleBlur = () => {
      this._adapter.setFocusVisible(!1);
    }, this.changeScale = () => {
      const { gap: l } = this.getProps(), u = this._adapter.getAvatarNode(), c = u == null ? void 0 : u.firstChild, [m, g] = [(u == null ? void 0 : u.offsetWidth) || 0, (c == null ? void 0 : c.offsetWidth) || 0];
      if (m !== 0 && g !== 0 && l * 2 < m) {
        const v = m - l * 2 > g ? 1 : (m - l * 2) / g;
        this._adapter.setScale(v);
      }
    };
  }
  init() {
    const { children: o } = this.getProps();
    typeof o == "string" && this.changeScale();
  }
  destroy() {
  }
  handleImgLoadError() {
    const { onError: o } = this.getProps();
    (o ? o() : void 0) !== !1 && this._adapter.notifyImgState(!1);
  }
  handleEnter(o) {
    this._adapter.notifyEnter(o);
  }
  handleLeave(o) {
    this._adapter.notifyLeave(o);
  }
}
const vuePropsType$2C = {
  gradientStart: {
    type: String,
    required: !0
  },
  gradientEnd: {
    type: String,
    required: !0
  }
}, TopSlotSvg = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2C
  },
  name: "TopSlotSvg",
  setup(s, {}) {
    return useSlots(), () => {
      const o = getUuidShort();
      return createVNode("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        width: "51",
        height: "52",
        viewBox: "0 0 51 52",
        fill: "none"
      }, [createVNode("g", {
        filter: "url(#filter0_d_6_2)"
      }, [createVNode("path", {
        d: "M40.4918 46.5592C44.6795 43.176 46.261 34.1333 47.5301 25.6141C49.5854 11.8168 39.6662 1 25.8097 1C11.2857 1 3 11.4279 3 25.3518C3 33.7866 6.29361 43.8947 10.4602 46.5592C12.5868 47.9192 12.5868 47.9051 25.8097 47.9192C38.3651 47.9282 38.5352 48.14 40.4918 46.5592Z",
        fill: `url(#${o})`
      }, null)]), createVNode("defs", null, [createVNode("filter", {
        id: "filter0_d_6_2",
        x: "0.789215",
        y: "0.447304",
        width: "49.2216",
        height: "51.3549",
        filterUnits: "userSpaceOnUse",
        "color-interpolation-filters": "sRGB"
      }, [createVNode("feFlood", {
        "flood-opacity": "0",
        result: "BackgroundImageFix"
      }, null), createVNode("feColorMatrix", {
        in: "SourceAlpha",
        type: "matrix",
        values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0",
        result: "hardAlpha"
      }, null), createVNode("feOffset", {
        dy: "1.65809"
      }, null), createVNode("feGaussianBlur", {
        stdDeviation: "1.10539"
      }, null), createVNode("feColorMatrix", {
        type: "matrix",
        values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.3 0"
      }, null), createVNode("feBlend", {
        mode: "normal",
        in2: "BackgroundImageFix",
        result: "effect1_dropShadow_6_2"
      }, null), createVNode("feBlend", {
        mode: "normal",
        in: "SourceGraphic",
        in2: "effect1_dropShadow_6_2",
        result: "shape"
      }, null)]), createVNode("linearGradient", {
        id: o,
        x1: "17.671",
        y1: "31.7392",
        x2: "17.671",
        y2: "47.9333",
        gradientUnits: "userSpaceOnUse"
      }, [createVNode("stop", {
        "stop-color": s.gradientStart
      }, null), createVNode("stop", {
        offset: "1",
        "stop-color": s.gradientEnd
      }, null)])])]);
    };
  }
}), prefixCls$I = cssClasses$M.PREFIX, vuePropsType$2B = {
  style: [Object, String],
  className: String,
  color: {
    type: String,
    default: "grey"
  },
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: String,
    default: "medium"
  },
  gap: {
    type: Number,
    default: 3
  },
  hoverMask: [Object, String, Number],
  src: String,
  srcSet: String,
  alt: String,
  onError: Function,
  onClick: {
    type: Function,
    default: noop$1
  },
  onMouseEnter: {
    type: Function,
    default: noop$1
  },
  onMouseLeave: {
    type: Function,
    default: noop$1
  },
  imgAttr: Object,
  bottomSlot: Object,
  topSlot: Object,
  border: [Object, Boolean],
  contentMotion: Boolean
}, Index$5 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2B
  },
  name: "Avatar",
  setup(s, {
    slots: o
  }) {
    let l;
    const u = reactive({
      isImgExist: !0,
      hoverContent: "",
      focusVisible: !1,
      scale: 1
    }), c = ref$1();
    let m = "";
    function g() {
      var K;
      const te = ((K = o.default) == null ? void 0 : K.call(o)) || [];
      if (l && te.length === 1 && te[0].type.toString() === "Symbol(v-txt)") {
        const ve = te[0].children;
        m !== ve && (l.changeScale(), m = ve);
      }
    }
    watch(() => s.src, () => {
      const te = new Image(0, 0);
      te.src = s.src, te.onload = () => {
        u.isImgExist = !0;
      }, te.onerror = () => {
        u.isImgExist = !1;
      }, te.onabort = () => {
        u.isImgExist = !1;
      }, g();
    });
    const {
      adapter: v
    } = useBaseComponent(s, u), b = S();
    function S() {
      return {
        ...v(),
        notifyImgState: (te) => {
          u.isImgExist = te;
        },
        notifyEnter: (te) => {
          const {
            hoverMask: K
          } = s;
          u.hoverContent = K;
          const {
            onMouseEnter: ve
          } = s;
          ve && ve(te);
        },
        notifyLeave: (te) => {
          u.hoverContent = "";
          const {
            onMouseLeave: K
          } = s;
          K && K(te);
        },
        setFocusVisible: (te) => {
          u.focusVisible = te;
        },
        setScale: (te) => {
          u.scale = te;
        },
        getAvatarNode: () => c.value
      };
    }
    onMounted(() => {
      l = new AvatarFoundation(b), l.init();
    }), onUnmounted(() => {
      l.destroy();
    });
    function E(te) {
      l.handleEnter(te);
    }
    function P(te) {
      l.handleLeave(te);
    }
    function T() {
      l.handleImgLoadError();
    }
    function N(te) {
      const {
        onClick: K
      } = s;
      switch (te.key) {
        case "Enter":
          K(te), handlePrevent(te);
          break;
        case "Escape":
          te.target.blur();
          break;
      }
    }
    const O = (te) => {
      l.handleFocusVisible(te);
    }, z = (te) => {
      l.handleBlur();
    }, Q = () => {
      var rn;
      const {
        onClick: te,
        imgAttr: K,
        src: ve,
        srcSet: ee,
        alt: Re
      } = s, {
        isImgExist: wt
      } = u, yt = (rn = o.default) == null ? void 0 : rn.call(o);
      let xt = yt;
      const Kt = te !== noop$1, tn = ve && wt, ln = {
        tabIndex: 0,
        onKeyDown: N,
        onFocus: O,
        onBlur: z
      };
      if (tn) {
        const an = Kt ? `clickable Avatar: ${Re}` : Re, Gt = {
          src: ve,
          srcSet: ee,
          onError: T,
          ...K,
          className: cls({
            [`${prefixCls$I}-no-focus-visible`]: Kt
          })
        }, nn = Kt ? {
          ...Gt,
          ...ln
        } : Gt;
        xt = [createVNode("img", mergeProps$1({
          alt: an
        }, nn), null)];
      } else if (typeof yt == "string") {
        const an = Re ?? yt, nn = {
          role: "img",
          "aria-label": Kt ? `clickable Avatar: ${an}` : an,
          className: cls(`${prefixCls$I}-label`, {
            [`${prefixCls$I}-no-focus-visible`]: Kt
          })
        }, vt = Kt ? {
          ...nn,
          ...ln
        } : nn, Et = {
          transform: `scale(${u.scale})`
        };
        xt = [createVNode("span", {
          class: `${prefixCls$I}-content`,
          style: Et
        }, [createVNode("span", mergeProps$1(vt, {
          "x-semi-prop": "children"
        }), [yt])])];
      }
      return xt;
    }, W = () => {
      if (!s.bottomSlot)
        return null;
      if (s.bottomSlot.render)
        return s.bottomSlot.render();
      const te = s.bottomSlot.render ?? (() => {
        const K = {};
        return s.bottomSlot.bgColor && (K.backgroundColor = s.bottomSlot.bgColor), s.bottomSlot.textColor && (K.color = s.bottomSlot.textColor), createVNode("span", {
          style: K,
          class: cls(`${prefixCls$I}-bottom_slot-shape_${s.bottomSlot.shape}`, `${prefixCls$I}-bottom_slot-shape_${s.bottomSlot.shape}-${s.size}`, s.bottomSlot.className ?? "")
        }, [s.bottomSlot.text]);
      });
      return createVNode("div", {
        class: cls([`${prefixCls$I}-bottom_slot`]),
        style: s.bottomSlot.style ?? {}
      }, [te()]);
    }, ue = () => {
      if (!s.topSlot)
        return null;
      if (s.topSlot.render)
        return s.topSlot.render();
      const te = {};
      return s.topSlot.textColor && (te.color = s.topSlot.textColor), createVNode("div", {
        style: s.topSlot.style ?? {},
        class: cls([`${prefixCls$I}-top_slot-wrapper`, s.topSlot.className ?? "", {
          [`${prefixCls$I}-animated`]: s.contentMotion
        }])
      }, [createVNode("div", {
        class: cls([`${prefixCls$I}-top_slot-bg`, `${prefixCls$I}-top_slot-bg-${s.size}`])
      }, [createVNode("div", {
        class: cls([`${prefixCls$I}-top_slot-bg-svg`, `${prefixCls$I}-top_slot-bg-svg-${s.size}`])
      }, [createVNode(TopSlotSvg, {
        gradientStart: s.topSlot.gradientStart ?? "var(--semi-color-primary)",
        gradientEnd: s.topSlot.gradientEnd ?? "var(--semi-color-primary)"
      }, null)])]), createVNode("div", {
        class: cls([`${prefixCls$I}-top_slot`])
      }, [createVNode("div", {
        style: te,
        class: cls([`${prefixCls$I}-top_slot-content`, `${prefixCls$I}-top_slot-content-${s.size}`])
      }, [s.topSlot.text])])]);
    };
    return () => {
      var Un;
      g();
      const {
        shape: te,
        size: K,
        color: ve,
        className: ee,
        hoverMask: Re,
        onClick: wt,
        imgAttr: yt,
        src: xt,
        srcSet: Kt,
        style: tn,
        alt: ln,
        gap: rn,
        bottomSlot: an,
        topSlot: Gt,
        border: nn,
        contentMotion: vt,
        ...Et
      } = s, {
        isImgExist: Qt,
        hoverContent: un,
        focusVisible: gn
      } = u;
      let dn = {};
      strings$j.SIZE.includes(K) || (dn = {
        width: styleNum(K),
        height: styleNum(K)
      }), dn = {
        ...dn,
        ...tn
      };
      const yn = an || Gt || nn, vn = {
        onClick: wt,
        onMouseenter: E,
        onMouseleave: P
      }, Pn = xt && Qt, On = cls(prefixCls$I, {
        [`${prefixCls$I}-${te}`]: te,
        [`${prefixCls$I}-${K}`]: K,
        [`${prefixCls$I}-${ve}`]: ve && !Pn,
        [`${prefixCls$I}-img`]: Pn,
        [`${prefixCls$I}-focus`]: gn,
        [`${prefixCls$I}-animated`]: vt
      }, ee), _n = un ? createVNode("div", {
        class: `${prefixCls$I}-hover`,
        "x-semi-prop": "hoverContent"
      }, [un]) : null;
      let Nn = createVNode("span", mergeProps$1(Et, {
        style: yn ? {} : dn,
        class: On
      }, yn ? {} : vn, {
        role: "listitem",
        ref: c
      }), [Q(), _n]);
      if (nn) {
        const Xn = {};
        typeof nn == "object" && (nn != null && nn.color) && (Xn.borderColor = nn == null ? void 0 : nn.color), Nn = createVNode("div", {
          style: {
            position: "relative",
            ...dn
          }
        }, [Nn, createVNode("span", {
          style: Xn,
          class: cls([`${prefixCls$I}-additionalBorder`, `${prefixCls$I}-additionalBorder-${K}`, {
            [`${prefixCls$I}-${te}`]: te
          }])
        }, null), typeof s.border == "object" && createVNode("span", {
          style: Xn,
          class: cls([`${prefixCls$I}-additionalBorder`, `${prefixCls$I}-additionalBorder-${K}`, {
            [`${prefixCls$I}-${te}`]: te,
            [`${prefixCls$I}-additionalBorder-animated`]: typeof s.border == "object" && ((Un = s.border) == null ? void 0 : Un.motion)
          }])
        }, null)]);
      }
      return yn ? createVNode("span", mergeProps$1({
        class: cls([`${prefixCls$I}-wrapper`]),
        style: dn
      }, vn), [Nn, Gt && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(K) && te === "circle" && ue(), an && ["extra-small", "small", "default", "medium", "large", "extra-large"].includes(K) && W()]) : Nn;
    };
  }
}), Avatar$1 = Index$5, DRAG_OFFSET = 0.45;
function getPosition$1(s, o) {
  return `${s}-${o}`;
}
function isValid$4(s) {
  return !lodashExports.isNull(s) && !lodashExports.isUndefined(s);
}
function flattenTreeData(s, o, l, u = !1) {
  const c = [], m = !!u, g = lodashExports.get(l, "key", "key"), v = lodashExports.get(l, "children", "children");
  function b(S, E = null) {
    return S.map((P, T) => {
      const N = getPosition$1(E ? E.pos : "0", T), O = P[g], z = {};
      l && Object.entries(lodashExports.omit(l, "children")).forEach(([ue, te]) => {
        const K = P[te];
        !lodashExports.isUndefined(K) && (z[ue] = K);
      });
      const Q = {
        ...lodashExports.pick(P, ["key", "label", "value", "icon", "disabled", "isLeaf"]),
        ...z,
        parent: E,
        pos: N,
        children: null,
        data: P,
        _innerDataTag: !0,
        isEnd: [...E ? E.isEnd : [], T === S.length - 1]
      }, W = typeof u == "boolean";
      return (!m || !W && u.has(O)) && c.push(Q), o.has(O) && (!m || !W && u.has(O)) ? Q.children = b(P[v] || [], Q) : Q.children = [], Q;
    });
  }
  return b(s), c;
}
function convertJsonToData(s) {
  const o = [], l = (u, c, m, g) => {
    const v = [...m, u], S = {
      key: v.join("-"),
      label: u,
      value: c
    };
    if (lodashExports.isObject(c)) {
      const E = [];
      Object.entries(c).forEach((P) => {
        l(P[0], P[1], v, E);
      }), S.children = E;
    }
    g.push(S);
  };
  return Object.entries(s).forEach((u) => l(u[0], u[1], [], o)), o;
}
function traverseDataNodes$1(s, o, l) {
  const u = lodashExports.get(l, "key", "key"), c = lodashExports.get(l, "children", "children"), m = (g, v, b) => {
    const S = g ? g[c] : s, E = g ? getPosition$1(b.pos, v) : "0";
    if (g) {
      const P = lodashExports.get(g, u, null), T = {
        data: { ...g },
        ind: v,
        pos: E,
        key: P !== null ? P : E,
        parentPos: b.node ? b.pos : null,
        level: Number(b.level) + 1
      };
      o(T);
    }
    S && S.forEach((P, T) => {
      m(P, T, {
        node: g,
        pos: E,
        level: b ? Number(b.level) + 1 : -1
      });
    });
  };
  m(null);
}
function convertDataToEntities$1(s, o) {
  const l = {}, u = {}, c = {}, m = {
    posEntities: l,
    keyEntities: u,
    valueEntities: c
  }, g = lodashExports.get(o, "value", "value");
  return traverseDataNodes$1(s, (v) => {
    const { pos: b, key: S, parentPos: E } = v, P = { ...v }, T = lodashExports.get(P, `data.${g}`, null);
    T !== null && (c[T] = S), l[b] = P, u[S] = P, P.parent = l[E], P.parent && (P.parent.children = P.parent.children || [], P.parent.children.push(P));
  }, o), m;
}
function findKeysForValues(s, o, l = !1) {
  if (!isValid$4(s))
    return [];
  if (!l && Array.isArray(s) ? s = s.length ? [s[0]] : [] : Array.isArray(s) || (s = [s]), lodashExports.isEmpty(o))
    return s;
  const u = [];
  return s.forEach((c) => {
    c in o ? u.push(o[c]) : c && u.push(c);
  }), u;
}
function findDescendantKeys(s, o, l = !0) {
  const u = [], c = (m) => {
    if (!m)
      return;
    const { children: g } = m;
    isValid$4(g) && g.forEach((b) => {
      u.push(b.key), c(o[b.key]);
    });
  };
  return s.forEach((m) => {
    l && u.push(m), c(o[m]);
  }), u;
}
function findChildKeys(s, o, l = []) {
  const u = [];
  return s && s.forEach((c) => {
    const m = o[c];
    m && m.children && m.children.forEach((g) => {
      (!l.length || !l.includes(g.key)) && u.push(g.key);
    });
  }), u;
}
function findSiblingKeys(s, o, l = !0) {
  const u = [];
  return s.forEach((m) => {
    o[m] && o[m].parent && u.push(o[m].parent.key);
  }), findChildKeys(lodashExports.uniq(u), o, l ? [] : s);
}
function findAncestorKeys(s, o, l = !0) {
  const u = [], c = (m) => {
    m.parent && (u.push(m.parent.key), c(m.parent));
  };
  return s.forEach((m) => {
    o[m] && c(o[m]), l && u.push(m);
  }), u;
}
function getSortedKeyList(s, o) {
  const l = {};
  return s.forEach((u) => {
    if (!o[u])
      return;
    const { level: c } = o[u];
    l[c] ? l[c].push(u) : l[c] = [u];
  }), l;
}
function calcCheckedKeys(s, o) {
  const l = Array.isArray(s) ? s : [s], u = findDescendantKeys(l, o, !0), c = /* @__PURE__ */ new Set([...u]);
  let m = /* @__PURE__ */ new Set([]), g = [];
  const v = getSortedKeyList(l, o), b = (S) => {
    const { key: E, parent: P, level: T } = S;
    if (!P || g.includes(E))
      return;
    const N = findSiblingKeys([E], o);
    if (g = [...g, ...N], N.every((z) => c.has(z)))
      c.add(P.key), T - 1 in v && T ? v[T - 1].push(P.key) : v[T - 1] = [P.key];
    else {
      const z = findAncestorKeys([E], o, !1);
      m = /* @__PURE__ */ new Set([...m, ...z]);
    }
  };
  for (; !lodashExports.isEmpty(v); ) {
    const S = lodashExports.max(Object.keys(v).map((E) => Number(E)));
    v[S].forEach((E) => b(o[E])), delete v[S];
  }
  return {
    checkedKeys: c,
    halfCheckedKeys: m
  };
}
function calcExpandedKeys(s = [], o, l = !0) {
  if (Array.isArray(s) || (s = [s]), l) {
    const u = findAncestorKeys(s, o, !0);
    return new Set(u);
  }
  return new Set(s);
}
function calcExpandedKeysForValues(s, o, l, u) {
  const c = findKeysForValues(s, u, l);
  return new Set(findAncestorKeys(c, o, !1));
}
function calcMotionKeys(s, o, l) {
  let u = "show";
  const c = [...s], m = [...o];
  if (Math.abs(c.length - m.length) !== 1)
    return { motionType: u, motionKeys: [] };
  let g = [];
  return c.length > m.length ? (u = "hide", g = lodashExports.difference(c, m)) : g = lodashExports.difference(m, c), {
    motionType: g.length === 1 ? u : "show",
    motionKeys: g.length === 1 ? findDescendantKeys(g, l, !1) : []
  };
}
function filter$1(s, o, l, u) {
  if (!l)
    return !0;
  let c = l, m = o;
  return typeof l == "boolean" && (c = (g, v) => {
    const b = g.toLowerCase();
    return v.toString().toLowerCase().includes(b);
  }), u && (m = o[u]), c(s, m, o);
}
function normalizedArr$1(s) {
  return Array.isArray(s) ? s : [s];
}
function normalizeKeyList(s, o, l = !1, u) {
  const c = [], m = new Set(s);
  return l ? s.forEach((g) => {
    o[g] && !isValid$4(o[g].children) && c.push(g), !o[g] && u && c.push(g);
  }) : s.forEach((g) => {
    if (!o[g]) {
      u && c.push(g);
      return;
    }
    const { parent: v } = o[g];
    v && m.has(v.key) || c.push(g);
  }), c;
}
function getMotionKeys(s, o, l) {
  const u = [], c = (m) => {
    l[m].children && l[m].children.forEach((g) => {
      const { key: v } = g;
      u.push(v), o.has(v) && c(v);
    });
  };
  return c(s), u;
}
function calcCheckedKeysForChecked(s, o, l, u) {
  const c = findDescendantKeys([s], o, !0), m = o[s];
  l = /* @__PURE__ */ new Set([...l, s]);
  const g = (v) => {
    if (!v.parent)
      return;
    const { key: b } = v;
    if (findSiblingKeys([b], o).every((P) => l.has(P))) {
      const P = v.parent;
      l.add(P.key), g(P);
    } else {
      const P = findAncestorKeys([b], o, !1);
      u = /* @__PURE__ */ new Set([...u, ...P]);
    }
  };
  return g(m), {
    checkedKeys: /* @__PURE__ */ new Set([...l, ...c]),
    halfCheckedKeys: u
  };
}
function calcCheckedKeysForUnchecked(s, o, l, u) {
  const c = findDescendantKeys([s], o, !0), m = o[s];
  c.forEach((v) => {
    l.has(v) && l.delete(v), u.has(v) && u.delete(v);
  });
  const g = (v) => {
    const b = v.parent;
    if (!b || !l.has(b.key) && !u.has(b.key))
      return;
    const { key: S } = v, P = findSiblingKeys([S], o).some((N) => l.has(N) || u.has(N)), T = findAncestorKeys([S], o, !1);
    P ? T.forEach((N) => {
      l.has(N) && (l.delete(N), u.add(N));
    }) : (l.has(b.key) && l.delete(b.key), u.has(b.key) && u.delete(b.key), g(b));
  };
  return m && g(m), {
    checkedKeys: l,
    halfCheckedKeys: u
  };
}
function filterTreeData(s) {
  const {
    showFilteredOnly: o,
    keyEntities: l,
    inputValue: u,
    treeData: c,
    filterTreeNode: m,
    filterProps: g,
    prevExpandedKeys: v,
    keyMaps: b
  } = s;
  let S = [];
  S = Object.values(l).filter((O) => filter$1(u, O.data, m, g)).map((O) => O.key);
  let E = findAncestorKeys(S, l, !1);
  if (v.length) {
    const O = v.filter((z) => !!l[z]);
    E = E.concat(O);
  }
  const P = findDescendantKeys(S, l, !0), T = /* @__PURE__ */ new Set([...P, ...E]);
  return {
    flattenNodes: flattenTreeData(c, new Set(E), b, o && T),
    filteredKeys: new Set(S),
    filteredExpandedKeys: new Set(E),
    filteredShownKeys: T
  };
}
function getValueOrKey(s, o) {
  const l = lodashExports.get(o, "value", "value"), u = lodashExports.get(o, "key", "key");
  return Array.isArray(s) ? s.map((c) => lodashExports.get(c, l, c[u])) : lodashExports.get(s, l, s[u]);
}
function normalizeValue(s, o, l) {
  return o && isValid$4(s) ? getValueOrKey(s, l) : s;
}
function updateKeys(s, o) {
  return [...s].filter((u) => u in o);
}
function calcDisabledKeys(s, o) {
  const l = lodashExports.get(o, "disabled", "disabled"), u = Object.keys(s).filter((m) => s[m].data[l]), { checkedKeys: c } = calcCheckedKeys(u, s);
  return c;
}
function calcDropRelativePosition(s, o) {
  const { clientY: l } = s, { top: u, bottom: c, height: m } = o.nodeInstance.getBoundingClientRect();
  return l <= u + m * DRAG_OFFSET ? -1 : l >= c - m * DRAG_OFFSET ? 1 : 0;
}
function getDragNodesKeys(s, o) {
  return findDescendantKeys([s], o, !0);
}
function calcDropActualPosition(s, o) {
  const l = s.split("-");
  return o + Number(l[l.length - 1]);
}
const cssClasses$L = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-cascader`,
  PREFIX_OPTION: `${BASE_CLASS_PREFIX$1}-cascader-option`
}, strings$i = {
  SIZE_SET: ["small", "large", "default"],
  VALIDATE_STATUS: ["success", "default", "error", "warning"],
  IS_KEY: "isKey",
  IS_VALUE: "isValue",
  SHOW_NEXT_BY_CLICK: "click",
  SHOW_NEXT_BY_HOVER: "hover",
  /* Merge Type */
  LEAF_ONLY_MERGE_TYPE: "leafOnly",
  AUTO_MERGE_VALUE_MERGE_TYPE: "autoMergeValue",
  NONE_MERGE_TYPE: "none",
  SEARCH_POSITION_TRIGGER: "trigger",
  SEARCH_POSITION_CUSTOM: "custom"
}, VALUE_SPLIT = "_SEMI_CASCADER_SPLIT_";
function getPosition(s, o) {
  return `${s}-${o}`;
}
function isValid$3(s) {
  return !lodashExports.isNull(s) && !lodashExports.isUndefined(s);
}
function normalizedArr(s) {
  return Array.isArray(s) ? s : [s];
}
function filter(s, o, l, u) {
  if (!l)
    return !0;
  let c = l, m;
  return typeof l == "boolean" ? (c = (g, v) => {
    const b = g.toLowerCase();
    return v.toLowerCase().includes(b);
  }, m = u.join("")) : m = u.join(), c(s, m, o);
}
function traverseDataNodes(s, o) {
  const l = (u, c, m) => {
    const g = u ? u.children : s;
    let v = null;
    if (u) {
      const b = m ? `${m.key}${VALUE_SPLIT}${u.value}` : `${u.value}`, S = m ? getPosition(m.pos, c) : `${c}`;
      v = {
        data: { ...u },
        ind: c,
        key: b,
        pos: S,
        level: m ? m.level + 1 : 0,
        parentKey: m ? m.key : null,
        path: m ? [...m.path, b] : [b],
        valuePath: m ? [...m.valuePath, u.value] : [u.value]
      }, o(v);
    }
    g && g.forEach((b, S) => {
      l(b, S, v);
    });
  };
  l(null);
}
function getKeysByValuePath(s) {
  return s != null && s.length ? Array.isArray(s[0]) ? s.map((o) => getKeyByValuePath(o)) : [getKeyByValuePath(s)] : [];
}
function getKeyByValuePath(s) {
  return s.join(VALUE_SPLIT);
}
function getKeyByPos(s, o) {
  const l = s.split("-").map((m) => Number(m));
  let u = o, c = [];
  return l.forEach((m, g) => {
    var v;
    u = g === 0 ? u[m] : (v = u == null ? void 0 : u.children) == null ? void 0 : v[m], c.push(u == null ? void 0 : u.value);
  }), getKeyByValuePath(c);
}
function convertDataToEntities(s) {
  const o = {};
  return traverseDataNodes(s, (l) => {
    const { key: u, parentKey: c } = l, m = { ...l };
    o[u] = m, m.parent = o[c], m.parent && (m.parent.children = m.parent.children || [], m.parent.children.push(m));
  }), o;
}
function calcMergeType(s, o) {
  let l;
  return o ? l = strings$i.LEAF_ONLY_MERGE_TYPE : s ? l = strings$i.AUTO_MERGE_VALUE_MERGE_TYPE : l = strings$i.NONE_MERGE_TYPE, l;
}
class CascaderFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleKeyDown = (l) => {
      l.key === ESC_KEY && this.getState("isOpen") && this.close(l);
    }, this.updateSearching = (l) => {
      this._adapter.updateStates({ isSearching: !1 });
    }, this.handleTagRemoveByKey = (l) => {
      var g;
      const { keyEntities: u } = this.getStates(), { disabled: c } = this.getProps();
      if (c)
        return;
      const m = u[l] ?? {};
      !((g = m == null ? void 0 : m.data) != null && g.disable) && this._handleMultipleSelect(m);
    }, this.handleTagRemoveInTrigger = (l) => {
      const { treeData: u } = this.getStates(), c = getKeyByPos(l, u);
      this.handleTagRemoveByKey(c);
    };
  }
  init() {
    const o = this.getProp("open") || this.getProp("defaultOpen");
    this.collectOptions(!0), this._adapter.updateLoadingKeyRefValue(/* @__PURE__ */ new Set()), this._adapter.updateLoadedKeyRefValue(/* @__PURE__ */ new Set()), o && !this._isDisabled() && this.open();
  }
  destroy() {
    this._adapter.unregisterClickOutsideHandler();
  }
  _isDisabled() {
    return this.getProp("disabled");
  }
  _isFilterable() {
    return !!this.getProp("filterTreeNode");
  }
  _notifyChange(o) {
    const { onChangeWithObject: l, multiple: u } = this.getProps(), c = l ? [] : "value";
    if (u) {
      const m = [];
      o.forEach((g) => {
        const v = this.getItemPropPath(g, c);
        m.push(v);
      }), this._adapter.notifyChange(m);
    } else {
      const m = lodashExports.isUndefined(o) || !("key" in o) ? [] : this.getItemPropPath(o.key, c);
      this._adapter.notifyChange(m);
    }
  }
  _isLeaf(o) {
    return this.getProp("loadData") ? !!o.isLeaf : !o.children || !o.children.length;
  }
  _clearInput() {
    this._adapter.updateInputValue("");
  }
  // Scenes that may trigger blur:
  //  1、clickOutSide
  _notifyBlur(o) {
    this._adapter.notifyBlur(o);
  }
  // Scenes that may trigger focus:
  //  1、click selection
  _notifyFocus(o) {
    this._adapter.notifyFocus(o);
  }
  _isOptionDisabled(o, l) {
    return findAncestorKeys([o], l, !0).some((c) => l[c].data.disabled);
  }
  // prop: is array, return all data
  getItemPropPath(o, l, u) {
    const c = u || this.getState("keyEntities"), m = c[o];
    let g = [];
    if (m) if (m._notExist)
      g = m.path;
    else {
      const v = m.path;
      g = Array.isArray(l) ? v.map((b) => c[b].data) : v.map((b) => c[b].data[l]);
    }
    return g;
  }
  _getCacheValue(o) {
    const { selectedKeys: l } = this.getStates(), u = Array.from(l)[0];
    let c;
    if (lodashExports.isEmpty(o[u]))
      if (lodashExports.includes(u, "not-exist-")) {
        const m = u.match(/not-exist-(\S*)/)[1];
        lodashExports.isEmpty(o[m]) ? c = m : c = o[m].valuePath;
      } else
        c = u;
    else
      c = o[u].valuePath;
    return c;
  }
  collectOptions(o = !1) {
    const { treeData: l, value: u, defaultValue: c } = this.getProps(), m = convertDataToEntities(l);
    this._adapter.rePositionDropdown();
    let g;
    o ? g = c : lodashExports.isEmpty(m) || (g = this._getCacheValue(m));
    const v = this._isControlledComponent() ? lodashExports.isUndefined(u) ? [] : u : g;
    isValid$3(v) ? this.updateSelectedKey(v, m) : this._adapter.updateStates({ keyEntities: m });
  }
  // call when props.value change
  handleValueChange(o) {
    const { keyEntities: l } = this.getStates();
    this.updateSelectedKey(o, l);
  }
  /**
   * When single selection, the clear objects of
   * selectedKeys, activeKeys, filteredKeys, input, etc.
   */
  _getClearSelectedKey(o) {
    const l = {}, { searchPlaceholder: u, placeholder: c, multiple: m } = this.getProps();
    return l.selectedKeys = /* @__PURE__ */ new Set([]), l.activeKeys = /* @__PURE__ */ new Set([]), l.filteredKeys = /* @__PURE__ */ new Set([]), o && !m && (l.inputPlaceHolder = u || c || "", l.inputValue = ""), l;
  }
  updateSelectedKey(o, l) {
    const { changeOnSelect: u, onChangeWithObject: c, multiple: m } = this.getProps(), {
      activeKeys: g,
      loading: v,
      keyEntities: b,
      selectedKeys: S
    } = this.getStates(), E = this._adapter.getLoadingKeyRefValue(), P = this._isFilterable(), T = [...g].filter((te) => E.has(te)), N = normalizedArr(o), O = c && lodashExports.isObject(N[0]) ? N.map((te) => te.value) : N, z = getKeysByValuePath(O);
    let Q = {};
    const W = z.length > 0 ? z[0] : void 0, ue = W ? l[W] : void 0;
    if (ue)
      if (u || this._isLeaf(ue.data)) {
        if (Q.selectedKeys = /* @__PURE__ */ new Set([W]), T.length || (Q.activeKeys = new Set(ue.path)), P && !m) {
          const te = this.renderDisplayText(W, l);
          Q.inputPlaceHolder = te;
        }
      } else lodashExports.isEqual(z, Array.from(S)) && (Q = this._getClearSelectedKey(P));
    else if (o && o.length) {
      const te = O[O.length - 1], K = `not-exist-${te}`, ve = {
        data: {
          label: te,
          value: te
        },
        key: K,
        path: O,
        _notExist: !0
      };
      if (Q.selectedKeys = /* @__PURE__ */ new Set([K]), P && !m) {
        const ee = this._defaultRenderText(O);
        Q.inputPlaceHolder = ee;
      }
      l[K] = ve;
    } else if (v) {
      Q.keyEntities = lodashExports.assign(b, l), this._adapter.updateStates(Q);
      return;
    } else
      Q = this._getClearSelectedKey(P);
    Q.keyEntities = l, this._adapter.updateStates(Q);
  }
  open() {
    const o = this._isFilterable(), { multiple: l } = this.getProps();
    this._adapter.openMenu(), o && (this._clearInput(), !l && this.toggle2SearchInput(!0)), this._isControlledComponent() && this.reCalcActiveKeys(), this._adapter.notifyDropdownVisibleChange(!0), this._adapter.registerClickOutsideHandler((u) => this.close(u));
  }
  reCalcActiveKeys() {
    const { selectedKeys: o, activeKeys: l, keyEntities: u } = this.getStates(), c = [...o][0], m = u[c];
    if (!m)
      return;
    const g = new Set(m.path);
    lodashExports.isEqual(g, l) || this._adapter.updateStates({
      activeKeys: g
    });
  }
  close(o, l) {
    const { multiple: u } = this.getProps();
    if (this._adapter.closeMenu(), this._adapter.notifyDropdownVisibleChange(!1), this._adapter.unregisterClickOutsideHandler(), this._isFilterable()) {
      const { selectedKeys: c, isSearching: m } = this.getStates();
      let g = "";
      l && !u ? g = this.renderDisplayText(l) : c.size && !u && (g = this.renderDisplayText([...c][0])), this._adapter.updateStates({ inputValue: g }), !u && this.toggle2SearchInput(!1), !u && this._adapter.updateFocusState(!1);
    }
    this._notifyBlur(o);
  }
  focus() {
    const { filterTreeNode: o } = this.getProps();
    o && this._adapter.focusInput(), this._adapter.updateFocusState(!0);
  }
  blur() {
    const { filterTreeNode: o } = this.getProps();
    o && this._adapter.blurInput(), this._adapter.updateFocusState(!1);
  }
  toggle2SearchInput(o) {
    o ? this._adapter.toggleInputShow(o, () => this.focus()) : this._adapter.toggleInputShow(o, () => {
    });
  }
  handleItemClick(o, l) {
    this._isDisabled() || (this.handleSingleSelect(o, l), this._adapter.rePositionDropdown());
  }
  handleItemHover(o, l) {
    this._isDisabled() || this.handleShowNextByHover(l);
  }
  handleShowNextByHover(o) {
    const { keyEntities: l } = this.getStates(), { data: u, key: c } = o, m = this._isLeaf(u), g = l[c].path;
    this._adapter.updateStates({
      activeKeys: new Set(g)
    }), m || this.notifyIfLoadData(o);
  }
  onItemCheckboxClick(o) {
    this._isDisabled() || (this._handleMultipleSelect(o), this._adapter.rePositionDropdown());
  }
  handleClick(o) {
    const l = this._isDisabled(), u = this._isFilterable(), { isOpen: c } = this.getStates();
    l || (c ? c && !u && this.close(o) : (this.open(), this._notifyFocus(o)));
  }
  /**
   * A11y: simulate selection click
   */
  /* istanbul ignore next */
  handleSelectionEnterPress(o) {
    isEnterPress(o) && this.handleClick(o);
  }
  toggleHoverState(o) {
    this._adapter.toggleHovering(o);
  }
  _defaultRenderText(o, l) {
    const u = this.getProp("separator");
    return l && typeof l == "function" ? l(o) : o.join(u);
  }
  renderDisplayText(o, l) {
    const u = this.getProp("displayRender"), c = this.getProp("displayProp"), m = this.getItemPropPath(o, c, l);
    return this._defaultRenderText(m, u);
  }
  handleNodeLoad(o) {
    const { data: l, key: u } = o, c = new Set(this._adapter.getLoadingKeyRefValue()), g = new Set(this._adapter.getLoadedKeyRefValue()).add(u), v = /* @__PURE__ */ new Set([...c]);
    v.delete(u), this._adapter.notifyOnLoad(g, l), this._adapter.updateLoadingKeyRefValue(v), this._adapter.updateLoadedKeyRefValue(g), this._adapter.updateStates({
      loadingKeys: v,
      loadedKeys: g
    });
  }
  notifyIfLoadData(o) {
    const { data: l, key: u } = o;
    if (this._adapter.updateStates({ loading: !1 }), !l.isLeaf && !l.children && this.getProp("loadData")) {
      const c = this._adapter.getLoadedKeyRefValue(), m = new Set(this._adapter.getLoadingKeyRefValue());
      if (c.has(u) || m.has(u))
        return;
      this._adapter.updateStates({ loading: !0 });
      const { keyEntities: g } = this.getStates(), v = this.getItemPropPath(u, [], g), b = m.add(u);
      this._adapter.updateLoadingKeyRefValue(b), this._adapter.updateStates({ loadingKeys: b }), this._adapter.notifyLoadData(v, this.handleNodeLoad.bind(this, o));
    }
  }
  handleSingleSelect(o, l) {
    const { changeOnSelect: u, filterLeafOnly: c, multiple: m, enableLeafClick: g } = this.getProps(), { keyEntities: v, selectedKeys: b, isSearching: S } = this.getStates(), E = this._isFilterable(), { data: P, key: T } = l, N = this._isLeaf(P), O = v[T].path, z = [T], Q = T !== [...b][0];
    if (!N && !u && !S) {
      this._adapter.updateStates({ activeKeys: new Set(O) }), this.notifyIfLoadData(l);
      return;
    }
    if (m)
      this._adapter.updateStates({ activeKeys: new Set(O) }), N && g && this.onItemCheckboxClick(l);
    else if (this._adapter.notifySelect(P.value), Q) {
      if (this._notifyChange(l), this.notifyIfLoadData(l), this._isControlledComponent()) {
        this._adapter.updateStates({ activeKeys: new Set(O) }), N && this.close(o);
        return;
      }
      this._adapter.updateStates({
        activeKeys: new Set(O),
        selectedKeys: new Set(z)
      });
      const W = this.renderDisplayText(T);
      E && this._adapter.updateInputPlaceHolder(W), N ? this.close(o, T) : !c && S && this.close(o, T);
    } else
      this.close(o);
  }
  _handleMultipleSelect(o) {
    const { key: l } = o, { checkedKeys: u, keyEntities: c, resolvedCheckedKeys: m } = this.getStates(), { autoMergeValue: g, max: v, disableStrictly: b, leafOnly: S } = this.getProps(), E = u.has(l), P = b ? this.calcCheckedStatus(!E, l) : !E, {
      checkedKeys: T,
      halfCheckedKeys: N
    } = b ? this.calcNonDisabledCheckedKeys(l, P) : this.calcCheckedKeys(l, P), O = calcMergeType(g, S), z = O === strings$i.LEAF_ONLY_MERGE_TYPE, Q = O === strings$i.NONE_MERGE_TYPE, W = new Set(normalizeKeyList(T, c, z)), ue = Q ? T : W;
    if (lodashExports.isNumber(v)) {
      if (Q) {
        if (u.size < T.size && T.size > v) {
          const te = [];
          T.forEach((K) => {
            te.push(c[K]);
          }), this._adapter.notifyOnExceed(te);
          return;
        }
      } else if (m.size < W.size && W.size > v) {
        const te = [];
        W.forEach((K) => {
          te.push(c[K]);
        }), this._adapter.notifyOnExceed(te);
        return;
      }
    }
    this._isControlledComponent() || this._adapter.updateStates({
      checkedKeys: T,
      halfCheckedKeys: N,
      resolvedCheckedKeys: W
    }), this._notifyChange(ue), P && this._notifySelect(ue), this._adapter.updateStates({ inputValue: "" });
  }
  calcNonDisabledCheckedKeys(o, l) {
    const { keyEntities: u, disabledKeys: c } = this.getStates(), m = new Set(this.getState("checkedKeys")), g = normalizeKeyList(findDescendantKeys([o], u, !1), u, !0);
    if (!g.some((E) => c.has(E)))
      return this.calcCheckedKeys(o, l);
    const b = g.filter((E) => !c.has(E)), S = l ? [...b, ...m] : lodashExports.difference(normalizeKeyList([...m], u, !0), b);
    return calcCheckedKeys(S, u);
  }
  calcCheckedStatus(o, l) {
    if (!o)
      return o;
    const { checkedKeys: u, keyEntities: c, disabledKeys: m } = this.getStates(), g = normalizeKeyList(findDescendantKeys([l], c, !1), c, !0);
    return g.some((E) => m.has(E)) ? !g.filter((E) => !m.has(E)).every((E) => u.has(E)) : o;
  }
  _notifySelect(o) {
    const { keyEntities: l } = this.getStates(), u = [];
    o.forEach((m) => {
      var v, b;
      const g = (b = (v = l[m]) == null ? void 0 : v.data) == null ? void 0 : b.value;
      g !== void 0 && u.push(g);
    });
    const c = u.length === 1 ? u[0] : u;
    this._adapter.notifySelect(c);
  }
  /**
   * calculate all key of nodes that are checked or half checked
   * @param {string} key key of node
   * @param {boolean} curCheckedStatus checked status of node
   */
  calcCheckedKeys(o, l) {
    const { keyEntities: u } = this.getStates(), c = new Set(this.getState("checkedKeys")), m = new Set(this.getState("halfCheckedKeys"));
    return l ? calcCheckedKeysForChecked(o, u, c, m) : calcCheckedKeysForUnchecked(o, u, c, m);
  }
  handleInputChange(o) {
    this._adapter.updateInputValue(o);
    const { keyEntities: l } = this.getStates(), { treeNodeFilterProp: u, filterTreeNode: c, filterLeafOnly: m } = this.getProps();
    let g = [];
    o && (g = Object.values(l).filter((v) => {
      const { key: b, _notExist: S, data: E } = v;
      if (S)
        return !1;
      const P = this.getItemPropPath(b, u);
      return filter(o, E, c, P);
    }).filter(
      (v) => c && !m || this._isLeaf(v)
    ).map((v) => v.key)), this._adapter.updateStates({
      isSearching: !!o,
      filteredKeys: new Set(g)
    }), this._adapter.notifyOnSearch(o);
  }
  handleClear() {
    const { isSearching: o } = this.getStates(), { searchPlaceholder: l, placeholder: u, multiple: c } = this.getProps(), m = this._isFilterable(), g = this._isControlledComponent(), v = {};
    c ? (v.isSearching = !1, this._adapter.updateInputValue(""), this._adapter.notifyOnSearch(""), v.checkedKeys = /* @__PURE__ */ new Set([]), v.halfCheckedKeys = /* @__PURE__ */ new Set([]), v.selectedKeys = /* @__PURE__ */ new Set([]), v.activeKeys = /* @__PURE__ */ new Set([]), v.resolvedCheckedKeys = /* @__PURE__ */ new Set([]), this._adapter.notifyChange([])) : m && o ? (v.isSearching = !1, this._adapter.updateInputValue(""), this._adapter.notifyOnSearch("")) : (m && (v.inputValue = "", v.inputPlaceHolder = l || u || "", this._adapter.updateInputValue(""), this._adapter.notifyOnSearch("")), g || (v.selectedKeys = /* @__PURE__ */ new Set([])), v.activeKeys = /* @__PURE__ */ new Set([]), v.filteredKeys = /* @__PURE__ */ new Set([]), this._adapter.notifyChange([])), this._adapter.updateStates(v), this._adapter.notifyClear(), this._adapter.rePositionDropdown();
  }
  /**
   * A11y: simulate clear button click
   */
  /* istanbul ignore next */
  handleClearEnterPress(o) {
    isEnterPress(o) && this.handleClear();
  }
  getRenderData() {
    const { keyEntities: o, isSearching: l } = this.getStates(), u = this._isFilterable();
    return l && u ? this.getFilteredData() : Object.values(o).filter((c) => c.parentKey === null && !c._notExist).sort((c, m) => parseInt(c.ind, 10) - parseInt(m.ind, 10));
  }
  getFilteredData() {
    const { treeNodeFilterProp: o, filterSorter: l } = this.getProps(), { filteredKeys: u, keyEntities: c, inputValue: m } = this.getStates(), g = [];
    return [...u].forEach((b) => {
      const S = c[b];
      if (!S)
        return;
      const E = this.getItemPropPath(b, []), P = E.map((N) => N[o]), T = this._isOptionDisabled(b, c);
      g.push({
        data: S.data,
        pathData: E,
        key: b,
        disabled: T,
        searchText: P
      });
    }), lodashExports.isFunction(l) && g.sort((b, S) => l(b.pathData, S.pathData, m)), g;
  }
  handleListScroll(o, l) {
    const { activeKeys: u, keyEntities: c } = this.getStates(), m = [...u][u.size - 1], g = m ? lodashExports.get(c, [m, "data"], null) : null;
    this._adapter.notifyListScroll(o, { panelIndex: l, activeNode: g });
  }
}
const checkboxClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-checkbox`,
  INNER: `${BASE_CLASS_PREFIX$1}-checkbox-inner`,
  TEXT: `${BASE_CLASS_PREFIX$1}-checkbox-text`,
  INPUT: `${BASE_CLASS_PREFIX$1}-checkbox-input`,
  CHECKED: `${BASE_CLASS_PREFIX$1}-checkbox-checked`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-checkbox-disabled`,
  BUTTON: `${BASE_CLASS_PREFIX$1}-checkbox-button`,
  WRAPPER: ""
}, checkboxGroupClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-checkboxGroup`,
  INNER: `${BASE_CLASS_PREFIX$1}-checkboxGroup-inner`,
  TEXT: `${BASE_CLASS_PREFIX$1}-checkboxGroup-text`,
  INPUT: `${BASE_CLASS_PREFIX$1}-checkboxGroup-input`,
  CHECKED: `${BASE_CLASS_PREFIX$1}-checkboxGroup-checked`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-checkboxGroup-disabled`
}, strings$h = {
  DIRECTION_SET: ["horizontal", "vertical"],
  TYPE_DEFAULT: "default",
  TYPE_CARD: "card",
  TYPE_PURECARD: "pureCard",
  DEFAULT_DIRECTION: "vertical"
};
class CheckboxFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.clickState = !1, this.handleFocusVisible = (l) => {
      const { target: u } = l;
      try {
        if (this.clickState) {
          this.clickState = !1;
          return;
        }
        u.matches(":focus-visible") && this._adapter.setFocusVisible(!0);
      } catch {
        warning$1(!0, "Warning: [Semi Checkbox] The current browser does not support the focus-visible");
      }
    }, this.handleBlur = () => {
      this.clickState = !1, this._adapter.setFocusVisible(!1);
    };
  }
  init() {
    const { children: o, extra: l, extraId: u, addonId: c } = this.getProps();
    o && !c && this._adapter.setAddonId(), l && !u && this._adapter.setExtraId();
  }
  notifyChange(o, l) {
    const u = this._adapter.generateEvent(o, l);
    this._adapter.notifyChange(u);
  }
  handleChange(o) {
    if (this.getProp("disabled"))
      return;
    if ((o == null ? void 0 : o.type) === "click" && (this.clickState = !0), this._adapter.focusCheckboxEntity(), this._adapter.getIsInGroup()) {
      this._adapter.getGroupDisabled() || this.handleChangeInGroup(o);
      return;
    }
    const m = !this.getState("checked");
    this._isControlledComponent("checked") ? this.notifyChange(m, o) : (this.setChecked(m), this.notifyChange(m, o));
  }
  handleChangeInGroup(o) {
    const { value: l } = this.getProps(), m = !this._adapter.getGroupValue().includes(l), g = this._adapter.generateEvent(m, o);
    this._adapter.notifyChange(g), this._adapter.notifyGroupChange(g);
  }
  handleEnterPress(o) {
    isEnterPress(o) && this.handleChange(o);
  }
  setChecked(o) {
    this._adapter.setNativeControlChecked(o);
  }
  destroy() {
  }
}
const propTypesCheckbox = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": [bool, string$3],
  "aria-labelledby": string$3,
  "aria-required": bool,
  // Specifies whether it is currently selected
  checked: bool,
  // Initial check
  defaultChecked: bool,
  // Failure state
  disabled: bool,
  // Set indeterminate state, only responsible for style control
  indeterminate: bool,
  // Callback function when changing
  onChange: func,
  value: any$1,
  style: object$1,
  className: string$3,
  prefixCls: string$3,
  onMouseEnter: func,
  onMouseLeave: func,
  extra: node$1,
  index: number$2,
  "aria-label": string$3,
  tabIndex: number$2,
  preventScroll: bool,
  type: string$3,
  class: string$3,
  role: String,
  addonId: String,
  extraId: String,
  id: String,
  autoFocus: Boolean
}, propTypes$1z = {
  ...propTypesCheckbox,
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": [bool, string$3],
  "aria-labelledby": string$3,
  "aria-required": bool,
  checked: bool,
  disabled: bool,
  onChange: func,
  children: node$1,
  grouped: bool,
  value: any$1,
  isPureCardType: bool,
  addonId: string$3,
  extraId: string$3,
  focusInner: bool,
  onInputFocus: func,
  onInputBlur: func,
  preventScroll: bool,
  indeterminate: Boolean,
  prefixCls: String,
  name: String,
  "aria-label": String
}, defaultProps$1u = {
  onChange: lodashExports.noop
}, vuePropsType$2A = vuePropsMake(propTypes$1z, defaultProps$1u), CheckboxInner = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2A
  },
  name: "vuePropsType",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const l = ref$1();
    function u() {
      l.value.blur();
    }
    function c() {
      const {
        preventScroll: m
      } = s;
      l.value.focus({
        preventScroll: m
      });
    }
    return o({
      blur: u,
      focus: c
    }), () => {
      const {
        indeterminate: m,
        checked: g,
        disabled: v,
        prefixCls: b,
        name: S,
        isPureCardType: E,
        addonId: P,
        extraId: T,
        focusInner: N,
        onInputFocus: O,
        onInputBlur: z
      } = s, Q = b || checkboxClasses.PREFIX, W = cls({
        [`${Q}-inner`]: !0,
        [`${Q}-inner-checked`]: !!g,
        [`${Q}-inner-pureCardType`]: E
      }, checkboxClasses.WRAPPER), ue = cls({
        [`${Q}-inner-display`]: !0,
        [`${Q}-focus`]: N,
        [`${Q}-focus-border`]: N && !g
      }), te = g ? createVNode(IconComponent$B, null, null) : m ? createVNode(IconComponent$C, null, null) : null, K = ref$1(symbol()), ve = {
        type: "checkbox",
        "aria-label": s["aria-label"],
        "aria-disabled": v,
        "aria-checked": g,
        "aria-labelledby": P,
        "aria-describedby": T || s["aria-describedby"],
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-required": s["aria-required"],
        class: checkboxClasses.INPUT,
        // 虽然没用到 但是还是写一下
        // onChange: noop,
        onChange: (ee) => {
          K.value = symbol();
        },
        checked: g,
        disabled: v,
        onFocus: O,
        onBlur: z
      };
      return S && (ve.name = S), createVNode("span", {
        class: W
      }, [createVNode("input", mergeProps$1(ve, {
        key: K.value,
        ref: l
      }), null), createVNode("span", {
        class: ue
      }, [te])]);
    };
  }
});
function useCheckboxContext() {
  return {
    context: inject("CheckboxContext", ref$1({}))
  };
}
const vuePropsType$2z = {
  name: String
}, Consumer$g = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useCheckboxContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$2z
  },
  name: "CheckboxContextConsumer"
}), defaultProps$1t = {
  defaultChecked: !1,
  indeterminate: !1,
  onChange: lodashExports.noop,
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop,
  type: "default"
}, vuePropsType$2y = vuePropsMake(propTypesCheckbox, defaultProps$1t), Checkbox$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2y
  },
  name: "Checkbox",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots(), c = reactive({
      checked: s.checked || s.defaultChecked || !1,
      addonId: s.addonId,
      extraId: s.extraId,
      focusVisible: !1
    }), m = ref$1(null), {
      adapter: g,
      getDataAttr: v
    } = useBaseComponent(s, c), {
      context: b
    } = useCheckboxContext();
    function S() {
      return {
        ...g(),
        setNativeControlChecked: (W) => {
          c.checked = W;
        },
        notifyChange: (W) => {
          const {
            onChange: ue
          } = s;
          ue && ue(W);
        },
        generateEvent: (W, ue) => ({
          target: {
            ...s,
            checked: W
          },
          stopPropagation: () => {
            ue.stopPropagation();
          },
          preventDefault: () => {
            ue.preventDefault();
          },
          nativeEvent: {
            stopImmediatePropagation: () => {
              ue.nativeEvent && typeof ue.nativeEvent.stopImmediatePropagation == "function" && ue.nativeEvent.stopImmediatePropagation();
            }
          }
        }),
        getIsInGroup: () => P(),
        getGroupValue: () => b && b.value.checkboxGroup.value || [],
        notifyGroupChange: (W) => {
          b.value.checkboxGroup.onChange(W);
        },
        getGroupDisabled: () => b && b.value.checkboxGroup.disabled,
        setAddonId: () => {
          c.addonId = getUuidShort({
            prefix: "addon"
          });
        },
        setExtraId: () => {
          c.extraId = getUuidShort({
            prefix: "extra"
          });
        },
        setFocusVisible: (W) => {
          c.focusVisible = W;
        },
        focusCheckboxEntity: () => {
          T();
        }
      };
    }
    const E = new CheckboxFoundation(S());
    watch(() => s.checked, () => {
      lodashExports.isUndefined(s.checked) ? E.setChecked(!1) : lodashExports.isBoolean(s.checked) && E.setChecked(s.checked);
    });
    function P() {
      return !!(b && b.value.checkboxGroup && "value" in o(s));
    }
    function T() {
      m.value && m.value.focus();
    }
    const N = (W) => E.handleChange(W), O = (W) => E.handleEnterPress(W), z = (W) => {
      E.handleFocusVisible(W);
    }, Q = (W) => {
      E.handleBlur();
    };
    return () => {
      const W = l.default ? l.default() : null, {
        disabled: ue,
        style: te,
        prefixCls: K,
        className: ve,
        indeterminate: ee,
        onMouseEnter: Re,
        onMouseLeave: wt,
        extra: yt,
        value: xt,
        role: Kt,
        tabIndex: tn,
        id: ln,
        type: rn
      } = s, {
        checked: an,
        addonId: Gt,
        extraId: nn,
        focusVisible: vt
      } = c, Et = {
        checked: an,
        disabled: ue
      }, Qt = P();
      if (Qt) {
        if (b.value.checkboxGroup.value) {
          const Nn = (b.value.checkboxGroup.value || []).includes(xt);
          Et.checked = Nn;
        }
        b.value.checkboxGroup.disabled && (Et.disabled = b.value.checkboxGroup.disabled || s.disabled);
        const {
          isCardType: On,
          isPureCardType: _n
        } = b.value.checkboxGroup;
        Et.isCardType = On, Et.isPureCardType = _n;
      } else
        Et.isPureCardType = rn === strings$h.TYPE_PURECARD, Et.isCardType = rn === strings$h.TYPE_CARD || Et.isPureCardType;
      const un = K || checkboxClasses.PREFIX, gn = Et.isCardType || Et.isPureCardType, dn = cls(un, {
        [`${un}-disabled`]: Et.disabled,
        [`${un}-indeterminate`]: ee,
        [`${un}-checked`]: Et.checked,
        [`${un}-unChecked`]: !Et.checked,
        [`${un}-cardType`]: Et.isCardType,
        [`${un}-cardType_disabled`]: Et.disabled && Et.isCardType,
        [`${un}-cardType_unDisabled`]: !(Et.disabled && Et.isCardType),
        [`${un}-cardType_checked`]: Et.isCardType && Et.checked && !Et.disabled,
        [`${un}-cardType_checked_disabled`]: Et.isCardType && Et.checked && Et.disabled,
        [ve]: !!ve,
        [`${un}-focus`]: vt && gn
      }), yn = cls(`${un}-extra`, {
        [`${un}-cardType_extra_noChildren`]: Et.isCardType && !W
      });
      Qt && b.value.checkboxGroup.name;
      const vn = s["x-semi-children-alias"] || "children", Pn = () => !W && !yt ? null : createVNode("div", {
        class: `${un}-content`
      }, [W ? createVNode("span", {
        id: Gt,
        class: `${un}-addon`,
        "x-semi-prop": vn
      }, [W]) : null, yt ? createVNode("div", {
        id: nn,
        class: yn,
        "x-semi-prop": "extra"
      }, [yt]) : null]);
      return (
        // label is better than span, however span is here which is to solve gitlab issue #364
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        createVNode("span", mergeProps$1({
          role: Kt,
          tabindex: tn,
          style: te,
          class: dn,
          id: ln,
          onMouseenter: Re,
          onMouseleave: wt,
          onClick: N,
          onKeypress: O,
          "aria-labelledby": s["aria-labelledby"]
        }, v()), [createVNode(CheckboxInner, {
          ...s,
          ...Et,
          addonId: W && Gt,
          extraId: yt && nn,
          isPureCardType: Et.isPureCardType,
          ref: m,
          focusInner: vt && !gn,
          onInputFocus: z,
          onInputBlur: Q
        }, null), Pn()])
      );
    };
  }
});
class CheckboxGroupFoundation extends BaseFoundation$1 {
  static get checkboxGroupDefaultAdapter() {
    return {};
  }
  constructor(o) {
    super({ ...CheckboxGroupFoundation.checkboxGroupDefaultAdapter, ...o });
  }
  init() {
    const { defaultValue: o, value: l } = this.getProps();
    typeof o < "u" && !Array.isArray(o) && warning$1(!0, "Warning: [Semi CheckboxGroup] defaultValue should be an Array"), typeof l < "u" && !Array.isArray(l) && warning$1(!0, "Warning: [Semi CheckboxGroup] value should be an Array");
  }
  notifyChange(o) {
    this._adapter.notifyChange(o);
  }
  handleChange(o) {
    const l = this.getState("value");
    let u = [];
    Array.isArray(l) || (u = [l]), o.target.checked ? u = [...l, o.target.value] : u = l.filter((m, g) => m !== o.target.value), "value" in this.getProps() ? this.notifyChange(u) : (this._adapter.updateGroupValue(u), this.notifyChange(u));
  }
  getFormatName() {
    return this.getProp("name") || "default";
  }
  handlePropValueChange(o) {
    Array.isArray(o) ? this._adapter.updateGroupValue(o) : (typeof o > "u" && this._adapter.updateGroupValue([]), warning$1(!0, "Warning: [Semi CheckboxGroup] value should be an Array"));
  }
  destroy() {
  }
}
const vuePropsType$2x = {
  value: Object
}, Provider$f = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("CheckboxContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$2x
  },
  name: "CheckboxContextProvider"
}), Context$1 = {
  Provider: Provider$f,
  Consumer: Consumer$g
};
function _isSlot$J(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$1y = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": [bool, string$3],
  "aria-labelledby": string$3,
  "aria-required": bool,
  defaultValue: array$1,
  disabled: bool,
  name: string$3,
  options: array$1,
  value: array$1,
  onChange: func,
  prefixCls: string$3,
  direction: String,
  className: string$3,
  type: String,
  style: object$1,
  id: String,
  "aria-label": String
}, defaultProps$1s = {
  disabled: !1,
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onChange: () => {
  },
  type: strings$h.TYPE_DEFAULT,
  defaultValue: [],
  direction: strings$h.DEFAULT_DIRECTION
}, vuePropsType$2w = vuePropsMake(propTypes$1y, defaultProps$1s), CheckboxGroup$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2w
  },
  name: "CheckboxGroup",
  setup(s, {}) {
    const o = useSlots(), l = reactive({
      value: s.value || s.defaultValue
    }), {
      adapter: u,
      getDataAttr: c
    } = useBaseComponent(s, l);
    function m() {
      return {
        ...u(),
        updateGroupValue: (b) => {
          l.value = b;
        },
        notifyChange: (b) => {
          s.onChange && s.onChange(b);
        }
      };
    }
    const g = new CheckboxGroupFoundation(m());
    onMounted(() => {
      g.init();
    }), watch(() => s.value, (b, S) => {
      lodashExports.isEqual(b, S) || g.handlePropValueChange(s.value);
    }, {
      deep: !0
    }), onUnmounted(() => {
      g.destroy();
    });
    function v(b) {
      g.handleChange(b);
    }
    return () => {
      var Re;
      const b = (Re = o.default) == null ? void 0 : Re.call(o), {
        options: S,
        prefixCls: E,
        direction: P,
        className: T,
        id: N,
        style: O,
        type: z,
        disabled: Q
      } = s, W = z === strings$h.TYPE_PURECARD, ue = z === strings$h.TYPE_CARD || W, te = E || checkboxGroupClasses.PREFIX, K = cls({
        [te]: !0,
        [`${te}-wrapper`]: !0,
        [`${te}-${P}`]: P,
        [`${te}-${P}-cardType`]: P && ue,
        [`${te}-${P}-pureCardType`]: P && W
      }, T), ve = l.value.slice();
      let ee;
      return S ? ee = (S || []).map((wt, yt) => typeof wt == "string" ? createVNode(Checkbox$1, {
        role: "listitem",
        key: yt,
        disabled: s.disabled,
        value: wt,
        prefixCls: E
      }, _isSlot$J(wt) ? wt : {
        default: () => [wt]
      }) : createVNode(Checkbox$1, {
        role: "listitem",
        key: yt,
        disabled: wt.disabled || s.disabled,
        value: wt.value,
        prefixCls: E,
        extra: wt.extra,
        className: wt.className,
        style: wt.style,
        onChange: wt.onChange
      }, {
        default: () => [wt.label]
      })) : b && (ee = o.default ? o.default().map((wt, yt) => cloneVNode(wt, {
        key: yt,
        role: "listitem"
      })) : null), createVNode("div", mergeProps$1({
        id: N,
        role: "list",
        "aria-label": s["aria-label"],
        class: K,
        style: O,
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"]
      }, c()), [createVNode(Context$1.Provider, {
        value: {
          checkboxGroup: {
            onChange: v,
            value: ve,
            disabled: s.disabled,
            name: g.getFormatName(),
            isCardType: ue,
            isPureCardType: W
          }
        }
      }, _isSlot$J(ee) ? ee : {
        default: () => [ee]
      })]);
    };
  }
});
Checkbox$1.Group = CheckboxGroup$1;
const CheckboxWithGroup = Checkbox$1, CheckboxGroup = CheckboxGroup$1, Checkbox = CheckboxWithGroup;
var mt = Number.isNaN || function(s) {
  return typeof s == "number" && s !== s;
};
function Lt(s, o) {
  return !!(s === o || mt(s) && mt(o));
}
function At(s, o) {
  if (s.length !== o.length)
    return !1;
  for (var l = 0; l < s.length; l++)
    if (!Lt(s[l], o[l]))
      return !1;
  return !0;
}
function V(s, o) {
  o === void 0 && (o = At);
  var l = null;
  function u() {
    for (var c = [], m = 0; m < arguments.length; m++)
      c[m] = arguments[m];
    if (l && l.lastThis === this && o(c, l.lastArgs))
      return l.lastResult;
    var g = s.apply(this, c);
    return l = {
      lastResult: g,
      lastArgs: c,
      lastThis: this
    }, g;
  }
  return u.clear = function() {
    l = null;
  }, u;
}
const Dt = typeof performance == "object" && typeof performance.now == "function", ht = Dt ? () => performance.now() : () => Date.now();
function at$1(s) {
  cancelAnimationFrame(s.id);
}
function zt(s, o) {
  const l = ht();
  function u() {
    ht() - l >= o ? s.call(null) : c.id = requestAnimationFrame(u);
  }
  const c = {
    id: requestAnimationFrame(u)
  };
  return c;
}
let ct$1 = -1;
function ft(s = !1) {
  if (ct$1 === -1 || s) {
    const o = document.createElement("div"), l = o.style;
    l.width = "50px", l.height = "50px", l.overflow = "scroll", document.body.appendChild(o), ct$1 = o.offsetWidth - o.clientWidth, document.body.removeChild(o);
  }
  return ct$1;
}
let j = null;
function lt$1(s = !1) {
  if (j === null || s) {
    const o = document.createElement("div"), l = o.style;
    l.width = "50px", l.height = "50px", l.overflow = "scroll", l.direction = "rtl";
    const u = document.createElement("div"), c = u.style;
    return c.width = "100px", c.height = "100px", o.appendChild(u), document.body.appendChild(o), o.scrollLeft > 0 ? j = "positive-descending" : (o.scrollLeft = 1, o.scrollLeft === 0 ? j = "negative" : j = "positive-ascending"), document.body.removeChild(o), j;
  }
  return j;
}
const kt = 150, Ut = ({ columnIndex: s, data: o, rowIndex: l }) => `${l}:${s}`;
function Rt$1({
  getColumnOffset: s,
  getColumnStartIndexForOffset: o,
  getColumnStopIndexForStartIndex: l,
  getColumnWidth: u,
  getEstimatedTotalHeight: c,
  getEstimatedTotalWidth: m,
  getOffsetForColumnAndAlignment: g,
  getOffsetForRowAndAlignment: v,
  getRowHeight: b,
  getRowOffset: S,
  getRowStartIndexForOffset: E,
  getRowStopIndexForStartIndex: P,
  initInstanceProps: T,
  shouldResetStyleCacheOnItemSizeChange: N,
  validateProps: O
}) {
  return defineComponent({
    props: {
      className: String,
      columnCount: Number,
      rowCount: Number,
      columnWidth: [Number, Function],
      rowHeight: [Number, Function],
      height: Number,
      overscanColumnCount: Number,
      overscanColumnsCount: Number,
      overscanRowCount: Number,
      overscanRowsCount: Number,
      initialScrollOffset: Number,
      innerRef: Object,
      initialScrollLeft: Number,
      initialScrollTop: Number,
      innerElementType: [String, Object, Function],
      innerTagName: String,
      itemCount: Number,
      itemKey: Function,
      itemSize: [Number, Function],
      onItemsRendered: Function,
      onScroll: Function,
      outerRef: [Object, Function],
      outerElementType: [String, Object, Function],
      outerTagName: String,
      style: [Object],
      width: [Number, String],
      direction: {
        type: String,
        default: "ltr"
      },
      itemData: {
        type: [Object, Array],
        default: void 0
      },
      layout: {
        type: String,
        default: "vertical"
      },
      overscanCount: {
        type: Number,
        default: 2
      },
      useIsScrolling: {
        type: Boolean,
        default: !1
      }
    },
    setup: (z, { slots: Q, expose: W }) => {
      let ue = T(z, {}), te, K = null;
      const ve = reactive({
        instance: {},
        isScrolling: !1,
        horizontalScrollDirection: "forward",
        scrollLeft: typeof z.initialScrollLeft == "number" ? z.initialScrollLeft : 0,
        scrollTop: typeof z.initialScrollTop == "number" ? z.initialScrollTop : 0,
        scrollUpdateWasRequested: !1,
        verticalScrollDirection: "forward"
      });
      let ee = V(
        (Et, Qt, un, gn, dn, yn, vn, Pn) => z.onItemsRendered && z.onItemsRendered({
          overscanColumnStartIndex: Et,
          overscanColumnStopIndex: Qt,
          overscanRowStartIndex: un,
          overscanRowStopIndex: gn,
          visibleColumnStartIndex: dn,
          visibleColumnStopIndex: yn,
          visibleRowStartIndex: vn,
          visibleRowStopIndex: Pn
        })
      ), Re = V(
        (Et, Qt, un, gn, dn) => z.onScroll && z.onScroll({
          horizontalScrollDirection: un,
          scrollLeft: Et,
          scrollTop: Qt,
          verticalScrollDirection: gn,
          scrollUpdateWasRequested: dn
        })
      );
      function wt() {
        const { columnCount: Et, onItemsRendered: Qt, onScroll: un, rowCount: gn } = z;
        if (typeof z.onItemsRendered == "function" && Et && gn && Et > 0 && gn > 0) {
          const [
            dn,
            yn,
            vn,
            Pn
          ] = Kt(), [
            On,
            _n,
            Nn,
            Un
          ] = tn();
          ee(
            dn,
            yn,
            On,
            _n,
            vn,
            Pn,
            Nn,
            Un
          );
        }
        if (typeof z.onScroll == "function") {
          const {
            horizontalScrollDirection: dn,
            scrollLeft: yn,
            scrollTop: vn,
            scrollUpdateWasRequested: Pn,
            verticalScrollDirection: On
          } = ve;
          Re(
            yn,
            vn,
            dn,
            On,
            Pn
          );
        }
      }
      const yt = (Et, Qt) => {
        const { columnWidth: un, direction: gn, rowHeight: dn } = z, yn = xt(
          N && un,
          N && gn,
          N && dn
        ), vn = `${Et}:${Qt}`;
        let Pn;
        if (yn.hasOwnProperty(vn))
          Pn = yn[vn];
        else {
          const On = s(
            z,
            Qt,
            ue
          ), _n = gn === "rtl";
          yn[vn] = Pn = {
            position: "absolute",
            left: _n ? void 0 : On + "px",
            right: _n ? On + "px" : void 0,
            top: S(z, Et, ue) + "px",
            height: b(z, Et, ue) + "px",
            width: u(z, Qt, ue) + "px"
          };
        }
        return Pn;
      }, xt = V((Et, Qt, un) => ({}));
      function Kt() {
        const {
          columnCount: Et,
          overscanColumnCount: Qt,
          overscanColumnsCount: un,
          overscanCount: gn,
          rowCount: dn
        } = z, { horizontalScrollDirection: yn, isScrolling: vn, scrollLeft: Pn } = ve, On = Qt || un || gn || 1;
        if (Et === 0 || dn === 0)
          return [0, 0, 0, 0];
        const _n = o(
          z,
          Pn,
          ue
        ), Nn = l(
          z,
          _n,
          Pn,
          ue
        ), Un = !vn || yn === "backward" ? Math.max(1, On) : 1, Xn = !vn || yn === "forward" ? Math.max(1, On) : 1;
        return [
          Math.max(0, _n - Un),
          Math.max(0, Math.min(Et - 1, Nn + Xn)),
          _n,
          Nn
        ];
      }
      function tn() {
        const {
          columnCount: Et,
          overscanCount: Qt,
          overscanRowCount: un,
          overscanRowsCount: gn,
          rowCount: dn
        } = z, { isScrolling: yn, verticalScrollDirection: vn, scrollTop: Pn } = ve, On = un || gn || Qt || 1;
        if (Et === 0 || dn === 0)
          return [0, 0, 0, 0];
        const _n = E(
          z,
          Pn,
          ue
        ), Nn = P(
          z,
          _n,
          Pn,
          ue
        ), Un = !yn || vn === "backward" ? Math.max(1, On) : 1, Xn = !yn || vn === "forward" ? Math.max(1, On) : 1;
        return [
          Math.max(0, _n - Un),
          Math.max(0, Math.min(dn - 1, Nn + Xn)),
          _n,
          Nn
        ];
      }
      const ln = (Et) => {
        const {
          clientHeight: Qt,
          clientWidth: un,
          scrollLeft: gn,
          scrollTop: dn,
          scrollHeight: yn,
          scrollWidth: vn
        } = Et.currentTarget;
        if (ve.scrollLeft !== gn || ve.scrollTop !== dn) {
          const { direction: Pn } = z;
          let On = gn;
          if (Pn === "rtl")
            switch (lt$1()) {
              case "negative":
                On = -gn;
                break;
              case "positive-descending":
                On = vn - un - gn;
                break;
            }
          On = Math.max(
            0,
            Math.min(On, vn - un)
          );
          const _n = Math.max(
            0,
            Math.min(dn, yn - Qt)
          );
          ve.isScrolling = !0, ve.horizontalScrollDirection = ve.scrollLeft < gn ? "forward" : "backward", ve.scrollLeft = On, ve.scrollTop = _n, ve.verticalScrollDirection = ve.scrollTop < dn ? "forward" : "backward", ve.scrollUpdateWasRequested = !1, an();
        }
      }, rn = (Et) => {
        const { outerRef: Qt } = z;
        te = Et, typeof Qt == "function" ? Qt(Et) : Qt != null && typeof Qt == "object" && Qt.hasOwnProperty("current") && (Qt.current = Et);
      }, an = () => {
        K !== null && at$1(K), K = zt(
          Gt,
          kt
        );
      }, Gt = () => {
        K = null, ve.isScrolling = !1, xt(-1, null, null);
      };
      function nn({ scrollLeft: Et, scrollTop: Qt }) {
        Et !== void 0 && (Et = Math.max(0, Et)), Qt !== void 0 && (Qt = Math.max(0, Qt)), Et === void 0 && (Et = ve.scrollLeft), Qt === void 0 && (Qt = ve.scrollTop), (ve.scrollLeft !== Et || ve.scrollTop !== Qt) && (ve.horizontalScrollDirection = ve.scrollLeft < Et ? "forward" : "backward", ve.scrollLeft = Et, ve.scrollTop = Qt, ve.scrollUpdateWasRequested = !0, ve.verticalScrollDirection = ve.scrollTop < Qt ? "forward" : "backward", an());
      }
      function vt({
        align: Et = "auto",
        columnIndex: Qt,
        rowIndex: un
      }) {
        const { columnCount: gn, height: dn, rowCount: yn, width: vn } = z, { scrollLeft: Pn, scrollTop: On } = ve, _n = ft();
        gn && Qt !== void 0 && (Qt = Math.max(0, Math.min(Qt, gn - 1))), yn && un !== void 0 && (un = Math.max(0, Math.min(un, yn - 1)));
        const Nn = c(
          z,
          ue
        ), Un = m(
          z,
          ue
        ) > parseInt(vn + "") ? _n : 0, Xn = Nn > parseInt(dn + "") ? _n : 0;
        nn({
          scrollLeft: Qt !== void 0 ? g(
            z,
            Qt,
            Et,
            Pn,
            ue,
            Xn
          ) : Pn,
          scrollTop: un !== void 0 ? v(
            z,
            un,
            Et,
            On,
            ue,
            Un
          ) : On
        });
      }
      return W({
        scrollToItem: vt
      }), onMounted(() => {
        const { initialScrollLeft: Et, initialScrollTop: Qt } = z;
        if (te != null) {
          const un = te;
          typeof Et == "number" && (un.scrollLeft = Et), typeof Qt == "number" && (un.scrollTop = Qt);
        }
        wt();
      }), watch(
        [
          () => z.direction,
          () => ve.scrollLeft,
          () => ve.scrollTop,
          () => ve.scrollUpdateWasRequested
        ],
        () => {
          const { direction: Et } = z, { scrollLeft: Qt, scrollTop: un, scrollUpdateWasRequested: gn } = ve;
          if (gn && te != null) {
            const dn = te;
            if (Et === "rtl")
              switch (lt$1()) {
                case "negative":
                  dn.scrollLeft = -Qt;
                  break;
                case "positive-ascending":
                  dn.scrollLeft = Qt;
                  break;
                default:
                  const { clientWidth: yn, scrollWidth: vn } = dn;
                  dn.scrollLeft = vn - yn - Qt;
                  break;
              }
            else
              dn.scrollLeft = Math.max(0, Qt);
            dn.scrollTop = Math.max(0, un);
          }
          wt();
        }
      ), onUnmounted(() => {
        K !== null && at$1(K);
      }), () => {
        const {
          className: Et,
          columnCount: Qt,
          direction: un,
          height: gn,
          innerRef: dn,
          innerElementType: yn,
          innerTagName: vn,
          itemData: Pn,
          itemKey: On = Ut,
          outerElementType: _n,
          outerTagName: Nn,
          rowCount: Un,
          style: Xn,
          useIsScrolling: zn,
          width: jn
        } = z, { isScrolling: kn } = ve, [
          Yn,
          Zn
        ] = Kt(), [er, bn] = tn(), Ln = [];
        if (Qt && Qt > 0 && Un)
          for (let Fn = er; Fn <= bn; Fn++)
            for (let Gn = Yn; Gn <= Zn; Gn++) {
              let Wn = {
                columnIndex: Gn,
                data: Pn,
                isScrolling: zn ? kn : void 0,
                key: On({ columnIndex: Gn, data: Pn, rowIndex: Fn }),
                rowIndex: Fn,
                style: yt(Fn, Gn)
              };
              Ln.push(
                h(Q.default ? Q.default(Wn)[0] : "", Wn)
              );
            }
        const Kn = c(
          z,
          ue
        ), Bn = m(
          z,
          ue
        );
        return h(
          _n || Nn || "div",
          {
            className: Et,
            onScroll: ln,
            ref: rn,
            style: {
              position: "relative",
              height: gn + "px",
              width: jn + "px",
              overflow: "auto",
              WebkitOverflowScrolling: "touch",
              willChange: "transform",
              direction: un,
              ...Xn
            }
          },
          h(yn || vn || "div", {
            ref: () => dn ? dn.value : void 0,
            style: {
              height: Kn + "px",
              pointerEvents: kn ? "none" : void 0,
              width: Bn + "px"
            }
          }, Ln)
        );
      };
    }
  });
}
const St = 50, Ct = ({ rowCount: s }, { rowMetadataMap: o, estimatedRowHeight: l, lastMeasuredRowIndex: u }) => {
  let c = 0;
  if (u >= s && (u = s - 1), u >= 0) {
    const g = o[u];
    c = g.offset + g.size;
  }
  const m = (s - u - 1) * l;
  return c + m;
}, Ot = ({ columnCount: s }, {
  columnMetadataMap: o,
  estimatedColumnWidth: l,
  lastMeasuredColumnIndex: u
}) => {
  let c = 0;
  if (u >= s && (u = s - 1), u >= 0) {
    const g = o[u];
    c = g.offset + g.size;
  }
  const m = (s - u - 1) * l;
  return c + m;
}, H$1 = (s, o, l, u) => {
  let c, m, g;
  if (s === "column" ? (c = u.columnMetadataMap, m = o.columnWidth, g = u.lastMeasuredColumnIndex) : (c = u.rowMetadataMap, m = o.rowHeight, g = u.lastMeasuredRowIndex), l > g) {
    let v = 0;
    if (g >= 0) {
      const b = c[g];
      v = b.offset + b.size;
    }
    for (let b = g + 1; b <= l; b++) {
      let S = m(b);
      c[b] = {
        offset: v,
        size: S
      }, v += S;
    }
    s === "column" ? u.lastMeasuredColumnIndex = l : u.lastMeasuredRowIndex = l;
  }
  return c[l];
}, Mt = (s, o, l, u) => {
  let c, m;
  return s === "column" ? (c = l.columnMetadataMap, m = l.lastMeasuredColumnIndex) : (c = l.rowMetadataMap, m = l.lastMeasuredRowIndex), (m > 0 ? c[m].offset : 0) >= u ? Tt(
    s,
    o,
    l,
    m,
    0,
    u
  ) : Ht(
    s,
    o,
    l,
    Math.max(0, m),
    u
  );
}, Tt = (s, o, l, u, c, m) => {
  for (; c <= u; ) {
    const g = c + Math.floor((u - c) / 2), v = H$1(
      s,
      o,
      g,
      l
    ).offset;
    if (v === m)
      return g;
    v < m ? c = g + 1 : v > m && (u = g - 1);
  }
  return c > 0 ? c - 1 : 0;
}, Ht = (s, o, l, u, c) => {
  const m = s === "column" ? o.columnCount : o.rowCount;
  let g = 1;
  for (; u < m && H$1(s, o, u, l).offset < c; )
    u += g, g *= 2;
  return Tt(
    s,
    o,
    l,
    Math.min(u, m - 1),
    Math.floor(u / 2),
    c
  );
}, gt = (s, o, l, u, c, m, g) => {
  const v = s === "column" ? o.width : o.height, b = H$1(s, o, l, m), S = s === "column" ? Ot(o, m) : Ct(o, m), E = Math.max(
    0,
    Math.min(S - v, b.offset)
  ), P = Math.max(
    0,
    b.offset - v + g + b.size
  );
  switch (u === "smart" && (c >= P - v && c <= E + v ? u = "auto" : u = "center"), u) {
    case "start":
      return E;
    case "end":
      return P;
    case "center":
      return Math.round(P + (E - P) / 2);
    case "auto":
    default:
      return c >= P && c <= E ? c : P > E || c < P ? P : E;
  }
};
Rt$1({
  getColumnOffset: (s, o, l) => H$1("column", s, o, l).offset,
  getColumnStartIndexForOffset: (s, o, l) => Mt("column", s, l, o),
  getColumnStopIndexForStartIndex: (s, o, l, u) => {
    const { columnCount: c, width: m } = s, g = H$1(
      "column",
      s,
      o,
      u
    ), v = l + m;
    let b = g.offset + g.size, S = o;
    for (; S < c - 1 && b < v; )
      S++, b += H$1("column", s, S, u).size;
    return S;
  },
  getColumnWidth: (s, o, l) => l.columnMetadataMap[o].size,
  getEstimatedTotalHeight: Ct,
  getEstimatedTotalWidth: Ot,
  getOffsetForColumnAndAlignment: (s, o, l, u, c, m) => gt(
    "column",
    s,
    o,
    l,
    u,
    c,
    m
  ),
  getOffsetForRowAndAlignment: (s, o, l, u, c, m) => gt(
    "row",
    s,
    o,
    l,
    u,
    c,
    m
  ),
  getRowOffset: (s, o, l) => H$1("row", s, o, l).offset,
  getRowHeight: (s, o, l) => l.rowMetadataMap[o].size,
  getRowStartIndexForOffset: (s, o, l) => Mt("row", s, l, o),
  getRowStopIndexForStartIndex: (s, o, l, u) => {
    const { rowCount: c, height: m } = s, g = H$1(
      "row",
      s,
      o,
      u
    ), v = l + m;
    let b = g.offset + g.size, S = o;
    for (; S < c - 1 && b < v; )
      S++, b += H$1("row", s, S, u).size;
    return S;
  },
  initInstanceProps(s, o) {
    const {
      estimatedColumnWidth: l,
      estimatedRowHeight: u
    } = s, c = {
      columnMetadataMap: {},
      estimatedColumnWidth: l || St,
      estimatedRowHeight: u || St,
      lastMeasuredColumnIndex: -1,
      lastMeasuredRowIndex: -1,
      rowMetadataMap: {}
    };
    return o.resetAfterColumnIndex = (m, g = !0) => {
      o.resetAfterIndices({ columnIndex: m, shouldForceUpdate: g });
    }, o.resetAfterRowIndex = (m, g = !0) => {
      o.resetAfterIndices({ rowIndex: m, shouldForceUpdate: g });
    }, o.resetAfterIndices = ({
      columnIndex: m,
      rowIndex: g,
      shouldForceUpdate: v = !0
    }) => {
      typeof m == "number" && (c.lastMeasuredColumnIndex = Math.min(
        c.lastMeasuredColumnIndex,
        m - 1
      )), typeof g == "number" && (c.lastMeasuredRowIndex = Math.min(
        c.lastMeasuredRowIndex,
        g - 1
      )), o._getItemStyleCache(-1), v && o.forceUpdate();
    }, c;
  },
  shouldResetStyleCacheOnItemSizeChange: !1,
  validateProps: ({ columnWidth: s, rowHeight: o }) => {
  }
});
const pt = 150, qt = (s, o) => s;
function Nt({
  getItemOffset: s,
  getEstimatedTotalSize: o,
  getItemSize: l,
  getOffsetForIndexAndAlignment: u,
  getStartIndexForOffset: c,
  getStopIndexForStartIndex: m,
  initInstanceProps: g,
  shouldResetStyleCacheOnItemSizeChange: v,
  validateProps: b
}) {
  return defineComponent({
    props: {
      className: String,
      height: Number,
      initialScrollOffset: Number,
      innerRef: Object,
      innerElementType: [String, Object, Function],
      innerTagName: String,
      itemCount: Number,
      itemKey: Function,
      itemSize: [Number, Function],
      onItemsRendered: Function,
      onScroll: Function,
      outerRef: [Object, Function],
      outerElementType: [String, Object, Function],
      outerTagName: String,
      style: [Object],
      width: [Number, String],
      direction: {
        type: String,
        default: "ltr"
      },
      itemData: {
        type: [Object, Array],
        default: void 0
      },
      layout: {
        type: String,
        default: "vertical"
      },
      overscanCount: {
        type: Number,
        default: 2
      },
      useIsScrolling: {
        type: Boolean,
        default: !1
      }
    },
    setup: (S, {
      slots: E,
      expose: P
    }) => {
      let T = g(S, {}), N, O = null;
      const z = reactive({
        instance: {},
        isScrolling: !1,
        scrollDirection: "forward",
        scrollOffset: typeof S.initialScrollOffset == "number" ? S.initialScrollOffset : 0,
        scrollUpdateWasRequested: !1
      });
      let Q;
      Q = V((ln, rn, an, Gt) => S.onItemsRendered && S.onItemsRendered({
        overscanStartIndex: ln,
        overscanStopIndex: rn,
        visibleStartIndex: an,
        visibleStopIndex: Gt
      }));
      let W;
      W = V((ln, rn, an) => S.onScroll && S.onScroll({
        scrollDirection: ln,
        scrollOffset: rn,
        scrollUpdateWasRequested: an
      }));
      function ue() {
        if (typeof S.onItemsRendered == "function") {
          const {
            itemCount: ln
          } = S;
          if (ln && ln > 0) {
            const [rn, an, Gt, nn] = ve();
            Q(rn, an, Gt, nn);
          }
        }
        if (typeof S.onScroll == "function") {
          const {
            scrollDirection: ln,
            scrollOffset: rn,
            scrollUpdateWasRequested: an
          } = z;
          W(ln, rn, an);
        }
      }
      const te = (ln) => {
        const {
          direction: rn,
          itemSize: an,
          layout: Gt
        } = S, nn = K(v && an, v && Gt, v && rn);
        let vt;
        if (nn.hasOwnProperty(ln))
          vt = nn[ln];
        else {
          const Et = s(S, ln, T), Qt = l(S, ln, T), un = rn === "horizontal" || Gt === "horizontal", gn = rn === "rtl", dn = un ? Et : 0;
          nn[ln] = vt = {
            position: "absolute",
            left: gn ? void 0 : dn + "px",
            right: gn ? dn + "px" : void 0,
            top: un ? 0 : Et + "px",
            height: un ? "100%" : Qt + "px",
            width: un ? Qt + "px" : "100%"
          };
        }
        return vt;
      }, K = V((ln, rn, an) => ({}));
      function ve() {
        const {
          itemCount: ln,
          overscanCount: rn
        } = S, {
          isScrolling: an,
          scrollDirection: Gt,
          scrollOffset: nn
        } = z;
        if (ln === 0)
          return [0, 0, 0, 0];
        const vt = c(S, nn, T), Et = m(S, vt, nn, T), Qt = !an || Gt === "backward" ? Math.max(1, rn) : 1, un = !an || Gt === "forward" ? Math.max(1, rn) : 1;
        return [
          Math.max(0, vt - Qt),
          Math.max(0, Math.min(ln - 1, Et + un)),
          vt,
          Et
        ];
      }
      const ee = (ln) => {
        const {
          clientWidth: rn,
          scrollLeft: an,
          scrollWidth: Gt
        } = ln.currentTarget;
        if (z.scrollOffset !== an) {
          const {
            direction: nn
          } = S;
          let vt = an;
          if (nn === "rtl")
            switch (lt$1()) {
              case "negative":
                vt = -an;
                break;
              case "positive-descending":
                vt = Gt - rn - an;
                break;
            }
          vt = Math.max(0, Math.min(vt, Gt - rn)), z.isScrolling = !0, z.scrollDirection = z.scrollOffset < an ? "forward" : "backward", z.scrollOffset = vt, z.scrollUpdateWasRequested = !1, yt();
        }
      }, Re = (ln) => {
        const {
          clientHeight: rn,
          scrollHeight: an,
          scrollTop: Gt
        } = ln.currentTarget;
        if (z.scrollOffset !== Gt) {
          const nn = Math.max(0, Math.min(Gt, an - rn));
          z.isScrolling = !0, z.scrollDirection = z.scrollOffset < nn ? "forward" : "backward", z.scrollOffset = nn, z.scrollUpdateWasRequested = !1, yt();
        }
      }, wt = (ln) => {
        const {
          outerRef: rn
        } = S;
        N = ln, typeof rn == "function" ? rn(ln) : rn != null && typeof rn == "object" && rn.hasOwnProperty("current") && (rn.current = ln);
      }, yt = () => {
        O !== null && at$1(O), O = zt(xt, pt);
      }, xt = () => {
        O = null, z.isScrolling = !1, K(-1, null, null);
      };
      function Kt(ln) {
        ln = Math.max(0, ln), z.scrollOffset !== ln && (z.scrollDirection = z.scrollOffset < ln ? "forward" : "backward", z.scrollOffset = ln, z.scrollUpdateWasRequested = !0, yt());
      }
      function tn(ln, rn = "auto") {
        const {
          itemCount: an,
          layout: Gt
        } = S, {
          scrollOffset: nn
        } = z;
        let vt = 0;
        if (N) {
          const Et = N;
          Gt === "vertical" ? vt = Et.scrollWidth > Et.clientWidth ? ft() : 0 : vt = Et.scrollHeight > Et.clientHeight ? ft() : 0;
        }
        an && (ln = Math.max(0, Math.min(ln, an - 1)), Kt(u(S, ln, rn, nn, T, vt)));
      }
      return P({
        scrollToItem: tn
      }), onMounted(() => {
        const {
          direction: ln,
          initialScrollOffset: rn,
          layout: an
        } = S;
        if (typeof rn == "number" && N != null) {
          const Gt = N;
          ln === "horizontal" || an === "horizontal" ? Gt.scrollLeft = rn : Gt.scrollTop = rn;
        }
        ue();
      }), watch([() => S.direction, () => S.layout, () => z.scrollOffset, () => z.scrollUpdateWasRequested], () => {
        const {
          direction: ln,
          layout: rn
        } = S, {
          scrollOffset: an,
          scrollUpdateWasRequested: Gt
        } = z;
        if (Gt && N != null) {
          const nn = N;
          if (ln === "horizontal" || rn === "horizontal")
            if (ln === "rtl")
              switch (lt$1()) {
                case "negative":
                  nn.scrollLeft = -an;
                  break;
                case "positive-ascending":
                  nn.scrollLeft = an;
                  break;
                default:
                  const {
                    clientWidth: vt,
                    scrollWidth: Et
                  } = nn;
                  nn.scrollLeft = Et - vt - an;
                  break;
              }
            else
              nn.scrollLeft = an;
          else
            nn.scrollTop = an;
        }
        ue();
      }), onUnmounted(() => {
        O !== null && at$1(O);
      }), () => {
        const {
          className: ln,
          direction: rn,
          height: an,
          innerRef: Gt,
          innerElementType: nn,
          innerTagName: vt,
          itemCount: Et,
          itemData: Qt,
          itemKey: un = qt,
          layout: gn,
          outerElementType: dn,
          outerTagName: yn,
          style: vn,
          useIsScrolling: Pn,
          width: On
        } = S, {
          isScrolling: _n
        } = z, Nn = rn === "horizontal" || gn === "horizontal", Un = Nn ? ee : Re, [Xn, zn] = ve(), jn = [];
        if (Et && Et > 0)
          for (let Zn = Xn; Zn <= zn; Zn++) {
            let er = {
              data: Qt,
              key: un(Zn, Qt),
              index: Zn,
              isScrolling: Pn ? _n : void 0,
              style: te(Zn)
            };
            jn.push(h(E.default ? E.default(er)[0] : "", er));
          }
        const kn = o(S, T), Yn = [h(nn || vt || "div", {
          ref: () => Gt ? Gt.value : void 0,
          style: {
            height: Nn ? "100%" : kn + "px",
            pointerEvents: _n ? "none" : void 0,
            width: Nn ? kn + "px" : "100%"
          }
        }, typeof (nn || vt || "div") == "string" ? jn : () => jn)];
        return h(dn || yn || "div", {
          className: ln,
          onScroll: Un,
          ref: wt,
          style: {
            position: "relative",
            height: an + "px",
            width: On + "px",
            overflow: "auto",
            WebkitOverflowScrolling: "touch",
            willChange: "transform",
            direction: rn,
            ...vn
          }
        }, typeof (dn || yn || "div") == "string" ? Yn : () => Yn);
      };
    }
  });
}
const jt = 50, $$1 = (s, o, l) => {
  const { itemSize: u } = s, { itemMetadataMap: c, lastMeasuredIndex: m } = l;
  if (o > m) {
    let g = 0;
    if (m >= 0) {
      const v = c[m];
      g = v.offset + v.size;
    }
    for (let v = m + 1; v <= o; v++) {
      let b = u(v);
      c[v] = {
        offset: g,
        size: b
      }, g += b;
    }
    l.lastMeasuredIndex = o;
  }
  return c[o];
}, $t = (s, o, l) => {
  const { itemMetadataMap: u, lastMeasuredIndex: c } = o;
  return (c > 0 ? u[c].offset : 0) >= l ? _t(
    s,
    o,
    c,
    0,
    l
  ) : Bt(
    s,
    o,
    Math.max(0, c),
    l
  );
}, _t = (s, o, l, u, c) => {
  for (; u <= l; ) {
    const m = u + Math.floor((l - u) / 2), g = $$1(s, m, o).offset;
    if (g === c)
      return m;
    g < c ? u = m + 1 : g > c && (l = m - 1);
  }
  return u > 0 ? u - 1 : 0;
}, Bt = (s, o, l, u) => {
  const { itemCount: c } = s;
  let m = 1;
  for (; l < c && $$1(s, l, o).offset < u; )
    l += m, m *= 2;
  return _t(
    s,
    o,
    Math.min(l, c - 1),
    Math.floor(l / 2),
    u
  );
}, It = ({ itemCount: s }, { itemMetadataMap: o, estimatedItemSize: l, lastMeasuredIndex: u }) => {
  let c = 0;
  if (u >= s && (u = s - 1), u >= 0) {
    const g = o[u];
    c = g.offset + g.size;
  }
  const m = (s - u - 1) * l;
  return c + m;
}, Pt = Nt({
  getItemOffset: (s, o, l) => $$1(s, o, l).offset,
  getItemSize: (s, o, l) => l.itemMetadataMap[o].size,
  getEstimatedTotalSize: It,
  getOffsetForIndexAndAlignment: (s, o, l, u, c, m) => {
    const { direction: g, height: v, layout: b, width: S } = s, E = g === "horizontal" || b === "horizontal" ? S : v, P = $$1(s, o, c), T = It(s, c), N = Math.max(
      0,
      Math.min(T - E, P.offset)
    ), O = Math.max(
      0,
      P.offset - E + P.size + m
    );
    switch (l === "smart" && (u >= O - E && u <= N + E ? l = "auto" : l = "center"), l) {
      case "start":
        return N;
      case "end":
        return O;
      case "center":
        return Math.round(O + (N - O) / 2);
      case "auto":
      default:
        return u >= O && u <= N ? u : u < O ? O : N;
    }
  },
  getStartIndexForOffset: (s, o, l) => $t(s, l, o),
  getStopIndexForStartIndex: (s, o, l, u) => {
    const { direction: c, height: m, itemCount: g, layout: v, width: b } = s, S = c === "horizontal" || v === "horizontal" ? b : m, E = $$1(s, o, u), P = l + S;
    let T = E.offset + E.size, N = o;
    for (; N < g - 1 && T < P; )
      N++, T += $$1(s, N, u).size;
    return N;
  },
  initInstanceProps(s, o) {
    const { estimatedItemSize: l } = s, u = {
      itemMetadataMap: {},
      estimatedItemSize: l || jt,
      lastMeasuredIndex: -1
    };
    return o.resetAfterIndex = (c, m = !0) => {
      u.lastMeasuredIndex = Math.min(
        u.lastMeasuredIndex,
        c - 1
      ), o._getItemStyleCache(-1), m && o.forceUpdate();
    }, u;
  },
  shouldResetStyleCacheOnItemSizeChange: !1,
  validateProps: ({ itemSize: s }) => {
  }
});
Rt$1({
  getColumnOffset: ({ columnWidth: s }, o) => o * s,
  getColumnWidth: ({ columnWidth: s }, o) => s,
  getRowOffset: ({ rowHeight: s }, o) => o * s,
  getRowHeight: ({ rowHeight: s }, o) => s,
  getEstimatedTotalHeight: ({ rowCount: s, rowHeight: o }) => o * s,
  getEstimatedTotalWidth: ({ columnCount: s, columnWidth: o }) => o * s,
  getOffsetForColumnAndAlignment: ({ columnCount: s, columnWidth: o, width: l }, u, c, m, g, v) => {
    const b = Math.max(
      0,
      s * o - l
    ), S = Math.min(
      b,
      u * o
    ), E = Math.max(
      0,
      u * o - l + v + o
    );
    switch (c === "smart" && (m >= E - l && m <= S + l ? c = "auto" : c = "center"), c) {
      case "start":
        return S;
      case "end":
        return E;
      case "center":
        const P = Math.round(
          E + (S - E) / 2
        );
        return P < Math.ceil(l / 2) ? 0 : P > b + Math.floor(l / 2) ? b : P;
      case "auto":
      default:
        return m >= E && m <= S ? m : E > S || m < E ? E : S;
    }
  },
  getOffsetForRowAndAlignment: ({ rowHeight: s, height: o, rowCount: l }, u, c, m, g, v) => {
    const b = Math.max(
      0,
      l * s - o
    ), S = Math.min(
      b,
      u * s
    ), E = Math.max(
      0,
      u * s - o + v + s
    );
    switch (c === "smart" && (m >= E - o && m <= S + o ? c = "auto" : c = "center"), c) {
      case "start":
        return S;
      case "end":
        return E;
      case "center":
        const P = Math.round(
          E + (S - E) / 2
        );
        return P < Math.ceil(o / 2) ? 0 : P > b + Math.floor(o / 2) ? b : P;
      case "auto":
      default:
        return m >= E && m <= S ? m : E > S || m < E ? E : S;
    }
  },
  getColumnStartIndexForOffset: ({ columnWidth: s, columnCount: o }, l) => Math.max(
    0,
    Math.min(
      o - 1,
      Math.floor(l / s)
    )
  ),
  getColumnStopIndexForStartIndex: ({ columnWidth: s, columnCount: o, width: l }, u, c) => {
    const m = u * s, g = Math.ceil(
      (l + c - m) / s
    );
    return Math.max(
      0,
      Math.min(
        o - 1,
        u + g - 1
      )
    );
  },
  getRowStartIndexForOffset: ({ rowHeight: s, rowCount: o }, l) => Math.max(
    0,
    Math.min(o - 1, Math.floor(l / s))
  ),
  getRowStopIndexForStartIndex: ({ rowHeight: s, rowCount: o, height: l }, u, c) => {
    const m = u * s, g = Math.ceil(
      (l + c - m) / s
    );
    return Math.max(
      0,
      Math.min(
        o - 1,
        u + g - 1
      )
    );
  },
  initInstanceProps(s) {
  },
  shouldResetStyleCacheOnItemSizeChange: !0,
  validateProps: ({ columnWidth: s, rowHeight: o }) => {
  }
});
const Vt = ({ direction: s, height: o, itemCount: l, itemSize: u, layout: c, width: m }, g, v, b, S, E) => {
  const P = s === "horizontal" || c === "horizontal" ? m : o, T = Math.max(
    0,
    l * u - P
  ), N = Math.min(
    T,
    g * u
  ), O = Math.max(
    0,
    g * u - P + u + E
  );
  switch (v === "smart" && (b >= O - P && b <= N + P ? v = "auto" : v = "center"), v) {
    case "start":
      return N;
    case "end":
      return O;
    case "center": {
      const z = Math.round(
        O + (N - O) / 2
      );
      return z < Math.ceil(P / 2) ? 0 : z > T + Math.floor(P / 2) ? T : z;
    }
    case "auto":
    default:
      return b >= O && b <= N ? b : b < O ? O : N;
  }
}, Jt$1 = Nt({
  getItemOffset: ({ itemSize: s }, o) => o * s,
  getItemSize: ({ itemSize: s }, o) => s,
  getEstimatedTotalSize: ({ itemCount: s, itemSize: o }) => o * s,
  getOffsetForIndexAndAlignment: Vt,
  getStartIndexForOffset: ({ itemCount: s, itemSize: o }, l) => Math.max(
    0,
    Math.min(s - 1, Math.floor(l / o))
  ),
  getStopIndexForStartIndex: ({ direction: s, height: o, itemCount: l, itemSize: u, layout: c, width: m }, g, v) => {
    const b = s === "horizontal" || c === "horizontal", S = g * u, E = Math.ceil(
      ((b ? m : o) + v - S) / u
    );
    return Math.max(
      0,
      Math.min(
        l - 1,
        g + E - 1
      )
    );
  },
  initInstanceProps(s) {
  },
  shouldResetStyleCacheOnItemSizeChange: !0,
  validateProps: ({ itemSize: s }) => {
  }
}), VirtualRow$1 = ({
  index: s,
  data: o,
  style: l
}) => {
  const {
    visibleOptions: u,
    renderOption: c
  } = o, m = u[s];
  return c(m, s, l);
};
function _isSlot$I(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$8 = cssClasses$L.PREFIX_OPTION, vuePropsType$2v = {
  activeKeys: {
    type: Object,
    required: !0
  },
  selectedKeys: {
    type: Object,
    required: !0
  },
  loadedKeys: {
    type: Object,
    required: !0
  },
  loadingKeys: {
    type: Object,
    required: !0
  },
  onItemClick: {
    type: Function,
    required: !0
  },
  onItemHover: {
    type: Function,
    required: !0
  },
  showNext: {
    type: String,
    required: !0
  },
  onItemCheckboxClick: {
    type: Function,
    required: !0
  },
  onListScroll: {
    type: Function,
    required: !0
  },
  searchable: {
    type: Boolean,
    required: !0
  },
  keyword: {
    type: String,
    required: !0
  },
  virtualize: Object,
  emptyContent: {
    type: [Object, String],
    required: !1
  },
  loadData: {
    type: Function,
    required: !1
  },
  data: {
    type: Array,
    required: !0
  },
  separator: {
    type: String,
    required: !0
  },
  multiple: {
    type: Boolean,
    required: !0
  },
  checkedKeys: {
    type: Object,
    required: !0
  },
  halfCheckedKeys: {
    type: Object,
    required: !0
  },
  empty: {
    type: Boolean,
    default: !1
  },
  filterRender: Function,
  style: Object,
  className: String
}, Item$4 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2v
  },
  name: "CascaderItem",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useBaseComponent(s, {}), l = (Q, W) => {
      const {
        onItemClick: ue
      } = s;
      W.data.disabled || "disabled" in W && W.disabled || ue(Q, W);
    }, u = (Q, W) => {
      isEnterPress(Q) && l(Q, W);
    }, c = (Q, W) => {
      const {
        showNext: ue,
        onItemHover: te
      } = s;
      W.data.disabled || ue === strings$i.SHOW_NEXT_BY_HOVER && te(Q, W);
    }, m = (Q, W) => {
      const {
        onItemCheckboxClick: ue
      } = s;
      Q.stopPropagation(), Q && Q.nativeEvent && typeof Q.nativeEvent.stopImmediatePropagation == "function" && Q.nativeEvent.stopImmediatePropagation(), Q && Q.stopImmediatePropagation && typeof Q.stopImmediatePropagation == "function" && Q.stopImmediatePropagation(), ue(W);
    }, g = (Q) => {
      const {
        activeKeys: W,
        selectedKeys: ue,
        loadedKeys: te,
        loadingKeys: K
      } = s, ve = {
        active: !1,
        selected: !1,
        loading: !1
      };
      return W.has(Q) && (ve.active = !0), ue.has(Q) && (ve.selected = !0), K.has(Q) && !te.has(Q) && (ve.loading = !0), ve;
    }, v = (Q) => {
      switch (Q) {
        case "child":
          return createVNode(IconComponent$y, {
            className: `${prefixcls$8}-icon ${prefixcls$8}-icon-expand`
          }, null);
        case "tick":
          return createVNode(IconComponent$6, {
            className: `${prefixcls$8}-icon ${prefixcls$8}-icon-active`
          }, null);
        case "loading":
          return createVNode(Spin, {
            wrapperClassName: `${prefixcls$8}-spin-icon`
          }, null);
        case "empty":
          return createVNode("span", {
            "aria-hidden": !0,
            class: `${prefixcls$8}-icon ${prefixcls$8}-icon-empty`
          }, null);
        default:
          return null;
      }
    }, b = (Q) => {
      const W = [], {
        keyword: ue,
        separator: te
      } = s;
      return Q.forEach((K, ve) => {
        typeof K == "string" && lodashExports.includes(K, ue) ? K.split(ue).forEach((ee, Re) => {
          Re > 0 && W.push(createVNode("span", {
            class: `${prefixcls$8}-label-highlight`,
            key: `${Re}-${ve}`
          }, [ue])), W.push(ee);
        }) : W.push(K), ve !== Q.length - 1 && W.push(te);
      }), W;
    }, S = (Q, W, ue) => {
      const {
        multiple: te,
        selectedKeys: K,
        checkedKeys: ve,
        halfCheckedKeys: ee,
        keyword: Re,
        filterRender: wt,
        virtualize: yt
      } = s, {
        searchText: xt,
        key: Kt,
        disabled: tn,
        pathData: ln
      } = Q, rn = K.has(Kt), an = cls(prefixcls$8, {
        [`${prefixcls$8}-flatten`]: !wt,
        [`${prefixcls$8}-disabled`]: tn,
        [`${prefixcls$8}-select`]: rn && !te
      }), Gt = (Et) => {
        l(Et, Q);
      }, nn = (Et) => u(Et, Q), vt = (Et) => m(Et, Q);
      if (wt) {
        const Et = {
          className: an,
          inputValue: Re,
          disabled: tn,
          data: ln,
          checkStatus: {
            checked: ve.has(Q.key),
            halfChecked: ee.has(Q.key)
          },
          selected: rn,
          onClick: Gt,
          onCheck: vt
        }, Qt = wt(Et), un = yt ? {
          key: Kt,
          style: {
            ...Qt.props.style ?? {},
            ...ue
          }
        } : {
          key: Kt
        };
        return cloneVNode(Qt, un);
      }
      return createVNode("li", {
        role: "menuitem",
        class: an,
        style: ue,
        key: Kt,
        onClick: Gt,
        onKeypress: nn
      }, [createVNode("span", {
        class: `${prefixcls$8}-label`
      }, [!te && v("empty"), te && createVNode(Checkbox, {
        onChange: vt,
        disabled: tn,
        indeterminate: ee.has(Q.key),
        checked: ve.has(Q.key),
        className: `${prefixcls$8}-label-checkbox`
      }, null), b(xt)])]);
    }, E = (Q) => {
      const {
        virtualize: W
      } = s;
      return createVNode("ul", {
        class: `${prefixcls$8}-list`,
        key: "flatten-list"
      }, [W ? P(Q) : Q.map((te) => S(te))]);
    }, P = (Q) => {
      const {
        direction: W
      } = o.value, {
        virtualize: ue
      } = s;
      return createVNode(Jt$1, {
        height: parseInt("" + ue.height),
        itemCount: Q.length,
        itemSize: ue.itemSize,
        itemData: {
          visibleOptions: Q,
          renderOption: S
        },
        width: ue.width ?? "100%",
        style: {
          direction: W
        }
      }, _isSlot$I(VirtualRow$1) ? VirtualRow$1 : {
        default: () => [VirtualRow$1]
      });
    }, T = ref$1();
    function N(Q, W = []) {
      const {
        multiple: ue,
        checkedKeys: te,
        halfCheckedKeys: K
      } = s;
      let ve;
      const ee = W.length;
      return W.push(createVNode("ul", {
        role: "menu",
        class: `${prefixcls$8}-list`,
        key: Q[0].key,
        onScroll: (Re) => s.onListScroll(Re, ee)
      }, [Q.map((Re) => {
        const {
          data: wt,
          key: yt,
          parentKey: xt
        } = Re, {
          children: Kt,
          label: tn,
          disabled: ln,
          isLeaf: rn
        } = wt, {
          active: an,
          selected: Gt,
          loading: nn
        } = g(yt), vt = !!Kt && Kt.length, Et = vt || s.loadData && !rn;
        an && vt && (ve = Re);
        const Qt = cls(prefixcls$8, {
          [`${prefixcls$8}-active`]: an && !Gt,
          [`${prefixcls$8}-select`]: Gt && !ue,
          [`${prefixcls$8}-disabled`]: ln
        }), un = xt ? {
          "aria-owns": `cascaderItem-${xt}`
        } : {};
        return createVNode("li", mergeProps$1({
          role: "menuitem",
          id: `cascaderItem-${yt}`,
          "aria-expanded": an,
          "aria-haspopup": !!Et,
          "aria-disabled": ln
        }, un, {
          class: Qt,
          key: yt,
          onClick: (gn) => {
            l(gn, Re);
          },
          onKeypress: (gn) => u(gn, Re),
          onMouseenter: (gn) => {
            c(gn, Re);
          }
        }), [createVNode("span", {
          class: `${prefixcls$8}-label`
        }, [Gt && !ue && v("tick"), !Gt && !ue && v("empty"), ue && createVNode(Checkbox, {
          onChange: (gn) => m(gn, Re),
          disabled: ln,
          indeterminate: K.has(Re.key),
          checked: te.has(Re.key),
          className: `${prefixcls$8}-label-checkbox`
        }, null), createVNode("span", null, [tn])]), Et ? v(nn ? "loading" : "child") : null]);
      })])), ve && W.concat(N(ve.children, W)), W;
    }
    function O() {
      const {
        emptyContent: Q
      } = s;
      return createVNode(LocaleConsumer$6, {
        componentName: "Cascader"
      }, {
        default: (W) => createVNode("ul", {
          class: `${prefixcls$8} ${prefixcls$8}-empty`,
          key: "empty-list"
        }, [createVNode("span", {
          class: `${prefixcls$8}-label`
        }, [Q || W.emptyText])])
      });
    }
    function z() {
      s.activeKeys.forEach((Q) => {
        var te;
        let W = `cascaderItem-${Q}`, ue = (te = T.value) == null ? void 0 : te.querySelector("#" + W);
        if (ue) {
          const K = ue.parentNode;
          K.scrollTop = ue.offsetTop - K.offsetTop - K.clientHeight / 2 + ue.clientHeight / 2;
        }
      });
    }
    return onMounted(() => {
      z();
    }), () => {
      const {
        data: Q,
        searchable: W
      } = s, {
        direction: ue
      } = o.value, te = !Q || !Q.length;
      let K;
      const ve = cls({
        [`${prefixcls$8}-lists`]: !0,
        [`${prefixcls$8}-lists-rtl`]: ue === "rtl",
        [`${prefixcls$8}-lists-empty`]: te
      });
      return te ? K = O() : K = W ? E(Q) : N(Q), createVNode("div", {
        ref: T,
        class: ve
      }, [K]);
    };
  }
}), cssClasses$K = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-tag`
}, strings$g = {
  TAG_SIZE: ["default", "small", "large"],
  TAG_COLOR: [
    "grey",
    "red",
    "pink",
    "purple",
    "violet",
    "indigo",
    "blue",
    "light-blue",
    "cyan",
    "teal",
    "green",
    "light-green",
    "lime",
    "yellow",
    "amber",
    "orange",
    "white"
  ],
  TAG_TYPE: ["light", "solid", "ghost"],
  AVATAR_SHAPE: ["square", "circle"]
}, prefixCls$H = cssClasses$K.PREFIX, tagColors = strings$g.TAG_COLOR, tagSize$1 = strings$g.TAG_SIZE, tagType = strings$g.TAG_TYPE, propTypes$1x = {
  tagKey: oneOfType([string$3, number$2]),
  size: String,
  color: String,
  type: String,
  closable: bool,
  visible: bool,
  onClose: func,
  onClick: func,
  style: object$1,
  className: string$3,
  avatarSrc: string$3,
  avatarShape: String,
  "aria-label": string$3,
  shape: {
    type: String,
    default: "square"
  },
  onKeydown: Function,
  tabIndex: Number,
  // use internal, when tag in taInput, we want to use left arrow and right arrow to control the tag focus, so the tabIndex need to be -1.
  onMouseenter: Function,
  prefixIcon: node$1,
  suffixIcon: node$1
}, defaultProps$1r = {
  size: tagSize$1[0],
  color: tagColors[0],
  closable: !1,
  // visible: true,
  type: tagType[0],
  onClose: () => {
  },
  onClick: () => {
  },
  onMouseenter: () => {
  },
  style: {},
  className: "",
  shape: "square",
  avatarShape: "square",
  prefixIcon: null,
  suffixIcon: null
}, vuePropsType$2u = vuePropsMake(propTypes$1x, defaultProps$1r), Index$4 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2u
  },
  name: "Tag",
  setup(s, {
    slots: o
  }) {
    const {
      getProps: l
    } = useHasInProps(), u = reactive({
      visible: !0
    });
    function c(S) {
      return "visible" in S ? {
        visible: S.visible
      } : null;
    }
    watch(() => s.visible, (S) => {
      const E = c({
        ...s
      });
      E && Object.keys(E).forEach((P) => {
        u[P] = E[P];
      });
    });
    function m(S) {
      "visible" in s || (u.visible = S);
    }
    function g(S, E, P) {
      const {
        onClose: T
      } = s;
      S.stopPropagation(), S.stopImmediatePropagation(), T && T(E, S, P), !S.defaultPrevented && m(!1);
    }
    function v(S) {
      var N;
      const {
        closable: E,
        onClick: P,
        onKeydown: T
      } = s;
      switch (S.key) {
        case "Backspace":
        case "Delete":
          E && g(S, (N = o.default) == null ? void 0 : N.call(o), s.tagKey), handlePrevent(S);
          break;
        case "Enter":
          P(S), handlePrevent(S);
          break;
        case "Escape":
          S.target.blur();
          break;
      }
      T && T(S);
    }
    function b() {
      const {
        avatarShape: S,
        avatarSrc: E
      } = s;
      return createVNode(Avatar$1, {
        src: E,
        shape: S
      }, null);
    }
    return () => {
      const S = o.default ? o.default() : null, {
        tagKey: E,
        size: P,
        color: T,
        closable: N,
        visible: O,
        onClose: z,
        onClick: Q,
        className: W,
        type: ue,
        shape: te,
        avatarSrc: K,
        avatarShape: ve,
        tabIndex: ee,
        prefixIcon: Re,
        suffixIcon: wt,
        ...yt
      } = l(s), {
        visible: xt
      } = u, Kt = Q !== defaultProps$1r.onClick || N, tn = {
        role: "button",
        tabIndex: ee || 0,
        onKeyDown: v
      }, ln = {
        ...yt,
        onClick: Q,
        tabindex: ee,
        className: cls(prefixCls$H, {
          [`${prefixCls$H}-default`]: P === "default",
          [`${prefixCls$H}-small`]: P === "small",
          [`${prefixCls$H}-large`]: P === "large",
          [`${prefixCls$H}-square`]: te === "square",
          [`${prefixCls$H}-circle`]: te === "circle",
          [`${prefixCls$H}-${ue}`]: ue,
          [`${prefixCls$H}-${T}-${ue}`]: T && ue,
          [`${prefixCls$H}-closable`]: N,
          [`${prefixCls$H}-invisible`]: !xt,
          [`${prefixCls$H}-avatar-${ve}`]: K
        }, W)
      }, rn = Kt ? {
        ...ln,
        ...tn
      } : ln, an = N ? createVNode("div", {
        class: `${prefixCls$H}-close`,
        onClick: (Et) => g(Et, S[0], E)
      }, [createVNode(IconComponent$u, {
        size: "small"
      }, null)]) : null, Gt = lodashExports.isString(S), nn = cls(`${prefixCls$H}-content`, `${prefixCls$H}-content-${Gt ? "ellipsis" : "center"}`), vt = symbol();
      return createVNode("div", mergeProps$1({
        "aria-label": s["aria-label"] || Gt ? `${N ? "Closable " : ""}Tag: ${S}` : ""
      }, rn), [Re ? createVNode("div", {
        class: `${prefixCls$H}-prefix-icon`
      }, [Re]) : null, K ? b() : null, createVNode("div", {
        class: nn,
        key: vt
      }, [S]), wt ? createVNode("div", {
        class: `${prefixCls$H}-suffix-icon`
      }, [wt]) : null, an]);
    };
  }
}), Tag = Index$4, cssClasses$J = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-tagInput`
}, getSplitedArray = (s, o) => {
  let l = [];
  if (lodashExports.isString(o) || lodashExports.isNumber(o))
    l = s.split(o);
  else if (lodashExports.isArray(o)) {
    const u = o[0];
    l = s;
    for (let c = 1; c < o.length; c++)
      l = l.split(o[c]).join(u);
    l = l.split(u);
  } else
    l.push(s);
  return l;
};
function arrayMove(s, o, l) {
  const u = s.slice();
  return u.splice(l < 0 ? u.length + l : l, 0, u.splice(o, 1)[0]), u;
}
class TagInputFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleInputChange = (l) => {
      const { value: u } = l.target, { entering: c } = this.getStates();
      c ? this._onInputChange(u, l) : this._checkInputChangeValid(u) && this._onInputChange(u, l);
    }, this.handleInputCompositionStart = (l) => {
      const { maxLength: u } = this.getProps();
      lodashExports.isNumber(u) && this._adapter.setEntering(!0);
    }, this.handleInputCompositionEnd = (l) => {
      const { value: u } = l.target, {
        maxLength: c,
        onInputExceed: m,
        separator: g
      } = this.getProps();
      if (!lodashExports.isNumber(c))
        return;
      this._adapter.setEntering(!1);
      let v = !0;
      const b = getSplitedArray(u, g);
      let S = 0;
      for (; S < b.length; S++)
        if (b[S].length > c) {
          v = !1, lodashExports.isFunction(m) && m(u);
          break;
        }
      if (v)
        this._adapter.setInputValue(u);
      else {
        const E = b.slice(0, S);
        S < b.length && E.push(b[S].slice(0, c)), this._adapter.setInputValue(E.join(g));
      }
    }, this._checkInputChangeValid = (l) => {
      const {
        maxLength: u,
        onInputExceed: c,
        separator: m
      } = this._adapter.getProps(), { inputValue: g } = this._adapter.getStates();
      let v = !0;
      if (lodashExports.isNumber(u)) {
        const b = getSplitedArray(l, m), S = getSplitedArray(g, m), E = Math.max(b.length, S.length);
        for (let P = 0; P < E; P++)
          if (!lodashExports.isUndefined(b[P]) && (lodashExports.isUndefined(S[P]) || b[P].length > S[P].length) && b[P].length > u) {
            v = !1, lodashExports.isFunction(c) && c(l);
            break;
          }
      }
      return v;
    }, this.handleKeyDown = (l) => {
      const {
        inputValue: u,
        tagsArray: c
      } = this._adapter.getStates(), m = l.keyCode;
      m === KeyCode.ENTER && (l.preventDefault(), u !== "" && this._handleAddTags(l));
      const { length: g } = c;
      if (m === KeyCode.BACKSPACE && u === "" && g > 0) {
        const v = c.slice(0, g - 1), b = c[g - 1];
        this._onRemove(v, b, g - 1);
      }
      this._adapter.notifyKeyDown(l);
    };
  }
  _handleAddTags(o) {
    const {
      separator: l,
      max: u,
      onExceed: c,
      allowDuplicates: m
    } = this._adapter.getProps(), {
      inputValue: g,
      tagsArray: v
    } = this._adapter.getStates();
    let b = getSplitedArray(g, l);
    b = b.filter((E, P) => !m && (v.includes(E) || b.indexOf(E) !== P) ? !1 : lodashExports.isString(E) && E.trim() !== "");
    let S = v.concat(b);
    lodashExports.isNumber(u) && S.length > u && (lodashExports.isFunction(c) && c(S), S = S.slice(0, u), b = b.slice(0, u - v.length)), b.length > 0 && this._onAdd(S, b), this._onInputChange("", o);
  }
  handleInputBlur(o) {
    const { addOnBlur: l } = this._adapter.getProps();
    l === !0 && this._handleAddTags(o), this._adapter.setFocusing(!1), this._adapter.notifyBlur(o);
  }
  handleInputFocus(o) {
    this._adapter.setFocusing(!0), this._adapter.notifyFocus(o);
  }
  /**
   * A11y: simulate clear button click
   */
  /* istanbul ignore next */
  handleClearEnterPress(o) {
    isEnterPress(o) && this.handleClearBtn(o);
  }
  handleClearBtn(o) {
    const { inputValue: l, tagsArray: u } = this._adapter.getStates();
    u.length > 0 && (this._adapter.setTagsArray([]), this._adapter.notifyTagChange([])), l.length > 0 && this._onInputChange("", o), o.stopPropagation();
  }
  handleTagClose(o) {
    const { tagsArray: l } = this._adapter.getStates(), u = [...l];
    u.splice(o, 1);
    const c = l[o];
    this._onRemove(u, c, o);
  }
  handleInputMouseEnter() {
    this._adapter.setHovering(!0);
  }
  handleInputMouseLeave() {
    this._adapter.setHovering(!1);
  }
  handleClick(o) {
    const { disabled: l } = this.getProps();
    if (l)
      return;
    this._adapter.getClickOutsideHandler() || (this._adapter.setActive(!0), this._adapter.registerClickOutsideHandler((c) => this.clickOutsideCallBack()));
  }
  clickOutsideCallBack() {
    this._adapter.unregisterClickOutsideHandler(), this._adapter.setActive(!1);
  }
  handleClickPrefixOrSuffix(o) {
    const { disabled: l } = this._adapter.getProps(), { isFocus: u } = this._adapter.getStates();
    !l && !u && this._adapter.toggleFocusing(!0);
  }
  handlePreventMouseDown(o) {
    o && lodashExports.isFunction(o.preventDefault) && o.preventDefault();
  }
  /**
   * handler of delete tag
   */
  _onRemove(o, l, u) {
    this._isControlledComponent() || this._adapter.setTagsArray(o), this._adapter.notifyTagChange(o), this._adapter.notifyTagRemove(l, u);
  }
  /**
   * handler of add tag
   */
  _onAdd(o, l) {
    this._isControlledComponent() || this._adapter.setTagsArray(o), this._adapter.notifyTagChange(o), this._adapter.notifyTagAdd(l);
  }
  /**
   * handler of input change
   */
  _onInputChange(o, l) {
    this._adapter.setInputValue(o), this._adapter.notifyInputChange(o, l);
  }
  handleSortEnd(o) {
    const { oldIndex: l, newIndex: u } = o, { tagsArray: c } = this.getStates(), m = arrayMove(c, l, u);
    this._isControlledComponent() || this._adapter.setTagsArray(m), this._adapter.notifyTagChange(m);
  }
}
var $p = Object.defineProperty, Hp = (s, o, l) => o in s ? $p(s, o, { enumerable: !0, configurable: !0, writable: !0, value: l }) : s[o] = l, oe$1 = (s, o, l) => (Hp(s, typeof o != "symbol" ? o + "" : o, l), l);
function Vu(s) {
  return shallowRef(s);
}
const Qu = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function Xt(s) {
  const o = Object.prototype.toString.call(s);
  return o === "[object Window]" || // In Electron context the Window object serializes to [object global]
  o === "[object global]";
}
function ku(s) {
  return "nodeType" in s;
}
function Ge$1(s) {
  var o;
  return s ? Xt(s) ? s : ku(s) ? ((o = s.ownerDocument) == null ? void 0 : o.defaultView) ?? window : window : window;
}
function ju(s) {
  const { Document: o } = Ge$1(s);
  return s instanceof o;
}
function Ar(s) {
  return Xt(s) ? !1 : s instanceof Ge$1(s).HTMLElement;
}
function Jp(s) {
  return s instanceof Ge$1(s).SVGElement;
}
function Zt(s) {
  return s ? Xt(s) ? s.document : ku(s) ? ju(s) ? s : Ar(s) ? s.ownerDocument : document : document : document;
}
function Vp() {
  const s = ref$1(null);
  return [(o, l) => {
    s.value = setInterval(o, l);
  }, () => {
    s.value !== null && (clearInterval(s.value), s.value = null);
  }];
}
function yr(s, o = [s]) {
  const l = shallowRef(s.value);
  return watch(o, () => {
    l.value !== s.value && (l.value = s.value);
  }, { immediate: !0 }), l;
}
function ea(s, o) {
  const l = shallowRef();
  return watch(
    o,
    () => {
      const u = s(l.value);
      return l.value = u, u;
    },
    { immediate: !0 }
  ), l;
}
function bi(s) {
  const o = Vu(s), l = ref$1(null);
  return [l, (u) => {
    var c;
    u !== l.value && ((c = o == null ? void 0 : o.value) == null || c.call(o, u, l.value)), l.value = u;
  }];
}
function Xu(s) {
  return shallowRef(s);
}
let $u = {};
function Ri(s, o) {
  return computed(() => {
    if (o)
      return o;
    const l = $u[s] == null ? 0 : $u[s] + 1;
    return $u[s] = l, `${s}-${l}`;
  });
}
function Vo(s) {
  return (o, ...l) => l.reduce(
    (u, c) => {
      const m = Object.entries(c);
      for (const [g, v] of m) {
        const b = u[g];
        b != null && (u[g] = b + s * v);
      }
      return u;
    },
    {
      ...o
    }
  );
}
const Yt = Vo(1), yi = Vo(-1);
function Qp(s) {
  return "clientX" in s && "clientY" in s;
}
function na(s) {
  if (!s)
    return !1;
  const { KeyboardEvent: o } = Ge$1(s.target);
  return o && s instanceof o;
}
function kp(s) {
  if (!s)
    return !1;
  const { TouchEvent: o } = Ge$1(s.target);
  return o && s instanceof o;
}
function mi(s) {
  if (kp(s)) {
    if (s.touches && s.touches.length) {
      const { clientX: o, clientY: l } = s.touches[0];
      return {
        x: o,
        y: l
      };
    } else if (s.changedTouches && s.changedTouches.length) {
      const { clientX: o, clientY: l } = s.changedTouches[0];
      return {
        x: o,
        y: l
      };
    }
  }
  return Qp(s) ? {
    x: s.clientX,
    y: s.clientY
  } : null;
}
const mr = Object.freeze({
  Translate: {
    toString(s) {
      if (!s)
        return;
      const { x: o, y: l } = s;
      return `translate3d(${o ? Math.round(o) : 0}px, ${l ? Math.round(l) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(s) {
      if (!s)
        return;
      const { scaleX: o, scaleY: l } = s;
      return `scaleX(${o}) scaleY(${l})`;
    }
  },
  Transform: {
    toString(s) {
      if (s)
        return [
          mr.Translate.toString(s),
          mr.Scale.toString(s)
        ].join(" ");
    }
  },
  Transition: {
    toString({ property: s, duration: o, easing: l }) {
      return `${s} ${o}ms ${l}`;
    }
  }
}), Fo = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function jp(s) {
  return s.matches(Fo) ? s : s.querySelector(Fo);
}
const e0$1 = {
  display: "none"
};
function n0$1({
  id: s,
  value: o
}) {
  return createVNode("div", {
    id: s,
    style: e0$1
  }, [o]);
}
const t0$1 = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function r0$1({
  id: s,
  announcement: o
}) {
  return createVNode("div", {
    id: s,
    style: t0$1,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": !0
  }, [o]);
}
function i0$1() {
  const s = ref$1("");
  return { announce: (o) => {
    o != null && (s.value = o);
  }, announcement: s };
}
const u0$1 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("DndMonitorContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    value: Function
  },
  name: "DndMonitorContextProvider"
}), a0$1 = {
  Provider: u0$1
};
function l0$1(s) {
  const o = inject("DndMonitorContext", ref$1(null));
  watchEffect(() => {
    if (!o.value)
      throw new Error(
        "useDndMonitor must be used within a children of <DndContext>"
      );
    return o.value(s);
  });
}
function o0$1() {
  const s = ref$1(/* @__PURE__ */ new Set());
  return [({
    type: o,
    event: l
  }) => {
    s.value.forEach((u) => {
      var c;
      return (c = u[o]) == null ? void 0 : c.call(u, l);
    });
  }, (o) => (s.value.add(o), () => s.value.delete(o))];
}
const s0$1 = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, c0$1 = {
  onDragStart({ active: s }) {
    return `Picked up draggable item ${s.id}.`;
  },
  onDragOver({ active: s, over: o }) {
    return o ? `Draggable item ${s.id} was moved over droppable area ${o.id}.` : `Draggable item ${s.id} is no longer over a droppable area.`;
  },
  onDragEnd({ active: s, over: o }) {
    return o ? `Draggable item ${s.id} was dropped over droppable area ${o.id}` : `Draggable item ${s.id} was dropped.`;
  },
  onDragCancel({ active: s }) {
    return `Dragging was cancelled. Draggable item ${s.id} was dropped.`;
  }
};
function f0$1(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function d0$1({
  announcements: s = c0$1,
  container: o,
  hiddenTextDescribedById: l,
  screenReaderInstructions: u = s0$1
}) {
  const {
    announce: c,
    announcement: m
  } = i0$1(), g = Ri("DndLiveRegion"), v = ref$1(!1);
  if (watchEffect(() => {
    v.value = !0;
  }), l0$1({
    onDragStart({
      active: S
    }) {
      c(s.onDragStart({
        active: S
      }));
    },
    onDragMove({
      active: S,
      over: E
    }) {
      s.onDragMove && c(s.onDragMove({
        active: S,
        over: E
      }));
    },
    onDragOver({
      active: S,
      over: E
    }) {
      c(s.onDragOver({
        active: S,
        over: E
      }));
    },
    onDragEnd({
      active: S,
      over: E
    }) {
      c(s.onDragEnd({
        active: S,
        over: E
      }));
    },
    onDragCancel({
      active: S,
      over: E
    }) {
      c(s.onDragCancel({
        active: S,
        over: E
      }));
    }
  }), !v)
    return null;
  const b = createVNode(Fragment, null, [createVNode(n0$1, {
    id: l,
    value: u.draggable
  }, null), createVNode(r0$1, {
    id: g.value,
    announcement: m.value
  }, null)]);
  return o ? createVNode(Teleport, {
    to: o
  }, f0$1(b) ? b : {
    default: () => [b]
  }) : b;
}
var De$2 = /* @__PURE__ */ ((s) => (s.DragStart = "dragStart", s.DragMove = "dragMove", s.DragEnd = "dragEnd", s.DragCancel = "dragCancel", s.DragOver = "dragOver", s.RegisterDroppable = "registerDroppable", s.SetDroppableDisabled = "setDroppableDisabled", s.UnregisterDroppable = "unregisterDroppable", s))(De$2 || {});
function Si(...s) {
}
function U_(s, o) {
  return computed(
    () => ({
      sensor: s,
      options: o ?? {}
    })
  );
}
function z_(...s) {
  return computed(
    () => [...s].map((o) => o.value).filter(
      (o) => o != null
    )
  );
}
const Cn = Object.freeze({
  x: 0,
  y: 0
});
function ta(s, o) {
  return Math.sqrt(Math.pow(s.x - o.x, 2) + Math.pow(s.y - o.y, 2));
}
function v0$1(s, o) {
  const l = mi(s);
  if (!l)
    return "0 0";
  const u = {
    x: (l.x - o.left) / o.width * 100,
    y: (l.y - o.top) / o.height * 100
  };
  return `${u.x}% ${u.y}%`;
}
function ra({ data: { value: s } }, { data: { value: o } }) {
  return s - o;
}
function h0$1({ data: { value: s } }, { data: { value: o } }) {
  return o - s;
}
function g0$1(s, o) {
  if (!s || s.length === 0)
    return null;
  const [l] = s;
  return l[o];
}
function Wo(s, o = s.left, l = s.top) {
  return {
    x: o + s.width * 0.5,
    y: l + s.height * 0.5
  };
}
const $_ = ({
  collisionRect: s,
  droppableRects: o,
  droppableContainers: l
}) => {
  const u = Wo(
    s,
    s.left,
    s.top
  ), c = [];
  for (const m of l) {
    const { id: g } = m, v = o.get(g);
    if (v) {
      const b = ta(Wo(v), u);
      c.push({ id: g, data: { droppableContainer: m, value: b } });
    }
  }
  return c.sort(ra);
};
function p0$1(s, o) {
  const l = Math.max(o.top, s.top), u = Math.max(o.left, s.left), c = Math.min(o.left + o.width, s.left + s.width), m = Math.min(o.top + o.height, s.top + s.height), g = c - u, v = m - l;
  if (u < c && l < m) {
    const b = o.width * o.height, S = s.width * s.height, E = g * v, P = E / (b + S - E);
    return Number(P.toFixed(4));
  }
  return 0;
}
const _0$1 = ({
  collisionRect: s,
  droppableRects: o,
  droppableContainers: l
}) => {
  const u = [];
  for (const c of l) {
    const { id: m } = c, g = o.get(m);
    if (g) {
      const v = p0$1(g, s);
      v > 0 && u.push({
        id: m,
        data: { droppableContainer: c, value: v }
      });
    }
  }
  return u.sort(h0$1);
};
function x0$1(s, o, l) {
  return {
    ...s,
    scaleX: o && l ? o.width / l.width : 1,
    scaleY: o && l ? o.height / l.height : 1
  };
}
function Qo(s, o) {
  return s && o ? {
    x: s.left - o.left,
    y: s.top - o.top
  } : Cn;
}
function b0$1(s) {
  return function(o, ...l) {
    return l.reduce(
      (u, c) => ({
        ...u,
        top: u.top + s * c.y,
        bottom: u.bottom + s * c.y,
        left: u.left + s * c.x,
        right: u.right + s * c.x
      }),
      { ...o }
    );
  };
}
const y0$1 = b0$1(1);
function ko(s) {
  if (s.startsWith("matrix3d(")) {
    const o = s.slice(9, -1).split(/, /);
    return {
      x: +o[12],
      y: +o[13],
      scaleX: +o[0],
      scaleY: +o[5]
    };
  } else if (s.startsWith("matrix(")) {
    const o = s.slice(7, -1).split(/, /);
    return {
      x: +o[4],
      y: +o[5],
      scaleX: +o[0],
      scaleY: +o[3]
    };
  }
  return null;
}
function m0$1(s, o, l) {
  const u = ko(o);
  if (!u)
    return s;
  const { scaleX: c, scaleY: m, x: g, y: v } = u, b = s.left - g - (1 - c) * parseFloat(l), S = s.top - v - (1 - m) * parseFloat(l.slice(l.indexOf(" ") + 1)), E = c ? s.width / c : s.width, P = m ? s.height / m : s.height;
  return {
    width: E,
    height: P,
    top: S,
    right: b + E,
    bottom: S + P,
    left: b
  };
}
const S0$1 = { ignoreTransform: !1 };
function Rr(s, o = S0$1) {
  let l = s.getBoundingClientRect();
  if (o.ignoreTransform) {
    const { getComputedStyle: S } = Ge$1(s), { transform: E, transformOrigin: P } = S(s);
    E && (l = m0$1(l, E, P));
  }
  const { top: u, left: c, width: m, height: g, bottom: v, right: b } = l;
  return {
    top: u,
    left: c,
    width: m,
    height: g,
    bottom: v,
    right: b
  };
}
function Uo(s) {
  return Rr(s, { ignoreTransform: !0 });
}
function C0$1(s) {
  const o = s.innerWidth, l = s.innerHeight;
  return {
    top: 0,
    left: 0,
    right: o,
    bottom: l,
    width: o,
    height: l
  };
}
function A0$1(s, o = Ge$1(s).getComputedStyle(s)) {
  return o.position === "fixed";
}
function R0$1(s, o = Ge$1(s).getComputedStyle(
  s
)) {
  const l = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((u) => {
    const c = o[u];
    return typeof c == "string" ? l.test(c) : !1;
  });
}
function ia(s, o) {
  const l = [];
  function u(c) {
    if (o != null && l.length >= o || !c)
      return l;
    if (ju(c) && c.scrollingElement != null && !l.includes(c.scrollingElement))
      return l.push(c.scrollingElement), l;
    if (!Ar(c) || Jp(c) || l.includes(c))
      return l;
    const { getComputedStyle: m } = Ge$1(c), g = m(c);
    return c !== s && R0$1(c, g) && l.push(c), A0$1(c, g) ? l : u(c.parentNode);
  }
  return s ? u(s) : l;
}
function jo(s) {
  const [o] = ia(s, 1);
  return o ?? null;
}
function Hu(s) {
  return !Qu || !s ? null : Xt(s) ? s : ku(s) ? ju(s) || s === Zt(s).scrollingElement ? window : Ar(s) ? s : null : null;
}
function es(s) {
  return Xt(s) ? s.scrollX : s.scrollLeft;
}
function ns(s) {
  return Xt(s) ? s.scrollY : s.scrollTop;
}
function Ju(s) {
  return {
    x: es(s),
    y: ns(s)
  };
}
var Le$2 = /* @__PURE__ */ ((s) => (s[s.Forward = 1] = "Forward", s[s.Backward = -1] = "Backward", s))(Le$2 || {});
function ts(s) {
  return !Qu || !s ? !1 : s === document.scrollingElement;
}
function rs(s) {
  const o = {
    x: 0,
    y: 0
  }, l = ts(s) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: s.clientHeight,
    width: s.clientWidth
  }, u = {
    x: s.scrollWidth - l.width,
    y: s.scrollHeight - l.height
  }, c = s.scrollTop <= o.y, m = s.scrollLeft <= o.x, g = s.scrollTop >= u.y, v = s.scrollLeft >= u.x;
  return {
    isTop: c,
    isLeft: m,
    isBottom: g,
    isRight: v,
    maxScroll: u,
    minScroll: o
  };
}
const D0$1 = {
  x: 0.2,
  y: 0.2
};
function E0(s, o, { top: l, left: u, right: c, bottom: m }, g = 10, v = D0$1) {
  const { isTop: b, isBottom: S, isLeft: E, isRight: P } = rs(s), T = {
    x: 0,
    y: 0
  }, N = {
    x: 0,
    y: 0
  }, O = {
    height: o.height * v.y,
    width: o.width * v.x
  };
  return !b && l <= o.top + O.height ? (T.y = Le$2.Backward, N.y = g * Math.abs(
    (o.top + O.height - l) / O.height
  )) : !S && m >= o.bottom - O.height && (T.y = Le$2.Forward, N.y = g * Math.abs(
    (o.bottom - O.height - m) / O.height
  )), !P && c >= o.right - O.width ? (T.x = Le$2.Forward, N.x = g * Math.abs(
    (o.right - O.width - c) / O.width
  )) : !E && u <= o.left + O.width && (T.x = Le$2.Backward, N.x = g * Math.abs(
    (o.left + O.width - u) / O.width
  )), {
    direction: T,
    speed: N
  };
}
function O0$1(s) {
  if (s === document.scrollingElement) {
    const { innerWidth: m, innerHeight: g } = window;
    return {
      top: 0,
      left: 0,
      right: m,
      bottom: g,
      width: m,
      height: g
    };
  }
  const { top: o, left: l, right: u, bottom: c } = s.getBoundingClientRect();
  return {
    top: o,
    left: l,
    right: u,
    bottom: c,
    width: s.clientWidth,
    height: s.clientHeight
  };
}
function is(s) {
  return s.reduce((o, l) => Yt(o, Ju(l)), Cn);
}
function T0$1(s) {
  return s.reduce((o, l) => o + es(l), 0);
}
function I0$1(s) {
  return s.reduce((o, l) => o + ns(l), 0);
}
function us(s, o = Rr) {
  if (!s)
    return;
  const { top: l, left: u, bottom: c, right: m } = o(s);
  jo(s) && (c <= 0 || m <= 0 || l >= window.innerHeight || u >= window.innerWidth) && s.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
const L0 = [
  ["x", ["left", "right"], T0$1],
  ["y", ["top", "bottom"], I0$1]
];
class ua {
  constructor(o, l) {
    oe$1(this, "rect"), oe$1(this, "width"), oe$1(this, "height"), oe$1(this, "top"), oe$1(this, "bottom"), oe$1(this, "right"), oe$1(this, "left");
    const u = ia(l), c = is(u);
    this.rect = { ...o }, this.width = o.width, this.height = o.height;
    for (const [m, g, v] of L0)
      for (const b of g)
        Object.defineProperty(this, b, {
          get: () => {
            const S = v(u), E = c[m] - S;
            return this.rect[b] + E;
          },
          enumerable: !0
        });
    Object.defineProperty(this, "rect", { enumerable: !1 });
  }
}
function as(s, o, l) {
  const u = ref$1(o);
  return l && (u.value = l()), [u, (c) => {
    u.value = s(u.value, c);
  }];
}
class xr {
  constructor(o) {
    oe$1(this, "listeners", []), oe$1(this, "removeAll", () => {
      this.listeners.forEach(
        (l) => {
          var u;
          return (u = this.target) == null ? void 0 : u.removeEventListener(...l);
        }
      );
    }), this.target = o;
  }
  add(o, l, u) {
    var c;
    (c = this.target) == null || c.addEventListener(o, l, u), this.listeners.push([o, l, u]);
  }
}
function M0$1(s) {
  const { EventTarget: o } = Ge$1(s);
  return s instanceof o ? s : Zt(s);
}
function Gu(s, o) {
  const l = Math.abs(s.x), u = Math.abs(s.y);
  return typeof o == "number" ? Math.sqrt(l ** 2 + u ** 2) > o : "x" in o && "y" in o ? l > o.x && u > o.y : "x" in o ? l > o.x : "y" in o ? u > o.y : !1;
}
var Sn = /* @__PURE__ */ ((s) => (s.Click = "click", s.DragStart = "dragstart", s.Keydown = "keydown", s.ContextMenu = "contextmenu", s.Resize = "resize", s.SelectionChange = "selectionchange", s.VisibilityChange = "visibilitychange", s))(Sn || {});
function zo(s) {
  s.preventDefault();
}
function P0(s) {
  s.stopPropagation();
}
var ce$1 = /* @__PURE__ */ ((s) => (s.Space = "Space", s.Down = "ArrowDown", s.Right = "ArrowRight", s.Left = "ArrowLeft", s.Up = "ArrowUp", s.Esc = "Escape", s.Enter = "Enter", s))(ce$1 || {});
const $o = {
  start: [ce$1.Space, ce$1.Enter],
  cancel: [ce$1.Esc],
  end: [ce$1.Space, ce$1.Enter]
}, N0 = (s, { currentCoordinates: o }) => {
  switch (s.code) {
    case ce$1.Right:
      return {
        ...o,
        x: o.x + 25
      };
    case ce$1.Left:
      return {
        ...o,
        x: o.x - 25
      };
    case ce$1.Down:
      return {
        ...o,
        y: o.y + 25
      };
    case ce$1.Up:
      return {
        ...o,
        y: o.y - 25
      };
  }
};
class ls {
  constructor(o) {
    oe$1(this, "autoScrollEnabled", !1), oe$1(this, "referenceCoordinates"), oe$1(this, "listeners"), oe$1(this, "windowListeners"), this.props = o;
    const {
      event: { target: l }
    } = o;
    this.props = o, this.listeners = new xr(Zt(l)), this.windowListeners = new xr(Ge$1(l)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(Sn.Resize, this.handleCancel), this.windowListeners.add(Sn.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(Sn.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const { activeNode: o, onStart: l } = this.props, u = o.node.current;
    u && us(u), l(Cn);
  }
  handleKeyDown(o) {
    if (na(o)) {
      const { active: l, context: u, options: c } = this.props, {
        keyboardCodes: m = $o,
        coordinateGetter: g = N0,
        scrollBehavior: v = "smooth"
      } = c, { code: b } = o;
      if (m.end.includes(b)) {
        this.handleEnd(o);
        return;
      }
      if (m.cancel.includes(b)) {
        this.handleCancel(o);
        return;
      }
      const { collisionRect: S } = u.current, E = S ? { x: S.left, y: S.top } : Cn;
      this.referenceCoordinates || (this.referenceCoordinates = E);
      const P = g(o, {
        active: l,
        context: u.current,
        currentCoordinates: E
      });
      if (P) {
        const T = yi(
          P,
          E
        ), N = {
          x: 0,
          y: 0
        }, { scrollableAncestors: O } = u.current;
        for (const z of O) {
          const Q = o.code, { isTop: W, isRight: ue, isLeft: te, isBottom: K, maxScroll: ve, minScroll: ee } = rs(z), Re = O0$1(z), wt = {
            x: Math.min(
              Q === ce$1.Right ? Re.right - Re.width / 2 : Re.right,
              Math.max(
                Q === ce$1.Right ? Re.left : Re.left + Re.width / 2,
                P.x
              )
            ),
            y: Math.min(
              Q === ce$1.Down ? Re.bottom - Re.height / 2 : Re.bottom,
              Math.max(
                Q === ce$1.Down ? Re.top : Re.top + Re.height / 2,
                P.y
              )
            )
          }, yt = Q === ce$1.Right && !ue || Q === ce$1.Left && !te, xt = Q === ce$1.Down && !K || Q === ce$1.Up && !W;
          if (yt && wt.x !== P.x) {
            const Kt = z.scrollLeft + T.x, tn = Q === ce$1.Right && Kt <= ve.x || Q === ce$1.Left && Kt >= ee.x;
            if (tn && !T.y) {
              z.scrollTo({
                left: Kt,
                behavior: v
              });
              return;
            }
            tn ? N.x = z.scrollLeft - Kt : N.x = Q === ce$1.Right ? z.scrollLeft - ve.x : z.scrollLeft - ee.x, N.x && z.scrollBy({
              left: -N.x,
              behavior: v
            });
            break;
          } else if (xt && wt.y !== P.y) {
            const Kt = z.scrollTop + T.y, tn = Q === ce$1.Down && Kt <= ve.y || Q === ce$1.Up && Kt >= ee.y;
            if (tn && !T.x) {
              z.scrollTo({
                top: Kt,
                behavior: v
              });
              return;
            }
            tn ? N.y = z.scrollTop - Kt : N.y = Q === ce$1.Down ? z.scrollTop - ve.y : z.scrollTop - ee.y, N.y && z.scrollBy({
              top: -N.y,
              behavior: v
            });
            break;
          }
        }
        this.handleMove(
          o,
          Yt(
            yi(P, this.referenceCoordinates),
            N
          )
        );
      }
    }
  }
  handleMove(o, l) {
    const { onMove: u } = this.props;
    o.preventDefault(), u(l);
  }
  handleEnd(o) {
    const { onEnd: l } = this.props;
    o.preventDefault(), this.detach(), l();
  }
  handleCancel(o) {
    const { onCancel: l } = this.props;
    o.preventDefault(), this.detach(), l();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
oe$1(ls, "activators", [
  {
    eventName: "onKeydown",
    handler: (s, { keyboardCodes: o = $o, onActivation: l }, { active: u }) => {
      const { code: c } = s;
      if (o.start.includes(c)) {
        const m = u.activatorNode.current;
        return m && s.target !== m ? !1 : (s.preventDefault(), l == null || l({ event: s }), !0);
      }
      return !1;
    }
  }
]);
function Ho(s) {
  return !!(s && "distance" in s);
}
function Go(s) {
  return !!(s && "delay" in s);
}
class aa {
  constructor(o, l, u = M0$1(o.event.target)) {
    oe$1(this, "autoScrollEnabled", !0), oe$1(this, "document"), oe$1(this, "activated", !1), oe$1(this, "initialCoordinates"), oe$1(this, "timeoutId"), oe$1(this, "listeners"), oe$1(this, "documentListeners"), oe$1(this, "windowListeners"), this.props = o, this.events = l;
    const { event: c } = o, { target: m } = c;
    this.props = o, this.events = l, this.document = Zt(m), this.documentListeners = new xr(this.document), this.listeners = new xr(u), this.windowListeners = new xr(Ge$1(m)), this.initialCoordinates = mi(c) ?? Cn, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: o,
      props: {
        options: { activationConstraint: l }
      }
    } = this;
    if (this.listeners.add(o.move.name, this.handleMove, { passive: !1 }), this.listeners.add(o.end.name, this.handleEnd), this.windowListeners.add(Sn.Resize, this.handleCancel), this.windowListeners.add(Sn.DragStart, zo), this.windowListeners.add(Sn.VisibilityChange, this.handleCancel), this.windowListeners.add(Sn.ContextMenu, zo), this.documentListeners.add(Sn.Keydown, this.handleKeydown), l) {
      if (Ho(l))
        return;
      if (Go(l)) {
        this.timeoutId = setTimeout(
          this.handleStart,
          l.delay
        );
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handleStart() {
    const { initialCoordinates: o } = this, { onStart: l } = this.props;
    o && (this.activated = !0, this.documentListeners.add(Sn.Click, P0, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(
      Sn.SelectionChange,
      this.removeTextSelection
    ), l(o));
  }
  handleMove(o) {
    const { activated: l, initialCoordinates: u, props: c } = this, {
      onMove: m,
      options: { activationConstraint: g }
    } = c;
    if (!u)
      return;
    const v = mi(o) ?? Cn, b = yi(u, v);
    if (!l && g) {
      if (Go(g))
        return Gu(b, g.tolerance) ? this.handleCancel() : void 0;
      if (Ho(g))
        return g.tolerance != null && Gu(b, g.tolerance) ? this.handleCancel() : Gu(b, g.distance) ? this.handleStart() : void 0;
    }
    o.cancelable && o.preventDefault(), m(v);
  }
  handleEnd() {
    const { onEnd: o } = this.props;
    this.detach(), o();
  }
  handleCancel() {
    const { onCancel: o } = this.props;
    this.detach(), o();
  }
  handleKeydown(o) {
    o.code === ce$1.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var o;
    (o = this.document.getSelection()) == null || o.removeAllRanges();
  }
}
const B0 = {
  move: { name: "pointermove" },
  end: { name: "pointerup" }
};
class os extends aa {
  constructor(o) {
    const { event: l } = o, u = Zt(l.target);
    super(o, B0, u);
  }
}
oe$1(os, "activators", [
  {
    eventName: "onPointerdown",
    handler: (s, { onActivation: o }) => !s.isPrimary || s.button !== 0 ? !1 : (o == null || o({ event: s }), !0)
  }
]);
const F0 = {
  move: { name: "mousemove" },
  end: { name: "mouseup" }
};
class W0 extends aa {
  constructor(o) {
    super(o, F0, Zt(o.event.target));
  }
}
oe$1(W0, "activators", [
  {
    eventName: "onMousedown",
    handler: (s, { onActivation: o }) => s.button === 2 ? !1 : (o == null || o({ event: s }), !0)
  }
]);
const Ku = {
  move: { name: "touchmove" },
  end: { name: "touchend" }
};
class U0 extends aa {
  constructor(o) {
    super(o, Ku);
  }
  static setup() {
    return window.addEventListener(Ku.move.name, o, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(Ku.move.name, o);
    };
    function o() {
    }
  }
}
oe$1(U0, "activators", [
  {
    eventName: "onTouchstart",
    handler: (s, { onActivation: o }) => {
      const { touches: l } = s;
      return l.length > 1 ? !1 : (o == null || o({ event: s }), !0);
    }
  }
]);
function H0({
  acceleration: s,
  activator: o = 0,
  canScroll: l,
  draggingRect: u,
  enabled: c,
  interval: m = 5,
  order: g = 0,
  pointerCoordinates: v,
  scrollableAncestors: b,
  scrollableAncestorRects: S,
  delta: E,
  threshold: P
}) {
  const T = K0({ delta: E, disabled: !c }), [N, O] = Vp(), z = ref$1({ x: 0, y: 0 }), Q = ref$1({ x: 0, y: 0 }), W = computed(() => {
    switch (o) {
      case 0:
        return v ? {
          top: v.y,
          bottom: v.y,
          left: v.x,
          right: v.x
        } : null;
      case 1:
        return u;
    }
  }), ue = ref$1(null), te = () => {
    const ve = ue.value;
    if (!ve)
      return;
    const ee = z.value.x * Q.value.x, Re = z.value.y * Q.value.y;
    ve.scrollBy(ee, Re);
  }, K = computed(
    () => g === 0 ? [...b].reverse() : b
  );
  watchEffect(
    () => {
      if (!c || !b.length || !W) {
        O();
        return;
      }
      for (const ve of K.value) {
        if ((l == null ? void 0 : l(ve)) === !1)
          continue;
        const ee = b.indexOf(ve), Re = S[ee];
        if (!Re)
          continue;
        const { direction: wt, speed: yt } = E0(
          ve,
          Re,
          W.value,
          s,
          P
        );
        for (const xt of ["x", "y"])
          T.value[xt][wt[xt]] || (yt[xt] = 0, wt[xt] = 0);
        if (yt.x > 0 || yt.y > 0) {
          O(), ue.value = ve, N(te, m), z.value = yt, Q.value = wt;
          return;
        }
      }
      z.value = { x: 0, y: 0 }, Q.value = { x: 0, y: 0 }, O();
    }
  );
}
const G0 = {
  x: { [Le$2.Backward]: !1, [Le$2.Forward]: !1 },
  y: { [Le$2.Backward]: !1, [Le$2.Forward]: !1 }
};
function K0({
  delta: s,
  disabled: o
}) {
  const l = Xu(s);
  return ea(
    (u) => {
      if (o || !l.value || !u)
        return G0;
      const c = {
        x: Math.sign(s.x - l.value.x),
        y: Math.sign(s.y - l.value.y)
      };
      return {
        x: {
          [Le$2.Backward]: u.x[Le$2.Backward] || c.x === -1,
          [Le$2.Forward]: u.x[Le$2.Forward] || c.x === 1
        },
        y: {
          [Le$2.Backward]: u.y[Le$2.Backward] || c.y === -1,
          [Le$2.Forward]: u.y[Le$2.Forward] || c.y === 1
        }
      };
    },
    [() => o, () => s, l]
  );
}
function q0(s, o) {
  const l = ref$1();
  return computed(
    () => {
      const u = o.value !== null ? s.value.get(o.value) : void 0, c = u ? u.node : null, m = () => o === null ? null : c ?? l.value ?? null;
      return l.value = m(), m();
    }
  );
}
function Y0(s, o) {
  return computed(
    () => s.reduce((l, u) => {
      const { sensor: c } = u, m = c.activators.map((g) => ({
        eventName: g.eventName,
        handler: o.value(g.handler, u)
      }));
      return [...l, ...m];
    }, [])
  );
}
var ss = /* @__PURE__ */ ((s) => (s[s.Always = 0] = "Always", s[s.BeforeDragging = 1] = "BeforeDragging", s[s.WhileDragging = 2] = "WhileDragging", s))(ss || {}), cs = /* @__PURE__ */ ((s) => (s.Optimized = "optimized", s))(cs || {});
const Ko = /* @__PURE__ */ new Map();
function X0(s, o) {
  const l = ref$1(null), u = ref$1(null), c = computed(() => u.value != null), m = ref$1(s.value), g = computed(P), v = yr(g), b = computed(() => (T = []) => {
    if (!v.value) {
      if (l.value === null)
        return T;
      l.value = l.value.concat(T.filter((N) => {
        var O;
        return !((O = l.value) != null && O.includes(N));
      }));
    }
  }), S = shallowRef(null), E = ea(
    (T) => {
      if (g.value && !o.value.dragging)
        return Ko;
      const N = u.value;
      if (!T || T === Ko || m.value !== s.value || N != null) {
        const O = /* @__PURE__ */ new Map();
        for (let z of s.value) {
          if (!z)
            continue;
          if (N && N.length > 0 && !N.includes(z.id) && z.rect) {
            O.set(z.id, z.rect);
            continue;
          }
          const Q = z.node, W = Q ? new ua(o.value.config.measure(Q), Q) : null;
          z.rect = W, W && O.set(z.id, W);
        }
        return O;
      }
      return T;
    },
    [s, l, () => o.value.dragging, g, () => o.value.config.measure]
  );
  return watchEffect(() => {
    m.value = s.value;
  }), watch([() => o.value.dragging, () => g.value], () => {
    g.value || requestAnimationFrame(() => b.value());
  }, { immediate: !0 }), watchEffect(() => {
    c.value && (u.value = null);
  }), watch([
    () => o.value.config.frequency,
    g,
    b,
    () => o.value.dependencies
  ], () => {
    g.value || typeof o.value.config.frequency != "number" || S.value !== null || (S.value = setTimeout(() => {
      b.value(), S.value = null;
    }, o.value.config.frequency));
  }, { deep: !0, immediate: !0 }), {
    droppableRects: E,
    measureDroppableContainers: b,
    measuringScheduled: c
  };
  function P() {
    switch (o.value.config.strategy) {
      case 0:
        return !1;
      case 1:
        return o.value.dragging;
      default:
        return !o.value.dragging;
    }
  }
}
function la(s, o) {
  const l = ref$1();
  return computed(() => {
    function u() {
      return s != null && s.value ? l.value ? l.value : typeof o == "function" ? o(s.value) : s.value : null;
    }
    return u();
  });
}
function Z0(s, o) {
  return la(s, o);
}
function J0({ callback: s, disabled: o }) {
  const l = Vu(s), u = computed(() => {
    if (o || typeof window > "u" || typeof window.MutationObserver > "u")
      return;
    const { MutationObserver: c } = window;
    return new c(l.value);
  });
  return watch(() => u.value, () => () => {
    var c;
    return (c = u.value) == null ? void 0 : c.disconnect();
  }, { immediate: !0 }), u;
}
function Di({ callback: s, disabled: o }) {
  const l = Vu(s), u = shallowRef();
  return watch(() => o, () => {
    if (o || typeof window > "u" || typeof window.ResizeObserver > "u")
      return;
    const { ResizeObserver: c } = window;
    return new c(l.value);
  }, { immediate: !0 }), onUnmounted(() => () => {
    var c;
    return (c = u.value) == null ? void 0 : c.disconnect();
  }), u;
}
function V0(s) {
  return new ua(Rr(s), s);
}
function qo(s, o = computed(() => V0), l) {
  const u = ref$1(null), c = J0({
    callback(v) {
      if (s.value)
        for (const b of v) {
          const { type: S, target: E } = b;
          if (S === "childList" && E instanceof HTMLElement && E.contains(s.value)) {
            g(u.value);
            break;
          }
        }
    }
  }), m = Di({ callback: () => {
    g(u.value);
  } });
  return watch([s, o, () => l == null ? void 0 : l.value], () => {
    var v, b, S, E;
    g(u.value), s && s.value ? ((v = m.value) == null || v.observe(s.value), (b = c.value) == null || b.observe(document.body, {
      childList: !0,
      subtree: !0
    })) : ((S = m.value) == null || S.disconnect(), (E = c.value) == null || E.disconnect());
  }, { immediate: !0 }), u;
  function g(v) {
    if (!(s != null && s.value))
      return null;
    if (s.value.isConnected === !1)
      return v ?? (l == null ? void 0 : l.value) ?? null;
    const b = o.value(s.value);
    JSON.stringify(v) !== JSON.stringify(b) && (u.value = b);
  }
}
function Q0(s) {
  const o = la(s);
  return Qo(s.value, o.value);
}
const Yo = [];
function k0$1(s) {
  const o = ref$1(s), l = ea(
    (u) => s ? u && u !== Yo && s && o.value && s.parentNode === o.value.parentNode ? u : ia(s) : Yo,
    [() => s]
  );
  return watchEffect(() => {
    o.value = s;
  }), l;
}
function j0(s) {
  const o = ref$1(null), l = shallowRef(s.value), u = shallowRef((c) => {
    const m = Hu(c.target);
    if (m) {
      if (!o.value)
        return null;
      o.value.set(
        m,
        Ju(m)
      ), o.value = new Map(o.value);
    }
  });
  return watch([() => u.value, () => s.value], (c, m, g) => {
    const v = l.value;
    if (s.value !== v) {
      b(v);
      const S = s.value.map((E) => {
        const P = Hu(E);
        return P ? (P.addEventListener("scroll", u.value, {
          passive: !0
        }), [
          P,
          Ju(P)
        ]) : null;
      }).filter(
        (E) => E != null
      );
      o.value = S.length ? new Map(S) : null, l.value = s.value;
    }
    g(() => {
      b(s.value), b(v);
    });
    function b(S) {
      S.forEach((E) => {
        const P = Hu(E);
        P == null || P.removeEventListener("scroll", u.value);
      });
    }
  }, { immediate: !0 }), computed(() => s.value.length ? o.value ? Array.from(o.value.values()).reduce(
    (c, m) => Yt(c, m),
    Cn
  ) : is(s.value) : Cn);
}
function Xo(s, o = []) {
  const l = shallowRef(null);
  return watch(o, () => {
    l.value = null;
  }, { immediate: !0 }), watch(o, () => {
    const u = s.value !== Cn;
    u && !l.value && (l.value = s.value), !u && l.value && (l.value = null);
  }, { immediate: !0 }), computed(() => l.value ? yi(s.value, l.value) : Cn);
}
function e_(s) {
  watchEffect(
    () => {
      if (!Qu)
        return;
      const o = s.map(({ sensor: l }) => {
        var u;
        return (u = l.setup) == null ? void 0 : u.call(l);
      });
      return () => {
        for (const l of o)
          l == null || l();
      };
    }
  );
}
function fs(s) {
  return computed(() => s != null && s.value ? C0$1(s.value) : null);
}
const qu = [];
function t_(s, o = Rr) {
  const l = computed(() => {
    const [b] = s.value;
    return b ? Ge$1(b) : null;
  }), u = fs(
    l
  ), [c, m] = as(v, qu), g = Di({ callback: m });
  return watch([() => s.value], () => {
    var b;
    s.value.length > 0 && c.value === qu && m(), s.value.length ? s.value.forEach((S) => {
      var E;
      return (E = g.value) == null ? void 0 : E.observe(S);
    }) : ((b = g.value) == null || b.disconnect(), m());
  }, { immediate: !0 }), c.value;
  function v() {
    return s.value.length ? s.value.map(
      (b) => ts(b) ? u.value : new ua(o(b), b)
    ) : qu;
  }
}
function ds(s) {
  if (!s)
    return null;
  if (s.children.length > 1)
    return s;
  const o = s.children[0];
  return Ar(o) ? o : s;
}
function r_({
  measure: s
}) {
  const o = ref$1(null), l = Di({ callback: (g) => {
    for (const { target: v } of g)
      if (Ar(v)) {
        const b = s(v);
        o.value = o.value ? { ...o.value, width: b.width, height: b.height } : b;
        break;
      }
  } }), u = (g) => {
    var v, b;
    const S = ds(g);
    (v = l.value) == null || v.disconnect(), S && ((b = l.value) == null || b.observe(S)), o.value = S ? s(S) : null;
  }, [c, m] = bi(u);
  return computed(
    () => ({
      nodeRef: c,
      rect: o,
      setRef: m
    })
  );
}
const i_ = [
  { sensor: os, options: {} },
  { sensor: ls, options: {} }
], u_ = { current: {} }, xi = {
  draggable: {
    measure: Uo
  },
  droppable: {
    measure: Uo,
    strategy: ss.WhileDragging,
    frequency: cs.Optimized
  },
  dragOverlay: {
    measure: Rr
  }
};
class br extends Map {
  get(o) {
    return o != null ? super.get(o) ?? void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter(({ disabled: o }) => !o);
  }
  getNodeFor(o) {
    var l;
    return ((l = this.get(o)) == null ? void 0 : l.node.current) ?? void 0;
  }
}
const a_ = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("InternalContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    value: Object
  },
  name: "InternalContextProvider"
}), l_ = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("PublicContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    value: Object
  }
}), o_ = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: new br(),
  over: null,
  dragOverlay: {
    nodeRef: ref$1(null),
    rect: ref$1(null),
    setRef: Si
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: xi,
  measureDroppableContainers: Si,
  windowRect: null,
  measuringScheduled: !1
}, oa = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: Si,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: Si
}, vs = {
  Provider: a_
}, s_ = {
  Provider: l_
};
function c_() {
  return {
    draggable: {
      active: null,
      initialCoordinates: { x: 0, y: 0 },
      nodes: /* @__PURE__ */ new Map(),
      translate: { x: 0, y: 0 }
    },
    droppable: {
      containers: new br()
    }
  };
}
function f_(s, o) {
  switch (o.type) {
    case De$2.DragStart:
      return {
        ...s,
        draggable: {
          ...s.draggable,
          initialCoordinates: o.initialCoordinates,
          active: o.active
        }
      };
    case De$2.DragMove:
      return s.draggable.active ? {
        ...s,
        draggable: {
          ...s.draggable,
          translate: {
            x: o.coordinates.x - s.draggable.initialCoordinates.x,
            y: o.coordinates.y - s.draggable.initialCoordinates.y
          }
        }
      } : s;
    case De$2.DragEnd:
    case De$2.DragCancel:
      return {
        ...s,
        draggable: {
          ...s.draggable,
          active: null,
          initialCoordinates: { x: 0, y: 0 },
          translate: { x: 0, y: 0 }
        }
      };
    case De$2.RegisterDroppable: {
      const { element: l } = o, { id: u } = l, c = new br(s.droppable.containers);
      return c.set(u, l), {
        ...s,
        droppable: {
          ...s.droppable,
          containers: c
        }
      };
    }
    case De$2.SetDroppableDisabled: {
      const { id: l, key: u, disabled: c } = o, m = s.droppable.containers.get(l);
      if (!m || u !== m.key)
        return s;
      const g = new br(s.droppable.containers);
      return g.set(l, {
        ...m,
        disabled: c
      }), {
        ...s,
        droppable: {
          ...s.droppable,
          containers: g
        }
      };
    }
    case De$2.UnregisterDroppable: {
      const { id: l, key: u } = o, c = s.droppable.containers.get(l);
      if (!c || u !== c.key)
        return s;
      const m = new br(s.droppable.containers);
      return m.delete(l), {
        ...s,
        droppable: {
          ...s.droppable,
          containers: m
        }
      };
    }
    default:
      return s;
  }
}
function d_({
  disabled: s
}) {
  const {
    active: o,
    activatorEvent: l,
    draggableNodes: u
  } = inject("InternalContext", ref$1(oa)).value, c = Xu(l), m = Xu(o == null ? void 0 : o.id);
  return watchEffect(() => {
    if (!s && !l && c.value && m.value != null) {
      if (!na(c.value) || document.activeElement === c.value.target)
        return;
      const g = u.get(m.value);
      if (!g)
        return;
      const {
        activatorNode: v,
        node: b
      } = g;
      if (!v.current && !b.current)
        return;
      requestAnimationFrame(() => {
        for (const S of [v.current, b.current]) {
          if (!S)
            continue;
          const E = jp(S);
          if (E) {
            E.focus();
            break;
          }
        }
      });
    }
  }), null;
}
function hs(s, { transform: o, ...l }) {
  return s != null && s.length ? s.reduce((u, c) => c({
    transform: u,
    ...l
  }), o) : o;
}
function v_(s) {
  return computed(
    () => ({
      draggable: {
        ...xi.draggable,
        ...s == null ? void 0 : s.draggable
      },
      droppable: {
        ...xi.droppable,
        ...s == null ? void 0 : s.droppable
      },
      dragOverlay: {
        ...xi.dragOverlay,
        ...s == null ? void 0 : s.dragOverlay
      }
    })
  );
}
function h_({
  activeNode: s,
  measure: o,
  initialRect: l,
  config: u = !0
}) {
  const c = ref$1(!1), { x: m, y: g } = typeof u == "boolean" ? { x: u, y: u } : u;
  watchEffect(() => {
    if (!m && !g || !s) {
      c.value = !1;
      return;
    }
    if (c.value || !l)
      return;
    const v = s == null ? void 0 : s.node.current;
    if (!v || v.isConnected === !1)
      return;
    const b = o(v), S = Qo(b, l);
    if (m || (S.x = 0), g || (S.y = 0), c.value = !0, Math.abs(S.x) > 0 || Math.abs(S.y) > 0) {
      const E = jo(v);
      E && E.scrollBy({
        top: S.y,
        left: S.x
      });
    }
  });
}
const g_ = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("DndContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    value: Object
  }
}), gs = {
  Provider: g_
};
var Rt = /* @__PURE__ */ function(s) {
  return s[s.Uninitialized = 0] = "Uninitialized", s[s.Initializing = 1] = "Initializing", s[s.Initialized = 2] = "Initialized", s;
}(Rt || {});
const p_ = {
  id: String,
  accessibility: Object,
  autoScroll: [Object, Array, Boolean],
  cancelDrop: [Object, Array],
  collisionDetection: [Object, Array, Function],
  measuring: [Object, Array],
  modifiers: [Object, Array],
  sensors: Object,
  onDragStart: Function,
  onDragMove: Function,
  onDragOver: Function,
  onDragEnd: Function,
  onDragCancel: Function
}, K_ = /* @__PURE__ */ defineComponent((s) => {
  const {
    id: o,
    accessibility: l,
    autoScroll: u = !0,
    sensors: c = i_,
    collisionDetection: m = _0$1,
    measuring: g,
    modifiers: v,
    ...b
  } = s, S = as(f_, void 0, c_), [E, P] = S, [T, N] = o0$1(), O = ref$1(Rt.Uninitialized), z = computed(() => O.value === Rt.Initialized), Q = he$1(() => E.value.draggable.active, [() => E.value.draggable.active]), W = he$1(() => E.value.draggable.nodes, [() => E.value.draggable.nodes]), ue = he$1(() => E.value.droppable.containers, [() => E.value.droppable.containers]), te = he$1(() => Q.value ? W.value.get(Q.value) : null, [Q, W]), K = ref$1({
    initial: null,
    translated: null
  }), ve = ref$1(null);
  function ee() {
    var ar;
    return E.value.draggable.active != null ? {
      id: E.value.draggable.active,
      // It's possible for the active node to unmount while dragging
      data: ((ar = te.value) == null ? void 0 : ar.data) ?? u_,
      rect: K.value
    } : null;
  }
  watch([Q, te], () => {
    ve.value = ee();
  }, {
    immediate: !0
  });
  const Re = ref$1(null), wt = ref$1(null), yt = ref$1(null);
  function xt(ar) {
    yt.value = ar;
  }
  const Kt = yr(computed(() => b)), tn = Ri("DndDescribedBy", o), ln = computed(() => E.value.droppable.containers.getEnabled()), rn = v_(g), an = he$1(() => ({
    dragging: z.value,
    dependencies: [E.value.draggable.translate.x, E.value.draggable.translate.y],
    config: rn.value.droppable
  }), [z, () => E.value.draggable.translate.x, () => E.value.draggable.translate.y, () => rn.value.droppable]), {
    droppableRects: Gt,
    measureDroppableContainers: nn,
    measuringScheduled: vt
  } = X0(ln, an), Et = q0(W, Q), Qt = he$1(() => yt.value ? mi(yt.value) : null, [yt]), un = ir(), gn = Z0(Et, rn.value.draggable.measure);
  h_({
    activeNode: Q.value ? W.value.get(Q.value) : null,
    config: un.layoutShiftCompensation,
    initialRect: gn.value,
    measure: rn.value.draggable.measure
  });
  const dn = computed(() => rn.value.draggable.measure), yn = qo(Et, dn, gn), vn = he$1(() => Et.value ? Et.value.parentElement : null, [Et, () => {
    var ar;
    return (ar = Et.value) == null ? void 0 : ar.parentElement;
  }]), Pn = qo(vn), On = ref$1({
    activatorEvent: null,
    active: null,
    activeNode: Et.value,
    collisionRect: null,
    collisions: null,
    droppableRects: Gt.value,
    draggableNodes: W.value,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers: ue.value,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  }), _n = he$1(() => {
    var ar;
    return ue.value.getNodeFor((ar = On.value.over) == null ? void 0 : ar.id);
  }, [ue, () => {
    var ar;
    return (ar = On.value.over) == null ? void 0 : ar.id;
  }]), Nn = r_({
    measure: rn.value.dragOverlay.measure
  }), Un = he$1(() => Nn.value.nodeRef.value ?? Et.value, [Nn.value.nodeRef, Et]), Xn = he$1(() => z.value ? Nn.value.rect.value ?? yn.value : null, [z, Nn.value.rect, yn]), zn = he$1(() => !!(Nn.value.nodeRef.value && Nn.value.rect.value), [Nn.value.nodeRef, Nn.value.rect]), jn = he$1(() => zn.value ? null : yn.value, [zn]), kn = Q0(jn), Yn = he$1(() => Un.value ? Ge$1(Un.value) : null, [Un]), Zn = fs(Yn), er = k0$1(z.value ? _n.value ?? Et.value : null), bn = t_(er), Ln = ref$1();
  watch([() => E.value.draggable.translate, () => yt.value, () => {
    var ar;
    return (ar = ve.value) == null ? void 0 : ar.id;
  }, () => {
    var ar;
    return (ar = ve.value) == null ? void 0 : ar.data.value;
  }, () => {
    var ar;
    return (ar = ve.value) == null ? void 0 : ar.rect;
  }, () => yn.value, () => Pn.value, () => Xn.value, () => On.value.over, () => Nn.value.rect.value, () => er.value, () => Zn.value], (ar, Or, Sr) => {
    Ln.value = {
      transform: {
        x: E.value.draggable.translate.x - kn.x,
        y: E.value.draggable.translate.y - kn.y,
        scaleX: 1,
        scaleY: 1
      },
      activatorEvent: yt.value,
      active: ve.value,
      activeNodeRect: yn.value,
      containerNodeRect: Pn.value,
      draggingNodeRect: Xn == null ? void 0 : Xn.value,
      over: On.value.over,
      overlayNodeRect: Nn.value.rect.value,
      scrollableAncestors: er.value,
      scrollableAncestorRects: bn,
      windowRect: Zn.value
    };
  }, {
    immediate: !0
  });
  const Kn = he$1(() => hs(v, Ln.value), [Ln]), Bn = he$1(() => Qt.value ? Yt(Qt.value, E.value.draggable.translate) : null, [Qt, () => E.value.draggable.translate]), Fn = j0(er), Gn = Xo(Fn), Wn = Xo(Fn, [() => yn.value]), Mn = he$1(() => Yt(Kn.value, Gn.value), [Kn, Gn]), Tn = he$1(() => Xn != null && Xn.value ? y0$1(Xn.value, Kn.value) : null, [Xn, Kn]), Rn = he$1(() => ve.value && Tn.value ? m({
    active: ve.value,
    collisionRect: Tn.value,
    droppableRects: Gt.value,
    droppableContainers: ln.value,
    pointerCoordinates: Bn.value
  }) : null, [ve, Tn, Gt, ln, Bn]), hn = ref$1(null);
  function Qn(ar) {
    hn.value = ar;
  }
  const rr = he$1(() => zn.value ? Kn.value : Yt(Kn.value, Wn.value), [zn, Kn, Wn]), tr = he$1(() => {
    var ar;
    return x0$1(rr.value, ((ar = hn.value) == null ? void 0 : ar.rect) ?? null, yn.value);
  }, [rr, () => {
    var ar;
    return (ar = hn.value) == null ? void 0 : ar.rect;
  }]), Cr = he$1(() => (ar, {
    sensor: Or,
    options: Sr
  }) => {
    if (Re.value == null)
      return;
    const kr = W.value.get(Re.value);
    if (!kr)
      return;
    const Nr = ar, Ur = new Or({
      active: Re.value,
      activeNode: kr,
      event: Nr,
      options: Sr,
      // Sensors need to be instantiated with refs for arguments that change over time
      // otherwise they are frozen in time with the stale arguments
      context: On.value,
      onStart(Zr) {
        const Jr = Re.value;
        if (Jr == null)
          return;
        const ii = W.value.get(Jr);
        if (!ii)
          return;
        const {
          onDragStart: Ti
        } = Kt.value, Mi = {
          active: {
            id: Jr,
            data: ii.data,
            rect: K.value
          }
        };
        Ti == null || Ti(Mi), O.value = Rt.Initializing, P({
          type: De$2.DragStart,
          initialCoordinates: Zr,
          active: Jr
        }), T({
          type: "onDragStart",
          event: Mi
        });
      },
      onMove(Zr) {
        P({
          type: De$2.DragMove,
          coordinates: Zr
        });
      },
      onEnd: _r(De$2.DragEnd),
      onCancel: _r(De$2.DragCancel)
    });
    wt.value = Ur, xt(ar);
    function _r(Zr) {
      return async function() {
        const {
          collisions: Jr,
          over: ii
        } = On.value;
        let Ti = null;
        if (ve.value && Mn.value) {
          const {
            cancelDrop: ui
          } = Kt.value;
          Ti = {
            activatorEvent: Nr,
            active: ve.value,
            collisions: Jr,
            delta: Mn.value,
            over: ii
          }, Zr === De$2.DragEnd && typeof ui == "function" && await Promise.resolve(ui(Ti)) && (Zr = De$2.DragCancel);
        }
        Re.value = null, P({
          type: Zr
        }), O.value = Rt.Uninitialized, Qn(null), wt.value = null, xt(null);
        const Mi = Zr === De$2.DragEnd ? "onDragEnd" : "onDragCancel";
        if (Ti) {
          const ui = Kt.value[Mi];
          ui == null || ui(Ti), T({
            type: Mi,
            event: Ti
          });
        }
      };
    }
  }, [Re, W, On, Kt, K]), Fr = he$1(() => (ar, Or) => (Sr, kr) => {
    const Nr = Sr, Ur = W.value.get(kr);
    if (
      // Another sensor is already instantiating
      Re.value !== null || // No active draggable
      !Ur || // Event has already been captured
      Nr.dndKit || Nr.defaultPrevented
    )
      return;
    const _r = {
      active: Ur
    };
    ar(Sr, Or.options, _r) === !0 && (Nr.dndKit = {
      capturedBy: Or.sensor
    }, Re.value = kr, Cr.value(Sr, Or));
  }, [W, Re, Cr]), An = Y0(c, Fr);
  e_(c), watch([yn, O], (ar, Or, Sr) => {
    yn.value && O.value === Rt.Initializing && (O.value = Rt.Initialized);
  }, {
    deep: !0,
    immediate: !0
  }), watch([() => Mn.value.x, () => Mn.value.y], () => {
    const {
      onDragMove: ar
    } = Kt.value, {
      collisions: Or,
      over: Sr
    } = On.value;
    if (!E.value.draggable.active || !yt.value)
      return;
    const kr = {
      active: E.value.draggable.active,
      activatorEvent: yt.value,
      collisions: Or,
      delta: {
        x: Mn.value.x,
        y: Mn.value.y
      },
      over: Sr
    };
    ar == null || ar(kr), T({
      type: "onDragMove",
      event: kr
    });
  }), watch([ve, Et, Rn, Tn, W, Un, Xn, Gt, ue, hn, er, Mn], (ar, Or) => {
    On.value = {
      activatorEvent: yt.value,
      active: ve.value,
      activeNode: Et.value,
      collisionRect: Tn.value,
      collisions: Rn.value,
      droppableRects: Gt.value,
      draggableNodes: W.value,
      draggingNode: Un.value,
      draggingNodeRect: Xn == null ? void 0 : Xn.value,
      droppableContainers: ue.value,
      over: hn.value,
      scrollableAncestors: er.value,
      scrollAdjustedTranslate: Mn.value
    }, K.value = {
      initial: Xn == null ? void 0 : Xn.value,
      translated: Tn.value
    };
  }, {
    immediate: !0
  }), H0({
    ...un,
    delta: E.value.draggable.translate,
    draggingRect: Tn.value,
    pointerCoordinates: Bn.value,
    scrollableAncestors: er.value,
    scrollableAncestorRects: bn
  });
  const Hn = useSlots();
  function ir() {
    var ar;
    const Or = ((ar = wt.value) == null ? void 0 : ar.autoScrollEnabled) === !1, Sr = typeof u == "object" ? u.enabled === !1 : u === !1, kr = z.value && !Or && !Sr;
    return typeof u == "object" ? {
      ...u,
      enabled: kr
    } : {
      enabled: kr
    };
  }
  let dr;
  return () => {
    const ar = g0$1(Rn.value, "id");
    if (dr !== ar) {
      const {
        collisions: kr,
        droppableContainers: Nr,
        scrollAdjustedTranslate: Ur
      } = On.value;
      if (!(!E.value.draggable.active || Re.value == null || !yt.value || !Ur)) {
        const {
          onDragOver: _r
        } = Kt.value, Zr = Nr.get(ar), Jr = Zr && Zr.rect ? {
          id: Zr.id,
          rect: Zr.rect,
          data: Zr.data,
          disabled: Zr.disabled
        } : null, ii = {
          active: E.value.draggable.active,
          activatorEvent: yt.value,
          collisions: kr,
          delta: {
            x: Ur.x,
            y: Ur.y
          },
          over: Jr
        };
        Qn(Jr), _r == null || _r(ii), T({
          type: "onDragOver",
          event: ii
        }), dr = ar;
      }
    }
    const Or = {
      activatorEvent: yt.value,
      activators: An.value,
      active: ve.value,
      activeNodeRect: yn.value,
      ariaDescribedById: {
        draggable: tn.value
      },
      dispatch: P,
      draggableNodes: W.value,
      over: hn.value,
      measureDroppableContainers: nn.value
    }, Sr = {
      active: ve.value,
      activeNode: Et.value,
      activeNodeRect: yn.value,
      activatorEvent: yt.value,
      collisions: Rn.value,
      containerNodeRect: Pn.value,
      dragOverlay: Nn.value,
      draggableNodes: W.value,
      droppableContainers: ue.value,
      droppableRects: Gt.value,
      over: hn.value,
      measureDroppableContainers: nn.value,
      scrollableAncestors: er.value,
      scrollableAncestorRects: bn,
      measuringConfiguration: rn.value,
      measuringScheduled: vt.value,
      windowRect: Zn.value
    };
    return createVNode(a0$1.Provider, {
      value: N
    }, {
      default: () => [createVNode(vs.Provider, {
        value: Or
      }, {
        default: () => [createVNode(s_.Provider, {
          value: Sr
        }, {
          default: () => [createVNode(gs.Provider, {
            value: tr.value
          }, {
            default: Hn.default
          })]
        }), createVNode(d_, {
          disabled: (l == null ? void 0 : l.restoreFocus) === !1
        }, null)]
      }), createVNode(d0$1, mergeProps$1(l, {
        hiddenTextDescribedById: tn.value
      }), null)]
    });
  };
}, {
  props: p_,
  name: "DndContext"
});
function ps() {
  return inject("DndContext", ref$1({
    ...Cn,
    scaleX: 1,
    scaleY: 1
  }));
}
function w_() {
  return inject("PublicContext", ref$1(o_));
}
var wr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, Ci = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
Ci.exports;
(function(s, o) {
  (function() {
    var l, u = "4.17.21", c = 200, m = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", g = "Expected a function", v = "Invalid `variable` option passed into `_.template`", b = "__lodash_hash_undefined__", S = 500, E = "__lodash_placeholder__", P = 1, T = 2, N = 4, O = 1, z = 2, Q = 1, W = 2, ue = 4, te = 8, K = 16, ve = 32, ee = 64, Re = 128, wt = 256, yt = 512, xt = 30, Kt = "...", tn = 800, ln = 16, rn = 1, an = 2, Gt = 3, nn = 1 / 0, vt = 9007199254740991, Et = 17976931348623157e292, Qt = NaN, un = 4294967295, gn = un - 1, dn = un >>> 1, yn = [
      ["ary", Re],
      ["bind", Q],
      ["bindKey", W],
      ["curry", te],
      ["curryRight", K],
      ["flip", yt],
      ["partial", ve],
      ["partialRight", ee],
      ["rearg", wt]
    ], vn = "[object Arguments]", Pn = "[object Array]", On = "[object AsyncFunction]", _n = "[object Boolean]", Nn = "[object Date]", Un = "[object DOMException]", Xn = "[object Error]", zn = "[object Function]", jn = "[object GeneratorFunction]", kn = "[object Map]", Yn = "[object Number]", Zn = "[object Null]", er = "[object Object]", bn = "[object Promise]", Ln = "[object Proxy]", Kn = "[object RegExp]", Bn = "[object Set]", Fn = "[object String]", Gn = "[object Symbol]", Wn = "[object Undefined]", Mn = "[object WeakMap]", Tn = "[object WeakSet]", Rn = "[object ArrayBuffer]", hn = "[object DataView]", Qn = "[object Float32Array]", rr = "[object Float64Array]", tr = "[object Int8Array]", Cr = "[object Int16Array]", Fr = "[object Int32Array]", An = "[object Uint8Array]", Hn = "[object Uint8ClampedArray]", ir = "[object Uint16Array]", dr = "[object Uint32Array]", ar = /\b__p \+= '';/g, Or = /\b(__p \+=) '' \+/g, Sr = /(__e\(.*?\)|\b__t\)) \+\n'';/g, kr = /&(?:amp|lt|gt|quot|#39);/g, Nr = /[&<>"']/g, Ur = RegExp(kr.source), _r = RegExp(Nr.source), Zr = /<%-([\s\S]+?)%>/g, Jr = /<%([\s\S]+?)%>/g, ii = /<%=([\s\S]+?)%>/g, Ti = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Mi = /^\w*$/, ui = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ii = /[\\^$.*+?()[\]{}|]/g, bs = RegExp(Ii.source), Oi = /^\s+/, Vs = /\s/, _s = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Is = /\{\n\/\* \[wrapped with (.+)\] \*/, Fa = /,? & /, io = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Da = /[()=,{}\[\]\/\s]/, oo = /\\(\\)?/g, Xs = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, so = /\w*$/, Ol = /^[-+]0x[0-9a-f]+$/i, kl = /^0b[01]+$/i, uc = /^\[object .+?Constructor\]$/, Vl = /^0o[0-7]+$/i, Ma = /^(?:0|[1-9]\d*)$/, Ll = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Oa = /($^)/, cc = /['\n\r\u2028\u2029\\]/g, va = "\\ud800-\\udfff", yc = "\\u0300-\\u036f", vc = "\\ufe20-\\ufe2f", Af = "\\u20d0-\\u20ff", Yr = yc + vc + Af, Ra = "\\u2700-\\u27bf", Bl = "a-z\\xdf-\\xf6\\xf8-\\xff", Nf = "\\xac\\xb1\\xd7\\xf7", Ff = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", xc = "\\u2000-\\u206f", Df = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", zl = "A-Z\\xc0-\\xd6\\xd8-\\xde", La = "\\ufe0e\\ufe0f", ya = Nf + Ff + xc + Df, Al = "['’]", bc = "[" + va + "]", dc = "[" + ya + "]", ao = "[" + Yr + "]", fc = "\\d+", Rf = "[" + Ra + "]", Nl = "[" + Bl + "]", jl = "[^" + va + ya + fc + Ra + Bl + zl + "]", lo = "\\ud83c[\\udffb-\\udfff]", Cc = "(?:" + ao + "|" + lo + ")", Fl = "[^" + va + "]", ki = "(?:\\ud83c[\\udde6-\\uddff]){2}", Dl = "[\\ud800-\\udbff][\\udc00-\\udfff]", Js = "[" + zl + "]", Hl = "\\u200d", Ul = "(?:" + Nl + "|" + jl + ")", Of = "(?:" + Js + "|" + jl + ")", pc = "(?:" + Al + "(?:d|ll|m|re|s|t|ve))?", hc = "(?:" + Al + "(?:D|LL|M|RE|S|T|VE))?", de = Cc + "?", en = "[" + La + "]?", mn = "(?:" + Hl + "(?:" + [Fl, ki, Dl].join("|") + ")" + en + de + ")*", $n = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Vn = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", sr = en + de + mn, cr = "(?:" + [Rf, ki, Dl].join("|") + ")" + sr, Br = "(?:" + [Fl + ao + "?", ao, ki, Dl, bc].join("|") + ")", Kr = RegExp(Al, "g"), Li = RegExp(ao, "g"), Pi = RegExp(lo + "(?=" + lo + ")|" + Br + sr, "g"), Zs = RegExp([
      Js + "?" + Nl + "+" + pc + "(?=" + [dc, Js, "$"].join("|") + ")",
      Of + "+" + hc + "(?=" + [dc, Js + Ul, "$"].join("|") + ")",
      Js + "?" + Ul + "+" + pc,
      Js + "+" + hc,
      Vn,
      $n,
      fc,
      cr
    ].join("|"), "g"), Rl = RegExp("[" + Hl + va + Yr + La + "]"), Kl = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ml = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], mc = -1, Wr = {};
    Wr[Qn] = Wr[rr] = Wr[tr] = Wr[Cr] = Wr[Fr] = Wr[An] = Wr[Hn] = Wr[ir] = Wr[dr] = !0, Wr[vn] = Wr[Pn] = Wr[Rn] = Wr[_n] = Wr[hn] = Wr[Nn] = Wr[Xn] = Wr[zn] = Wr[kn] = Wr[Yn] = Wr[er] = Wr[Kn] = Wr[Bn] = Wr[Fn] = Wr[Mn] = !1;
    var Hr = {};
    Hr[vn] = Hr[Pn] = Hr[Rn] = Hr[hn] = Hr[_n] = Hr[Nn] = Hr[Qn] = Hr[rr] = Hr[tr] = Hr[Cr] = Hr[Fr] = Hr[kn] = Hr[Yn] = Hr[er] = Hr[Kn] = Hr[Bn] = Hr[Fn] = Hr[Gn] = Hr[An] = Hr[Hn] = Hr[ir] = Hr[dr] = !0, Hr[Xn] = Hr[zn] = Hr[Mn] = !1;
    var Mf = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, Vf = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Bf = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, zf = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, jf = parseFloat, Hf = parseInt, Sc = typeof wr == "object" && wr && wr.Object === Object && wr, Uf = typeof self == "object" && self && self.Object === Object && self, di = Sc || Uf || Function("return this")(), Wl = o && !o.nodeType && o, Qs = Wl && !0 && s && !s.nodeType && s, $c = Qs && Qs.exports === Wl, Gl = $c && Sc.process, Yi = function() {
      try {
        var fn = Qs && Qs.require && Qs.require("util").types;
        return fn || Gl && Gl.binding && Gl.binding("util");
      } catch {
      }
    }(), wc = Yi && Yi.isArrayBuffer, _c = Yi && Yi.isDate, Ec = Yi && Yi.isMap, Pc = Yi && Yi.isRegExp, Tc = Yi && Yi.isSet, Ic = Yi && Yi.isTypedArray;
    function Hi(fn, wn, xn) {
      switch (xn.length) {
        case 0:
          return fn.call(wn);
        case 1:
          return fn.call(wn, xn[0]);
        case 2:
          return fn.call(wn, xn[0], xn[1]);
        case 3:
          return fn.call(wn, xn[0], xn[1], xn[2]);
      }
      return fn.apply(wn, xn);
    }
    function Kf(fn, wn, xn, Jn) {
      for (var fr = -1, Mr = fn == null ? 0 : fn.length; ++fr < Mr; ) {
        var ni = fn[fr];
        wn(Jn, ni, xn(ni), fn);
      }
      return Jn;
    }
    function Xi(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function Wf(fn, wn) {
      for (var xn = fn == null ? 0 : fn.length; xn-- && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function kc(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (!wn(fn[xn], xn, fn))
          return !1;
      return !0;
    }
    function Bs(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        wn(ni, xn, fn) && (Mr[fr++] = ni);
      }
      return Mr;
    }
    function uo(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return !!xn && xa(fn, wn, 0) > -1;
    }
    function ql(fn, wn, xn) {
      for (var Jn = -1, fr = fn == null ? 0 : fn.length; ++Jn < fr; )
        if (xn(wn, fn[Jn]))
          return !0;
      return !1;
    }
    function qr(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = Array(Jn); ++xn < Jn; )
        fr[xn] = wn(fn[xn], xn, fn);
      return fr;
    }
    function zs(fn, wn) {
      for (var xn = -1, Jn = wn.length, fr = fn.length; ++xn < Jn; )
        fn[fr + xn] = wn[xn];
      return fn;
    }
    function Yl(fn, wn, xn, Jn) {
      var fr = -1, Mr = fn == null ? 0 : fn.length;
      for (Jn && Mr && (xn = fn[++fr]); ++fr < Mr; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Gf(fn, wn, xn, Jn) {
      var fr = fn == null ? 0 : fn.length;
      for (Jn && fr && (xn = fn[--fr]); fr--; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Xl(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (wn(fn[xn], xn, fn))
          return !0;
      return !1;
    }
    var qf = Zl("length");
    function Yf(fn) {
      return fn.split("");
    }
    function Xf(fn) {
      return fn.match(io) || [];
    }
    function Ac(fn, wn, xn) {
      var Jn;
      return xn(fn, function(fr, Mr, ni) {
        if (wn(fr, Mr, ni))
          return Jn = Mr, !1;
      }), Jn;
    }
    function co(fn, wn, xn, Jn) {
      for (var fr = fn.length, Mr = xn + (Jn ? 1 : -1); Jn ? Mr-- : ++Mr < fr; )
        if (wn(fn[Mr], Mr, fn))
          return Mr;
      return -1;
    }
    function xa(fn, wn, xn) {
      return wn === wn ? lp(fn, wn, xn) : co(fn, Nc, xn);
    }
    function Zf(fn, wn, xn, Jn) {
      for (var fr = xn - 1, Mr = fn.length; ++fr < Mr; )
        if (Jn(fn[fr], wn))
          return fr;
      return -1;
    }
    function Nc(fn) {
      return fn !== fn;
    }
    function Fc(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return xn ? Ql(fn, wn) / xn : Qt;
    }
    function Zl(fn) {
      return function(wn) {
        return wn == null ? l : wn[fn];
      };
    }
    function Jl(fn) {
      return function(wn) {
        return fn == null ? l : fn[wn];
      };
    }
    function Dc(fn, wn, xn, Jn, fr) {
      return fr(fn, function(Mr, ni, Gr) {
        xn = Jn ? (Jn = !1, Mr) : wn(xn, Mr, ni, Gr);
      }), xn;
    }
    function Jf(fn, wn) {
      var xn = fn.length;
      for (fn.sort(wn); xn--; )
        fn[xn] = fn[xn].value;
      return fn;
    }
    function Ql(fn, wn) {
      for (var xn, Jn = -1, fr = fn.length; ++Jn < fr; ) {
        var Mr = wn(fn[Jn]);
        Mr !== l && (xn = xn === l ? Mr : xn + Mr);
      }
      return xn;
    }
    function eu(fn, wn) {
      for (var xn = -1, Jn = Array(fn); ++xn < fn; )
        Jn[xn] = wn(xn);
      return Jn;
    }
    function Qf(fn, wn) {
      return qr(wn, function(xn) {
        return [xn, fn[xn]];
      });
    }
    function Rc(fn) {
      return fn && fn.slice(0, Vc(fn) + 1).replace(Oi, "");
    }
    function Ui(fn) {
      return function(wn) {
        return fn(wn);
      };
    }
    function tu(fn, wn) {
      return qr(wn, function(xn) {
        return fn[xn];
      });
    }
    function Va(fn, wn) {
      return fn.has(wn);
    }
    function Oc(fn, wn) {
      for (var xn = -1, Jn = fn.length; ++xn < Jn && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function Lc(fn, wn) {
      for (var xn = fn.length; xn-- && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function ep(fn, wn) {
      for (var xn = fn.length, Jn = 0; xn--; )
        fn[xn] === wn && ++Jn;
      return Jn;
    }
    var tp = Jl(Mf), np = Jl(Vf);
    function rp(fn) {
      return "\\" + zf[fn];
    }
    function ip(fn, wn) {
      return fn == null ? l : fn[wn];
    }
    function ba(fn) {
      return Rl.test(fn);
    }
    function sp(fn) {
      return Kl.test(fn);
    }
    function ap(fn) {
      for (var wn, xn = []; !(wn = fn.next()).done; )
        xn.push(wn.value);
      return xn;
    }
    function nu(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn, fr) {
        xn[++wn] = [fr, Jn];
      }), xn;
    }
    function Mc(fn, wn) {
      return function(xn) {
        return fn(wn(xn));
      };
    }
    function Hs(fn, wn) {
      for (var xn = -1, Jn = fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        (ni === wn || ni === E) && (fn[xn] = E, Mr[fr++] = xn);
      }
      return Mr;
    }
    function fo(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = Jn;
      }), xn;
    }
    function op(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = [Jn, Jn];
      }), xn;
    }
    function lp(fn, wn, xn) {
      for (var Jn = xn - 1, fr = fn.length; ++Jn < fr; )
        if (fn[Jn] === wn)
          return Jn;
      return -1;
    }
    function up(fn, wn, xn) {
      for (var Jn = xn + 1; Jn--; )
        if (fn[Jn] === wn)
          return Jn;
      return Jn;
    }
    function Ca(fn) {
      return ba(fn) ? dp(fn) : qf(fn);
    }
    function Cs(fn) {
      return ba(fn) ? fp(fn) : Yf(fn);
    }
    function Vc(fn) {
      for (var wn = fn.length; wn-- && Vs.test(fn.charAt(wn)); )
        ;
      return wn;
    }
    var cp = Jl(Bf);
    function dp(fn) {
      for (var wn = Pi.lastIndex = 0; Pi.test(fn); )
        ++wn;
      return wn;
    }
    function fp(fn) {
      return fn.match(Pi) || [];
    }
    function hp(fn) {
      return fn.match(Zs) || [];
    }
    var mp = function fn(wn) {
      wn = wn == null ? di : Sa.defaults(di.Object(), wn, Sa.pick(di, Ml));
      var xn = wn.Array, Jn = wn.Date, fr = wn.Error, Mr = wn.Function, ni = wn.Math, Gr = wn.Object, ru = wn.RegExp, gp = wn.String, Zi = wn.TypeError, po = xn.prototype, yp = Mr.prototype, $a = Gr.prototype, ho = wn["__core-js_shared__"], mo = yp.toString, zr = $a.hasOwnProperty, vp = 0, Bc = function() {
        var f = /[^.]+$/.exec(ho && ho.keys && ho.keys.IE_PROTO || "");
        return f ? "Symbol(src)_1." + f : "";
      }(), go = $a.toString, xp = mo.call(Gr), bp = di._, Cp = ru(
        "^" + mo.call(zr).replace(Ii, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), yo = $c ? wn.Buffer : l, Us = wn.Symbol, vo = wn.Uint8Array, zc = yo ? yo.allocUnsafe : l, xo = Mc(Gr.getPrototypeOf, Gr), jc = Gr.create, Hc = $a.propertyIsEnumerable, bo = po.splice, Uc = Us ? Us.isConcatSpreadable : l, Ba = Us ? Us.iterator : l, sa = Us ? Us.toStringTag : l, Co = function() {
        try {
          var f = ha(Gr, "defineProperty");
          return f({}, "", {}), f;
        } catch {
        }
      }(), Sp = wn.clearTimeout !== di.clearTimeout && wn.clearTimeout, wp = Jn && Jn.now !== di.Date.now && Jn.now, _p = wn.setTimeout !== di.setTimeout && wn.setTimeout, So = ni.ceil, wo = ni.floor, iu = Gr.getOwnPropertySymbols, Ep = yo ? yo.isBuffer : l, Kc = wn.isFinite, Pp = po.join, Tp = Mc(Gr.keys, Gr), ri = ni.max, wi = ni.min, Ip = Jn.now, Ap = wn.parseInt, Wc = ni.random, Np = po.reverse, su = ha(wn, "DataView"), za = ha(wn, "Map"), au = ha(wn, "Promise"), wa = ha(wn, "Set"), ja = ha(wn, "WeakMap"), Ua = ha(Gr, "create"), _o = ja && new ja(), Ea = {}, Fp = ma(su), Dp = ma(za), Rp = ma(au), Op = ma(wa), Lp = ma(ja), Eo = Us ? Us.prototype : l, Ka = Eo ? Eo.valueOf : l, Gc = Eo ? Eo.toString : l;
      function Ft(f) {
        if (Qr(f) && !pr(f) && !(f instanceof Pr)) {
          if (f instanceof Ji)
            return f;
          if (zr.call(f, "__wrapped__"))
            return Yd(f);
        }
        return new Ji(f);
      }
      var Pa = /* @__PURE__ */ function() {
        function f() {
        }
        return function(y) {
          if (!Xr(y))
            return {};
          if (jc)
            return jc(y);
          f.prototype = y;
          var w = new f();
          return f.prototype = l, w;
        };
      }();
      function Po() {
      }
      function Ji(f, y) {
        this.__wrapped__ = f, this.__actions__ = [], this.__chain__ = !!y, this.__index__ = 0, this.__values__ = l;
      }
      Ft.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Zr,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Jr,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ii,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: Ft
        }
      }, Ft.prototype = Po.prototype, Ft.prototype.constructor = Ft, Ji.prototype = Pa(Po.prototype), Ji.prototype.constructor = Ji;
      function Pr(f) {
        this.__wrapped__ = f, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = un, this.__views__ = [];
      }
      function Mp() {
        var f = new Pr(this.__wrapped__);
        return f.__actions__ = Vi(this.__actions__), f.__dir__ = this.__dir__, f.__filtered__ = this.__filtered__, f.__iteratees__ = Vi(this.__iteratees__), f.__takeCount__ = this.__takeCount__, f.__views__ = Vi(this.__views__), f;
      }
      function Bp() {
        if (this.__filtered__) {
          var f = new Pr(this);
          f.__dir__ = -1, f.__filtered__ = !0;
        } else
          f = this.clone(), f.__dir__ *= -1;
        return f;
      }
      function zp() {
        var f = this.__wrapped__.value(), y = this.__dir__, w = pr(f), Y = y < 0, dt = w ? f.length : 0, Wt = rm(0, dt, this.__views__), sn = Wt.start, cn = Wt.end, pn = cn - sn, En = Y ? cn : sn - 1, In = this.__iteratees__, Dn = In.length, qn = 0, nr = wi(pn, this.__takeCount__);
        if (!w || !Y && dt == pn && nr == pn)
          return vd(f, this.__actions__);
        var lr = [];
        e:
          for (; pn-- && qn < nr; ) {
            En += y;
            for (var gr = -1, ur = f[En]; ++gr < Dn; ) {
              var $r = In[gr], Ir = $r.iteratee, Gi = $r.type, Fi = Ir(ur);
              if (Gi == an)
                ur = Fi;
              else if (!Fi) {
                if (Gi == rn)
                  continue e;
                break e;
              }
            }
            lr[qn++] = ur;
          }
        return lr;
      }
      Pr.prototype = Pa(Po.prototype), Pr.prototype.constructor = Pr;
      function ca(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Up() {
        this.__data__ = Ua ? Ua(null) : {}, this.size = 0;
      }
      function Kp(f) {
        var y = this.has(f) && delete this.__data__[f];
        return this.size -= y ? 1 : 0, y;
      }
      function Wp(f) {
        var y = this.__data__;
        if (Ua) {
          var w = y[f];
          return w === b ? l : w;
        }
        return zr.call(y, f) ? y[f] : l;
      }
      function Gp(f) {
        var y = this.__data__;
        return Ua ? y[f] !== l : zr.call(y, f);
      }
      function qp(f, y) {
        var w = this.__data__;
        return this.size += this.has(f) ? 0 : 1, w[f] = Ua && y === l ? b : y, this;
      }
      ca.prototype.clear = Up, ca.prototype.delete = Kp, ca.prototype.get = Wp, ca.prototype.has = Gp, ca.prototype.set = qp;
      function ks(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Yp() {
        this.__data__ = [], this.size = 0;
      }
      function Xp(f) {
        var y = this.__data__, w = To(y, f);
        if (w < 0)
          return !1;
        var Y = y.length - 1;
        return w == Y ? y.pop() : bo.call(y, w, 1), --this.size, !0;
      }
      function Zp(f) {
        var y = this.__data__, w = To(y, f);
        return w < 0 ? l : y[w][1];
      }
      function eh(f) {
        return To(this.__data__, f) > -1;
      }
      function th(f, y) {
        var w = this.__data__, Y = To(w, f);
        return Y < 0 ? (++this.size, w.push([f, y])) : w[Y][1] = y, this;
      }
      ks.prototype.clear = Yp, ks.prototype.delete = Xp, ks.prototype.get = Zp, ks.prototype.has = eh, ks.prototype.set = th;
      function As(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function nh() {
        this.size = 0, this.__data__ = {
          hash: new ca(),
          map: new (za || ks)(),
          string: new ca()
        };
      }
      function rh(f) {
        var y = el(this, f).delete(f);
        return this.size -= y ? 1 : 0, y;
      }
      function ih(f) {
        return el(this, f).get(f);
      }
      function sh(f) {
        return el(this, f).has(f);
      }
      function ah(f, y) {
        var w = el(this, f), Y = w.size;
        return w.set(f, y), this.size += w.size == Y ? 0 : 1, this;
      }
      As.prototype.clear = nh, As.prototype.delete = rh, As.prototype.get = ih, As.prototype.has = sh, As.prototype.set = ah;
      function da(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.__data__ = new As(); ++y < w; )
          this.add(f[y]);
      }
      function oh(f) {
        return this.__data__.set(f, b), this;
      }
      function lh(f) {
        return this.__data__.has(f);
      }
      da.prototype.add = da.prototype.push = oh, da.prototype.has = lh;
      function Ss(f) {
        var y = this.__data__ = new ks(f);
        this.size = y.size;
      }
      function uh() {
        this.__data__ = new ks(), this.size = 0;
      }
      function ch(f) {
        var y = this.__data__, w = y.delete(f);
        return this.size = y.size, w;
      }
      function dh(f) {
        return this.__data__.get(f);
      }
      function fh(f) {
        return this.__data__.has(f);
      }
      function ph(f, y) {
        var w = this.__data__;
        if (w instanceof ks) {
          var Y = w.__data__;
          if (!za || Y.length < c - 1)
            return Y.push([f, y]), this.size = ++w.size, this;
          w = this.__data__ = new As(Y);
        }
        return w.set(f, y), this.size = w.size, this;
      }
      Ss.prototype.clear = uh, Ss.prototype.delete = ch, Ss.prototype.get = dh, Ss.prototype.has = fh, Ss.prototype.set = ph;
      function qc(f, y) {
        var w = pr(f), Y = !w && ga(f), dt = !w && !Y && Ys(f), Wt = !w && !Y && !dt && Aa(f), sn = w || Y || dt || Wt, cn = sn ? eu(f.length, gp) : [], pn = cn.length;
        for (var En in f)
          (y || zr.call(f, En)) && !(sn && // Safari 9 has enumerable `arguments.length` in strict mode.
          (En == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          dt && (En == "offset" || En == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          Wt && (En == "buffer" || En == "byteLength" || En == "byteOffset") || // Skip index properties.
          Rs(En, pn))) && cn.push(En);
        return cn;
      }
      function Yc(f) {
        var y = f.length;
        return y ? f[yu(0, y - 1)] : l;
      }
      function hh(f, y) {
        return xl(Vi(f), fa(y, 0, f.length));
      }
      function mh(f) {
        return xl(Vi(f));
      }
      function ou(f, y, w) {
        (w !== l && !$s(f[y], w) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function Wa(f, y, w) {
        var Y = f[y];
        (!(zr.call(f, y) && $s(Y, w)) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function To(f, y) {
        for (var w = f.length; w--; )
          if ($s(f[w][0], y))
            return w;
        return -1;
      }
      function gh(f, y, w, Y) {
        return Ks(f, function(dt, Wt, sn) {
          y(Y, dt, w(dt), sn);
        }), Y;
      }
      function Xc(f, y) {
        return f && Ps(y, oi(y), f);
      }
      function yh(f, y) {
        return f && Ps(y, zi(y), f);
      }
      function Ns(f, y, w) {
        y == "__proto__" && Co ? Co(f, y, {
          configurable: !0,
          enumerable: !0,
          value: w,
          writable: !0
        }) : f[y] = w;
      }
      function lu(f, y) {
        for (var w = -1, Y = y.length, dt = xn(Y), Wt = f == null; ++w < Y; )
          dt[w] = Wt ? l : ec(f, y[w]);
        return dt;
      }
      function fa(f, y, w) {
        return f === f && (w !== l && (f = f <= w ? f : w), y !== l && (f = f >= y ? f : y)), f;
      }
      function Qi(f, y, w, Y, dt, Wt) {
        var sn, cn = y & P, pn = y & T, En = y & N;
        if (w && (sn = dt ? w(f, Y, dt, Wt) : w(f)), sn !== l)
          return sn;
        if (!Xr(f))
          return f;
        var In = pr(f);
        if (In) {
          if (sn = sm(f), !cn)
            return Vi(f, sn);
        } else {
          var Dn = Ei(f), qn = Dn == zn || Dn == jn;
          if (Ys(f))
            return Cd(f, cn);
          if (Dn == er || Dn == vn || qn && !dt) {
            if (sn = pn || qn ? {} : Bd(f), !cn)
              return pn ? qh(f, yh(sn, f)) : Gh(f, Xc(sn, f));
          } else {
            if (!Hr[Dn])
              return dt ? f : {};
            sn = am(f, Dn, cn);
          }
        }
        Wt || (Wt = new Ss());
        var nr = Wt.get(f);
        if (nr)
          return nr;
        Wt.set(f, sn), gf(f) ? f.forEach(function(ur) {
          sn.add(Qi(ur, y, w, ur, f, Wt));
        }) : hf(f) && f.forEach(function(ur, $r) {
          sn.set($r, Qi(ur, y, w, $r, f, Wt));
        });
        var lr = En ? pn ? Iu : Tu : pn ? zi : oi, gr = In ? l : lr(f);
        return Xi(gr || f, function(ur, $r) {
          gr && ($r = ur, ur = f[$r]), Wa(sn, $r, Qi(ur, y, w, $r, f, Wt));
        }), sn;
      }
      function vh(f) {
        var y = oi(f);
        return function(w) {
          return Zc(w, f, y);
        };
      }
      function Zc(f, y, w) {
        var Y = w.length;
        if (f == null)
          return !Y;
        for (f = Gr(f); Y--; ) {
          var dt = w[Y], Wt = y[dt], sn = f[dt];
          if (sn === l && !(dt in f) || !Wt(sn))
            return !1;
        }
        return !0;
      }
      function Jc(f, y, w) {
        if (typeof f != "function")
          throw new Zi(g);
        return no(function() {
          f.apply(l, w);
        }, y);
      }
      function Ga(f, y, w, Y) {
        var dt = -1, Wt = uo, sn = !0, cn = f.length, pn = [], En = y.length;
        if (!cn)
          return pn;
        w && (y = qr(y, Ui(w))), Y ? (Wt = ql, sn = !1) : y.length >= c && (Wt = Va, sn = !1, y = new da(y));
        e:
          for (; ++dt < cn; ) {
            var In = f[dt], Dn = w == null ? In : w(In);
            if (In = Y || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = En; qn--; )
                if (y[qn] === Dn)
                  continue e;
              pn.push(In);
            } else
              Wt(y, Dn, Y) || pn.push(In);
          }
        return pn;
      }
      var Ks = Ed(Es), Qc = Ed(cu, !0);
      function xh(f, y) {
        var w = !0;
        return Ks(f, function(Y, dt, Wt) {
          return w = !!y(Y, dt, Wt), w;
        }), w;
      }
      function Io(f, y, w) {
        for (var Y = -1, dt = f.length; ++Y < dt; ) {
          var Wt = f[Y], sn = y(Wt);
          if (sn != null && (cn === l ? sn === sn && !Wi(sn) : w(sn, cn)))
            var cn = sn, pn = Wt;
        }
        return pn;
      }
      function bh(f, y, w, Y) {
        var dt = f.length;
        for (w = hr(w), w < 0 && (w = -w > dt ? 0 : dt + w), Y = Y === l || Y > dt ? dt : hr(Y), Y < 0 && (Y += dt), Y = w > Y ? 0 : vf(Y); w < Y; )
          f[w++] = y;
        return f;
      }
      function ed(f, y) {
        var w = [];
        return Ks(f, function(Y, dt, Wt) {
          y(Y, dt, Wt) && w.push(Y);
        }), w;
      }
      function $i(f, y, w, Y, dt) {
        var Wt = -1, sn = f.length;
        for (w || (w = lm), dt || (dt = []); ++Wt < sn; ) {
          var cn = f[Wt];
          y > 0 && w(cn) ? y > 1 ? $i(cn, y - 1, w, Y, dt) : zs(dt, cn) : Y || (dt[dt.length] = cn);
        }
        return dt;
      }
      var uu = Pd(), td = Pd(!0);
      function Es(f, y) {
        return f && uu(f, y, oi);
      }
      function cu(f, y) {
        return f && td(f, y, oi);
      }
      function Ao(f, y) {
        return Bs(y, function(w) {
          return Os(f[w]);
        });
      }
      function pa(f, y) {
        y = Gs(y, f);
        for (var w = 0, Y = y.length; f != null && w < Y; )
          f = f[Ts(y[w++])];
        return w && w == Y ? f : l;
      }
      function nd(f, y, w) {
        var Y = y(f);
        return pr(f) ? Y : zs(Y, w(f));
      }
      function Ai(f) {
        return f == null ? f === l ? Wn : Zn : sa && sa in Gr(f) ? nm(f) : mm(f);
      }
      function du(f, y) {
        return f > y;
      }
      function Ch(f, y) {
        return f != null && zr.call(f, y);
      }
      function Sh(f, y) {
        return f != null && y in Gr(f);
      }
      function $h(f, y, w) {
        return f >= wi(y, w) && f < ri(y, w);
      }
      function fu(f, y, w) {
        for (var Y = w ? ql : uo, dt = f[0].length, Wt = f.length, sn = Wt, cn = xn(Wt), pn = 1 / 0, En = []; sn--; ) {
          var In = f[sn];
          sn && y && (In = qr(In, Ui(y))), pn = wi(In.length, pn), cn[sn] = !w && (y || dt >= 120 && In.length >= 120) ? new da(sn && In) : l;
        }
        In = f[0];
        var Dn = -1, qn = cn[0];
        e:
          for (; ++Dn < dt && En.length < pn; ) {
            var nr = In[Dn], lr = y ? y(nr) : nr;
            if (nr = w || nr !== 0 ? nr : 0, !(qn ? Va(qn, lr) : Y(En, lr, w))) {
              for (sn = Wt; --sn; ) {
                var gr = cn[sn];
                if (!(gr ? Va(gr, lr) : Y(f[sn], lr, w)))
                  continue e;
              }
              qn && qn.push(lr), En.push(nr);
            }
          }
        return En;
      }
      function wh(f, y, w, Y) {
        return Es(f, function(dt, Wt, sn) {
          y(Y, w(dt), Wt, sn);
        }), Y;
      }
      function qa(f, y, w) {
        y = Gs(y, f), f = Ud(f, y);
        var Y = f == null ? f : f[Ts(ys(y))];
        return Y == null ? l : Hi(Y, f, w);
      }
      function rd(f) {
        return Qr(f) && Ai(f) == vn;
      }
      function _h(f) {
        return Qr(f) && Ai(f) == Rn;
      }
      function Eh(f) {
        return Qr(f) && Ai(f) == Nn;
      }
      function Ya(f, y, w, Y, dt) {
        return f === y ? !0 : f == null || y == null || !Qr(f) && !Qr(y) ? f !== f && y !== y : Ph(f, y, w, Y, Ya, dt);
      }
      function Ph(f, y, w, Y, dt, Wt) {
        var sn = pr(f), cn = pr(y), pn = sn ? Pn : Ei(f), En = cn ? Pn : Ei(y);
        pn = pn == vn ? er : pn, En = En == vn ? er : En;
        var In = pn == er, Dn = En == er, qn = pn == En;
        if (qn && Ys(f)) {
          if (!Ys(y))
            return !1;
          sn = !0, In = !1;
        }
        if (qn && !In)
          return Wt || (Wt = new Ss()), sn || Aa(f) ? Ld(f, y, w, Y, dt, Wt) : em(f, y, pn, w, Y, dt, Wt);
        if (!(w & O)) {
          var nr = In && zr.call(f, "__wrapped__"), lr = Dn && zr.call(y, "__wrapped__");
          if (nr || lr) {
            var gr = nr ? f.value() : f, ur = lr ? y.value() : y;
            return Wt || (Wt = new Ss()), dt(gr, ur, w, Y, Wt);
          }
        }
        return qn ? (Wt || (Wt = new Ss()), tm(f, y, w, Y, dt, Wt)) : !1;
      }
      function Th(f) {
        return Qr(f) && Ei(f) == kn;
      }
      function pu(f, y, w, Y) {
        var dt = w.length, Wt = dt, sn = !Y;
        if (f == null)
          return !Wt;
        for (f = Gr(f); dt--; ) {
          var cn = w[dt];
          if (sn && cn[2] ? cn[1] !== f[cn[0]] : !(cn[0] in f))
            return !1;
        }
        for (; ++dt < Wt; ) {
          cn = w[dt];
          var pn = cn[0], En = f[pn], In = cn[1];
          if (sn && cn[2]) {
            if (En === l && !(pn in f))
              return !1;
          } else {
            var Dn = new Ss();
            if (Y)
              var qn = Y(En, In, pn, f, y, Dn);
            if (!(qn === l ? Ya(In, En, O | z, Y, Dn) : qn))
              return !1;
          }
        }
        return !0;
      }
      function id(f) {
        if (!Xr(f) || cm(f))
          return !1;
        var y = Os(f) ? Cp : uc;
        return y.test(ma(f));
      }
      function Ih(f) {
        return Qr(f) && Ai(f) == Kn;
      }
      function kh(f) {
        return Qr(f) && Ei(f) == Bn;
      }
      function Ah(f) {
        return Qr(f) && Pl(f.length) && !!Wr[Ai(f)];
      }
      function sd(f) {
        return typeof f == "function" ? f : f == null ? ji : typeof f == "object" ? pr(f) ? ld(f[0], f[1]) : od(f) : If(f);
      }
      function hu(f) {
        if (!to(f))
          return Tp(f);
        var y = [];
        for (var w in Gr(f))
          zr.call(f, w) && w != "constructor" && y.push(w);
        return y;
      }
      function Nh(f) {
        if (!Xr(f))
          return hm(f);
        var y = to(f), w = [];
        for (var Y in f)
          Y == "constructor" && (y || !zr.call(f, Y)) || w.push(Y);
        return w;
      }
      function mu(f, y) {
        return f < y;
      }
      function ad(f, y) {
        var w = -1, Y = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(dt, Wt, sn) {
          Y[++w] = y(dt, Wt, sn);
        }), Y;
      }
      function od(f) {
        var y = Nu(f);
        return y.length == 1 && y[0][2] ? jd(y[0][0], y[0][1]) : function(w) {
          return w === f || pu(w, f, y);
        };
      }
      function ld(f, y) {
        return Du(f) && zd(y) ? jd(Ts(f), y) : function(w) {
          var Y = ec(w, f);
          return Y === l && Y === y ? tc(w, f) : Ya(y, Y, O | z);
        };
      }
      function No(f, y, w, Y, dt) {
        f !== y && uu(y, function(Wt, sn) {
          if (dt || (dt = new Ss()), Xr(Wt))
            Fh(f, y, sn, w, No, Y, dt);
          else {
            var cn = Y ? Y(Ou(f, sn), Wt, sn + "", f, y, dt) : l;
            cn === l && (cn = Wt), ou(f, sn, cn);
          }
        }, zi);
      }
      function Fh(f, y, w, Y, dt, Wt, sn) {
        var cn = Ou(f, w), pn = Ou(y, w), En = sn.get(pn);
        if (En) {
          ou(f, w, En);
          return;
        }
        var In = Wt ? Wt(cn, pn, w + "", f, y, sn) : l, Dn = In === l;
        if (Dn) {
          var qn = pr(pn), nr = !qn && Ys(pn), lr = !qn && !nr && Aa(pn);
          In = pn, qn || nr || lr ? pr(cn) ? In = cn : ei(cn) ? In = Vi(cn) : nr ? (Dn = !1, In = Cd(pn, !0)) : lr ? (Dn = !1, In = Sd(pn, !0)) : In = [] : ro(pn) || ga(pn) ? (In = cn, ga(cn) ? In = xf(cn) : (!Xr(cn) || Os(cn)) && (In = Bd(pn))) : Dn = !1;
        }
        Dn && (sn.set(pn, In), dt(In, pn, Y, Wt, sn), sn.delete(pn)), ou(f, w, In);
      }
      function ud(f, y) {
        var w = f.length;
        if (w)
          return y += y < 0 ? w : 0, Rs(y, w) ? f[y] : l;
      }
      function cd(f, y, w) {
        y.length ? y = qr(y, function(Wt) {
          return pr(Wt) ? function(sn) {
            return pa(sn, Wt.length === 1 ? Wt[0] : Wt);
          } : Wt;
        }) : y = [ji];
        var Y = -1;
        y = qr(y, Ui(or()));
        var dt = ad(f, function(Wt, sn, cn) {
          var pn = qr(y, function(En) {
            return En(Wt);
          });
          return { criteria: pn, index: ++Y, value: Wt };
        });
        return Jf(dt, function(Wt, sn) {
          return Wh(Wt, sn, w);
        });
      }
      function Dh(f, y) {
        return dd(f, y, function(w, Y) {
          return tc(f, Y);
        });
      }
      function dd(f, y, w) {
        for (var Y = -1, dt = y.length, Wt = {}; ++Y < dt; ) {
          var sn = y[Y], cn = pa(f, sn);
          w(cn, sn) && Xa(Wt, Gs(sn, f), cn);
        }
        return Wt;
      }
      function Rh(f) {
        return function(y) {
          return pa(y, f);
        };
      }
      function gu(f, y, w, Y) {
        var dt = Y ? Zf : xa, Wt = -1, sn = y.length, cn = f;
        for (f === y && (y = Vi(y)), w && (cn = qr(f, Ui(w))); ++Wt < sn; )
          for (var pn = 0, En = y[Wt], In = w ? w(En) : En; (pn = dt(cn, In, pn, Y)) > -1; )
            cn !== f && bo.call(cn, pn, 1), bo.call(f, pn, 1);
        return f;
      }
      function fd(f, y) {
        for (var w = f ? y.length : 0, Y = w - 1; w--; ) {
          var dt = y[w];
          if (w == Y || dt !== Wt) {
            var Wt = dt;
            Rs(dt) ? bo.call(f, dt, 1) : bu(f, dt);
          }
        }
        return f;
      }
      function yu(f, y) {
        return f + wo(Wc() * (y - f + 1));
      }
      function Oh(f, y, w, Y) {
        for (var dt = -1, Wt = ri(So((y - f) / (w || 1)), 0), sn = xn(Wt); Wt--; )
          sn[Y ? Wt : ++dt] = f, f += w;
        return sn;
      }
      function vu(f, y) {
        var w = "";
        if (!f || y < 1 || y > vt)
          return w;
        do
          y % 2 && (w += f), y = wo(y / 2), y && (f += f);
        while (y);
        return w;
      }
      function vr(f, y) {
        return Lu(Hd(f, y, ji), f + "");
      }
      function Lh(f) {
        return Yc(Na(f));
      }
      function Mh(f, y) {
        var w = Na(f);
        return xl(w, fa(y, 0, w.length));
      }
      function Xa(f, y, w, Y) {
        if (!Xr(f))
          return f;
        y = Gs(y, f);
        for (var dt = -1, Wt = y.length, sn = Wt - 1, cn = f; cn != null && ++dt < Wt; ) {
          var pn = Ts(y[dt]), En = w;
          if (pn === "__proto__" || pn === "constructor" || pn === "prototype")
            return f;
          if (dt != sn) {
            var In = cn[pn];
            En = Y ? Y(In, pn, cn) : l, En === l && (En = Xr(In) ? In : Rs(y[dt + 1]) ? [] : {});
          }
          Wa(cn, pn, En), cn = cn[pn];
        }
        return f;
      }
      var pd = _o ? function(f, y) {
        return _o.set(f, y), f;
      } : ji, Vh = Co ? function(f, y) {
        return Co(f, "toString", {
          configurable: !0,
          enumerable: !1,
          value: rc(y),
          writable: !0
        });
      } : ji;
      function Bh(f) {
        return xl(Na(f));
      }
      function ms(f, y, w) {
        var Y = -1, dt = f.length;
        y < 0 && (y = -y > dt ? 0 : dt + y), w = w > dt ? dt : w, w < 0 && (w += dt), dt = y > w ? 0 : w - y >>> 0, y >>>= 0;
        for (var Wt = xn(dt); ++Y < dt; )
          Wt[Y] = f[Y + y];
        return Wt;
      }
      function zh(f, y) {
        var w;
        return Ks(f, function(Y, dt, Wt) {
          return w = y(Y, dt, Wt), !w;
        }), !!w;
      }
      function Do(f, y, w) {
        var Y = 0, dt = f == null ? Y : f.length;
        if (typeof y == "number" && y === y && dt <= dn) {
          for (; Y < dt; ) {
            var Wt = Y + dt >>> 1, sn = f[Wt];
            sn !== null && !Wi(sn) && (w ? sn <= y : sn < y) ? Y = Wt + 1 : dt = Wt;
          }
          return dt;
        }
        return xu(f, y, ji, w);
      }
      function xu(f, y, w, Y) {
        var dt = 0, Wt = f == null ? 0 : f.length;
        if (Wt === 0)
          return 0;
        y = w(y);
        for (var sn = y !== y, cn = y === null, pn = Wi(y), En = y === l; dt < Wt; ) {
          var In = wo((dt + Wt) / 2), Dn = w(f[In]), qn = Dn !== l, nr = Dn === null, lr = Dn === Dn, gr = Wi(Dn);
          if (sn)
            var ur = Y || lr;
          else
            En ? ur = lr && (Y || qn) : cn ? ur = lr && qn && (Y || !nr) : pn ? ur = lr && qn && !nr && (Y || !gr) : nr || gr ? ur = !1 : ur = Y ? Dn <= y : Dn < y;
          ur ? dt = In + 1 : Wt = In;
        }
        return wi(Wt, gn);
      }
      function hd(f, y) {
        for (var w = -1, Y = f.length, dt = 0, Wt = []; ++w < Y; ) {
          var sn = f[w], cn = y ? y(sn) : sn;
          if (!w || !$s(cn, pn)) {
            var pn = cn;
            Wt[dt++] = sn === 0 ? 0 : sn;
          }
        }
        return Wt;
      }
      function gd(f) {
        return typeof f == "number" ? f : Wi(f) ? Qt : +f;
      }
      function Ki(f) {
        if (typeof f == "string")
          return f;
        if (pr(f))
          return qr(f, Ki) + "";
        if (Wi(f))
          return Gc ? Gc.call(f) : "";
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function Ws(f, y, w) {
        var Y = -1, dt = uo, Wt = f.length, sn = !0, cn = [], pn = cn;
        if (w)
          sn = !1, dt = ql;
        else if (Wt >= c) {
          var En = y ? null : Jh(f);
          if (En)
            return fo(En);
          sn = !1, dt = Va, pn = new da();
        } else
          pn = y ? [] : cn;
        e:
          for (; ++Y < Wt; ) {
            var In = f[Y], Dn = y ? y(In) : In;
            if (In = w || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = pn.length; qn--; )
                if (pn[qn] === Dn)
                  continue e;
              y && pn.push(Dn), cn.push(In);
            } else
              dt(pn, Dn, w) || (pn !== cn && pn.push(Dn), cn.push(In));
          }
        return cn;
      }
      function bu(f, y) {
        return y = Gs(y, f), f = Ud(f, y), f == null || delete f[Ts(ys(y))];
      }
      function yd(f, y, w, Y) {
        return Xa(f, y, w(pa(f, y)), Y);
      }
      function Ro(f, y, w, Y) {
        for (var dt = f.length, Wt = Y ? dt : -1; (Y ? Wt-- : ++Wt < dt) && y(f[Wt], Wt, f); )
          ;
        return w ? ms(f, Y ? 0 : Wt, Y ? Wt + 1 : dt) : ms(f, Y ? Wt + 1 : 0, Y ? dt : Wt);
      }
      function vd(f, y) {
        var w = f;
        return w instanceof Pr && (w = w.value()), Yl(y, function(Y, dt) {
          return dt.func.apply(dt.thisArg, zs([Y], dt.args));
        }, w);
      }
      function Cu(f, y, w) {
        var Y = f.length;
        if (Y < 2)
          return Y ? Ws(f[0]) : [];
        for (var dt = -1, Wt = xn(Y); ++dt < Y; )
          for (var sn = f[dt], cn = -1; ++cn < Y; )
            cn != dt && (Wt[dt] = Ga(Wt[dt] || sn, f[cn], y, w));
        return Ws($i(Wt, 1), y, w);
      }
      function xd(f, y, w) {
        for (var Y = -1, dt = f.length, Wt = y.length, sn = {}; ++Y < dt; ) {
          var cn = Y < Wt ? y[Y] : l;
          w(sn, f[Y], cn);
        }
        return sn;
      }
      function Su(f) {
        return ei(f) ? f : [];
      }
      function wu(f) {
        return typeof f == "function" ? f : ji;
      }
      function Gs(f, y) {
        return pr(f) ? f : Du(f, y) ? [f] : qd(Vr(f));
      }
      var jh = vr;
      function qs(f, y, w) {
        var Y = f.length;
        return w = w === l ? Y : w, !y && w >= Y ? f : ms(f, y, w);
      }
      var bd = Sp || function(f) {
        return di.clearTimeout(f);
      };
      function Cd(f, y) {
        if (y)
          return f.slice();
        var w = f.length, Y = zc ? zc(w) : new f.constructor(w);
        return f.copy(Y), Y;
      }
      function _u(f) {
        var y = new f.constructor(f.byteLength);
        return new vo(y).set(new vo(f)), y;
      }
      function Hh(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.byteLength);
      }
      function Uh(f) {
        var y = new f.constructor(f.source, so.exec(f));
        return y.lastIndex = f.lastIndex, y;
      }
      function Kh(f) {
        return Ka ? Gr(Ka.call(f)) : {};
      }
      function Sd(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.length);
      }
      function $d(f, y) {
        if (f !== y) {
          var w = f !== l, Y = f === null, dt = f === f, Wt = Wi(f), sn = y !== l, cn = y === null, pn = y === y, En = Wi(y);
          if (!cn && !En && !Wt && f > y || Wt && sn && pn && !cn && !En || Y && sn && pn || !w && pn || !dt)
            return 1;
          if (!Y && !Wt && !En && f < y || En && w && dt && !Y && !Wt || cn && w && dt || !sn && dt || !pn)
            return -1;
        }
        return 0;
      }
      function Wh(f, y, w) {
        for (var Y = -1, dt = f.criteria, Wt = y.criteria, sn = dt.length, cn = w.length; ++Y < sn; ) {
          var pn = $d(dt[Y], Wt[Y]);
          if (pn) {
            if (Y >= cn)
              return pn;
            var En = w[Y];
            return pn * (En == "desc" ? -1 : 1);
          }
        }
        return f.index - y.index;
      }
      function wd(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = w.length, cn = -1, pn = y.length, En = ri(Wt - sn, 0), In = xn(pn + En), Dn = !Y; ++cn < pn; )
          In[cn] = y[cn];
        for (; ++dt < sn; )
          (Dn || dt < Wt) && (In[w[dt]] = f[dt]);
        for (; En--; )
          In[cn++] = f[dt++];
        return In;
      }
      function _d(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = -1, cn = w.length, pn = -1, En = y.length, In = ri(Wt - cn, 0), Dn = xn(In + En), qn = !Y; ++dt < In; )
          Dn[dt] = f[dt];
        for (var nr = dt; ++pn < En; )
          Dn[nr + pn] = y[pn];
        for (; ++sn < cn; )
          (qn || dt < Wt) && (Dn[nr + w[sn]] = f[dt++]);
        return Dn;
      }
      function Vi(f, y) {
        var w = -1, Y = f.length;
        for (y || (y = xn(Y)); ++w < Y; )
          y[w] = f[w];
        return y;
      }
      function Ps(f, y, w, Y) {
        var dt = !w;
        w || (w = {});
        for (var Wt = -1, sn = y.length; ++Wt < sn; ) {
          var cn = y[Wt], pn = Y ? Y(w[cn], f[cn], cn, w, f) : l;
          pn === l && (pn = f[cn]), dt ? Ns(w, cn, pn) : Wa(w, cn, pn);
        }
        return w;
      }
      function Gh(f, y) {
        return Ps(f, Fu(f), y);
      }
      function qh(f, y) {
        return Ps(f, Md(f), y);
      }
      function Oo(f, y) {
        return function(w, Y) {
          var dt = pr(w) ? Kf : gh, Wt = y ? y() : {};
          return dt(w, f, or(Y, 2), Wt);
        };
      }
      function Ta(f) {
        return vr(function(y, w) {
          var Y = -1, dt = w.length, Wt = dt > 1 ? w[dt - 1] : l, sn = dt > 2 ? w[2] : l;
          for (Wt = f.length > 3 && typeof Wt == "function" ? (dt--, Wt) : l, sn && Ni(w[0], w[1], sn) && (Wt = dt < 3 ? l : Wt, dt = 1), y = Gr(y); ++Y < dt; ) {
            var cn = w[Y];
            cn && f(y, cn, Y, Wt);
          }
          return y;
        });
      }
      function Ed(f, y) {
        return function(w, Y) {
          if (w == null)
            return w;
          if (!Bi(w))
            return f(w, Y);
          for (var dt = w.length, Wt = y ? dt : -1, sn = Gr(w); (y ? Wt-- : ++Wt < dt) && Y(sn[Wt], Wt, sn) !== !1; )
            ;
          return w;
        };
      }
      function Pd(f) {
        return function(y, w, Y) {
          for (var dt = -1, Wt = Gr(y), sn = Y(y), cn = sn.length; cn--; ) {
            var pn = sn[f ? cn : ++dt];
            if (w(Wt[pn], pn, Wt) === !1)
              break;
          }
          return y;
        };
      }
      function Yh(f, y, w) {
        var Y = y & Q, dt = eo(f);
        function Wt() {
          var sn = this && this !== di && this instanceof Wt ? dt : f;
          return sn.apply(Y ? w : this, arguments);
        }
        return Wt;
      }
      function Td(f) {
        return function(y) {
          y = Vr(y);
          var w = ba(y) ? Cs(y) : l, Y = w ? w[0] : y.charAt(0), dt = w ? qs(w, 1).join("") : y.slice(1);
          return Y[f]() + dt;
        };
      }
      function Ia(f) {
        return function(y) {
          return Yl(Pf(Ef(y).replace(Kr, "")), f, "");
        };
      }
      function eo(f) {
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return new f();
            case 1:
              return new f(y[0]);
            case 2:
              return new f(y[0], y[1]);
            case 3:
              return new f(y[0], y[1], y[2]);
            case 4:
              return new f(y[0], y[1], y[2], y[3]);
            case 5:
              return new f(y[0], y[1], y[2], y[3], y[4]);
            case 6:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5]);
            case 7:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5], y[6]);
          }
          var w = Pa(f.prototype), Y = f.apply(w, y);
          return Xr(Y) ? Y : w;
        };
      }
      function Xh(f, y, w) {
        var Y = eo(f);
        function dt() {
          for (var Wt = arguments.length, sn = xn(Wt), cn = Wt, pn = ka(dt); cn--; )
            sn[cn] = arguments[cn];
          var En = Wt < 3 && sn[0] !== pn && sn[Wt - 1] !== pn ? [] : Hs(sn, pn);
          if (Wt -= En.length, Wt < w)
            return Fd(
              f,
              y,
              Lo,
              dt.placeholder,
              l,
              sn,
              En,
              l,
              l,
              w - Wt
            );
          var In = this && this !== di && this instanceof dt ? Y : f;
          return Hi(In, this, sn);
        }
        return dt;
      }
      function Id(f) {
        return function(y, w, Y) {
          var dt = Gr(y);
          if (!Bi(y)) {
            var Wt = or(w, 3);
            y = oi(y), w = function(cn) {
              return Wt(dt[cn], cn, dt);
            };
          }
          var sn = f(y, w, Y);
          return sn > -1 ? dt[Wt ? y[sn] : sn] : l;
        };
      }
      function kd(f) {
        return Ds(function(y) {
          var w = y.length, Y = w, dt = Ji.prototype.thru;
          for (f && y.reverse(); Y--; ) {
            var Wt = y[Y];
            if (typeof Wt != "function")
              throw new Zi(g);
            if (dt && !sn && Jo(Wt) == "wrapper")
              var sn = new Ji([], !0);
          }
          for (Y = sn ? Y : w; ++Y < w; ) {
            Wt = y[Y];
            var cn = Jo(Wt), pn = cn == "wrapper" ? Au(Wt) : l;
            pn && Ru(pn[0]) && pn[1] == (Re | te | ve | wt) && !pn[4].length && pn[9] == 1 ? sn = sn[Jo(pn[0])].apply(sn, pn[3]) : sn = Wt.length == 1 && Ru(Wt) ? sn[cn]() : sn.thru(Wt);
          }
          return function() {
            var En = arguments, In = En[0];
            if (sn && En.length == 1 && pr(In))
              return sn.plant(In).value();
            for (var Dn = 0, qn = w ? y[Dn].apply(this, En) : In; ++Dn < w; )
              qn = y[Dn].call(this, qn);
            return qn;
          };
        });
      }
      function Lo(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & Re, Dn = y & Q, qn = y & W, nr = y & (te | K), lr = y & yt, gr = qn ? l : eo(f);
        function ur() {
          for (var $r = arguments.length, Ir = xn($r), Gi = $r; Gi--; )
            Ir[Gi] = arguments[Gi];
          if (nr)
            var Fi = ka(ur), qi = ep(Ir, Fi);
          if (Y && (Ir = wd(Ir, Y, dt, nr)), Wt && (Ir = _d(Ir, Wt, sn, nr)), $r -= qi, nr && $r < En) {
            var ti = Hs(Ir, Fi);
            return Fd(
              f,
              y,
              Lo,
              ur.placeholder,
              w,
              Ir,
              ti,
              cn,
              pn,
              En - $r
            );
          }
          var ws = Dn ? w : this, Ms = qn ? ws[f] : f;
          return $r = Ir.length, cn ? Ir = gm(Ir, cn) : lr && $r > 1 && Ir.reverse(), In && pn < $r && (Ir.length = pn), this && this !== di && this instanceof ur && (Ms = gr || eo(Ms)), Ms.apply(ws, Ir);
        }
        return ur;
      }
      function Ad(f, y) {
        return function(w, Y) {
          return wh(w, f, y(Y), {});
        };
      }
      function Mo(f, y) {
        return function(w, Y) {
          var dt;
          if (w === l && Y === l)
            return y;
          if (w !== l && (dt = w), Y !== l) {
            if (dt === l)
              return Y;
            typeof w == "string" || typeof Y == "string" ? (w = Ki(w), Y = Ki(Y)) : (w = gd(w), Y = gd(Y)), dt = f(w, Y);
          }
          return dt;
        };
      }
      function Eu(f) {
        return Ds(function(y) {
          return y = qr(y, Ui(or())), vr(function(w) {
            var Y = this;
            return f(y, function(dt) {
              return Hi(dt, Y, w);
            });
          });
        });
      }
      function Bo(f, y) {
        y = y === l ? " " : Ki(y);
        var w = y.length;
        if (w < 2)
          return w ? vu(y, f) : y;
        var Y = vu(y, So(f / Ca(y)));
        return ba(y) ? qs(Cs(Y), 0, f).join("") : Y.slice(0, f);
      }
      function Zh(f, y, w, Y) {
        var dt = y & Q, Wt = eo(f);
        function sn() {
          for (var cn = -1, pn = arguments.length, En = -1, In = Y.length, Dn = xn(In + pn), qn = this && this !== di && this instanceof sn ? Wt : f; ++En < In; )
            Dn[En] = Y[En];
          for (; pn--; )
            Dn[En++] = arguments[++cn];
          return Hi(qn, dt ? w : this, Dn);
        }
        return sn;
      }
      function Nd(f) {
        return function(y, w, Y) {
          return Y && typeof Y != "number" && Ni(y, w, Y) && (w = Y = l), y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), Y = Y === l ? y < w ? 1 : -1 : Ls(Y), Oh(y, w, Y, f);
        };
      }
      function Zo(f) {
        return function(y, w) {
          return typeof y == "string" && typeof w == "string" || (y = xs(y), w = xs(w)), f(y, w);
        };
      }
      function Fd(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & te, Dn = In ? sn : l, qn = In ? l : sn, nr = In ? Wt : l, lr = In ? l : Wt;
        y |= In ? ve : ee, y &= ~(In ? ee : ve), y & ue || (y &= ~(Q | W));
        var gr = [
          f,
          y,
          dt,
          nr,
          Dn,
          lr,
          qn,
          cn,
          pn,
          En
        ], ur = w.apply(l, gr);
        return Ru(f) && Kd(ur, gr), ur.placeholder = Y, Wd(ur, f, y);
      }
      function Pu(f) {
        var y = ni[f];
        return function(w, Y) {
          if (w = xs(w), Y = Y == null ? 0 : wi(hr(Y), 292), Y && Kc(w)) {
            var dt = (Vr(w) + "e").split("e"), Wt = y(dt[0] + "e" + (+dt[1] + Y));
            return dt = (Vr(Wt) + "e").split("e"), +(dt[0] + "e" + (+dt[1] - Y));
          }
          return y(w);
        };
      }
      var Jh = wa && 1 / fo(new wa([, -0]))[1] == nn ? function(f) {
        return new wa(f);
      } : ac;
      function Dd(f) {
        return function(y) {
          var w = Ei(y);
          return w == kn ? nu(y) : w == Bn ? op(y) : Qf(y, f(y));
        };
      }
      function Fs(f, y, w, Y, dt, Wt, sn, cn) {
        var pn = y & W;
        if (!pn && typeof f != "function")
          throw new Zi(g);
        var En = Y ? Y.length : 0;
        if (En || (y &= ~(ve | ee), Y = dt = l), sn = sn === l ? sn : ri(hr(sn), 0), cn = cn === l ? cn : hr(cn), En -= dt ? dt.length : 0, y & ee) {
          var In = Y, Dn = dt;
          Y = dt = l;
        }
        var qn = pn ? l : Au(f), nr = [
          f,
          y,
          w,
          Y,
          dt,
          In,
          Dn,
          Wt,
          sn,
          cn
        ];
        if (qn && pm(nr, qn), f = nr[0], y = nr[1], w = nr[2], Y = nr[3], dt = nr[4], cn = nr[9] = nr[9] === l ? pn ? 0 : f.length : ri(nr[9] - En, 0), !cn && y & (te | K) && (y &= ~(te | K)), !y || y == Q)
          var lr = Yh(f, y, w);
        else
          y == te || y == K ? lr = Xh(f, y, cn) : (y == ve || y == (Q | ve)) && !dt.length ? lr = Zh(f, y, w, Y) : lr = Lo.apply(l, nr);
        var gr = qn ? pd : Kd;
        return Wd(gr(lr, nr), f, y);
      }
      function Rd(f, y, w, Y) {
        return f === l || $s(f, $a[w]) && !zr.call(Y, w) ? y : f;
      }
      function Od(f, y, w, Y, dt, Wt) {
        return Xr(f) && Xr(y) && (Wt.set(y, f), No(f, y, l, Od, Wt), Wt.delete(y)), f;
      }
      function Qh(f) {
        return ro(f) ? l : f;
      }
      function Ld(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = f.length, pn = y.length;
        if (cn != pn && !(sn && pn > cn))
          return !1;
        var En = Wt.get(f), In = Wt.get(y);
        if (En && In)
          return En == y && In == f;
        var Dn = -1, qn = !0, nr = w & z ? new da() : l;
        for (Wt.set(f, y), Wt.set(y, f); ++Dn < cn; ) {
          var lr = f[Dn], gr = y[Dn];
          if (Y)
            var ur = sn ? Y(gr, lr, Dn, y, f, Wt) : Y(lr, gr, Dn, f, y, Wt);
          if (ur !== l) {
            if (ur)
              continue;
            qn = !1;
            break;
          }
          if (nr) {
            if (!Xl(y, function($r, Ir) {
              if (!Va(nr, Ir) && (lr === $r || dt(lr, $r, w, Y, Wt)))
                return nr.push(Ir);
            })) {
              qn = !1;
              break;
            }
          } else if (!(lr === gr || dt(lr, gr, w, Y, Wt))) {
            qn = !1;
            break;
          }
        }
        return Wt.delete(f), Wt.delete(y), qn;
      }
      function em(f, y, w, Y, dt, Wt, sn) {
        switch (w) {
          case hn:
            if (f.byteLength != y.byteLength || f.byteOffset != y.byteOffset)
              return !1;
            f = f.buffer, y = y.buffer;
          case Rn:
            return !(f.byteLength != y.byteLength || !Wt(new vo(f), new vo(y)));
          case _n:
          case Nn:
          case Yn:
            return $s(+f, +y);
          case Xn:
            return f.name == y.name && f.message == y.message;
          case Kn:
          case Fn:
            return f == y + "";
          case kn:
            var cn = nu;
          case Bn:
            var pn = Y & O;
            if (cn || (cn = fo), f.size != y.size && !pn)
              return !1;
            var En = sn.get(f);
            if (En)
              return En == y;
            Y |= z, sn.set(f, y);
            var In = Ld(cn(f), cn(y), Y, dt, Wt, sn);
            return sn.delete(f), In;
          case Gn:
            if (Ka)
              return Ka.call(f) == Ka.call(y);
        }
        return !1;
      }
      function tm(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = Tu(f), pn = cn.length, En = Tu(y), In = En.length;
        if (pn != In && !sn)
          return !1;
        for (var Dn = pn; Dn--; ) {
          var qn = cn[Dn];
          if (!(sn ? qn in y : zr.call(y, qn)))
            return !1;
        }
        var nr = Wt.get(f), lr = Wt.get(y);
        if (nr && lr)
          return nr == y && lr == f;
        var gr = !0;
        Wt.set(f, y), Wt.set(y, f);
        for (var ur = sn; ++Dn < pn; ) {
          qn = cn[Dn];
          var $r = f[qn], Ir = y[qn];
          if (Y)
            var Gi = sn ? Y(Ir, $r, qn, y, f, Wt) : Y($r, Ir, qn, f, y, Wt);
          if (!(Gi === l ? $r === Ir || dt($r, Ir, w, Y, Wt) : Gi)) {
            gr = !1;
            break;
          }
          ur || (ur = qn == "constructor");
        }
        if (gr && !ur) {
          var Fi = f.constructor, qi = y.constructor;
          Fi != qi && "constructor" in f && "constructor" in y && !(typeof Fi == "function" && Fi instanceof Fi && typeof qi == "function" && qi instanceof qi) && (gr = !1);
        }
        return Wt.delete(f), Wt.delete(y), gr;
      }
      function Ds(f) {
        return Lu(Hd(f, l, Jd), f + "");
      }
      function Tu(f) {
        return nd(f, oi, Fu);
      }
      function Iu(f) {
        return nd(f, zi, Md);
      }
      var Au = _o ? function(f) {
        return _o.get(f);
      } : ac;
      function Jo(f) {
        for (var y = f.name + "", w = Ea[y], Y = zr.call(Ea, y) ? w.length : 0; Y--; ) {
          var dt = w[Y], Wt = dt.func;
          if (Wt == null || Wt == f)
            return dt.name;
        }
        return y;
      }
      function ka(f) {
        var y = zr.call(Ft, "placeholder") ? Ft : f;
        return y.placeholder;
      }
      function or() {
        var f = Ft.iteratee || ic;
        return f = f === ic ? sd : f, arguments.length ? f(arguments[0], arguments[1]) : f;
      }
      function el(f, y) {
        var w = f.__data__;
        return um(y) ? w[typeof y == "string" ? "string" : "hash"] : w.map;
      }
      function Nu(f) {
        for (var y = oi(f), w = y.length; w--; ) {
          var Y = y[w], dt = f[Y];
          y[w] = [Y, dt, zd(dt)];
        }
        return y;
      }
      function ha(f, y) {
        var w = ip(f, y);
        return id(w) ? w : l;
      }
      function nm(f) {
        var y = zr.call(f, sa), w = f[sa];
        try {
          f[sa] = l;
          var Y = !0;
        } catch {
        }
        var dt = go.call(f);
        return Y && (y ? f[sa] = w : delete f[sa]), dt;
      }
      var Fu = iu ? function(f) {
        return f == null ? [] : (f = Gr(f), Bs(iu(f), function(y) {
          return Hc.call(f, y);
        }));
      } : oc, Md = iu ? function(f) {
        for (var y = []; f; )
          zs(y, Fu(f)), f = xo(f);
        return y;
      } : oc, Ei = Ai;
      (su && Ei(new su(new ArrayBuffer(1))) != hn || za && Ei(new za()) != kn || au && Ei(au.resolve()) != bn || wa && Ei(new wa()) != Bn || ja && Ei(new ja()) != Mn) && (Ei = function(f) {
        var y = Ai(f), w = y == er ? f.constructor : l, Y = w ? ma(w) : "";
        if (Y)
          switch (Y) {
            case Fp:
              return hn;
            case Dp:
              return kn;
            case Rp:
              return bn;
            case Op:
              return Bn;
            case Lp:
              return Mn;
          }
        return y;
      });
      function rm(f, y, w) {
        for (var Y = -1, dt = w.length; ++Y < dt; ) {
          var Wt = w[Y], sn = Wt.size;
          switch (Wt.type) {
            case "drop":
              f += sn;
              break;
            case "dropRight":
              y -= sn;
              break;
            case "take":
              y = wi(y, f + sn);
              break;
            case "takeRight":
              f = ri(f, y - sn);
              break;
          }
        }
        return { start: f, end: y };
      }
      function im(f) {
        var y = f.match(Is);
        return y ? y[1].split(Fa) : [];
      }
      function Vd(f, y, w) {
        y = Gs(y, f);
        for (var Y = -1, dt = y.length, Wt = !1; ++Y < dt; ) {
          var sn = Ts(y[Y]);
          if (!(Wt = f != null && w(f, sn)))
            break;
          f = f[sn];
        }
        return Wt || ++Y != dt ? Wt : (dt = f == null ? 0 : f.length, !!dt && Pl(dt) && Rs(sn, dt) && (pr(f) || ga(f)));
      }
      function sm(f) {
        var y = f.length, w = new f.constructor(y);
        return y && typeof f[0] == "string" && zr.call(f, "index") && (w.index = f.index, w.input = f.input), w;
      }
      function Bd(f) {
        return typeof f.constructor == "function" && !to(f) ? Pa(xo(f)) : {};
      }
      function am(f, y, w) {
        var Y = f.constructor;
        switch (y) {
          case Rn:
            return _u(f);
          case _n:
          case Nn:
            return new Y(+f);
          case hn:
            return Hh(f, w);
          case Qn:
          case rr:
          case tr:
          case Cr:
          case Fr:
          case An:
          case Hn:
          case ir:
          case dr:
            return Sd(f, w);
          case kn:
            return new Y();
          case Yn:
          case Fn:
            return new Y(f);
          case Kn:
            return Uh(f);
          case Bn:
            return new Y();
          case Gn:
            return Kh(f);
        }
      }
      function om(f, y) {
        var w = y.length;
        if (!w)
          return f;
        var Y = w - 1;
        return y[Y] = (w > 1 ? "& " : "") + y[Y], y = y.join(w > 2 ? ", " : " "), f.replace(_s, `{
/* [wrapped with ` + y + `] */
`);
      }
      function lm(f) {
        return pr(f) || ga(f) || !!(Uc && f && f[Uc]);
      }
      function Rs(f, y) {
        var w = typeof f;
        return y = y ?? vt, !!y && (w == "number" || w != "symbol" && Ma.test(f)) && f > -1 && f % 1 == 0 && f < y;
      }
      function Ni(f, y, w) {
        if (!Xr(w))
          return !1;
        var Y = typeof y;
        return (Y == "number" ? Bi(w) && Rs(y, w.length) : Y == "string" && y in w) ? $s(w[y], f) : !1;
      }
      function Du(f, y) {
        if (pr(f))
          return !1;
        var w = typeof f;
        return w == "number" || w == "symbol" || w == "boolean" || f == null || Wi(f) ? !0 : Mi.test(f) || !Ti.test(f) || y != null && f in Gr(y);
      }
      function um(f) {
        var y = typeof f;
        return y == "string" || y == "number" || y == "symbol" || y == "boolean" ? f !== "__proto__" : f === null;
      }
      function Ru(f) {
        var y = Jo(f), w = Ft[y];
        if (typeof w != "function" || !(y in Pr.prototype))
          return !1;
        if (f === w)
          return !0;
        var Y = Au(w);
        return !!Y && f === Y[0];
      }
      function cm(f) {
        return !!Bc && Bc in f;
      }
      var dm = ho ? Os : lc;
      function to(f) {
        var y = f && f.constructor, w = typeof y == "function" && y.prototype || $a;
        return f === w;
      }
      function zd(f) {
        return f === f && !Xr(f);
      }
      function jd(f, y) {
        return function(w) {
          return w == null ? !1 : w[f] === y && (y !== l || f in Gr(w));
        };
      }
      function fm(f) {
        var y = $l(f, function(Y) {
          return w.size === S && w.clear(), Y;
        }), w = y.cache;
        return y;
      }
      function pm(f, y) {
        var w = f[1], Y = y[1], dt = w | Y, Wt = dt < (Q | W | Re), sn = Y == Re && w == te || Y == Re && w == wt && f[7].length <= y[8] || Y == (Re | wt) && y[7].length <= y[8] && w == te;
        if (!(Wt || sn))
          return f;
        Y & Q && (f[2] = y[2], dt |= w & Q ? 0 : ue);
        var cn = y[3];
        if (cn) {
          var pn = f[3];
          f[3] = pn ? wd(pn, cn, y[4]) : cn, f[4] = pn ? Hs(f[3], E) : y[4];
        }
        return cn = y[5], cn && (pn = f[5], f[5] = pn ? _d(pn, cn, y[6]) : cn, f[6] = pn ? Hs(f[5], E) : y[6]), cn = y[7], cn && (f[7] = cn), Y & Re && (f[8] = f[8] == null ? y[8] : wi(f[8], y[8])), f[9] == null && (f[9] = y[9]), f[0] = y[0], f[1] = dt, f;
      }
      function hm(f) {
        var y = [];
        if (f != null)
          for (var w in Gr(f))
            y.push(w);
        return y;
      }
      function mm(f) {
        return go.call(f);
      }
      function Hd(f, y, w) {
        return y = ri(y === l ? f.length - 1 : y, 0), function() {
          for (var Y = arguments, dt = -1, Wt = ri(Y.length - y, 0), sn = xn(Wt); ++dt < Wt; )
            sn[dt] = Y[y + dt];
          dt = -1;
          for (var cn = xn(y + 1); ++dt < y; )
            cn[dt] = Y[dt];
          return cn[y] = w(sn), Hi(f, this, cn);
        };
      }
      function Ud(f, y) {
        return y.length < 2 ? f : pa(f, ms(y, 0, -1));
      }
      function gm(f, y) {
        for (var w = f.length, Y = wi(y.length, w), dt = Vi(f); Y--; ) {
          var Wt = y[Y];
          f[Y] = Rs(Wt, w) ? dt[Wt] : l;
        }
        return f;
      }
      function Ou(f, y) {
        if (!(y === "constructor" && typeof f[y] == "function") && y != "__proto__")
          return f[y];
      }
      var Kd = Gd(pd), no = _p || function(f, y) {
        return di.setTimeout(f, y);
      }, Lu = Gd(Vh);
      function Wd(f, y, w) {
        var Y = y + "";
        return Lu(f, om(Y, ym(im(Y), w)));
      }
      function Gd(f) {
        var y = 0, w = 0;
        return function() {
          var Y = Ip(), dt = ln - (Y - w);
          if (w = Y, dt > 0) {
            if (++y >= tn)
              return arguments[0];
          } else
            y = 0;
          return f.apply(l, arguments);
        };
      }
      function xl(f, y) {
        var w = -1, Y = f.length, dt = Y - 1;
        for (y = y === l ? Y : y; ++w < y; ) {
          var Wt = yu(w, dt), sn = f[Wt];
          f[Wt] = f[w], f[w] = sn;
        }
        return f.length = y, f;
      }
      var qd = fm(function(f) {
        var y = [];
        return f.charCodeAt(0) === 46 && y.push(""), f.replace(ui, function(w, Y, dt, Wt) {
          y.push(dt ? Wt.replace(oo, "$1") : Y || w);
        }), y;
      });
      function Ts(f) {
        if (typeof f == "string" || Wi(f))
          return f;
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function ma(f) {
        if (f != null) {
          try {
            return mo.call(f);
          } catch {
          }
          try {
            return f + "";
          } catch {
          }
        }
        return "";
      }
      function ym(f, y) {
        return Xi(yn, function(w) {
          var Y = "_." + w[0];
          y & w[1] && !uo(f, Y) && f.push(Y);
        }), f.sort();
      }
      function Yd(f) {
        if (f instanceof Pr)
          return f.clone();
        var y = new Ji(f.__wrapped__, f.__chain__);
        return y.__actions__ = Vi(f.__actions__), y.__index__ = f.__index__, y.__values__ = f.__values__, y;
      }
      function vm(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = ri(hr(y), 0);
        var Y = f == null ? 0 : f.length;
        if (!Y || y < 1)
          return [];
        for (var dt = 0, Wt = 0, sn = xn(So(Y / y)); dt < Y; )
          sn[Wt++] = ms(f, dt, dt += y);
        return sn;
      }
      function xm(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = 0, dt = []; ++y < w; ) {
          var Wt = f[y];
          Wt && (dt[Y++] = Wt);
        }
        return dt;
      }
      function bm() {
        var f = arguments.length;
        if (!f)
          return [];
        for (var y = xn(f - 1), w = arguments[0], Y = f; Y--; )
          y[Y - 1] = arguments[Y];
        return zs(pr(w) ? Vi(w) : [w], $i(y, 1));
      }
      var Cm = vr(function(f, y) {
        return ei(f) ? Ga(f, $i(y, 1, ei, !0)) : [];
      }), Sm = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), or(w, 2)) : [];
      }), $m = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), l, w) : [];
      });
      function wm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function _m(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function Em(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0, !0) : [];
      }
      function Pm(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0) : [];
      }
      function Tm(f, y, w, Y) {
        var dt = f == null ? 0 : f.length;
        return dt ? (w && typeof w != "number" && Ni(f, y, w) && (w = 0, Y = dt), bh(f, y, w, Y)) : [];
      }
      function Xd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), co(f, or(y, 3), dt);
      }
      function Zd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y - 1;
        return w !== l && (dt = hr(w), dt = w < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), co(f, or(y, 3), dt, !0);
      }
      function Jd(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, 1) : [];
      }
      function Im(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, nn) : [];
      }
      function km(f, y) {
        var w = f == null ? 0 : f.length;
        return w ? (y = y === l ? 1 : hr(y), $i(f, y)) : [];
      }
      function Am(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = {}; ++y < w; ) {
          var dt = f[y];
          Y[dt[0]] = dt[1];
        }
        return Y;
      }
      function Qd(f) {
        return f && f.length ? f[0] : l;
      }
      function Nm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), xa(f, y, dt);
      }
      function Fm(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 0, -1) : [];
      }
      var Dm = vr(function(f) {
        var y = qr(f, Su);
        return y.length && y[0] === f[0] ? fu(y) : [];
      }), Rm = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y === ys(w) ? y = l : w.pop(), w.length && w[0] === f[0] ? fu(w, or(y, 2)) : [];
      }), Om = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y = typeof y == "function" ? y : l, y && w.pop(), w.length && w[0] === f[0] ? fu(w, l, y) : [];
      });
      function Lm(f, y) {
        return f == null ? "" : Pp.call(f, y);
      }
      function ys(f) {
        var y = f == null ? 0 : f.length;
        return y ? f[y - 1] : l;
      }
      function Mm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y;
        return w !== l && (dt = hr(w), dt = dt < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), y === y ? up(f, y, dt) : co(f, Nc, dt, !0);
      }
      function Vm(f, y) {
        return f && f.length ? ud(f, hr(y)) : l;
      }
      var Bm = vr(ef);
      function ef(f, y) {
        return f && f.length && y && y.length ? gu(f, y) : f;
      }
      function zm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, or(w, 2)) : f;
      }
      function jm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, l, w) : f;
      }
      var Hm = Ds(function(f, y) {
        var w = f == null ? 0 : f.length, Y = lu(f, y);
        return fd(f, qr(y, function(dt) {
          return Rs(dt, w) ? +dt : dt;
        }).sort($d)), Y;
      });
      function Um(f, y) {
        var w = [];
        if (!(f && f.length))
          return w;
        var Y = -1, dt = [], Wt = f.length;
        for (y = or(y, 3); ++Y < Wt; ) {
          var sn = f[Y];
          y(sn, Y, f) && (w.push(sn), dt.push(Y));
        }
        return fd(f, dt), w;
      }
      function Mu(f) {
        return f == null ? f : Np.call(f);
      }
      function Km(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (w && typeof w != "number" && Ni(f, y, w) ? (y = 0, w = Y) : (y = y == null ? 0 : hr(y), w = w === l ? Y : hr(w)), ms(f, y, w)) : [];
      }
      function Wm(f, y) {
        return Do(f, y);
      }
      function Gm(f, y, w) {
        return xu(f, y, or(w, 2));
      }
      function qm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y);
          if (Y < w && $s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Ym(f, y) {
        return Do(f, y, !0);
      }
      function Xm(f, y, w) {
        return xu(f, y, or(w, 2), !0);
      }
      function Zm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y, !0) - 1;
          if ($s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Jm(f) {
        return f && f.length ? hd(f) : [];
      }
      function Qm(f, y) {
        return f && f.length ? hd(f, or(y, 2)) : [];
      }
      function eg(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 1, y) : [];
      }
      function tg(f, y, w) {
        return f && f.length ? (y = w || y === l ? 1 : hr(y), ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function ng(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function rg(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !1, !0) : [];
      }
      function ig(f, y) {
        return f && f.length ? Ro(f, or(y, 3)) : [];
      }
      var ag = vr(function(f) {
        return Ws($i(f, 1, ei, !0));
      }), og = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Ws($i(f, 1, ei, !0), or(y, 2));
      }), lg = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Ws($i(f, 1, ei, !0), l, y);
      });
      function ug(f) {
        return f && f.length ? Ws(f) : [];
      }
      function cg(f, y) {
        return f && f.length ? Ws(f, or(y, 2)) : [];
      }
      function ey(f, y) {
        return y = typeof y == "function" ? y : l, f && f.length ? Ws(f, l, y) : [];
      }
      function Bu(f) {
        if (!(f && f.length))
          return [];
        var y = 0;
        return f = Bs(f, function(w) {
          if (ei(w))
            return y = ri(w.length, y), !0;
        }), eu(y, function(w) {
          return qr(f, Zl(w));
        });
      }
      function tf(f, y) {
        if (!(f && f.length))
          return [];
        var w = Bu(f);
        return y == null ? w : qr(w, function(Y) {
          return Hi(y, l, Y);
        });
      }
      var ty = vr(function(f, y) {
        return ei(f) ? Ga(f, y) : [];
      }), ny = vr(function(f) {
        return Cu(Bs(f, ei));
      }), ry = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Cu(Bs(f, ei), or(y, 2));
      }), iy = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Cu(Bs(f, ei), l, y);
      }), sy = vr(Bu);
      function ay(f, y) {
        return xd(f || [], y || [], Wa);
      }
      function oy(f, y) {
        return xd(f || [], y || [], Xa);
      }
      var ly = vr(function(f) {
        var y = f.length, w = y > 1 ? f[y - 1] : l;
        return w = typeof w == "function" ? (f.pop(), w) : l, tf(f, w);
      });
      function nf(f) {
        var y = Ft(f);
        return y.__chain__ = !0, y;
      }
      function uy(f, y) {
        return y(f), f;
      }
      function bl(f, y) {
        return y(f);
      }
      var cy = Ds(function(f) {
        var y = f.length, w = y ? f[0] : 0, Y = this.__wrapped__, dt = function(Wt) {
          return lu(Wt, f);
        };
        return y > 1 || this.__actions__.length || !(Y instanceof Pr) || !Rs(w) ? this.thru(dt) : (Y = Y.slice(w, +w + (y ? 1 : 0)), Y.__actions__.push({
          func: bl,
          args: [dt],
          thisArg: l
        }), new Ji(Y, this.__chain__).thru(function(Wt) {
          return y && !Wt.length && Wt.push(l), Wt;
        }));
      });
      function dy() {
        return nf(this);
      }
      function fy() {
        return new Ji(this.value(), this.__chain__);
      }
      function py() {
        this.__values__ === l && (this.__values__ = yf(this.value()));
        var f = this.__index__ >= this.__values__.length, y = f ? l : this.__values__[this.__index__++];
        return { done: f, value: y };
      }
      function hy() {
        return this;
      }
      function my(f) {
        for (var y, w = this; w instanceof Po; ) {
          var Y = Yd(w);
          Y.__index__ = 0, Y.__values__ = l, y ? dt.__wrapped__ = Y : y = Y;
          var dt = Y;
          w = w.__wrapped__;
        }
        return dt.__wrapped__ = f, y;
      }
      function gy() {
        var f = this.__wrapped__;
        if (f instanceof Pr) {
          var y = f;
          return this.__actions__.length && (y = new Pr(this)), y = y.reverse(), y.__actions__.push({
            func: bl,
            args: [Mu],
            thisArg: l
          }), new Ji(y, this.__chain__);
        }
        return this.thru(Mu);
      }
      function yy() {
        return vd(this.__wrapped__, this.__actions__);
      }
      var vy = Oo(function(f, y, w) {
        zr.call(f, w) ? ++f[w] : Ns(f, w, 1);
      });
      function xy(f, y, w) {
        var Y = pr(f) ? kc : xh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      function by(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, or(y, 3));
      }
      var Cy = Id(Xd), Sy = Id(Zd);
      function $y(f, y) {
        return $i(Cl(f, y), 1);
      }
      function wy(f, y) {
        return $i(Cl(f, y), nn);
      }
      function _y(f, y, w) {
        return w = w === l ? 1 : hr(w), $i(Cl(f, y), w);
      }
      function rf(f, y) {
        var w = pr(f) ? Xi : Ks;
        return w(f, or(y, 3));
      }
      function sf(f, y) {
        var w = pr(f) ? Wf : Qc;
        return w(f, or(y, 3));
      }
      var Ey = Oo(function(f, y, w) {
        zr.call(f, w) ? f[w].push(y) : Ns(f, w, [y]);
      });
      function Py(f, y, w, Y) {
        f = Bi(f) ? f : Na(f), w = w && !Y ? hr(w) : 0;
        var dt = f.length;
        return w < 0 && (w = ri(dt + w, 0)), Tl(f) ? w <= dt && f.indexOf(y, w) > -1 : !!dt && xa(f, y, w) > -1;
      }
      var Ty = vr(function(f, y, w) {
        var Y = -1, dt = typeof y == "function", Wt = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(sn) {
          Wt[++Y] = dt ? Hi(y, sn, w) : qa(sn, y, w);
        }), Wt;
      }), Iy = Oo(function(f, y, w) {
        Ns(f, w, y);
      });
      function Cl(f, y) {
        var w = pr(f) ? qr : ad;
        return w(f, or(y, 3));
      }
      function ky(f, y, w, Y) {
        return f == null ? [] : (pr(y) || (y = y == null ? [] : [y]), w = Y ? l : w, pr(w) || (w = w == null ? [] : [w]), cd(f, y, w));
      }
      var Ay = Oo(function(f, y, w) {
        f[w ? 0 : 1].push(y);
      }, function() {
        return [[], []];
      });
      function Ny(f, y, w) {
        var Y = pr(f) ? Yl : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Ks);
      }
      function Fy(f, y, w) {
        var Y = pr(f) ? Gf : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Qc);
      }
      function Dy(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, El(or(y, 3)));
      }
      function Ry(f) {
        var y = pr(f) ? Yc : Lh;
        return y(f);
      }
      function Oy(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y);
        var Y = pr(f) ? hh : Mh;
        return Y(f, y);
      }
      function Ly(f) {
        var y = pr(f) ? mh : Bh;
        return y(f);
      }
      function My(f) {
        if (f == null)
          return 0;
        if (Bi(f))
          return Tl(f) ? Ca(f) : f.length;
        var y = Ei(f);
        return y == kn || y == Bn ? f.size : hu(f).length;
      }
      function Vy(f, y, w) {
        var Y = pr(f) ? Xl : zh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      var By = vr(function(f, y) {
        if (f == null)
          return [];
        var w = y.length;
        return w > 1 && Ni(f, y[0], y[1]) ? y = [] : w > 2 && Ni(y[0], y[1], y[2]) && (y = [y[0]]), cd(f, $i(y, 1), []);
      }), Sl = wp || function() {
        return di.Date.now();
      };
      function zy(f, y) {
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          if (--f < 1)
            return y.apply(this, arguments);
        };
      }
      function af(f, y, w) {
        return y = w ? l : y, y = f && y == null ? f.length : y, Fs(f, Re, l, l, l, l, y);
      }
      function of(f, y) {
        var w;
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          return --f > 0 && (w = y.apply(this, arguments)), f <= 1 && (y = l), w;
        };
      }
      var zu = vr(function(f, y, w) {
        var Y = Q;
        if (w.length) {
          var dt = Hs(w, ka(zu));
          Y |= ve;
        }
        return Fs(f, Y, y, w, dt);
      }), lf = vr(function(f, y, w) {
        var Y = Q | W;
        if (w.length) {
          var dt = Hs(w, ka(lf));
          Y |= ve;
        }
        return Fs(y, Y, f, w, dt);
      });
      function uf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, te, l, l, l, l, l, y);
        return Y.placeholder = uf.placeholder, Y;
      }
      function cf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, K, l, l, l, l, l, y);
        return Y.placeholder = cf.placeholder, Y;
      }
      function df(f, y, w) {
        var Y, dt, Wt, sn, cn, pn, En = 0, In = !1, Dn = !1, qn = !0;
        if (typeof f != "function")
          throw new Zi(g);
        y = xs(y) || 0, Xr(w) && (In = !!w.leading, Dn = "maxWait" in w, Wt = Dn ? ri(xs(w.maxWait) || 0, y) : Wt, qn = "trailing" in w ? !!w.trailing : qn);
        function nr(ti) {
          var ws = Y, Ms = dt;
          return Y = dt = l, En = ti, sn = f.apply(Ms, ws), sn;
        }
        function lr(ti) {
          return En = ti, cn = no($r, y), In ? nr(ti) : sn;
        }
        function gr(ti) {
          var ws = ti - pn, Ms = ti - En, kf = y - ws;
          return Dn ? wi(kf, Wt - Ms) : kf;
        }
        function ur(ti) {
          var ws = ti - pn, Ms = ti - En;
          return pn === l || ws >= y || ws < 0 || Dn && Ms >= Wt;
        }
        function $r() {
          var ti = Sl();
          if (ur(ti))
            return Ir(ti);
          cn = no($r, gr(ti));
        }
        function Ir(ti) {
          return cn = l, qn && Y ? nr(ti) : (Y = dt = l, sn);
        }
        function Gi() {
          cn !== l && bd(cn), En = 0, Y = pn = dt = cn = l;
        }
        function Fi() {
          return cn === l ? sn : Ir(Sl());
        }
        function qi() {
          var ti = Sl(), ws = ur(ti);
          if (Y = arguments, dt = this, pn = ti, ws) {
            if (cn === l)
              return lr(pn);
            if (Dn)
              return bd(cn), cn = no($r, y), nr(pn);
          }
          return cn === l && (cn = no($r, y)), sn;
        }
        return qi.cancel = Gi, qi.flush = Fi, qi;
      }
      var jy = vr(function(f, y) {
        return Jc(f, 1, y);
      }), Hy = vr(function(f, y, w) {
        return Jc(f, xs(y) || 0, w);
      });
      function Uy(f) {
        return Fs(f, yt);
      }
      function $l(f, y) {
        if (typeof f != "function" || y != null && typeof y != "function")
          throw new Zi(g);
        var w = function() {
          var Y = arguments, dt = y ? y.apply(this, Y) : Y[0], Wt = w.cache;
          if (Wt.has(dt))
            return Wt.get(dt);
          var sn = f.apply(this, Y);
          return w.cache = Wt.set(dt, sn) || Wt, sn;
        };
        return w.cache = new ($l.Cache || As)(), w;
      }
      $l.Cache = As;
      function El(f) {
        if (typeof f != "function")
          throw new Zi(g);
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return !f.call(this);
            case 1:
              return !f.call(this, y[0]);
            case 2:
              return !f.call(this, y[0], y[1]);
            case 3:
              return !f.call(this, y[0], y[1], y[2]);
          }
          return !f.apply(this, y);
        };
      }
      function Ky(f) {
        return of(2, f);
      }
      var Wy = jh(function(f, y) {
        y = y.length == 1 && pr(y[0]) ? qr(y[0], Ui(or())) : qr($i(y, 1), Ui(or()));
        var w = y.length;
        return vr(function(Y) {
          for (var dt = -1, Wt = wi(Y.length, w); ++dt < Wt; )
            Y[dt] = y[dt].call(this, Y[dt]);
          return Hi(f, this, Y);
        });
      }), Uu = vr(function(f, y) {
        var w = Hs(y, ka(Uu));
        return Fs(f, ve, l, y, w);
      }), ff = vr(function(f, y) {
        var w = Hs(y, ka(ff));
        return Fs(f, ee, l, y, w);
      }), Gy = Ds(function(f, y) {
        return Fs(f, wt, l, l, l, y);
      });
      function qy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y === l ? y : hr(y), vr(f, y);
      }
      function Yy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y == null ? 0 : ri(hr(y), 0), vr(function(w) {
          var Y = w[y], dt = qs(w, 0, y);
          return Y && zs(dt, Y), Hi(f, this, dt);
        });
      }
      function Xy(f, y, w) {
        var Y = !0, dt = !0;
        if (typeof f != "function")
          throw new Zi(g);
        return Xr(w) && (Y = "leading" in w ? !!w.leading : Y, dt = "trailing" in w ? !!w.trailing : dt), df(f, y, {
          leading: Y,
          maxWait: y,
          trailing: dt
        });
      }
      function Zy(f) {
        return af(f, 1);
      }
      function Jy(f, y) {
        return Uu(wu(y), f);
      }
      function Qy() {
        if (!arguments.length)
          return [];
        var f = arguments[0];
        return pr(f) ? f : [f];
      }
      function ev(f) {
        return Qi(f, N);
      }
      function tv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, N, y);
      }
      function nv(f) {
        return Qi(f, P | N);
      }
      function rv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, P | N, y);
      }
      function iv(f, y) {
        return y == null || Zc(f, y, oi(y));
      }
      function $s(f, y) {
        return f === y || f !== f && y !== y;
      }
      var sv = Zo(du), av = Zo(function(f, y) {
        return f >= y;
      }), ga = rd(/* @__PURE__ */ function() {
        return arguments;
      }()) ? rd : function(f) {
        return Qr(f) && zr.call(f, "callee") && !Hc.call(f, "callee");
      }, pr = xn.isArray, ov = wc ? Ui(wc) : _h;
      function Bi(f) {
        return f != null && Pl(f.length) && !Os(f);
      }
      function ei(f) {
        return Qr(f) && Bi(f);
      }
      function lv(f) {
        return f === !0 || f === !1 || Qr(f) && Ai(f) == _n;
      }
      var Ys = Ep || lc, uv = _c ? Ui(_c) : Eh;
      function cv(f) {
        return Qr(f) && f.nodeType === 1 && !ro(f);
      }
      function dv(f) {
        if (f == null)
          return !0;
        if (Bi(f) && (pr(f) || typeof f == "string" || typeof f.splice == "function" || Ys(f) || Aa(f) || ga(f)))
          return !f.length;
        var y = Ei(f);
        if (y == kn || y == Bn)
          return !f.size;
        if (to(f))
          return !hu(f).length;
        for (var w in f)
          if (zr.call(f, w))
            return !1;
        return !0;
      }
      function fv(f, y) {
        return Ya(f, y);
      }
      function pv(f, y, w) {
        w = typeof w == "function" ? w : l;
        var Y = w ? w(f, y) : l;
        return Y === l ? Ya(f, y, l, w) : !!Y;
      }
      function Wu(f) {
        if (!Qr(f))
          return !1;
        var y = Ai(f);
        return y == Xn || y == Un || typeof f.message == "string" && typeof f.name == "string" && !ro(f);
      }
      function hv(f) {
        return typeof f == "number" && Kc(f);
      }
      function Os(f) {
        if (!Xr(f))
          return !1;
        var y = Ai(f);
        return y == zn || y == jn || y == On || y == Ln;
      }
      function pf(f) {
        return typeof f == "number" && f == hr(f);
      }
      function Pl(f) {
        return typeof f == "number" && f > -1 && f % 1 == 0 && f <= vt;
      }
      function Xr(f) {
        var y = typeof f;
        return f != null && (y == "object" || y == "function");
      }
      function Qr(f) {
        return f != null && typeof f == "object";
      }
      var hf = Ec ? Ui(Ec) : Th;
      function mv(f, y) {
        return f === y || pu(f, y, Nu(y));
      }
      function gv(f, y, w) {
        return w = typeof w == "function" ? w : l, pu(f, y, Nu(y), w);
      }
      function yv(f) {
        return mf(f) && f != +f;
      }
      function vv(f) {
        if (dm(f))
          throw new fr(m);
        return id(f);
      }
      function xv(f) {
        return f === null;
      }
      function bv(f) {
        return f == null;
      }
      function mf(f) {
        return typeof f == "number" || Qr(f) && Ai(f) == Yn;
      }
      function ro(f) {
        if (!Qr(f) || Ai(f) != er)
          return !1;
        var y = xo(f);
        if (y === null)
          return !0;
        var w = zr.call(y, "constructor") && y.constructor;
        return typeof w == "function" && w instanceof w && mo.call(w) == xp;
      }
      var Zu = Pc ? Ui(Pc) : Ih;
      function Cv(f) {
        return pf(f) && f >= -vt && f <= vt;
      }
      var gf = Tc ? Ui(Tc) : kh;
      function Tl(f) {
        return typeof f == "string" || !pr(f) && Qr(f) && Ai(f) == Fn;
      }
      function Wi(f) {
        return typeof f == "symbol" || Qr(f) && Ai(f) == Gn;
      }
      var Aa = Ic ? Ui(Ic) : Ah;
      function Sv(f) {
        return f === l;
      }
      function $v(f) {
        return Qr(f) && Ei(f) == Mn;
      }
      function wv(f) {
        return Qr(f) && Ai(f) == Tn;
      }
      var _v = Zo(mu), Ev = Zo(function(f, y) {
        return f <= y;
      });
      function yf(f) {
        if (!f)
          return [];
        if (Bi(f))
          return Tl(f) ? Cs(f) : Vi(f);
        if (Ba && f[Ba])
          return ap(f[Ba]());
        var y = Ei(f), w = y == kn ? nu : y == Bn ? fo : Na;
        return w(f);
      }
      function Ls(f) {
        if (!f)
          return f === 0 ? f : 0;
        if (f = xs(f), f === nn || f === -nn) {
          var y = f < 0 ? -1 : 1;
          return y * Et;
        }
        return f === f ? f : 0;
      }
      function hr(f) {
        var y = Ls(f), w = y % 1;
        return y === y ? w ? y - w : y : 0;
      }
      function vf(f) {
        return f ? fa(hr(f), 0, un) : 0;
      }
      function xs(f) {
        if (typeof f == "number")
          return f;
        if (Wi(f))
          return Qt;
        if (Xr(f)) {
          var y = typeof f.valueOf == "function" ? f.valueOf() : f;
          f = Xr(y) ? y + "" : y;
        }
        if (typeof f != "string")
          return f === 0 ? f : +f;
        f = Rc(f);
        var w = kl.test(f);
        return w || Vl.test(f) ? Hf(f.slice(2), w ? 2 : 8) : Ol.test(f) ? Qt : +f;
      }
      function xf(f) {
        return Ps(f, zi(f));
      }
      function Pv(f) {
        return f ? fa(hr(f), -vt, vt) : f === 0 ? f : 0;
      }
      function Vr(f) {
        return f == null ? "" : Ki(f);
      }
      var Tv = Ta(function(f, y) {
        if (to(y) || Bi(y)) {
          Ps(y, oi(y), f);
          return;
        }
        for (var w in y)
          zr.call(y, w) && Wa(f, w, y[w]);
      }), bf = Ta(function(f, y) {
        Ps(y, zi(y), f);
      }), Il = Ta(function(f, y, w, Y) {
        Ps(y, zi(y), f, Y);
      }), Iv = Ta(function(f, y, w, Y) {
        Ps(y, oi(y), f, Y);
      }), kv = Ds(lu);
      function Av(f, y) {
        var w = Pa(f);
        return y == null ? w : Xc(w, y);
      }
      var Nv = vr(function(f, y) {
        f = Gr(f);
        var w = -1, Y = y.length, dt = Y > 2 ? y[2] : l;
        for (dt && Ni(y[0], y[1], dt) && (Y = 1); ++w < Y; )
          for (var Wt = y[w], sn = zi(Wt), cn = -1, pn = sn.length; ++cn < pn; ) {
            var En = sn[cn], In = f[En];
            (In === l || $s(In, $a[En]) && !zr.call(f, En)) && (f[En] = Wt[En]);
          }
        return f;
      }), Fv = vr(function(f) {
        return f.push(l, Od), Hi(Cf, l, f);
      });
      function Dv(f, y) {
        return Ac(f, or(y, 3), Es);
      }
      function Rv(f, y) {
        return Ac(f, or(y, 3), cu);
      }
      function Ov(f, y) {
        return f == null ? f : uu(f, or(y, 3), zi);
      }
      function Lv(f, y) {
        return f == null ? f : td(f, or(y, 3), zi);
      }
      function Mv(f, y) {
        return f && Es(f, or(y, 3));
      }
      function Vv(f, y) {
        return f && cu(f, or(y, 3));
      }
      function Bv(f) {
        return f == null ? [] : Ao(f, oi(f));
      }
      function zv(f) {
        return f == null ? [] : Ao(f, zi(f));
      }
      function ec(f, y, w) {
        var Y = f == null ? l : pa(f, y);
        return Y === l ? w : Y;
      }
      function jv(f, y) {
        return f != null && Vd(f, y, Ch);
      }
      function tc(f, y) {
        return f != null && Vd(f, y, Sh);
      }
      var Hv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), f[y] = w;
      }, rc(ji)), Uv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), zr.call(f, y) ? f[y].push(w) : f[y] = [w];
      }, or), Kv = vr(qa);
      function oi(f) {
        return Bi(f) ? qc(f) : hu(f);
      }
      function zi(f) {
        return Bi(f) ? qc(f, !0) : Nh(f);
      }
      function Wv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, y(Y, dt, Wt), Y);
        }), w;
      }
      function Gv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, dt, y(Y, dt, Wt));
        }), w;
      }
      var qv = Ta(function(f, y, w) {
        No(f, y, w);
      }), Cf = Ta(function(f, y, w, Y) {
        No(f, y, w, Y);
      }), Yv = Ds(function(f, y) {
        var w = {};
        if (f == null)
          return w;
        var Y = !1;
        y = qr(y, function(Wt) {
          return Wt = Gs(Wt, f), Y || (Y = Wt.length > 1), Wt;
        }), Ps(f, Iu(f), w), Y && (w = Qi(w, P | T | N, Qh));
        for (var dt = y.length; dt--; )
          bu(w, y[dt]);
        return w;
      });
      function Xv(f, y) {
        return Sf(f, El(or(y)));
      }
      var Zv = Ds(function(f, y) {
        return f == null ? {} : Dh(f, y);
      });
      function Sf(f, y) {
        if (f == null)
          return {};
        var w = qr(Iu(f), function(Y) {
          return [Y];
        });
        return y = or(y), dd(f, w, function(Y, dt) {
          return y(Y, dt[0]);
        });
      }
      function Jv(f, y, w) {
        y = Gs(y, f);
        var Y = -1, dt = y.length;
        for (dt || (dt = 1, f = l); ++Y < dt; ) {
          var Wt = f == null ? l : f[Ts(y[Y])];
          Wt === l && (Y = dt, Wt = w), f = Os(Wt) ? Wt.call(f) : Wt;
        }
        return f;
      }
      function Qv(f, y, w) {
        return f == null ? f : Xa(f, y, w);
      }
      function e1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : Xa(f, y, w, Y);
      }
      var $f = Dd(oi), wf = Dd(zi);
      function t1(f, y, w) {
        var Y = pr(f), dt = Y || Ys(f) || Aa(f);
        if (y = or(y, 4), w == null) {
          var Wt = f && f.constructor;
          dt ? w = Y ? new Wt() : [] : Xr(f) ? w = Os(Wt) ? Pa(xo(f)) : {} : w = {};
        }
        return (dt ? Xi : Es)(f, function(sn, cn, pn) {
          return y(w, sn, cn, pn);
        }), w;
      }
      function n1(f, y) {
        return f == null ? !0 : bu(f, y);
      }
      function r1(f, y, w) {
        return f == null ? f : yd(f, y, wu(w));
      }
      function i1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : yd(f, y, wu(w), Y);
      }
      function Na(f) {
        return f == null ? [] : tu(f, oi(f));
      }
      function s1(f) {
        return f == null ? [] : tu(f, zi(f));
      }
      function a1(f, y, w) {
        return w === l && (w = y, y = l), w !== l && (w = xs(w), w = w === w ? w : 0), y !== l && (y = xs(y), y = y === y ? y : 0), fa(xs(f), y, w);
      }
      function o1(f, y, w) {
        return y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), f = xs(f), $h(f, y, w);
      }
      function l1(f, y, w) {
        if (w && typeof w != "boolean" && Ni(f, y, w) && (y = w = l), w === l && (typeof y == "boolean" ? (w = y, y = l) : typeof f == "boolean" && (w = f, f = l)), f === l && y === l ? (f = 0, y = 1) : (f = Ls(f), y === l ? (y = f, f = 0) : y = Ls(y)), f > y) {
          var Y = f;
          f = y, y = Y;
        }
        if (w || f % 1 || y % 1) {
          var dt = Wc();
          return wi(f + dt * (y - f + jf("1e-" + ((dt + "").length - 1))), y);
        }
        return yu(f, y);
      }
      var u1 = Ia(function(f, y, w) {
        return y = y.toLowerCase(), f + (w ? _f(y) : y);
      });
      function _f(f) {
        return nc(Vr(f).toLowerCase());
      }
      function Ef(f) {
        return f = Vr(f), f && f.replace(Ll, tp).replace(Li, "");
      }
      function c1(f, y, w) {
        f = Vr(f), y = Ki(y);
        var Y = f.length;
        w = w === l ? Y : fa(hr(w), 0, Y);
        var dt = w;
        return w -= y.length, w >= 0 && f.slice(w, dt) == y;
      }
      function d1(f) {
        return f = Vr(f), f && _r.test(f) ? f.replace(Nr, np) : f;
      }
      function f1(f) {
        return f = Vr(f), f && bs.test(f) ? f.replace(Ii, "\\$&") : f;
      }
      var p1 = Ia(function(f, y, w) {
        return f + (w ? "-" : "") + y.toLowerCase();
      }), m1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toLowerCase();
      }), g1 = Td("toLowerCase");
      function y1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        if (!y || Y >= y)
          return f;
        var dt = (y - Y) / 2;
        return Bo(wo(dt), w) + f + Bo(So(dt), w);
      }
      function v1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? f + Bo(y - Y, w) : f;
      }
      function x1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? Bo(y - Y, w) + f : f;
      }
      function b1(f, y, w) {
        return w || y == null ? y = 0 : y && (y = +y), Ap(Vr(f).replace(Oi, ""), y || 0);
      }
      function C1(f, y, w) {
        return (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y), vu(Vr(f), y);
      }
      function S1() {
        var f = arguments, y = Vr(f[0]);
        return f.length < 3 ? y : y.replace(f[1], f[2]);
      }
      var $1 = Ia(function(f, y, w) {
        return f + (w ? "_" : "") + y.toLowerCase();
      });
      function w1(f, y, w) {
        return w && typeof w != "number" && Ni(f, y, w) && (y = w = l), w = w === l ? un : w >>> 0, w ? (f = Vr(f), f && (typeof y == "string" || y != null && !Zu(y)) && (y = Ki(y), !y && ba(f)) ? qs(Cs(f), 0, w) : f.split(y, w)) : [];
      }
      var _1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + nc(y);
      });
      function E1(f, y, w) {
        return f = Vr(f), w = w == null ? 0 : fa(hr(w), 0, f.length), y = Ki(y), f.slice(w, w + y.length) == y;
      }
      function P1(f, y, w) {
        var Y = Ft.templateSettings;
        w && Ni(f, y, w) && (y = l), f = Vr(f), y = Il({}, y, Y, Rd);
        var dt = Il({}, y.imports, Y.imports, Rd), Wt = oi(dt), sn = tu(dt, Wt), cn, pn, En = 0, In = y.interpolate || Oa, Dn = "__p += '", qn = ru(
          (y.escape || Oa).source + "|" + In.source + "|" + (In === ii ? Xs : Oa).source + "|" + (y.evaluate || Oa).source + "|$",
          "g"
        ), nr = "//# sourceURL=" + (zr.call(y, "sourceURL") ? (y.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++mc + "]") + `
`;
        f.replace(qn, function(ur, $r, Ir, Gi, Fi, qi) {
          return Ir || (Ir = Gi), Dn += f.slice(En, qi).replace(cc, rp), $r && (cn = !0, Dn += `' +
__e(` + $r + `) +
'`), Fi && (pn = !0, Dn += `';
` + Fi + `;
__p += '`), Ir && (Dn += `' +
((__t = (` + Ir + `)) == null ? '' : __t) +
'`), En = qi + ur.length, ur;
        }), Dn += `';
`;
        var lr = zr.call(y, "variable") && y.variable;
        if (!lr)
          Dn = `with (obj) {
` + Dn + `
}
`;
        else if (Da.test(lr))
          throw new fr(v);
        Dn = (pn ? Dn.replace(ar, "") : Dn).replace(Or, "$1").replace(Sr, "$1;"), Dn = "function(" + (lr || "obj") + `) {
` + (lr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (cn ? ", __e = _.escape" : "") + (pn ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Dn + `return __p
}`;
        var gr = Tf(function() {
          return Mr(Wt, nr + "return " + Dn).apply(l, sn);
        });
        if (gr.source = Dn, Wu(gr))
          throw gr;
        return gr;
      }
      function T1(f) {
        return Vr(f).toLowerCase();
      }
      function I1(f) {
        return Vr(f).toUpperCase();
      }
      function k1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return Rc(f);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Cs(y), Wt = Oc(Y, dt), sn = Lc(Y, dt) + 1;
        return qs(Y, Wt, sn).join("");
      }
      function A1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.slice(0, Vc(f) + 1);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Lc(Y, Cs(y)) + 1;
        return qs(Y, 0, dt).join("");
      }
      function N1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.replace(Oi, "");
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Oc(Y, Cs(y));
        return qs(Y, dt).join("");
      }
      function F1(f, y) {
        var w = xt, Y = Kt;
        if (Xr(y)) {
          var dt = "separator" in y ? y.separator : dt;
          w = "length" in y ? hr(y.length) : w, Y = "omission" in y ? Ki(y.omission) : Y;
        }
        f = Vr(f);
        var Wt = f.length;
        if (ba(f)) {
          var sn = Cs(f);
          Wt = sn.length;
        }
        if (w >= Wt)
          return f;
        var cn = w - Ca(Y);
        if (cn < 1)
          return Y;
        var pn = sn ? qs(sn, 0, cn).join("") : f.slice(0, cn);
        if (dt === l)
          return pn + Y;
        if (sn && (cn += pn.length - cn), Zu(dt)) {
          if (f.slice(cn).search(dt)) {
            var En, In = pn;
            for (dt.global || (dt = ru(dt.source, Vr(so.exec(dt)) + "g")), dt.lastIndex = 0; En = dt.exec(In); )
              var Dn = En.index;
            pn = pn.slice(0, Dn === l ? cn : Dn);
          }
        } else if (f.indexOf(Ki(dt), cn) != cn) {
          var qn = pn.lastIndexOf(dt);
          qn > -1 && (pn = pn.slice(0, qn));
        }
        return pn + Y;
      }
      function D1(f) {
        return f = Vr(f), f && Ur.test(f) ? f.replace(kr, cp) : f;
      }
      var R1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toUpperCase();
      }), nc = Td("toUpperCase");
      function Pf(f, y, w) {
        return f = Vr(f), y = w ? l : y, y === l ? sp(f) ? hp(f) : Xf(f) : f.match(y) || [];
      }
      var Tf = vr(function(f, y) {
        try {
          return Hi(f, l, y);
        } catch (w) {
          return Wu(w) ? w : new fr(w);
        }
      }), O1 = Ds(function(f, y) {
        return Xi(y, function(w) {
          w = Ts(w), Ns(f, w, zu(f[w], f));
        }), f;
      });
      function L1(f) {
        var y = f == null ? 0 : f.length, w = or();
        return f = y ? qr(f, function(Y) {
          if (typeof Y[1] != "function")
            throw new Zi(g);
          return [w(Y[0]), Y[1]];
        }) : [], vr(function(Y) {
          for (var dt = -1; ++dt < y; ) {
            var Wt = f[dt];
            if (Hi(Wt[0], this, Y))
              return Hi(Wt[1], this, Y);
          }
        });
      }
      function M1(f) {
        return vh(Qi(f, P));
      }
      function rc(f) {
        return function() {
          return f;
        };
      }
      function V1(f, y) {
        return f == null || f !== f ? y : f;
      }
      var B1 = kd(), z1 = kd(!0);
      function ji(f) {
        return f;
      }
      function ic(f) {
        return sd(typeof f == "function" ? f : Qi(f, P));
      }
      function j1(f) {
        return od(Qi(f, P));
      }
      function H1(f, y) {
        return ld(f, Qi(y, P));
      }
      var U1 = vr(function(f, y) {
        return function(w) {
          return qa(w, f, y);
        };
      }), K1 = vr(function(f, y) {
        return function(w) {
          return qa(f, w, y);
        };
      });
      function sc(f, y, w) {
        var Y = oi(y), dt = Ao(y, Y);
        w == null && !(Xr(y) && (dt.length || !Y.length)) && (w = y, y = f, f = this, dt = Ao(y, oi(y)));
        var Wt = !(Xr(w) && "chain" in w) || !!w.chain, sn = Os(f);
        return Xi(dt, function(cn) {
          var pn = y[cn];
          f[cn] = pn, sn && (f.prototype[cn] = function() {
            var En = this.__chain__;
            if (Wt || En) {
              var In = f(this.__wrapped__), Dn = In.__actions__ = Vi(this.__actions__);
              return Dn.push({ func: pn, args: arguments, thisArg: f }), In.__chain__ = En, In;
            }
            return pn.apply(f, zs([this.value()], arguments));
          });
        }), f;
      }
      function W1() {
        return di._ === this && (di._ = bp), this;
      }
      function ac() {
      }
      function G1(f) {
        return f = hr(f), vr(function(y) {
          return ud(y, f);
        });
      }
      var q1 = Eu(qr), Y1 = Eu(kc), X1 = Eu(Xl);
      function If(f) {
        return Du(f) ? Zl(Ts(f)) : Rh(f);
      }
      function Z1(f) {
        return function(y) {
          return f == null ? l : pa(f, y);
        };
      }
      var J1 = Nd(), Q1 = Nd(!0);
      function oc() {
        return [];
      }
      function lc() {
        return !1;
      }
      function ex() {
        return {};
      }
      function tx() {
        return "";
      }
      function nx() {
        return !0;
      }
      function rx(f, y) {
        if (f = hr(f), f < 1 || f > vt)
          return [];
        var w = un, Y = wi(f, un);
        y = or(y), f -= un;
        for (var dt = eu(Y, y); ++w < f; )
          y(w);
        return dt;
      }
      function ix(f) {
        return pr(f) ? qr(f, Ts) : Wi(f) ? [f] : Vi(qd(Vr(f)));
      }
      function sx(f) {
        var y = ++vp;
        return Vr(f) + y;
      }
      var ax = Mo(function(f, y) {
        return f + y;
      }, 0), ox = Pu("ceil"), lx = Mo(function(f, y) {
        return f / y;
      }, 1), ux = Pu("floor");
      function cx(f) {
        return f && f.length ? Io(f, ji, du) : l;
      }
      function dx(f, y) {
        return f && f.length ? Io(f, or(y, 2), du) : l;
      }
      function fx(f) {
        return Fc(f, ji);
      }
      function px(f, y) {
        return Fc(f, or(y, 2));
      }
      function hx(f) {
        return f && f.length ? Io(f, ji, mu) : l;
      }
      function mx(f, y) {
        return f && f.length ? Io(f, or(y, 2), mu) : l;
      }
      var gx = Mo(function(f, y) {
        return f * y;
      }, 1), yx = Pu("round"), vx = Mo(function(f, y) {
        return f - y;
      }, 0);
      function xx(f) {
        return f && f.length ? Ql(f, ji) : 0;
      }
      function bx(f, y) {
        return f && f.length ? Ql(f, or(y, 2)) : 0;
      }
      return Ft.after = zy, Ft.ary = af, Ft.assign = Tv, Ft.assignIn = bf, Ft.assignInWith = Il, Ft.assignWith = Iv, Ft.at = kv, Ft.before = of, Ft.bind = zu, Ft.bindAll = O1, Ft.bindKey = lf, Ft.castArray = Qy, Ft.chain = nf, Ft.chunk = vm, Ft.compact = xm, Ft.concat = bm, Ft.cond = L1, Ft.conforms = M1, Ft.constant = rc, Ft.countBy = vy, Ft.create = Av, Ft.curry = uf, Ft.curryRight = cf, Ft.debounce = df, Ft.defaults = Nv, Ft.defaultsDeep = Fv, Ft.defer = jy, Ft.delay = Hy, Ft.difference = Cm, Ft.differenceBy = Sm, Ft.differenceWith = $m, Ft.drop = wm, Ft.dropRight = _m, Ft.dropRightWhile = Em, Ft.dropWhile = Pm, Ft.fill = Tm, Ft.filter = by, Ft.flatMap = $y, Ft.flatMapDeep = wy, Ft.flatMapDepth = _y, Ft.flatten = Jd, Ft.flattenDeep = Im, Ft.flattenDepth = km, Ft.flip = Uy, Ft.flow = B1, Ft.flowRight = z1, Ft.fromPairs = Am, Ft.functions = Bv, Ft.functionsIn = zv, Ft.groupBy = Ey, Ft.initial = Fm, Ft.intersection = Dm, Ft.intersectionBy = Rm, Ft.intersectionWith = Om, Ft.invert = Hv, Ft.invertBy = Uv, Ft.invokeMap = Ty, Ft.iteratee = ic, Ft.keyBy = Iy, Ft.keys = oi, Ft.keysIn = zi, Ft.map = Cl, Ft.mapKeys = Wv, Ft.mapValues = Gv, Ft.matches = j1, Ft.matchesProperty = H1, Ft.memoize = $l, Ft.merge = qv, Ft.mergeWith = Cf, Ft.method = U1, Ft.methodOf = K1, Ft.mixin = sc, Ft.negate = El, Ft.nthArg = G1, Ft.omit = Yv, Ft.omitBy = Xv, Ft.once = Ky, Ft.orderBy = ky, Ft.over = q1, Ft.overArgs = Wy, Ft.overEvery = Y1, Ft.overSome = X1, Ft.partial = Uu, Ft.partialRight = ff, Ft.partition = Ay, Ft.pick = Zv, Ft.pickBy = Sf, Ft.property = If, Ft.propertyOf = Z1, Ft.pull = Bm, Ft.pullAll = ef, Ft.pullAllBy = zm, Ft.pullAllWith = jm, Ft.pullAt = Hm, Ft.range = J1, Ft.rangeRight = Q1, Ft.rearg = Gy, Ft.reject = Dy, Ft.remove = Um, Ft.rest = qy, Ft.reverse = Mu, Ft.sampleSize = Oy, Ft.set = Qv, Ft.setWith = e1, Ft.shuffle = Ly, Ft.slice = Km, Ft.sortBy = By, Ft.sortedUniq = Jm, Ft.sortedUniqBy = Qm, Ft.split = w1, Ft.spread = Yy, Ft.tail = eg, Ft.take = tg, Ft.takeRight = ng, Ft.takeRightWhile = rg, Ft.takeWhile = ig, Ft.tap = uy, Ft.throttle = Xy, Ft.thru = bl, Ft.toArray = yf, Ft.toPairs = $f, Ft.toPairsIn = wf, Ft.toPath = ix, Ft.toPlainObject = xf, Ft.transform = t1, Ft.unary = Zy, Ft.union = ag, Ft.unionBy = og, Ft.unionWith = lg, Ft.uniq = ug, Ft.uniqBy = cg, Ft.uniqWith = ey, Ft.unset = n1, Ft.unzip = Bu, Ft.unzipWith = tf, Ft.update = r1, Ft.updateWith = i1, Ft.values = Na, Ft.valuesIn = s1, Ft.without = ty, Ft.words = Pf, Ft.wrap = Jy, Ft.xor = ny, Ft.xorBy = ry, Ft.xorWith = iy, Ft.zip = sy, Ft.zipObject = ay, Ft.zipObjectDeep = oy, Ft.zipWith = ly, Ft.entries = $f, Ft.entriesIn = wf, Ft.extend = bf, Ft.extendWith = Il, sc(Ft, Ft), Ft.add = ax, Ft.attempt = Tf, Ft.camelCase = u1, Ft.capitalize = _f, Ft.ceil = ox, Ft.clamp = a1, Ft.clone = ev, Ft.cloneDeep = nv, Ft.cloneDeepWith = rv, Ft.cloneWith = tv, Ft.conformsTo = iv, Ft.deburr = Ef, Ft.defaultTo = V1, Ft.divide = lx, Ft.endsWith = c1, Ft.eq = $s, Ft.escape = d1, Ft.escapeRegExp = f1, Ft.every = xy, Ft.find = Cy, Ft.findIndex = Xd, Ft.findKey = Dv, Ft.findLast = Sy, Ft.findLastIndex = Zd, Ft.findLastKey = Rv, Ft.floor = ux, Ft.forEach = rf, Ft.forEachRight = sf, Ft.forIn = Ov, Ft.forInRight = Lv, Ft.forOwn = Mv, Ft.forOwnRight = Vv, Ft.get = ec, Ft.gt = sv, Ft.gte = av, Ft.has = jv, Ft.hasIn = tc, Ft.head = Qd, Ft.identity = ji, Ft.includes = Py, Ft.indexOf = Nm, Ft.inRange = o1, Ft.invoke = Kv, Ft.isArguments = ga, Ft.isArray = pr, Ft.isArrayBuffer = ov, Ft.isArrayLike = Bi, Ft.isArrayLikeObject = ei, Ft.isBoolean = lv, Ft.isBuffer = Ys, Ft.isDate = uv, Ft.isElement = cv, Ft.isEmpty = dv, Ft.isEqual = fv, Ft.isEqualWith = pv, Ft.isError = Wu, Ft.isFinite = hv, Ft.isFunction = Os, Ft.isInteger = pf, Ft.isLength = Pl, Ft.isMap = hf, Ft.isMatch = mv, Ft.isMatchWith = gv, Ft.isNaN = yv, Ft.isNative = vv, Ft.isNil = bv, Ft.isNull = xv, Ft.isNumber = mf, Ft.isObject = Xr, Ft.isObjectLike = Qr, Ft.isPlainObject = ro, Ft.isRegExp = Zu, Ft.isSafeInteger = Cv, Ft.isSet = gf, Ft.isString = Tl, Ft.isSymbol = Wi, Ft.isTypedArray = Aa, Ft.isUndefined = Sv, Ft.isWeakMap = $v, Ft.isWeakSet = wv, Ft.join = Lm, Ft.kebabCase = p1, Ft.last = ys, Ft.lastIndexOf = Mm, Ft.lowerCase = m1, Ft.lowerFirst = g1, Ft.lt = _v, Ft.lte = Ev, Ft.max = cx, Ft.maxBy = dx, Ft.mean = fx, Ft.meanBy = px, Ft.min = hx, Ft.minBy = mx, Ft.stubArray = oc, Ft.stubFalse = lc, Ft.stubObject = ex, Ft.stubString = tx, Ft.stubTrue = nx, Ft.multiply = gx, Ft.nth = Vm, Ft.noConflict = W1, Ft.noop = ac, Ft.now = Sl, Ft.pad = y1, Ft.padEnd = v1, Ft.padStart = x1, Ft.parseInt = b1, Ft.random = l1, Ft.reduce = Ny, Ft.reduceRight = Fy, Ft.repeat = C1, Ft.replace = S1, Ft.result = Jv, Ft.round = yx, Ft.runInContext = fn, Ft.sample = Ry, Ft.size = My, Ft.snakeCase = $1, Ft.some = Vy, Ft.sortedIndex = Wm, Ft.sortedIndexBy = Gm, Ft.sortedIndexOf = qm, Ft.sortedLastIndex = Ym, Ft.sortedLastIndexBy = Xm, Ft.sortedLastIndexOf = Zm, Ft.startCase = _1, Ft.startsWith = E1, Ft.subtract = vx, Ft.sum = xx, Ft.sumBy = bx, Ft.template = P1, Ft.times = rx, Ft.toFinite = Ls, Ft.toInteger = hr, Ft.toLength = vf, Ft.toLower = T1, Ft.toNumber = xs, Ft.toSafeInteger = Pv, Ft.toString = Vr, Ft.toUpper = I1, Ft.trim = k1, Ft.trimEnd = A1, Ft.trimStart = N1, Ft.truncate = F1, Ft.unescape = D1, Ft.uniqueId = sx, Ft.upperCase = R1, Ft.upperFirst = nc, Ft.each = rf, Ft.eachRight = sf, Ft.first = Qd, sc(Ft, function() {
        var f = {};
        return Es(Ft, function(y, w) {
          zr.call(Ft.prototype, w) || (f[w] = y);
        }), f;
      }(), { chain: !1 }), Ft.VERSION = u, Xi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(f) {
        Ft[f].placeholder = Ft;
      }), Xi(["drop", "take"], function(f, y) {
        Pr.prototype[f] = function(w) {
          w = w === l ? 1 : ri(hr(w), 0);
          var Y = this.__filtered__ && !y ? new Pr(this) : this.clone();
          return Y.__filtered__ ? Y.__takeCount__ = wi(w, Y.__takeCount__) : Y.__views__.push({
            size: wi(w, un),
            type: f + (Y.__dir__ < 0 ? "Right" : "")
          }), Y;
        }, Pr.prototype[f + "Right"] = function(w) {
          return this.reverse()[f](w).reverse();
        };
      }), Xi(["filter", "map", "takeWhile"], function(f, y) {
        var w = y + 1, Y = w == rn || w == Gt;
        Pr.prototype[f] = function(dt) {
          var Wt = this.clone();
          return Wt.__iteratees__.push({
            iteratee: or(dt, 3),
            type: w
          }), Wt.__filtered__ = Wt.__filtered__ || Y, Wt;
        };
      }), Xi(["head", "last"], function(f, y) {
        var w = "take" + (y ? "Right" : "");
        Pr.prototype[f] = function() {
          return this[w](1).value()[0];
        };
      }), Xi(["initial", "tail"], function(f, y) {
        var w = "drop" + (y ? "" : "Right");
        Pr.prototype[f] = function() {
          return this.__filtered__ ? new Pr(this) : this[w](1);
        };
      }), Pr.prototype.compact = function() {
        return this.filter(ji);
      }, Pr.prototype.find = function(f) {
        return this.filter(f).head();
      }, Pr.prototype.findLast = function(f) {
        return this.reverse().find(f);
      }, Pr.prototype.invokeMap = vr(function(f, y) {
        return typeof f == "function" ? new Pr(this) : this.map(function(w) {
          return qa(w, f, y);
        });
      }), Pr.prototype.reject = function(f) {
        return this.filter(El(or(f)));
      }, Pr.prototype.slice = function(f, y) {
        f = hr(f);
        var w = this;
        return w.__filtered__ && (f > 0 || y < 0) ? new Pr(w) : (f < 0 ? w = w.takeRight(-f) : f && (w = w.drop(f)), y !== l && (y = hr(y), w = y < 0 ? w.dropRight(-y) : w.take(y - f)), w);
      }, Pr.prototype.takeRightWhile = function(f) {
        return this.reverse().takeWhile(f).reverse();
      }, Pr.prototype.toArray = function() {
        return this.take(un);
      }, Es(Pr.prototype, function(f, y) {
        var w = /^(?:filter|find|map|reject)|While$/.test(y), Y = /^(?:head|last)$/.test(y), dt = Ft[Y ? "take" + (y == "last" ? "Right" : "") : y], Wt = Y || /^find/.test(y);
        dt && (Ft.prototype[y] = function() {
          var sn = this.__wrapped__, cn = Y ? [1] : arguments, pn = sn instanceof Pr, En = cn[0], In = pn || pr(sn), Dn = function($r) {
            var Ir = dt.apply(Ft, zs([$r], cn));
            return Y && qn ? Ir[0] : Ir;
          };
          In && w && typeof En == "function" && En.length != 1 && (pn = In = !1);
          var qn = this.__chain__, nr = !!this.__actions__.length, lr = Wt && !qn, gr = pn && !nr;
          if (!Wt && In) {
            sn = gr ? sn : new Pr(this);
            var ur = f.apply(sn, cn);
            return ur.__actions__.push({ func: bl, args: [Dn], thisArg: l }), new Ji(ur, qn);
          }
          return lr && gr ? f.apply(this, cn) : (ur = this.thru(Dn), lr ? Y ? ur.value()[0] : ur.value() : ur);
        });
      }), Xi(["pop", "push", "shift", "sort", "splice", "unshift"], function(f) {
        var y = po[f], w = /^(?:push|sort|unshift)$/.test(f) ? "tap" : "thru", Y = /^(?:pop|shift)$/.test(f);
        Ft.prototype[f] = function() {
          var dt = arguments;
          if (Y && !this.__chain__) {
            var Wt = this.value();
            return y.apply(pr(Wt) ? Wt : [], dt);
          }
          return this[w](function(sn) {
            return y.apply(pr(sn) ? sn : [], dt);
          });
        };
      }), Es(Pr.prototype, function(f, y) {
        var w = Ft[y];
        if (w) {
          var Y = w.name + "";
          zr.call(Ea, Y) || (Ea[Y] = []), Ea[Y].push({ name: y, func: w });
        }
      }), Ea[Lo(l, W).name] = [{
        name: "wrapper",
        func: l
      }], Pr.prototype.clone = Mp, Pr.prototype.reverse = Bp, Pr.prototype.value = zp, Ft.prototype.at = cy, Ft.prototype.chain = dy, Ft.prototype.commit = fy, Ft.prototype.next = py, Ft.prototype.plant = my, Ft.prototype.reverse = gy, Ft.prototype.toJSON = Ft.prototype.valueOf = Ft.prototype.value = yy, Ft.prototype.first = Ft.prototype.head, Ba && (Ft.prototype[Ba] = hy), Ft;
    }, Sa = mp();
    Qs ? ((Qs.exports = Sa)._ = Sa, Wl._ = Sa) : di._ = Sa;
  }).call(wr);
})(Ci, Ci.exports);
Ci.exports;
const m_ = {
  animation: Function,
  children: [Object, Function]
}, S_ = /* @__PURE__ */ defineComponent((s, {}) => {
  useSlots();
  const o = ref$1(null), l = ref$1(null), u = shallowRef(s.children);
  return watch(() => s.children, (c, m, g) => {
    u.value = m;
  }), watch([() => s.animation, () => o.value, () => l.value], () => {
    var c, m;
    if (!l.value)
      return;
    const g = (c = o.value) == null ? void 0 : c.key, v = (m = o.value) == null ? void 0 : m.props.id;
    if (g == null || v == null) {
      o.value = null;
      return;
    }
    Promise.resolve(s.animation(
      v,
      // @ts-ignore
      l.value.$el ? l.value.$el : l.value
    )).then(() => {
      o.value = null;
    });
  }, {
    immediate: !0
  }), () => (!s.children && !o.value && u.value && (o.value = u.value, u.value = s.children), createVNode(Fragment, null, [s.children, o.value ? cloneVNode(o.value, {
    ref: l
  }) : null]));
}, {
  props: m_,
  name: "AnimationManager"
}), C_ = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function A_() {
  const s = useSlots();
  return createVNode(vs.Provider, {
    value: oa
  }, {
    default: () => [createVNode(gs.Provider, {
      value: C_
    }, {
      default: () => {
        var o;
        return [(o = s.default) == null ? void 0 : o.call(s)];
      }
    })]
  });
}
const R_ = {
  position: "fixed",
  touchAction: "none"
}, D_ = (s) => na(s) ? "transform 250ms ease" : void 0, E_ = {
  as: [Object, Function, String],
  activatorEvent: [Object, Function],
  adjustScale: Boolean,
  className: String,
  id: [String, Number],
  rect: Object,
  style: [String, Object],
  transition: [String, Function],
  transform: Object,
  setRef: [Function, Object]
}, O_ = /* @__PURE__ */ defineComponent((s, {}) => {
  const o = useSlots();
  return () => {
    const {
      as: l,
      activatorEvent: u,
      adjustScale: c,
      className: m,
      rect: g,
      style: v,
      transform: b,
      transition: S = D_
    } = s;
    if (!g)
      return null;
    const E = c ? b : {
      ...b,
      scaleX: 1,
      scaleY: 1
    }, P = {
      ...R_,
      width: g.width + "px",
      height: g.height + "px",
      top: g.top + "px",
      left: g.left + "px",
      transform: mr.Transform.toString(E),
      transformOrigin: c && u ? v0$1(u, g) : void 0,
      transition: typeof S == "function" ? S(u) : S,
      ...v
    };
    return h(l, {
      className: m,
      style: P,
      ref: (T) => {
        s.setRef(T);
      }
    }, {
      default: o.default
    });
  };
}, {
  props: E_,
  name: "PositionedOverlay"
}), T_ = (s) => ({ active: o, dragOverlay: l }) => {
  const u = {}, { styles: c, className: m } = s;
  if (c != null && c.active)
    for (const [g, v] of Object.entries(c.active))
      v !== void 0 && (u[g] = o.node.style.getPropertyValue(g), o.node.style.setProperty(g, v));
  if (c != null && c.dragOverlay)
    for (const [g, v] of Object.entries(c.dragOverlay))
      v !== void 0 && l.node.style.setProperty(g, v);
  return m != null && m.active && o.node.classList.add(m.active), m != null && m.dragOverlay && l.node.classList.add(m.dragOverlay), function() {
    for (const [g, v] of Object.entries(u))
      o.node.style.setProperty(g, v);
    m != null && m.active && o.node.classList.remove(m.active);
  };
}, I_ = ({
  transform: { initial: s, final: o }
}) => [
  {
    transform: mr.Transform.toString(s)
  },
  {
    transform: mr.Transform.toString(o)
  }
], L_ = {
  duration: 250,
  easing: "ease",
  keyframes: I_,
  sideEffects: T_({
    styles: {
      active: {
        opacity: "0"
      }
    }
  })
};
function M_({
  config: s,
  draggableNodes: o,
  droppableContainers: l,
  measuringConfiguration: u
}) {
  return (c, m) => {
    if (s === null)
      return;
    const g = o.get(c);
    if (!g)
      return;
    const v = g.node;
    if (!v)
      return;
    const b = ds(m);
    if (!b)
      return;
    const { transform: S } = Ge$1(m).getComputedStyle(m), E = ko(S);
    if (!E)
      return;
    const P = typeof s == "function" ? s : P_(s);
    return us(
      v,
      u.draggable.measure
    ), P({
      active: {
        id: c,
        data: g.data,
        node: v,
        rect: u.draggable.measure(v)
      },
      draggableNodes: o,
      dragOverlay: {
        node: m,
        rect: u.dragOverlay.measure(b)
      },
      droppableContainers: l,
      measuringConfiguration: u,
      transform: E
    });
  };
}
function P_(s) {
  const { duration: o, easing: l, sideEffects: u, keyframes: c } = {
    ...L_,
    ...s
  };
  return ({ active: m, dragOverlay: g, transform: v, ...b }) => {
    if (!o)
      return;
    const S = {
      x: g.rect.left - m.rect.left,
      y: g.rect.top - m.rect.top
    }, E = {
      scaleX: v.scaleX !== 1 ? m.rect.width * v.scaleX / g.rect.width : 1,
      scaleY: v.scaleY !== 1 ? m.rect.height * v.scaleY / g.rect.height : 1
    }, P = {
      x: v.x - S.x,
      y: v.y - S.y,
      ...E
    }, T = c({
      ...b,
      active: m,
      dragOverlay: g,
      transform: { initial: v, final: P }
    }), [N] = T, O = T[T.length - 1];
    if (JSON.stringify(N) === JSON.stringify(O))
      return;
    const z = (u == null ? void 0 : u({ active: m, dragOverlay: g, ...b })) || void 0, Q = g.node.animate(T, {
      duration: o,
      easing: l,
      fill: "forwards"
    });
    return new Promise((W) => {
      Q.onfinish = () => {
        console.log("onfinish"), z == null || z(), W();
      };
    });
  };
}
let Yu = 0;
function N_(s) {
  const o = ref$1(Yu);
  return watch(() => s == null ? void 0 : s.value, () => {
    Yu++, o.value = Yu;
  }), o;
}
const B_ = {
  adjustScale: {
    type: Boolean,
    default: !1
  },
  dropAnimation: {
    type: Object
  },
  style: {
    type: [Object]
  },
  transition: {
    type: [String, Object]
  },
  modifiers: {
    type: Array
  },
  wrapperElement: {
    type: String,
    default: "div"
  },
  className: {
    type: String
  },
  zIndex: {
    type: Number,
    default: 999
  }
}, X_ = /* @__PURE__ */ defineComponent((s, {}) => {
  const o = useSlots(), l = w_(), u = ps(), c = computed(() => {
    var P;
    return (P = l.value.active) == null ? void 0 : P.id;
  }), m = N_(c), g = computed(() => l.value.activeNodeRect), v = la(g), b = ref$1();
  watch([() => s.dropAnimation, () => l.value.draggableNodes, () => l.value.droppableContainers, () => l.value.measuringConfiguration], (P, T, N) => {
    b.value = M_({
      config: s.dropAnimation,
      draggableNodes: l.value.draggableNodes,
      droppableContainers: l.value.droppableContainers,
      measuringConfiguration: l.value.measuringConfiguration
    });
  }, {
    immediate: !0
  });
  const S = ref$1();
  watch([() => l.value.activatorEvent, () => {
    var P;
    return (P = l.value.active) == null ? void 0 : P.id;
  }, () => {
    var P;
    return (P = l.value.active) == null ? void 0 : P.data.value;
  }, () => {
    var P;
    return (P = l.value.active) == null ? void 0 : P.rect;
  }, () => l.value.activeNodeRect, () => l.value.containerNodeRect, () => l.value.dragOverlay.rect, () => {
    var P;
    return (P = l.value.over) == null ? void 0 : P.id;
  }, () => {
    var P;
    return (P = l.value.over) == null ? void 0 : P.rect;
  }, () => {
    var P;
    return (P = l.value.over) == null ? void 0 : P.data.value;
  }, () => {
    var P;
    return (P = l.value.over) == null ? void 0 : P.data.disabled;
  }, () => l.value.dragOverlay.rect, () => l.value.scrollableAncestors, () => l.value.scrollableAncestorRects, () => u.value, () => l.value.windowRect], (P, T, N) => {
    S.value = hs(s.modifiers, {
      activatorEvent: l.value.activatorEvent,
      active: l.value.active,
      activeNodeRect: l.value.activeNodeRect,
      containerNodeRect: l.value.containerNodeRect,
      draggingNodeRect: l.value.dragOverlay.rect,
      over: l.value.over,
      overlayNodeRect: l.value.dragOverlay.rect,
      scrollableAncestors: l.value.scrollableAncestors,
      scrollableAncestorRects: l.value.scrollableAncestorRects,
      transform: u.value,
      windowRect: l.value.windowRect
    });
  }, {
    immediate: !0
  });
  const E = computed(() => !!(l.value.active && m && m.value));
  return () => {
    const P = v.value ? l.value.dragOverlay.setRef : void 0;
    return createVNode(A_, null, {
      default: () => [createVNode(S_, {
        animation: b.value,
        children: E.value ? createVNode(O_, {
          key: m.value,
          id: l.value.active.id,
          setRef: P,
          as: s.wrapperElement,
          activatorEvent: l.value.activatorEvent,
          adjustScale: s.adjustScale,
          className: s.className,
          transition: s.transition,
          rect: v.value,
          style: {
            zIndex: s.zIndex,
            ...s.style
          },
          transform: S.value
        }, {
          default: o.default
        }) : null
      }, null)]
    });
  };
}, {
  props: B_,
  name: "DragOverlay"
});
function he$1(s, o) {
  const l = ref$1(s());
  return watch(o, () => {
    l.value = s();
  }, { immediate: !0 }), l;
}
var fg = Object.defineProperty, sg = (s, o, l) => o in s ? fg(s, o, { enumerable: !0, configurable: !0, writable: !0, value: l }) : s[o] = l, bt = (s, o, l) => (sg(s, typeof o != "symbol" ? o + "" : o, l), l);
function ul(s) {
  return shallowRef(s);
}
const hg = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function gi(s) {
  const o = Object.prototype.toString.call(s);
  return o === "[object Window]" || // In Electron context the Window object serializes to [object global]
  o === "[object global]";
}
function il(s) {
  return "nodeType" in s;
}
function Jt(s) {
  var o;
  return s ? gi(s) ? s : il(s) ? ((o = s.ownerDocument) == null ? void 0 : o.defaultView) ?? window : window : window;
}
function ol(s) {
  const { Document: o } = Jt(s);
  return s instanceof o;
}
function al(s) {
  return gi(s) ? !1 : s instanceof Jt(s).HTMLElement;
}
function vg(s) {
  return s instanceof Jt(s).SVGElement;
}
function Lr(s) {
  return s ? gi(s) ? s.document : il(s) ? ol(s) ? s : al(s) ? s.ownerDocument : document : document : document;
}
function hi(s, o = [s]) {
  const l = shallowRef(s.value);
  return watch(o, () => {
    l.value !== s.value && (l.value = s.value);
  }, { immediate: !0 }), l;
}
function vi(s) {
  const o = ul(s), l = ref$1(null);
  return [l, (u) => {
    var c;
    u !== l.value && ((c = o == null ? void 0 : o.value) == null || c.call(o, u, l.value)), l.value = u;
  }];
}
let ai = {};
function ll(s, o) {
  return computed(() => {
    const l = ai[s] == null ? 0 : ai[s] + 1;
    return ai[s] = l, `${s}-${l}`;
  });
}
function cl(s) {
  return (o, ...l) => l.reduce(
    (u, c) => {
      const m = Object.entries(c);
      for (const [g, v] of m) {
        const b = u[g];
        b != null && (u[g] = b + s * v);
      }
      return u;
    },
    {
      ...o
    }
  );
}
const pg = cl(1), pi = cl(-1);
function dg(s) {
  return "clientX" in s && "clientY" in s;
}
function gg(s) {
  if (!s)
    return !1;
  const { KeyboardEvent: o } = Jt(s.target);
  return o && s instanceof o;
}
function _g(s) {
  if (!s)
    return !1;
  const { TouchEvent: o } = Jt(s.target);
  return o && s instanceof o;
}
function Ha(s) {
  if (_g(s)) {
    if (s.touches && s.touches.length) {
      const { clientX: o, clientY: l } = s.touches[0];
      return {
        x: o,
        y: l
      };
    } else if (s.changedTouches && s.changedTouches.length) {
      const { clientX: o, clientY: l } = s.changedTouches[0];
      return {
        x: o,
        y: l
      };
    }
  }
  return dg(s) ? {
    x: s.clientX,
    y: s.clientY
  } : null;
}
var Te$1 = /* @__PURE__ */ ((s) => (s.DragStart = "dragStart", s.DragMove = "dragMove", s.DragEnd = "dragEnd", s.DragCancel = "dragCancel", s.DragOver = "dragOver", s.RegisterDroppable = "registerDroppable", s.SetDroppableDisabled = "setDroppableDisabled", s.UnregisterDroppable = "unregisterDroppable", s))(Te$1 || {});
function Le$1(...s) {
}
const Tr = Object.freeze({
  x: 0,
  y: 0
});
function yg(s, o) {
  return Math.sqrt(Math.pow(s.x - o.x, 2) + Math.pow(s.y - o.y, 2));
}
function mg({ data: { value: s } }, { data: { value: o } }) {
  return s - o;
}
function Za({ left: s, top: o, height: l, width: u }) {
  return [
    {
      x: s,
      y: o
    },
    {
      x: s + u,
      y: o
    },
    {
      x: s,
      y: o + l
    },
    {
      x: s + u,
      y: o + l
    }
  ];
}
function wg(s, o) {
  if (!s || s.length === 0)
    return null;
  const [l] = s;
  return l[o];
}
const bg = ({
  collisionRect: s,
  droppableRects: o,
  droppableContainers: l
}) => {
  const u = Za(s), c = [];
  for (const m of l) {
    const { id: g } = m, v = o.get(g);
    if (v) {
      const b = Za(v), S = u.reduce((P, T, N) => P + yg(b[N], T), 0), E = Number((S / 4).toFixed(4));
      c.push({
        id: g,
        data: { droppableContainer: m, value: E }
      });
    }
  }
  return c.sort(mg);
};
function xg(s) {
  if (s.startsWith("matrix3d(")) {
    const o = s.slice(9, -1).split(/, /);
    return {
      x: +o[12],
      y: +o[13],
      scaleX: +o[0],
      scaleY: +o[5]
    };
  } else if (s.startsWith("matrix(")) {
    const o = s.slice(7, -1).split(/, /);
    return {
      x: +o[4],
      y: +o[5],
      scaleX: +o[0],
      scaleY: +o[3]
    };
  }
  return null;
}
function Sg(s, o, l) {
  const u = xg(o);
  if (!u)
    return s;
  const { scaleX: c, scaleY: m, x: g, y: v } = u, b = s.left - g - (1 - c) * parseFloat(l), S = s.top - v - (1 - m) * parseFloat(l.slice(l.indexOf(" ") + 1)), E = c ? s.width / c : s.width, P = m ? s.height / m : s.height;
  return {
    width: E,
    height: P,
    top: S,
    right: b + E,
    bottom: S + P,
    left: b
  };
}
const Ag = { ignoreTransform: !1 };
function Be$1(s, o = Ag) {
  let l = s.getBoundingClientRect();
  if (o.ignoreTransform) {
    const { getComputedStyle: S } = Jt(s), { transform: E, transformOrigin: P } = S(s);
    E && (l = Sg(l, E, P));
  }
  const { top: u, left: c, width: m, height: g, bottom: v, right: b } = l;
  return {
    top: u,
    left: c,
    width: m,
    height: g,
    bottom: v,
    right: b
  };
}
function Ja(s) {
  return Be$1(s, { ignoreTransform: !0 });
}
function Ig(s, o = Jt(s).getComputedStyle(s)) {
  return o.position === "fixed";
}
function Rg(s, o = Jt(s).getComputedStyle(
  s
)) {
  const l = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((u) => {
    const c = o[u];
    return typeof c == "string" ? l.test(c) : !1;
  });
}
function fl(s, o) {
  const l = [];
  function u(c) {
    if (o != null && l.length >= o || !c)
      return l;
    if (ol(c) && c.scrollingElement != null && !l.includes(c.scrollingElement))
      return l.push(c.scrollingElement), l;
    if (!al(c) || vg(c) || l.includes(c))
      return l;
    const { getComputedStyle: m } = Jt(c), g = m(c);
    return c !== s && Rg(c, g) && l.push(c), Ig(c, g) ? l : u(c.parentNode);
  }
  return s ? u(s) : l;
}
function Cg(s) {
  const [o] = fl(s, 1);
  return o ?? null;
}
var jr = /* @__PURE__ */ ((s) => (s[s.Forward = 1] = "Forward", s[s.Backward = -1] = "Backward", s))(jr || {});
function Dg(s) {
  return !hg || !s ? !1 : s === document.scrollingElement;
}
function jg(s) {
  const o = {
    x: 0,
    y: 0
  }, l = Dg(s) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: s.clientHeight,
    width: s.clientWidth
  }, u = {
    x: s.scrollWidth - l.width,
    y: s.scrollHeight - l.height
  }, c = s.scrollTop <= o.y, m = s.scrollLeft <= o.x, g = s.scrollTop >= u.y, v = s.scrollLeft >= u.x;
  return {
    isTop: c,
    isLeft: m,
    isBottom: g,
    isRight: v,
    maxScroll: u,
    minScroll: o
  };
}
function Eg(s) {
  if (s === document.scrollingElement) {
    const { innerWidth: m, innerHeight: g } = window;
    return {
      top: 0,
      left: 0,
      right: m,
      bottom: g,
      width: m,
      height: g
    };
  }
  const { top: o, left: l, right: u, bottom: c } = s.getBoundingClientRect();
  return {
    top: o,
    left: l,
    right: u,
    bottom: c,
    width: s.clientWidth,
    height: s.clientHeight
  };
}
function Tg(s, o = Be$1) {
  if (!s)
    return;
  const { top: l, left: u, bottom: c, right: m } = o(s);
  Cg(s) && (c <= 0 || m <= 0 || l >= window.innerHeight || u >= window.innerWidth) && s.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
class Er {
  constructor(o) {
    bt(this, "listeners", []), bt(this, "removeAll", () => {
      this.listeners.forEach(
        (l) => {
          var u;
          return (u = this.target) == null ? void 0 : u.removeEventListener(...l);
        }
      );
    }), this.target = o;
  }
  add(o, l, u) {
    var c;
    (c = this.target) == null || c.addEventListener(o, l, u), this.listeners.push([o, l, u]);
  }
}
function Lg(s) {
  const { EventTarget: o } = Jt(s);
  return s instanceof o ? s : Lr(s);
}
function li(s, o) {
  const l = Math.abs(s.x), u = Math.abs(s.y);
  return typeof o == "number" ? Math.sqrt(l ** 2 + u ** 2) > o : "x" in o && "y" in o ? l > o.x && u > o.y : "x" in o ? l > o.x : "y" in o ? u > o.y : !1;
}
var on = /* @__PURE__ */ ((s) => (s.Click = "click", s.DragStart = "dragstart", s.Keydown = "keydown", s.ContextMenu = "contextmenu", s.Resize = "resize", s.SelectionChange = "selectionchange", s.VisibilityChange = "visibilitychange", s))(on || {});
function Qa(s) {
  s.preventDefault();
}
function kg(s) {
  s.stopPropagation();
}
var q$1 = /* @__PURE__ */ ((s) => (s.Space = "Space", s.Down = "ArrowDown", s.Right = "ArrowRight", s.Left = "ArrowLeft", s.Up = "ArrowUp", s.Esc = "Escape", s.Enter = "Enter", s))(q$1 || {});
const sl = {
  start: [q$1.Space, q$1.Enter],
  cancel: [q$1.Esc],
  end: [q$1.Space, q$1.Enter]
}, Og = (s, { currentCoordinates: o }) => {
  switch (s.code) {
    case q$1.Right:
      return {
        ...o,
        x: o.x + 25
      };
    case q$1.Left:
      return {
        ...o,
        x: o.x - 25
      };
    case q$1.Down:
      return {
        ...o,
        y: o.y + 25
      };
    case q$1.Up:
      return {
        ...o,
        y: o.y - 25
      };
  }
};
class zg {
  constructor(o) {
    bt(this, "autoScrollEnabled", !1), bt(this, "referenceCoordinates"), bt(this, "listeners"), bt(this, "windowListeners"), this.props = o;
    const {
      event: { target: l }
    } = o;
    this.props = o, this.listeners = new Er(Lr(l)), this.windowListeners = new Er(Jt(l)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(on.Resize, this.handleCancel), this.windowListeners.add(on.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(on.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const { activeNode: o, onStart: l } = this.props, u = o.node.current;
    u && Tg(u), l(Tr);
  }
  handleKeyDown(o) {
    if (gg(o)) {
      const { active: l, context: u, options: c } = this.props, {
        keyboardCodes: m = sl,
        coordinateGetter: g = Og,
        scrollBehavior: v = "smooth"
      } = c, { code: b } = o;
      if (m.end.includes(b)) {
        this.handleEnd(o);
        return;
      }
      if (m.cancel.includes(b)) {
        this.handleCancel(o);
        return;
      }
      const { collisionRect: S } = u.current, E = S ? { x: S.left, y: S.top } : Tr;
      this.referenceCoordinates || (this.referenceCoordinates = E);
      const P = g(o, {
        active: l,
        context: u.current,
        currentCoordinates: E
      });
      if (P) {
        const T = pi(
          P,
          E
        ), N = {
          x: 0,
          y: 0
        }, { scrollableAncestors: O } = u.current;
        for (const z of O) {
          const Q = o.code, { isTop: W, isRight: ue, isLeft: te, isBottom: K, maxScroll: ve, minScroll: ee } = jg(z), Re = Eg(z), wt = {
            x: Math.min(
              Q === q$1.Right ? Re.right - Re.width / 2 : Re.right,
              Math.max(
                Q === q$1.Right ? Re.left : Re.left + Re.width / 2,
                P.x
              )
            ),
            y: Math.min(
              Q === q$1.Down ? Re.bottom - Re.height / 2 : Re.bottom,
              Math.max(
                Q === q$1.Down ? Re.top : Re.top + Re.height / 2,
                P.y
              )
            )
          }, yt = Q === q$1.Right && !ue || Q === q$1.Left && !te, xt = Q === q$1.Down && !K || Q === q$1.Up && !W;
          if (yt && wt.x !== P.x) {
            const Kt = z.scrollLeft + T.x, tn = Q === q$1.Right && Kt <= ve.x || Q === q$1.Left && Kt >= ee.x;
            if (tn && !T.y) {
              z.scrollTo({
                left: Kt,
                behavior: v
              });
              return;
            }
            tn ? N.x = z.scrollLeft - Kt : N.x = Q === q$1.Right ? z.scrollLeft - ve.x : z.scrollLeft - ee.x, N.x && z.scrollBy({
              left: -N.x,
              behavior: v
            });
            break;
          } else if (xt && wt.y !== P.y) {
            const Kt = z.scrollTop + T.y, tn = Q === q$1.Down && Kt <= ve.y || Q === q$1.Up && Kt >= ee.y;
            if (tn && !T.x) {
              z.scrollTo({
                top: Kt,
                behavior: v
              });
              return;
            }
            tn ? N.y = z.scrollTop - Kt : N.y = Q === q$1.Down ? z.scrollTop - ve.y : z.scrollTop - ee.y, N.y && z.scrollBy({
              top: -N.y,
              behavior: v
            });
            break;
          }
        }
        this.handleMove(
          o,
          pg(
            pi(P, this.referenceCoordinates),
            N
          )
        );
      }
    }
  }
  handleMove(o, l) {
    const { onMove: u } = this.props;
    o.preventDefault(), u(l);
  }
  handleEnd(o) {
    const { onEnd: l } = this.props;
    o.preventDefault(), this.detach(), l();
  }
  handleCancel(o) {
    const { onCancel: l } = this.props;
    o.preventDefault(), this.detach(), l();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
bt(zg, "activators", [
  {
    eventName: "onKeydown",
    handler: (s, { keyboardCodes: o = sl, onActivation: l }, { active: u }) => {
      const { code: c } = s;
      if (o.start.includes(c)) {
        const m = u.activatorNode.current;
        return m && s.target !== m ? !1 : (s.preventDefault(), l == null || l({ event: s }), !0);
      }
      return !1;
    }
  }
]);
function tl(s) {
  return !!(s && "distance" in s);
}
function nl(s) {
  return !!(s && "delay" in s);
}
class _i {
  constructor(o, l, u = Lg(o.event.target)) {
    bt(this, "autoScrollEnabled", !0), bt(this, "document"), bt(this, "activated", !1), bt(this, "initialCoordinates"), bt(this, "timeoutId"), bt(this, "listeners"), bt(this, "documentListeners"), bt(this, "windowListeners"), this.props = o, this.events = l;
    const { event: c } = o, { target: m } = c;
    this.props = o, this.events = l, this.document = Lr(m), this.documentListeners = new Er(this.document), this.listeners = new Er(u), this.windowListeners = new Er(Jt(m)), this.initialCoordinates = Ha(c) ?? Tr, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: o,
      props: {
        options: { activationConstraint: l }
      }
    } = this;
    if (this.listeners.add(o.move.name, this.handleMove, { passive: !1 }), this.listeners.add(o.end.name, this.handleEnd), this.windowListeners.add(on.Resize, this.handleCancel), this.windowListeners.add(on.DragStart, Qa), this.windowListeners.add(on.VisibilityChange, this.handleCancel), this.windowListeners.add(on.ContextMenu, Qa), this.documentListeners.add(on.Keydown, this.handleKeydown), l) {
      if (tl(l))
        return;
      if (nl(l)) {
        this.timeoutId = setTimeout(
          this.handleStart,
          l.delay
        );
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handleStart() {
    const { initialCoordinates: o } = this, { onStart: l } = this.props;
    o && (this.activated = !0, this.documentListeners.add(on.Click, kg, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(
      on.SelectionChange,
      this.removeTextSelection
    ), l(o));
  }
  handleMove(o) {
    const { activated: l, initialCoordinates: u, props: c } = this, {
      onMove: m,
      options: { activationConstraint: g }
    } = c;
    if (!u)
      return;
    const v = Ha(o) ?? Tr, b = pi(u, v);
    if (!l && g) {
      if (nl(g))
        return li(b, g.tolerance) ? this.handleCancel() : void 0;
      if (tl(g))
        return g.tolerance != null && li(b, g.tolerance) ? this.handleCancel() : li(b, g.distance) ? this.handleStart() : void 0;
    }
    o.cancelable && o.preventDefault(), m(v);
  }
  handleEnd() {
    const { onEnd: o } = this.props;
    this.detach(), o();
  }
  handleCancel() {
    const { onCancel: o } = this.props;
    this.detach(), o();
  }
  handleKeydown(o) {
    o.code === q$1.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var o;
    (o = this.document.getSelection()) == null || o.removeAllRanges();
  }
}
const Mg = {
  move: { name: "pointermove" },
  end: { name: "pointerup" }
};
class Bg extends _i {
  constructor(o) {
    const { event: l } = o, u = Lr(l.target);
    super(o, Mg, u);
  }
}
bt(Bg, "activators", [
  {
    eventName: "onPointerdown",
    handler: (s, { onActivation: o }) => !s.isPrimary || s.button !== 0 ? !1 : (o == null || o({ event: s }), !0)
  }
]);
const Wg = {
  move: { name: "mousemove" },
  end: { name: "mouseup" }
};
class Ug extends _i {
  constructor(o) {
    super(o, Wg, Lr(o.event.target));
  }
}
bt(Ug, "activators", [
  {
    eventName: "onMousedown",
    handler: (s, { onActivation: o }) => s.button === 2 ? !1 : (o == null || o({ event: s }), !0)
  }
]);
const ci = {
  move: { name: "touchmove" },
  end: { name: "touchend" }
};
class Ng extends _i {
  constructor(o) {
    super(o, ci);
  }
  static setup() {
    return window.addEventListener(ci.move.name, o, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(ci.move.name, o);
    };
    function o() {
    }
  }
}
bt(Ng, "activators", [
  {
    eventName: "onTouchstart",
    handler: (s, { onActivation: o }) => {
      const { touches: l } = s;
      return l.length > 1 ? !1 : (o == null || o({ event: s }), !0);
    }
  }
]);
jr.Backward + "", jr.Forward + "", jr.Backward + "", jr.Forward + "";
var hl = /* @__PURE__ */ ((s) => (s[s.Always = 0] = "Always", s[s.BeforeDragging = 1] = "BeforeDragging", s[s.WhileDragging = 2] = "WhileDragging", s))(hl || {}), vl = /* @__PURE__ */ ((s) => (s.Optimized = "optimized", s))(vl || {});
function $g({ callback: s, disabled: o }) {
  const l = ul(s), u = shallowRef();
  return watch(() => o, () => {
    if (o || typeof window > "u" || typeof window.ResizeObserver > "u")
      return;
    const { ResizeObserver: c } = window;
    return new c(l.value);
  }, { immediate: !0 }), onUnmounted(() => () => {
    var c;
    return (c = u.value) == null ? void 0 : c.disconnect();
  }), u;
}
function Fg(s, o) {
  return computed(() => s.reduce(
    (l, { eventName: u, handler: c }) => (l[u] = (m) => {
      c(m, o.value);
    }, l),
    {}
  ));
}
const Kg = {
  draggable: {
    measure: Ja
  },
  droppable: {
    measure: Ja,
    strategy: hl.WhileDragging,
    frequency: vl.Optimized
  },
  dragOverlay: {
    measure: Be$1
  }
};
class Pg extends Map {
  get(o) {
    return o != null ? super.get(o) ?? void 0 : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter(({ disabled: o }) => !o);
  }
  getNodeFor(o) {
    var l;
    return ((l = this.get(o)) == null ? void 0 : l.node.current) ?? void 0;
  }
}
const qg = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: new Pg(),
  over: null,
  dragOverlay: {
    nodeRef: ref$1(null),
    rect: ref$1(null),
    setRef: Le$1
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: Kg,
  measureDroppableContainers: Le$1,
  windowRect: null,
  measuringScheduled: !1
}, Vg = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: Le$1,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: Le$1
};
function Yg() {
  return inject("DndContext", ref$1({
    ...Tr,
    scaleX: 1,
    scaleY: 1
  }));
}
function pl() {
  return inject("InternalContext", ref$1(Vg));
}
const rl = "button", Xg = "Droppable";
function Gg({
  id: s,
  data: o,
  disabled: l,
  attributes: u
}) {
  const c = ll(Xg), m = pl(), g = Yg(), { role: v = rl, roleDescription: b = "draggable", tabIndex: S = 0 } = u ?? {}, E = computed(() => {
    var ve;
    return (ve = m.value.active) == null ? void 0 : ve.id;
  }), P = ref$1(!1);
  watch(E, () => {
    var ve;
    P.value = ((ve = m.value.active) == null ? void 0 : ve.id) === s.value;
  }, { immediate: !0 });
  const T = computed(() => P.value ? g.value : null), [N, O] = vi(), [z, Q] = vi(), W = Fg(m.value.activators, s), ue = hi(computed(() => o == null ? void 0 : o.value));
  watch([() => m.value.draggableNodes, () => s.value], () => (m.value.draggableNodes.set(s.value, { id: s.value, key: c.value, node: N, activatorNode: z, data: ue }), () => {
    const ve = m.value.draggableNodes.get(s.value);
    ve && ve.key === c.value && m.value.draggableNodes.delete(s.value);
  }), { immediate: !0 });
  const te = ref$1(K());
  function K() {
    return {
      role: v,
      tabIndex: S,
      "aria-disabled": l == null ? void 0 : l.value,
      "aria-pressed": P.value && v === rl ? !0 : void 0,
      "aria-roledescription": b,
      "aria-describedby": m.value.ariaDescribedById.draggable
    };
  }
  return watch([
    () => P.value,
    () => l == null ? void 0 : l.value,
    () => m.value.ariaDescribedById.draggable
  ], () => {
    te.value = K();
  }), {
    internalContext: m,
    isDragging: P,
    attributes: te,
    listeners: computed(() => l != null && l.value ? void 0 : W.value),
    node: N,
    setNodeRef: O,
    setActivatorNodeRef: Q,
    transform: T
  };
}
function Hg() {
  return inject("PublicContext", ref$1(qg));
}
var Dr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ke$1 = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
ke$1.exports;
(function(s, o) {
  (function() {
    var l, u = "4.17.21", c = 200, m = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", g = "Expected a function", v = "Invalid `variable` option passed into `_.template`", b = "__lodash_hash_undefined__", S = 500, E = "__lodash_placeholder__", P = 1, T = 2, N = 4, O = 1, z = 2, Q = 1, W = 2, ue = 4, te = 8, K = 16, ve = 32, ee = 64, Re = 128, wt = 256, yt = 512, xt = 30, Kt = "...", tn = 800, ln = 16, rn = 1, an = 2, Gt = 3, nn = 1 / 0, vt = 9007199254740991, Et = 17976931348623157e292, Qt = NaN, un = 4294967295, gn = un - 1, dn = un >>> 1, yn = [
      ["ary", Re],
      ["bind", Q],
      ["bindKey", W],
      ["curry", te],
      ["curryRight", K],
      ["flip", yt],
      ["partial", ve],
      ["partialRight", ee],
      ["rearg", wt]
    ], vn = "[object Arguments]", Pn = "[object Array]", On = "[object AsyncFunction]", _n = "[object Boolean]", Nn = "[object Date]", Un = "[object DOMException]", Xn = "[object Error]", zn = "[object Function]", jn = "[object GeneratorFunction]", kn = "[object Map]", Yn = "[object Number]", Zn = "[object Null]", er = "[object Object]", bn = "[object Promise]", Ln = "[object Proxy]", Kn = "[object RegExp]", Bn = "[object Set]", Fn = "[object String]", Gn = "[object Symbol]", Wn = "[object Undefined]", Mn = "[object WeakMap]", Tn = "[object WeakSet]", Rn = "[object ArrayBuffer]", hn = "[object DataView]", Qn = "[object Float32Array]", rr = "[object Float64Array]", tr = "[object Int8Array]", Cr = "[object Int16Array]", Fr = "[object Int32Array]", An = "[object Uint8Array]", Hn = "[object Uint8ClampedArray]", ir = "[object Uint16Array]", dr = "[object Uint32Array]", ar = /\b__p \+= '';/g, Or = /\b(__p \+=) '' \+/g, Sr = /(__e\(.*?\)|\b__t\)) \+\n'';/g, kr = /&(?:amp|lt|gt|quot|#39);/g, Nr = /[&<>"']/g, Ur = RegExp(kr.source), _r = RegExp(Nr.source), Zr = /<%-([\s\S]+?)%>/g, Jr = /<%([\s\S]+?)%>/g, ii = /<%=([\s\S]+?)%>/g, Ti = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Mi = /^\w*$/, ui = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, Ii = /[\\^$.*+?()[\]{}|]/g, bs = RegExp(Ii.source), Oi = /^\s+/, Vs = /\s/, _s = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Is = /\{\n\/\* \[wrapped with (.+)\] \*/, Fa = /,? & /, io = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Da = /[()=,{}\[\]\/\s]/, oo = /\\(\\)?/g, Xs = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, so = /\w*$/, Ol = /^[-+]0x[0-9a-f]+$/i, kl = /^0b[01]+$/i, uc = /^\[object .+?Constructor\]$/, Vl = /^0o[0-7]+$/i, Ma = /^(?:0|[1-9]\d*)$/, Ll = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Oa = /($^)/, cc = /['\n\r\u2028\u2029\\]/g, va = "\\ud800-\\udfff", yc = "\\u0300-\\u036f", vc = "\\ufe20-\\ufe2f", Af = "\\u20d0-\\u20ff", Yr = yc + vc + Af, Ra = "\\u2700-\\u27bf", Bl = "a-z\\xdf-\\xf6\\xf8-\\xff", Nf = "\\xac\\xb1\\xd7\\xf7", Ff = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", xc = "\\u2000-\\u206f", Df = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", zl = "A-Z\\xc0-\\xd6\\xd8-\\xde", La = "\\ufe0e\\ufe0f", ya = Nf + Ff + xc + Df, Al = "['’]", bc = "[" + va + "]", dc = "[" + ya + "]", ao = "[" + Yr + "]", fc = "\\d+", Rf = "[" + Ra + "]", Nl = "[" + Bl + "]", jl = "[^" + va + ya + fc + Ra + Bl + zl + "]", lo = "\\ud83c[\\udffb-\\udfff]", Cc = "(?:" + ao + "|" + lo + ")", Fl = "[^" + va + "]", ki = "(?:\\ud83c[\\udde6-\\uddff]){2}", Dl = "[\\ud800-\\udbff][\\udc00-\\udfff]", Js = "[" + zl + "]", Hl = "\\u200d", Ul = "(?:" + Nl + "|" + jl + ")", Of = "(?:" + Js + "|" + jl + ")", pc = "(?:" + Al + "(?:d|ll|m|re|s|t|ve))?", hc = "(?:" + Al + "(?:D|LL|M|RE|S|T|VE))?", de = Cc + "?", en = "[" + La + "]?", mn = "(?:" + Hl + "(?:" + [Fl, ki, Dl].join("|") + ")" + en + de + ")*", $n = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", Vn = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", sr = en + de + mn, cr = "(?:" + [Rf, ki, Dl].join("|") + ")" + sr, Br = "(?:" + [Fl + ao + "?", ao, ki, Dl, bc].join("|") + ")", Kr = RegExp(Al, "g"), Li = RegExp(ao, "g"), Pi = RegExp(lo + "(?=" + lo + ")|" + Br + sr, "g"), Zs = RegExp([
      Js + "?" + Nl + "+" + pc + "(?=" + [dc, Js, "$"].join("|") + ")",
      Of + "+" + hc + "(?=" + [dc, Js + Ul, "$"].join("|") + ")",
      Js + "?" + Ul + "+" + pc,
      Js + "+" + hc,
      Vn,
      $n,
      fc,
      cr
    ].join("|"), "g"), Rl = RegExp("[" + Hl + va + Yr + La + "]"), Kl = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, Ml = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], mc = -1, Wr = {};
    Wr[Qn] = Wr[rr] = Wr[tr] = Wr[Cr] = Wr[Fr] = Wr[An] = Wr[Hn] = Wr[ir] = Wr[dr] = !0, Wr[vn] = Wr[Pn] = Wr[Rn] = Wr[_n] = Wr[hn] = Wr[Nn] = Wr[Xn] = Wr[zn] = Wr[kn] = Wr[Yn] = Wr[er] = Wr[Kn] = Wr[Bn] = Wr[Fn] = Wr[Mn] = !1;
    var Hr = {};
    Hr[vn] = Hr[Pn] = Hr[Rn] = Hr[hn] = Hr[_n] = Hr[Nn] = Hr[Qn] = Hr[rr] = Hr[tr] = Hr[Cr] = Hr[Fr] = Hr[kn] = Hr[Yn] = Hr[er] = Hr[Kn] = Hr[Bn] = Hr[Fn] = Hr[Gn] = Hr[An] = Hr[Hn] = Hr[ir] = Hr[dr] = !0, Hr[Xn] = Hr[zn] = Hr[Mn] = !1;
    var Mf = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, Vf = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, Bf = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, zf = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, jf = parseFloat, Hf = parseInt, Sc = typeof Dr == "object" && Dr && Dr.Object === Object && Dr, Uf = typeof self == "object" && self && self.Object === Object && self, di = Sc || Uf || Function("return this")(), Wl = o && !o.nodeType && o, Qs = Wl && !0 && s && !s.nodeType && s, $c = Qs && Qs.exports === Wl, Gl = $c && Sc.process, Yi = function() {
      try {
        var fn = Qs && Qs.require && Qs.require("util").types;
        return fn || Gl && Gl.binding && Gl.binding("util");
      } catch {
      }
    }(), wc = Yi && Yi.isArrayBuffer, _c = Yi && Yi.isDate, Ec = Yi && Yi.isMap, Pc = Yi && Yi.isRegExp, Tc = Yi && Yi.isSet, Ic = Yi && Yi.isTypedArray;
    function Hi(fn, wn, xn) {
      switch (xn.length) {
        case 0:
          return fn.call(wn);
        case 1:
          return fn.call(wn, xn[0]);
        case 2:
          return fn.call(wn, xn[0], xn[1]);
        case 3:
          return fn.call(wn, xn[0], xn[1], xn[2]);
      }
      return fn.apply(wn, xn);
    }
    function Kf(fn, wn, xn, Jn) {
      for (var fr = -1, Mr = fn == null ? 0 : fn.length; ++fr < Mr; ) {
        var ni = fn[fr];
        wn(Jn, ni, xn(ni), fn);
      }
      return Jn;
    }
    function Xi(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function Wf(fn, wn) {
      for (var xn = fn == null ? 0 : fn.length; xn-- && wn(fn[xn], xn, fn) !== !1; )
        ;
      return fn;
    }
    function kc(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (!wn(fn[xn], xn, fn))
          return !1;
      return !0;
    }
    function Bs(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        wn(ni, xn, fn) && (Mr[fr++] = ni);
      }
      return Mr;
    }
    function uo(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return !!xn && xa(fn, wn, 0) > -1;
    }
    function ql(fn, wn, xn) {
      for (var Jn = -1, fr = fn == null ? 0 : fn.length; ++Jn < fr; )
        if (xn(wn, fn[Jn]))
          return !0;
      return !1;
    }
    function qr(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length, fr = Array(Jn); ++xn < Jn; )
        fr[xn] = wn(fn[xn], xn, fn);
      return fr;
    }
    function zs(fn, wn) {
      for (var xn = -1, Jn = wn.length, fr = fn.length; ++xn < Jn; )
        fn[fr + xn] = wn[xn];
      return fn;
    }
    function Yl(fn, wn, xn, Jn) {
      var fr = -1, Mr = fn == null ? 0 : fn.length;
      for (Jn && Mr && (xn = fn[++fr]); ++fr < Mr; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Gf(fn, wn, xn, Jn) {
      var fr = fn == null ? 0 : fn.length;
      for (Jn && fr && (xn = fn[--fr]); fr--; )
        xn = wn(xn, fn[fr], fr, fn);
      return xn;
    }
    function Xl(fn, wn) {
      for (var xn = -1, Jn = fn == null ? 0 : fn.length; ++xn < Jn; )
        if (wn(fn[xn], xn, fn))
          return !0;
      return !1;
    }
    var qf = Zl("length");
    function Yf(fn) {
      return fn.split("");
    }
    function Xf(fn) {
      return fn.match(io) || [];
    }
    function Ac(fn, wn, xn) {
      var Jn;
      return xn(fn, function(fr, Mr, ni) {
        if (wn(fr, Mr, ni))
          return Jn = Mr, !1;
      }), Jn;
    }
    function co(fn, wn, xn, Jn) {
      for (var fr = fn.length, Mr = xn + (Jn ? 1 : -1); Jn ? Mr-- : ++Mr < fr; )
        if (wn(fn[Mr], Mr, fn))
          return Mr;
      return -1;
    }
    function xa(fn, wn, xn) {
      return wn === wn ? lp(fn, wn, xn) : co(fn, Nc, xn);
    }
    function Zf(fn, wn, xn, Jn) {
      for (var fr = xn - 1, Mr = fn.length; ++fr < Mr; )
        if (Jn(fn[fr], wn))
          return fr;
      return -1;
    }
    function Nc(fn) {
      return fn !== fn;
    }
    function Fc(fn, wn) {
      var xn = fn == null ? 0 : fn.length;
      return xn ? Ql(fn, wn) / xn : Qt;
    }
    function Zl(fn) {
      return function(wn) {
        return wn == null ? l : wn[fn];
      };
    }
    function Jl(fn) {
      return function(wn) {
        return fn == null ? l : fn[wn];
      };
    }
    function Dc(fn, wn, xn, Jn, fr) {
      return fr(fn, function(Mr, ni, Gr) {
        xn = Jn ? (Jn = !1, Mr) : wn(xn, Mr, ni, Gr);
      }), xn;
    }
    function Jf(fn, wn) {
      var xn = fn.length;
      for (fn.sort(wn); xn--; )
        fn[xn] = fn[xn].value;
      return fn;
    }
    function Ql(fn, wn) {
      for (var xn, Jn = -1, fr = fn.length; ++Jn < fr; ) {
        var Mr = wn(fn[Jn]);
        Mr !== l && (xn = xn === l ? Mr : xn + Mr);
      }
      return xn;
    }
    function eu(fn, wn) {
      for (var xn = -1, Jn = Array(fn); ++xn < fn; )
        Jn[xn] = wn(xn);
      return Jn;
    }
    function Qf(fn, wn) {
      return qr(wn, function(xn) {
        return [xn, fn[xn]];
      });
    }
    function Rc(fn) {
      return fn && fn.slice(0, Vc(fn) + 1).replace(Oi, "");
    }
    function Ui(fn) {
      return function(wn) {
        return fn(wn);
      };
    }
    function tu(fn, wn) {
      return qr(wn, function(xn) {
        return fn[xn];
      });
    }
    function Va(fn, wn) {
      return fn.has(wn);
    }
    function Oc(fn, wn) {
      for (var xn = -1, Jn = fn.length; ++xn < Jn && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function Lc(fn, wn) {
      for (var xn = fn.length; xn-- && xa(wn, fn[xn], 0) > -1; )
        ;
      return xn;
    }
    function ep(fn, wn) {
      for (var xn = fn.length, Jn = 0; xn--; )
        fn[xn] === wn && ++Jn;
      return Jn;
    }
    var tp = Jl(Mf), np = Jl(Vf);
    function rp(fn) {
      return "\\" + zf[fn];
    }
    function ip(fn, wn) {
      return fn == null ? l : fn[wn];
    }
    function ba(fn) {
      return Rl.test(fn);
    }
    function sp(fn) {
      return Kl.test(fn);
    }
    function ap(fn) {
      for (var wn, xn = []; !(wn = fn.next()).done; )
        xn.push(wn.value);
      return xn;
    }
    function nu(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn, fr) {
        xn[++wn] = [fr, Jn];
      }), xn;
    }
    function Mc(fn, wn) {
      return function(xn) {
        return fn(wn(xn));
      };
    }
    function Hs(fn, wn) {
      for (var xn = -1, Jn = fn.length, fr = 0, Mr = []; ++xn < Jn; ) {
        var ni = fn[xn];
        (ni === wn || ni === E) && (fn[xn] = E, Mr[fr++] = xn);
      }
      return Mr;
    }
    function fo(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = Jn;
      }), xn;
    }
    function op(fn) {
      var wn = -1, xn = Array(fn.size);
      return fn.forEach(function(Jn) {
        xn[++wn] = [Jn, Jn];
      }), xn;
    }
    function lp(fn, wn, xn) {
      for (var Jn = xn - 1, fr = fn.length; ++Jn < fr; )
        if (fn[Jn] === wn)
          return Jn;
      return -1;
    }
    function up(fn, wn, xn) {
      for (var Jn = xn + 1; Jn--; )
        if (fn[Jn] === wn)
          return Jn;
      return Jn;
    }
    function Ca(fn) {
      return ba(fn) ? dp(fn) : qf(fn);
    }
    function Cs(fn) {
      return ba(fn) ? fp(fn) : Yf(fn);
    }
    function Vc(fn) {
      for (var wn = fn.length; wn-- && Vs.test(fn.charAt(wn)); )
        ;
      return wn;
    }
    var cp = Jl(Bf);
    function dp(fn) {
      for (var wn = Pi.lastIndex = 0; Pi.test(fn); )
        ++wn;
      return wn;
    }
    function fp(fn) {
      return fn.match(Pi) || [];
    }
    function hp(fn) {
      return fn.match(Zs) || [];
    }
    var mp = function fn(wn) {
      wn = wn == null ? di : Sa.defaults(di.Object(), wn, Sa.pick(di, Ml));
      var xn = wn.Array, Jn = wn.Date, fr = wn.Error, Mr = wn.Function, ni = wn.Math, Gr = wn.Object, ru = wn.RegExp, gp = wn.String, Zi = wn.TypeError, po = xn.prototype, yp = Mr.prototype, $a = Gr.prototype, ho = wn["__core-js_shared__"], mo = yp.toString, zr = $a.hasOwnProperty, vp = 0, Bc = function() {
        var f = /[^.]+$/.exec(ho && ho.keys && ho.keys.IE_PROTO || "");
        return f ? "Symbol(src)_1." + f : "";
      }(), go = $a.toString, xp = mo.call(Gr), bp = di._, Cp = ru(
        "^" + mo.call(zr).replace(Ii, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), yo = $c ? wn.Buffer : l, Us = wn.Symbol, vo = wn.Uint8Array, zc = yo ? yo.allocUnsafe : l, xo = Mc(Gr.getPrototypeOf, Gr), jc = Gr.create, Hc = $a.propertyIsEnumerable, bo = po.splice, Uc = Us ? Us.isConcatSpreadable : l, Ba = Us ? Us.iterator : l, sa = Us ? Us.toStringTag : l, Co = function() {
        try {
          var f = ha(Gr, "defineProperty");
          return f({}, "", {}), f;
        } catch {
        }
      }(), Sp = wn.clearTimeout !== di.clearTimeout && wn.clearTimeout, wp = Jn && Jn.now !== di.Date.now && Jn.now, _p = wn.setTimeout !== di.setTimeout && wn.setTimeout, So = ni.ceil, wo = ni.floor, iu = Gr.getOwnPropertySymbols, Ep = yo ? yo.isBuffer : l, Kc = wn.isFinite, Pp = po.join, Tp = Mc(Gr.keys, Gr), ri = ni.max, wi = ni.min, Ip = Jn.now, Ap = wn.parseInt, Wc = ni.random, Np = po.reverse, su = ha(wn, "DataView"), za = ha(wn, "Map"), au = ha(wn, "Promise"), wa = ha(wn, "Set"), ja = ha(wn, "WeakMap"), Ua = ha(Gr, "create"), _o = ja && new ja(), Ea = {}, Fp = ma(su), Dp = ma(za), Rp = ma(au), Op = ma(wa), Lp = ma(ja), Eo = Us ? Us.prototype : l, Ka = Eo ? Eo.valueOf : l, Gc = Eo ? Eo.toString : l;
      function Ft(f) {
        if (Qr(f) && !pr(f) && !(f instanceof Pr)) {
          if (f instanceof Ji)
            return f;
          if (zr.call(f, "__wrapped__"))
            return Yd(f);
        }
        return new Ji(f);
      }
      var Pa = /* @__PURE__ */ function() {
        function f() {
        }
        return function(y) {
          if (!Xr(y))
            return {};
          if (jc)
            return jc(y);
          f.prototype = y;
          var w = new f();
          return f.prototype = l, w;
        };
      }();
      function Po() {
      }
      function Ji(f, y) {
        this.__wrapped__ = f, this.__actions__ = [], this.__chain__ = !!y, this.__index__ = 0, this.__values__ = l;
      }
      Ft.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Zr,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Jr,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: ii,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: Ft
        }
      }, Ft.prototype = Po.prototype, Ft.prototype.constructor = Ft, Ji.prototype = Pa(Po.prototype), Ji.prototype.constructor = Ji;
      function Pr(f) {
        this.__wrapped__ = f, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = un, this.__views__ = [];
      }
      function Mp() {
        var f = new Pr(this.__wrapped__);
        return f.__actions__ = Vi(this.__actions__), f.__dir__ = this.__dir__, f.__filtered__ = this.__filtered__, f.__iteratees__ = Vi(this.__iteratees__), f.__takeCount__ = this.__takeCount__, f.__views__ = Vi(this.__views__), f;
      }
      function Bp() {
        if (this.__filtered__) {
          var f = new Pr(this);
          f.__dir__ = -1, f.__filtered__ = !0;
        } else
          f = this.clone(), f.__dir__ *= -1;
        return f;
      }
      function zp() {
        var f = this.__wrapped__.value(), y = this.__dir__, w = pr(f), Y = y < 0, dt = w ? f.length : 0, Wt = rm(0, dt, this.__views__), sn = Wt.start, cn = Wt.end, pn = cn - sn, En = Y ? cn : sn - 1, In = this.__iteratees__, Dn = In.length, qn = 0, nr = wi(pn, this.__takeCount__);
        if (!w || !Y && dt == pn && nr == pn)
          return vd(f, this.__actions__);
        var lr = [];
        e:
          for (; pn-- && qn < nr; ) {
            En += y;
            for (var gr = -1, ur = f[En]; ++gr < Dn; ) {
              var $r = In[gr], Ir = $r.iteratee, Gi = $r.type, Fi = Ir(ur);
              if (Gi == an)
                ur = Fi;
              else if (!Fi) {
                if (Gi == rn)
                  continue e;
                break e;
              }
            }
            lr[qn++] = ur;
          }
        return lr;
      }
      Pr.prototype = Pa(Po.prototype), Pr.prototype.constructor = Pr;
      function ca(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Up() {
        this.__data__ = Ua ? Ua(null) : {}, this.size = 0;
      }
      function Kp(f) {
        var y = this.has(f) && delete this.__data__[f];
        return this.size -= y ? 1 : 0, y;
      }
      function Wp(f) {
        var y = this.__data__;
        if (Ua) {
          var w = y[f];
          return w === b ? l : w;
        }
        return zr.call(y, f) ? y[f] : l;
      }
      function Gp(f) {
        var y = this.__data__;
        return Ua ? y[f] !== l : zr.call(y, f);
      }
      function qp(f, y) {
        var w = this.__data__;
        return this.size += this.has(f) ? 0 : 1, w[f] = Ua && y === l ? b : y, this;
      }
      ca.prototype.clear = Up, ca.prototype.delete = Kp, ca.prototype.get = Wp, ca.prototype.has = Gp, ca.prototype.set = qp;
      function ks(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function Yp() {
        this.__data__ = [], this.size = 0;
      }
      function Xp(f) {
        var y = this.__data__, w = To(y, f);
        if (w < 0)
          return !1;
        var Y = y.length - 1;
        return w == Y ? y.pop() : bo.call(y, w, 1), --this.size, !0;
      }
      function Zp(f) {
        var y = this.__data__, w = To(y, f);
        return w < 0 ? l : y[w][1];
      }
      function eh(f) {
        return To(this.__data__, f) > -1;
      }
      function th(f, y) {
        var w = this.__data__, Y = To(w, f);
        return Y < 0 ? (++this.size, w.push([f, y])) : w[Y][1] = y, this;
      }
      ks.prototype.clear = Yp, ks.prototype.delete = Xp, ks.prototype.get = Zp, ks.prototype.has = eh, ks.prototype.set = th;
      function As(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.clear(); ++y < w; ) {
          var Y = f[y];
          this.set(Y[0], Y[1]);
        }
      }
      function nh() {
        this.size = 0, this.__data__ = {
          hash: new ca(),
          map: new (za || ks)(),
          string: new ca()
        };
      }
      function rh(f) {
        var y = el(this, f).delete(f);
        return this.size -= y ? 1 : 0, y;
      }
      function ih(f) {
        return el(this, f).get(f);
      }
      function sh(f) {
        return el(this, f).has(f);
      }
      function ah(f, y) {
        var w = el(this, f), Y = w.size;
        return w.set(f, y), this.size += w.size == Y ? 0 : 1, this;
      }
      As.prototype.clear = nh, As.prototype.delete = rh, As.prototype.get = ih, As.prototype.has = sh, As.prototype.set = ah;
      function da(f) {
        var y = -1, w = f == null ? 0 : f.length;
        for (this.__data__ = new As(); ++y < w; )
          this.add(f[y]);
      }
      function oh(f) {
        return this.__data__.set(f, b), this;
      }
      function lh(f) {
        return this.__data__.has(f);
      }
      da.prototype.add = da.prototype.push = oh, da.prototype.has = lh;
      function Ss(f) {
        var y = this.__data__ = new ks(f);
        this.size = y.size;
      }
      function uh() {
        this.__data__ = new ks(), this.size = 0;
      }
      function ch(f) {
        var y = this.__data__, w = y.delete(f);
        return this.size = y.size, w;
      }
      function dh(f) {
        return this.__data__.get(f);
      }
      function fh(f) {
        return this.__data__.has(f);
      }
      function ph(f, y) {
        var w = this.__data__;
        if (w instanceof ks) {
          var Y = w.__data__;
          if (!za || Y.length < c - 1)
            return Y.push([f, y]), this.size = ++w.size, this;
          w = this.__data__ = new As(Y);
        }
        return w.set(f, y), this.size = w.size, this;
      }
      Ss.prototype.clear = uh, Ss.prototype.delete = ch, Ss.prototype.get = dh, Ss.prototype.has = fh, Ss.prototype.set = ph;
      function qc(f, y) {
        var w = pr(f), Y = !w && ga(f), dt = !w && !Y && Ys(f), Wt = !w && !Y && !dt && Aa(f), sn = w || Y || dt || Wt, cn = sn ? eu(f.length, gp) : [], pn = cn.length;
        for (var En in f)
          (y || zr.call(f, En)) && !(sn && // Safari 9 has enumerable `arguments.length` in strict mode.
          (En == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          dt && (En == "offset" || En == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          Wt && (En == "buffer" || En == "byteLength" || En == "byteOffset") || // Skip index properties.
          Rs(En, pn))) && cn.push(En);
        return cn;
      }
      function Yc(f) {
        var y = f.length;
        return y ? f[yu(0, y - 1)] : l;
      }
      function hh(f, y) {
        return xl(Vi(f), fa(y, 0, f.length));
      }
      function mh(f) {
        return xl(Vi(f));
      }
      function ou(f, y, w) {
        (w !== l && !$s(f[y], w) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function Wa(f, y, w) {
        var Y = f[y];
        (!(zr.call(f, y) && $s(Y, w)) || w === l && !(y in f)) && Ns(f, y, w);
      }
      function To(f, y) {
        for (var w = f.length; w--; )
          if ($s(f[w][0], y))
            return w;
        return -1;
      }
      function gh(f, y, w, Y) {
        return Ks(f, function(dt, Wt, sn) {
          y(Y, dt, w(dt), sn);
        }), Y;
      }
      function Xc(f, y) {
        return f && Ps(y, oi(y), f);
      }
      function yh(f, y) {
        return f && Ps(y, zi(y), f);
      }
      function Ns(f, y, w) {
        y == "__proto__" && Co ? Co(f, y, {
          configurable: !0,
          enumerable: !0,
          value: w,
          writable: !0
        }) : f[y] = w;
      }
      function lu(f, y) {
        for (var w = -1, Y = y.length, dt = xn(Y), Wt = f == null; ++w < Y; )
          dt[w] = Wt ? l : ec(f, y[w]);
        return dt;
      }
      function fa(f, y, w) {
        return f === f && (w !== l && (f = f <= w ? f : w), y !== l && (f = f >= y ? f : y)), f;
      }
      function Qi(f, y, w, Y, dt, Wt) {
        var sn, cn = y & P, pn = y & T, En = y & N;
        if (w && (sn = dt ? w(f, Y, dt, Wt) : w(f)), sn !== l)
          return sn;
        if (!Xr(f))
          return f;
        var In = pr(f);
        if (In) {
          if (sn = sm(f), !cn)
            return Vi(f, sn);
        } else {
          var Dn = Ei(f), qn = Dn == zn || Dn == jn;
          if (Ys(f))
            return Cd(f, cn);
          if (Dn == er || Dn == vn || qn && !dt) {
            if (sn = pn || qn ? {} : Bd(f), !cn)
              return pn ? qh(f, yh(sn, f)) : Gh(f, Xc(sn, f));
          } else {
            if (!Hr[Dn])
              return dt ? f : {};
            sn = am(f, Dn, cn);
          }
        }
        Wt || (Wt = new Ss());
        var nr = Wt.get(f);
        if (nr)
          return nr;
        Wt.set(f, sn), gf(f) ? f.forEach(function(ur) {
          sn.add(Qi(ur, y, w, ur, f, Wt));
        }) : hf(f) && f.forEach(function(ur, $r) {
          sn.set($r, Qi(ur, y, w, $r, f, Wt));
        });
        var lr = En ? pn ? Iu : Tu : pn ? zi : oi, gr = In ? l : lr(f);
        return Xi(gr || f, function(ur, $r) {
          gr && ($r = ur, ur = f[$r]), Wa(sn, $r, Qi(ur, y, w, $r, f, Wt));
        }), sn;
      }
      function vh(f) {
        var y = oi(f);
        return function(w) {
          return Zc(w, f, y);
        };
      }
      function Zc(f, y, w) {
        var Y = w.length;
        if (f == null)
          return !Y;
        for (f = Gr(f); Y--; ) {
          var dt = w[Y], Wt = y[dt], sn = f[dt];
          if (sn === l && !(dt in f) || !Wt(sn))
            return !1;
        }
        return !0;
      }
      function Jc(f, y, w) {
        if (typeof f != "function")
          throw new Zi(g);
        return no(function() {
          f.apply(l, w);
        }, y);
      }
      function Ga(f, y, w, Y) {
        var dt = -1, Wt = uo, sn = !0, cn = f.length, pn = [], En = y.length;
        if (!cn)
          return pn;
        w && (y = qr(y, Ui(w))), Y ? (Wt = ql, sn = !1) : y.length >= c && (Wt = Va, sn = !1, y = new da(y));
        e:
          for (; ++dt < cn; ) {
            var In = f[dt], Dn = w == null ? In : w(In);
            if (In = Y || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = En; qn--; )
                if (y[qn] === Dn)
                  continue e;
              pn.push(In);
            } else
              Wt(y, Dn, Y) || pn.push(In);
          }
        return pn;
      }
      var Ks = Ed(Es), Qc = Ed(cu, !0);
      function xh(f, y) {
        var w = !0;
        return Ks(f, function(Y, dt, Wt) {
          return w = !!y(Y, dt, Wt), w;
        }), w;
      }
      function Io(f, y, w) {
        for (var Y = -1, dt = f.length; ++Y < dt; ) {
          var Wt = f[Y], sn = y(Wt);
          if (sn != null && (cn === l ? sn === sn && !Wi(sn) : w(sn, cn)))
            var cn = sn, pn = Wt;
        }
        return pn;
      }
      function bh(f, y, w, Y) {
        var dt = f.length;
        for (w = hr(w), w < 0 && (w = -w > dt ? 0 : dt + w), Y = Y === l || Y > dt ? dt : hr(Y), Y < 0 && (Y += dt), Y = w > Y ? 0 : vf(Y); w < Y; )
          f[w++] = y;
        return f;
      }
      function ed(f, y) {
        var w = [];
        return Ks(f, function(Y, dt, Wt) {
          y(Y, dt, Wt) && w.push(Y);
        }), w;
      }
      function $i(f, y, w, Y, dt) {
        var Wt = -1, sn = f.length;
        for (w || (w = lm), dt || (dt = []); ++Wt < sn; ) {
          var cn = f[Wt];
          y > 0 && w(cn) ? y > 1 ? $i(cn, y - 1, w, Y, dt) : zs(dt, cn) : Y || (dt[dt.length] = cn);
        }
        return dt;
      }
      var uu = Pd(), td = Pd(!0);
      function Es(f, y) {
        return f && uu(f, y, oi);
      }
      function cu(f, y) {
        return f && td(f, y, oi);
      }
      function Ao(f, y) {
        return Bs(y, function(w) {
          return Os(f[w]);
        });
      }
      function pa(f, y) {
        y = Gs(y, f);
        for (var w = 0, Y = y.length; f != null && w < Y; )
          f = f[Ts(y[w++])];
        return w && w == Y ? f : l;
      }
      function nd(f, y, w) {
        var Y = y(f);
        return pr(f) ? Y : zs(Y, w(f));
      }
      function Ai(f) {
        return f == null ? f === l ? Wn : Zn : sa && sa in Gr(f) ? nm(f) : mm(f);
      }
      function du(f, y) {
        return f > y;
      }
      function Ch(f, y) {
        return f != null && zr.call(f, y);
      }
      function Sh(f, y) {
        return f != null && y in Gr(f);
      }
      function $h(f, y, w) {
        return f >= wi(y, w) && f < ri(y, w);
      }
      function fu(f, y, w) {
        for (var Y = w ? ql : uo, dt = f[0].length, Wt = f.length, sn = Wt, cn = xn(Wt), pn = 1 / 0, En = []; sn--; ) {
          var In = f[sn];
          sn && y && (In = qr(In, Ui(y))), pn = wi(In.length, pn), cn[sn] = !w && (y || dt >= 120 && In.length >= 120) ? new da(sn && In) : l;
        }
        In = f[0];
        var Dn = -1, qn = cn[0];
        e:
          for (; ++Dn < dt && En.length < pn; ) {
            var nr = In[Dn], lr = y ? y(nr) : nr;
            if (nr = w || nr !== 0 ? nr : 0, !(qn ? Va(qn, lr) : Y(En, lr, w))) {
              for (sn = Wt; --sn; ) {
                var gr = cn[sn];
                if (!(gr ? Va(gr, lr) : Y(f[sn], lr, w)))
                  continue e;
              }
              qn && qn.push(lr), En.push(nr);
            }
          }
        return En;
      }
      function wh(f, y, w, Y) {
        return Es(f, function(dt, Wt, sn) {
          y(Y, w(dt), Wt, sn);
        }), Y;
      }
      function qa(f, y, w) {
        y = Gs(y, f), f = Ud(f, y);
        var Y = f == null ? f : f[Ts(ys(y))];
        return Y == null ? l : Hi(Y, f, w);
      }
      function rd(f) {
        return Qr(f) && Ai(f) == vn;
      }
      function _h(f) {
        return Qr(f) && Ai(f) == Rn;
      }
      function Eh(f) {
        return Qr(f) && Ai(f) == Nn;
      }
      function Ya(f, y, w, Y, dt) {
        return f === y ? !0 : f == null || y == null || !Qr(f) && !Qr(y) ? f !== f && y !== y : Ph(f, y, w, Y, Ya, dt);
      }
      function Ph(f, y, w, Y, dt, Wt) {
        var sn = pr(f), cn = pr(y), pn = sn ? Pn : Ei(f), En = cn ? Pn : Ei(y);
        pn = pn == vn ? er : pn, En = En == vn ? er : En;
        var In = pn == er, Dn = En == er, qn = pn == En;
        if (qn && Ys(f)) {
          if (!Ys(y))
            return !1;
          sn = !0, In = !1;
        }
        if (qn && !In)
          return Wt || (Wt = new Ss()), sn || Aa(f) ? Ld(f, y, w, Y, dt, Wt) : em(f, y, pn, w, Y, dt, Wt);
        if (!(w & O)) {
          var nr = In && zr.call(f, "__wrapped__"), lr = Dn && zr.call(y, "__wrapped__");
          if (nr || lr) {
            var gr = nr ? f.value() : f, ur = lr ? y.value() : y;
            return Wt || (Wt = new Ss()), dt(gr, ur, w, Y, Wt);
          }
        }
        return qn ? (Wt || (Wt = new Ss()), tm(f, y, w, Y, dt, Wt)) : !1;
      }
      function Th(f) {
        return Qr(f) && Ei(f) == kn;
      }
      function pu(f, y, w, Y) {
        var dt = w.length, Wt = dt, sn = !Y;
        if (f == null)
          return !Wt;
        for (f = Gr(f); dt--; ) {
          var cn = w[dt];
          if (sn && cn[2] ? cn[1] !== f[cn[0]] : !(cn[0] in f))
            return !1;
        }
        for (; ++dt < Wt; ) {
          cn = w[dt];
          var pn = cn[0], En = f[pn], In = cn[1];
          if (sn && cn[2]) {
            if (En === l && !(pn in f))
              return !1;
          } else {
            var Dn = new Ss();
            if (Y)
              var qn = Y(En, In, pn, f, y, Dn);
            if (!(qn === l ? Ya(In, En, O | z, Y, Dn) : qn))
              return !1;
          }
        }
        return !0;
      }
      function id(f) {
        if (!Xr(f) || cm(f))
          return !1;
        var y = Os(f) ? Cp : uc;
        return y.test(ma(f));
      }
      function Ih(f) {
        return Qr(f) && Ai(f) == Kn;
      }
      function kh(f) {
        return Qr(f) && Ei(f) == Bn;
      }
      function Ah(f) {
        return Qr(f) && Pl(f.length) && !!Wr[Ai(f)];
      }
      function sd(f) {
        return typeof f == "function" ? f : f == null ? ji : typeof f == "object" ? pr(f) ? ld(f[0], f[1]) : od(f) : If(f);
      }
      function hu(f) {
        if (!to(f))
          return Tp(f);
        var y = [];
        for (var w in Gr(f))
          zr.call(f, w) && w != "constructor" && y.push(w);
        return y;
      }
      function Nh(f) {
        if (!Xr(f))
          return hm(f);
        var y = to(f), w = [];
        for (var Y in f)
          Y == "constructor" && (y || !zr.call(f, Y)) || w.push(Y);
        return w;
      }
      function mu(f, y) {
        return f < y;
      }
      function ad(f, y) {
        var w = -1, Y = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(dt, Wt, sn) {
          Y[++w] = y(dt, Wt, sn);
        }), Y;
      }
      function od(f) {
        var y = Nu(f);
        return y.length == 1 && y[0][2] ? jd(y[0][0], y[0][1]) : function(w) {
          return w === f || pu(w, f, y);
        };
      }
      function ld(f, y) {
        return Du(f) && zd(y) ? jd(Ts(f), y) : function(w) {
          var Y = ec(w, f);
          return Y === l && Y === y ? tc(w, f) : Ya(y, Y, O | z);
        };
      }
      function No(f, y, w, Y, dt) {
        f !== y && uu(y, function(Wt, sn) {
          if (dt || (dt = new Ss()), Xr(Wt))
            Fh(f, y, sn, w, No, Y, dt);
          else {
            var cn = Y ? Y(Ou(f, sn), Wt, sn + "", f, y, dt) : l;
            cn === l && (cn = Wt), ou(f, sn, cn);
          }
        }, zi);
      }
      function Fh(f, y, w, Y, dt, Wt, sn) {
        var cn = Ou(f, w), pn = Ou(y, w), En = sn.get(pn);
        if (En) {
          ou(f, w, En);
          return;
        }
        var In = Wt ? Wt(cn, pn, w + "", f, y, sn) : l, Dn = In === l;
        if (Dn) {
          var qn = pr(pn), nr = !qn && Ys(pn), lr = !qn && !nr && Aa(pn);
          In = pn, qn || nr || lr ? pr(cn) ? In = cn : ei(cn) ? In = Vi(cn) : nr ? (Dn = !1, In = Cd(pn, !0)) : lr ? (Dn = !1, In = Sd(pn, !0)) : In = [] : ro(pn) || ga(pn) ? (In = cn, ga(cn) ? In = xf(cn) : (!Xr(cn) || Os(cn)) && (In = Bd(pn))) : Dn = !1;
        }
        Dn && (sn.set(pn, In), dt(In, pn, Y, Wt, sn), sn.delete(pn)), ou(f, w, In);
      }
      function ud(f, y) {
        var w = f.length;
        if (w)
          return y += y < 0 ? w : 0, Rs(y, w) ? f[y] : l;
      }
      function cd(f, y, w) {
        y.length ? y = qr(y, function(Wt) {
          return pr(Wt) ? function(sn) {
            return pa(sn, Wt.length === 1 ? Wt[0] : Wt);
          } : Wt;
        }) : y = [ji];
        var Y = -1;
        y = qr(y, Ui(or()));
        var dt = ad(f, function(Wt, sn, cn) {
          var pn = qr(y, function(En) {
            return En(Wt);
          });
          return { criteria: pn, index: ++Y, value: Wt };
        });
        return Jf(dt, function(Wt, sn) {
          return Wh(Wt, sn, w);
        });
      }
      function Dh(f, y) {
        return dd(f, y, function(w, Y) {
          return tc(f, Y);
        });
      }
      function dd(f, y, w) {
        for (var Y = -1, dt = y.length, Wt = {}; ++Y < dt; ) {
          var sn = y[Y], cn = pa(f, sn);
          w(cn, sn) && Xa(Wt, Gs(sn, f), cn);
        }
        return Wt;
      }
      function Rh(f) {
        return function(y) {
          return pa(y, f);
        };
      }
      function gu(f, y, w, Y) {
        var dt = Y ? Zf : xa, Wt = -1, sn = y.length, cn = f;
        for (f === y && (y = Vi(y)), w && (cn = qr(f, Ui(w))); ++Wt < sn; )
          for (var pn = 0, En = y[Wt], In = w ? w(En) : En; (pn = dt(cn, In, pn, Y)) > -1; )
            cn !== f && bo.call(cn, pn, 1), bo.call(f, pn, 1);
        return f;
      }
      function fd(f, y) {
        for (var w = f ? y.length : 0, Y = w - 1; w--; ) {
          var dt = y[w];
          if (w == Y || dt !== Wt) {
            var Wt = dt;
            Rs(dt) ? bo.call(f, dt, 1) : bu(f, dt);
          }
        }
        return f;
      }
      function yu(f, y) {
        return f + wo(Wc() * (y - f + 1));
      }
      function Oh(f, y, w, Y) {
        for (var dt = -1, Wt = ri(So((y - f) / (w || 1)), 0), sn = xn(Wt); Wt--; )
          sn[Y ? Wt : ++dt] = f, f += w;
        return sn;
      }
      function vu(f, y) {
        var w = "";
        if (!f || y < 1 || y > vt)
          return w;
        do
          y % 2 && (w += f), y = wo(y / 2), y && (f += f);
        while (y);
        return w;
      }
      function vr(f, y) {
        return Lu(Hd(f, y, ji), f + "");
      }
      function Lh(f) {
        return Yc(Na(f));
      }
      function Mh(f, y) {
        var w = Na(f);
        return xl(w, fa(y, 0, w.length));
      }
      function Xa(f, y, w, Y) {
        if (!Xr(f))
          return f;
        y = Gs(y, f);
        for (var dt = -1, Wt = y.length, sn = Wt - 1, cn = f; cn != null && ++dt < Wt; ) {
          var pn = Ts(y[dt]), En = w;
          if (pn === "__proto__" || pn === "constructor" || pn === "prototype")
            return f;
          if (dt != sn) {
            var In = cn[pn];
            En = Y ? Y(In, pn, cn) : l, En === l && (En = Xr(In) ? In : Rs(y[dt + 1]) ? [] : {});
          }
          Wa(cn, pn, En), cn = cn[pn];
        }
        return f;
      }
      var pd = _o ? function(f, y) {
        return _o.set(f, y), f;
      } : ji, Vh = Co ? function(f, y) {
        return Co(f, "toString", {
          configurable: !0,
          enumerable: !1,
          value: rc(y),
          writable: !0
        });
      } : ji;
      function Bh(f) {
        return xl(Na(f));
      }
      function ms(f, y, w) {
        var Y = -1, dt = f.length;
        y < 0 && (y = -y > dt ? 0 : dt + y), w = w > dt ? dt : w, w < 0 && (w += dt), dt = y > w ? 0 : w - y >>> 0, y >>>= 0;
        for (var Wt = xn(dt); ++Y < dt; )
          Wt[Y] = f[Y + y];
        return Wt;
      }
      function zh(f, y) {
        var w;
        return Ks(f, function(Y, dt, Wt) {
          return w = y(Y, dt, Wt), !w;
        }), !!w;
      }
      function Do(f, y, w) {
        var Y = 0, dt = f == null ? Y : f.length;
        if (typeof y == "number" && y === y && dt <= dn) {
          for (; Y < dt; ) {
            var Wt = Y + dt >>> 1, sn = f[Wt];
            sn !== null && !Wi(sn) && (w ? sn <= y : sn < y) ? Y = Wt + 1 : dt = Wt;
          }
          return dt;
        }
        return xu(f, y, ji, w);
      }
      function xu(f, y, w, Y) {
        var dt = 0, Wt = f == null ? 0 : f.length;
        if (Wt === 0)
          return 0;
        y = w(y);
        for (var sn = y !== y, cn = y === null, pn = Wi(y), En = y === l; dt < Wt; ) {
          var In = wo((dt + Wt) / 2), Dn = w(f[In]), qn = Dn !== l, nr = Dn === null, lr = Dn === Dn, gr = Wi(Dn);
          if (sn)
            var ur = Y || lr;
          else
            En ? ur = lr && (Y || qn) : cn ? ur = lr && qn && (Y || !nr) : pn ? ur = lr && qn && !nr && (Y || !gr) : nr || gr ? ur = !1 : ur = Y ? Dn <= y : Dn < y;
          ur ? dt = In + 1 : Wt = In;
        }
        return wi(Wt, gn);
      }
      function hd(f, y) {
        for (var w = -1, Y = f.length, dt = 0, Wt = []; ++w < Y; ) {
          var sn = f[w], cn = y ? y(sn) : sn;
          if (!w || !$s(cn, pn)) {
            var pn = cn;
            Wt[dt++] = sn === 0 ? 0 : sn;
          }
        }
        return Wt;
      }
      function gd(f) {
        return typeof f == "number" ? f : Wi(f) ? Qt : +f;
      }
      function Ki(f) {
        if (typeof f == "string")
          return f;
        if (pr(f))
          return qr(f, Ki) + "";
        if (Wi(f))
          return Gc ? Gc.call(f) : "";
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function Ws(f, y, w) {
        var Y = -1, dt = uo, Wt = f.length, sn = !0, cn = [], pn = cn;
        if (w)
          sn = !1, dt = ql;
        else if (Wt >= c) {
          var En = y ? null : Jh(f);
          if (En)
            return fo(En);
          sn = !1, dt = Va, pn = new da();
        } else
          pn = y ? [] : cn;
        e:
          for (; ++Y < Wt; ) {
            var In = f[Y], Dn = y ? y(In) : In;
            if (In = w || In !== 0 ? In : 0, sn && Dn === Dn) {
              for (var qn = pn.length; qn--; )
                if (pn[qn] === Dn)
                  continue e;
              y && pn.push(Dn), cn.push(In);
            } else
              dt(pn, Dn, w) || (pn !== cn && pn.push(Dn), cn.push(In));
          }
        return cn;
      }
      function bu(f, y) {
        return y = Gs(y, f), f = Ud(f, y), f == null || delete f[Ts(ys(y))];
      }
      function yd(f, y, w, Y) {
        return Xa(f, y, w(pa(f, y)), Y);
      }
      function Ro(f, y, w, Y) {
        for (var dt = f.length, Wt = Y ? dt : -1; (Y ? Wt-- : ++Wt < dt) && y(f[Wt], Wt, f); )
          ;
        return w ? ms(f, Y ? 0 : Wt, Y ? Wt + 1 : dt) : ms(f, Y ? Wt + 1 : 0, Y ? dt : Wt);
      }
      function vd(f, y) {
        var w = f;
        return w instanceof Pr && (w = w.value()), Yl(y, function(Y, dt) {
          return dt.func.apply(dt.thisArg, zs([Y], dt.args));
        }, w);
      }
      function Cu(f, y, w) {
        var Y = f.length;
        if (Y < 2)
          return Y ? Ws(f[0]) : [];
        for (var dt = -1, Wt = xn(Y); ++dt < Y; )
          for (var sn = f[dt], cn = -1; ++cn < Y; )
            cn != dt && (Wt[dt] = Ga(Wt[dt] || sn, f[cn], y, w));
        return Ws($i(Wt, 1), y, w);
      }
      function xd(f, y, w) {
        for (var Y = -1, dt = f.length, Wt = y.length, sn = {}; ++Y < dt; ) {
          var cn = Y < Wt ? y[Y] : l;
          w(sn, f[Y], cn);
        }
        return sn;
      }
      function Su(f) {
        return ei(f) ? f : [];
      }
      function wu(f) {
        return typeof f == "function" ? f : ji;
      }
      function Gs(f, y) {
        return pr(f) ? f : Du(f, y) ? [f] : qd(Vr(f));
      }
      var jh = vr;
      function qs(f, y, w) {
        var Y = f.length;
        return w = w === l ? Y : w, !y && w >= Y ? f : ms(f, y, w);
      }
      var bd = Sp || function(f) {
        return di.clearTimeout(f);
      };
      function Cd(f, y) {
        if (y)
          return f.slice();
        var w = f.length, Y = zc ? zc(w) : new f.constructor(w);
        return f.copy(Y), Y;
      }
      function _u(f) {
        var y = new f.constructor(f.byteLength);
        return new vo(y).set(new vo(f)), y;
      }
      function Hh(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.byteLength);
      }
      function Uh(f) {
        var y = new f.constructor(f.source, so.exec(f));
        return y.lastIndex = f.lastIndex, y;
      }
      function Kh(f) {
        return Ka ? Gr(Ka.call(f)) : {};
      }
      function Sd(f, y) {
        var w = y ? _u(f.buffer) : f.buffer;
        return new f.constructor(w, f.byteOffset, f.length);
      }
      function $d(f, y) {
        if (f !== y) {
          var w = f !== l, Y = f === null, dt = f === f, Wt = Wi(f), sn = y !== l, cn = y === null, pn = y === y, En = Wi(y);
          if (!cn && !En && !Wt && f > y || Wt && sn && pn && !cn && !En || Y && sn && pn || !w && pn || !dt)
            return 1;
          if (!Y && !Wt && !En && f < y || En && w && dt && !Y && !Wt || cn && w && dt || !sn && dt || !pn)
            return -1;
        }
        return 0;
      }
      function Wh(f, y, w) {
        for (var Y = -1, dt = f.criteria, Wt = y.criteria, sn = dt.length, cn = w.length; ++Y < sn; ) {
          var pn = $d(dt[Y], Wt[Y]);
          if (pn) {
            if (Y >= cn)
              return pn;
            var En = w[Y];
            return pn * (En == "desc" ? -1 : 1);
          }
        }
        return f.index - y.index;
      }
      function wd(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = w.length, cn = -1, pn = y.length, En = ri(Wt - sn, 0), In = xn(pn + En), Dn = !Y; ++cn < pn; )
          In[cn] = y[cn];
        for (; ++dt < sn; )
          (Dn || dt < Wt) && (In[w[dt]] = f[dt]);
        for (; En--; )
          In[cn++] = f[dt++];
        return In;
      }
      function _d(f, y, w, Y) {
        for (var dt = -1, Wt = f.length, sn = -1, cn = w.length, pn = -1, En = y.length, In = ri(Wt - cn, 0), Dn = xn(In + En), qn = !Y; ++dt < In; )
          Dn[dt] = f[dt];
        for (var nr = dt; ++pn < En; )
          Dn[nr + pn] = y[pn];
        for (; ++sn < cn; )
          (qn || dt < Wt) && (Dn[nr + w[sn]] = f[dt++]);
        return Dn;
      }
      function Vi(f, y) {
        var w = -1, Y = f.length;
        for (y || (y = xn(Y)); ++w < Y; )
          y[w] = f[w];
        return y;
      }
      function Ps(f, y, w, Y) {
        var dt = !w;
        w || (w = {});
        for (var Wt = -1, sn = y.length; ++Wt < sn; ) {
          var cn = y[Wt], pn = Y ? Y(w[cn], f[cn], cn, w, f) : l;
          pn === l && (pn = f[cn]), dt ? Ns(w, cn, pn) : Wa(w, cn, pn);
        }
        return w;
      }
      function Gh(f, y) {
        return Ps(f, Fu(f), y);
      }
      function qh(f, y) {
        return Ps(f, Md(f), y);
      }
      function Oo(f, y) {
        return function(w, Y) {
          var dt = pr(w) ? Kf : gh, Wt = y ? y() : {};
          return dt(w, f, or(Y, 2), Wt);
        };
      }
      function Ta(f) {
        return vr(function(y, w) {
          var Y = -1, dt = w.length, Wt = dt > 1 ? w[dt - 1] : l, sn = dt > 2 ? w[2] : l;
          for (Wt = f.length > 3 && typeof Wt == "function" ? (dt--, Wt) : l, sn && Ni(w[0], w[1], sn) && (Wt = dt < 3 ? l : Wt, dt = 1), y = Gr(y); ++Y < dt; ) {
            var cn = w[Y];
            cn && f(y, cn, Y, Wt);
          }
          return y;
        });
      }
      function Ed(f, y) {
        return function(w, Y) {
          if (w == null)
            return w;
          if (!Bi(w))
            return f(w, Y);
          for (var dt = w.length, Wt = y ? dt : -1, sn = Gr(w); (y ? Wt-- : ++Wt < dt) && Y(sn[Wt], Wt, sn) !== !1; )
            ;
          return w;
        };
      }
      function Pd(f) {
        return function(y, w, Y) {
          for (var dt = -1, Wt = Gr(y), sn = Y(y), cn = sn.length; cn--; ) {
            var pn = sn[f ? cn : ++dt];
            if (w(Wt[pn], pn, Wt) === !1)
              break;
          }
          return y;
        };
      }
      function Yh(f, y, w) {
        var Y = y & Q, dt = eo(f);
        function Wt() {
          var sn = this && this !== di && this instanceof Wt ? dt : f;
          return sn.apply(Y ? w : this, arguments);
        }
        return Wt;
      }
      function Td(f) {
        return function(y) {
          y = Vr(y);
          var w = ba(y) ? Cs(y) : l, Y = w ? w[0] : y.charAt(0), dt = w ? qs(w, 1).join("") : y.slice(1);
          return Y[f]() + dt;
        };
      }
      function Ia(f) {
        return function(y) {
          return Yl(Pf(Ef(y).replace(Kr, "")), f, "");
        };
      }
      function eo(f) {
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return new f();
            case 1:
              return new f(y[0]);
            case 2:
              return new f(y[0], y[1]);
            case 3:
              return new f(y[0], y[1], y[2]);
            case 4:
              return new f(y[0], y[1], y[2], y[3]);
            case 5:
              return new f(y[0], y[1], y[2], y[3], y[4]);
            case 6:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5]);
            case 7:
              return new f(y[0], y[1], y[2], y[3], y[4], y[5], y[6]);
          }
          var w = Pa(f.prototype), Y = f.apply(w, y);
          return Xr(Y) ? Y : w;
        };
      }
      function Xh(f, y, w) {
        var Y = eo(f);
        function dt() {
          for (var Wt = arguments.length, sn = xn(Wt), cn = Wt, pn = ka(dt); cn--; )
            sn[cn] = arguments[cn];
          var En = Wt < 3 && sn[0] !== pn && sn[Wt - 1] !== pn ? [] : Hs(sn, pn);
          if (Wt -= En.length, Wt < w)
            return Fd(
              f,
              y,
              Lo,
              dt.placeholder,
              l,
              sn,
              En,
              l,
              l,
              w - Wt
            );
          var In = this && this !== di && this instanceof dt ? Y : f;
          return Hi(In, this, sn);
        }
        return dt;
      }
      function Id(f) {
        return function(y, w, Y) {
          var dt = Gr(y);
          if (!Bi(y)) {
            var Wt = or(w, 3);
            y = oi(y), w = function(cn) {
              return Wt(dt[cn], cn, dt);
            };
          }
          var sn = f(y, w, Y);
          return sn > -1 ? dt[Wt ? y[sn] : sn] : l;
        };
      }
      function kd(f) {
        return Ds(function(y) {
          var w = y.length, Y = w, dt = Ji.prototype.thru;
          for (f && y.reverse(); Y--; ) {
            var Wt = y[Y];
            if (typeof Wt != "function")
              throw new Zi(g);
            if (dt && !sn && Jo(Wt) == "wrapper")
              var sn = new Ji([], !0);
          }
          for (Y = sn ? Y : w; ++Y < w; ) {
            Wt = y[Y];
            var cn = Jo(Wt), pn = cn == "wrapper" ? Au(Wt) : l;
            pn && Ru(pn[0]) && pn[1] == (Re | te | ve | wt) && !pn[4].length && pn[9] == 1 ? sn = sn[Jo(pn[0])].apply(sn, pn[3]) : sn = Wt.length == 1 && Ru(Wt) ? sn[cn]() : sn.thru(Wt);
          }
          return function() {
            var En = arguments, In = En[0];
            if (sn && En.length == 1 && pr(In))
              return sn.plant(In).value();
            for (var Dn = 0, qn = w ? y[Dn].apply(this, En) : In; ++Dn < w; )
              qn = y[Dn].call(this, qn);
            return qn;
          };
        });
      }
      function Lo(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & Re, Dn = y & Q, qn = y & W, nr = y & (te | K), lr = y & yt, gr = qn ? l : eo(f);
        function ur() {
          for (var $r = arguments.length, Ir = xn($r), Gi = $r; Gi--; )
            Ir[Gi] = arguments[Gi];
          if (nr)
            var Fi = ka(ur), qi = ep(Ir, Fi);
          if (Y && (Ir = wd(Ir, Y, dt, nr)), Wt && (Ir = _d(Ir, Wt, sn, nr)), $r -= qi, nr && $r < En) {
            var ti = Hs(Ir, Fi);
            return Fd(
              f,
              y,
              Lo,
              ur.placeholder,
              w,
              Ir,
              ti,
              cn,
              pn,
              En - $r
            );
          }
          var ws = Dn ? w : this, Ms = qn ? ws[f] : f;
          return $r = Ir.length, cn ? Ir = gm(Ir, cn) : lr && $r > 1 && Ir.reverse(), In && pn < $r && (Ir.length = pn), this && this !== di && this instanceof ur && (Ms = gr || eo(Ms)), Ms.apply(ws, Ir);
        }
        return ur;
      }
      function Ad(f, y) {
        return function(w, Y) {
          return wh(w, f, y(Y), {});
        };
      }
      function Mo(f, y) {
        return function(w, Y) {
          var dt;
          if (w === l && Y === l)
            return y;
          if (w !== l && (dt = w), Y !== l) {
            if (dt === l)
              return Y;
            typeof w == "string" || typeof Y == "string" ? (w = Ki(w), Y = Ki(Y)) : (w = gd(w), Y = gd(Y)), dt = f(w, Y);
          }
          return dt;
        };
      }
      function Eu(f) {
        return Ds(function(y) {
          return y = qr(y, Ui(or())), vr(function(w) {
            var Y = this;
            return f(y, function(dt) {
              return Hi(dt, Y, w);
            });
          });
        });
      }
      function Bo(f, y) {
        y = y === l ? " " : Ki(y);
        var w = y.length;
        if (w < 2)
          return w ? vu(y, f) : y;
        var Y = vu(y, So(f / Ca(y)));
        return ba(y) ? qs(Cs(Y), 0, f).join("") : Y.slice(0, f);
      }
      function Zh(f, y, w, Y) {
        var dt = y & Q, Wt = eo(f);
        function sn() {
          for (var cn = -1, pn = arguments.length, En = -1, In = Y.length, Dn = xn(In + pn), qn = this && this !== di && this instanceof sn ? Wt : f; ++En < In; )
            Dn[En] = Y[En];
          for (; pn--; )
            Dn[En++] = arguments[++cn];
          return Hi(qn, dt ? w : this, Dn);
        }
        return sn;
      }
      function Nd(f) {
        return function(y, w, Y) {
          return Y && typeof Y != "number" && Ni(y, w, Y) && (w = Y = l), y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), Y = Y === l ? y < w ? 1 : -1 : Ls(Y), Oh(y, w, Y, f);
        };
      }
      function Zo(f) {
        return function(y, w) {
          return typeof y == "string" && typeof w == "string" || (y = xs(y), w = xs(w)), f(y, w);
        };
      }
      function Fd(f, y, w, Y, dt, Wt, sn, cn, pn, En) {
        var In = y & te, Dn = In ? sn : l, qn = In ? l : sn, nr = In ? Wt : l, lr = In ? l : Wt;
        y |= In ? ve : ee, y &= ~(In ? ee : ve), y & ue || (y &= ~(Q | W));
        var gr = [
          f,
          y,
          dt,
          nr,
          Dn,
          lr,
          qn,
          cn,
          pn,
          En
        ], ur = w.apply(l, gr);
        return Ru(f) && Kd(ur, gr), ur.placeholder = Y, Wd(ur, f, y);
      }
      function Pu(f) {
        var y = ni[f];
        return function(w, Y) {
          if (w = xs(w), Y = Y == null ? 0 : wi(hr(Y), 292), Y && Kc(w)) {
            var dt = (Vr(w) + "e").split("e"), Wt = y(dt[0] + "e" + (+dt[1] + Y));
            return dt = (Vr(Wt) + "e").split("e"), +(dt[0] + "e" + (+dt[1] - Y));
          }
          return y(w);
        };
      }
      var Jh = wa && 1 / fo(new wa([, -0]))[1] == nn ? function(f) {
        return new wa(f);
      } : ac;
      function Dd(f) {
        return function(y) {
          var w = Ei(y);
          return w == kn ? nu(y) : w == Bn ? op(y) : Qf(y, f(y));
        };
      }
      function Fs(f, y, w, Y, dt, Wt, sn, cn) {
        var pn = y & W;
        if (!pn && typeof f != "function")
          throw new Zi(g);
        var En = Y ? Y.length : 0;
        if (En || (y &= ~(ve | ee), Y = dt = l), sn = sn === l ? sn : ri(hr(sn), 0), cn = cn === l ? cn : hr(cn), En -= dt ? dt.length : 0, y & ee) {
          var In = Y, Dn = dt;
          Y = dt = l;
        }
        var qn = pn ? l : Au(f), nr = [
          f,
          y,
          w,
          Y,
          dt,
          In,
          Dn,
          Wt,
          sn,
          cn
        ];
        if (qn && pm(nr, qn), f = nr[0], y = nr[1], w = nr[2], Y = nr[3], dt = nr[4], cn = nr[9] = nr[9] === l ? pn ? 0 : f.length : ri(nr[9] - En, 0), !cn && y & (te | K) && (y &= ~(te | K)), !y || y == Q)
          var lr = Yh(f, y, w);
        else
          y == te || y == K ? lr = Xh(f, y, cn) : (y == ve || y == (Q | ve)) && !dt.length ? lr = Zh(f, y, w, Y) : lr = Lo.apply(l, nr);
        var gr = qn ? pd : Kd;
        return Wd(gr(lr, nr), f, y);
      }
      function Rd(f, y, w, Y) {
        return f === l || $s(f, $a[w]) && !zr.call(Y, w) ? y : f;
      }
      function Od(f, y, w, Y, dt, Wt) {
        return Xr(f) && Xr(y) && (Wt.set(y, f), No(f, y, l, Od, Wt), Wt.delete(y)), f;
      }
      function Qh(f) {
        return ro(f) ? l : f;
      }
      function Ld(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = f.length, pn = y.length;
        if (cn != pn && !(sn && pn > cn))
          return !1;
        var En = Wt.get(f), In = Wt.get(y);
        if (En && In)
          return En == y && In == f;
        var Dn = -1, qn = !0, nr = w & z ? new da() : l;
        for (Wt.set(f, y), Wt.set(y, f); ++Dn < cn; ) {
          var lr = f[Dn], gr = y[Dn];
          if (Y)
            var ur = sn ? Y(gr, lr, Dn, y, f, Wt) : Y(lr, gr, Dn, f, y, Wt);
          if (ur !== l) {
            if (ur)
              continue;
            qn = !1;
            break;
          }
          if (nr) {
            if (!Xl(y, function($r, Ir) {
              if (!Va(nr, Ir) && (lr === $r || dt(lr, $r, w, Y, Wt)))
                return nr.push(Ir);
            })) {
              qn = !1;
              break;
            }
          } else if (!(lr === gr || dt(lr, gr, w, Y, Wt))) {
            qn = !1;
            break;
          }
        }
        return Wt.delete(f), Wt.delete(y), qn;
      }
      function em(f, y, w, Y, dt, Wt, sn) {
        switch (w) {
          case hn:
            if (f.byteLength != y.byteLength || f.byteOffset != y.byteOffset)
              return !1;
            f = f.buffer, y = y.buffer;
          case Rn:
            return !(f.byteLength != y.byteLength || !Wt(new vo(f), new vo(y)));
          case _n:
          case Nn:
          case Yn:
            return $s(+f, +y);
          case Xn:
            return f.name == y.name && f.message == y.message;
          case Kn:
          case Fn:
            return f == y + "";
          case kn:
            var cn = nu;
          case Bn:
            var pn = Y & O;
            if (cn || (cn = fo), f.size != y.size && !pn)
              return !1;
            var En = sn.get(f);
            if (En)
              return En == y;
            Y |= z, sn.set(f, y);
            var In = Ld(cn(f), cn(y), Y, dt, Wt, sn);
            return sn.delete(f), In;
          case Gn:
            if (Ka)
              return Ka.call(f) == Ka.call(y);
        }
        return !1;
      }
      function tm(f, y, w, Y, dt, Wt) {
        var sn = w & O, cn = Tu(f), pn = cn.length, En = Tu(y), In = En.length;
        if (pn != In && !sn)
          return !1;
        for (var Dn = pn; Dn--; ) {
          var qn = cn[Dn];
          if (!(sn ? qn in y : zr.call(y, qn)))
            return !1;
        }
        var nr = Wt.get(f), lr = Wt.get(y);
        if (nr && lr)
          return nr == y && lr == f;
        var gr = !0;
        Wt.set(f, y), Wt.set(y, f);
        for (var ur = sn; ++Dn < pn; ) {
          qn = cn[Dn];
          var $r = f[qn], Ir = y[qn];
          if (Y)
            var Gi = sn ? Y(Ir, $r, qn, y, f, Wt) : Y($r, Ir, qn, f, y, Wt);
          if (!(Gi === l ? $r === Ir || dt($r, Ir, w, Y, Wt) : Gi)) {
            gr = !1;
            break;
          }
          ur || (ur = qn == "constructor");
        }
        if (gr && !ur) {
          var Fi = f.constructor, qi = y.constructor;
          Fi != qi && "constructor" in f && "constructor" in y && !(typeof Fi == "function" && Fi instanceof Fi && typeof qi == "function" && qi instanceof qi) && (gr = !1);
        }
        return Wt.delete(f), Wt.delete(y), gr;
      }
      function Ds(f) {
        return Lu(Hd(f, l, Jd), f + "");
      }
      function Tu(f) {
        return nd(f, oi, Fu);
      }
      function Iu(f) {
        return nd(f, zi, Md);
      }
      var Au = _o ? function(f) {
        return _o.get(f);
      } : ac;
      function Jo(f) {
        for (var y = f.name + "", w = Ea[y], Y = zr.call(Ea, y) ? w.length : 0; Y--; ) {
          var dt = w[Y], Wt = dt.func;
          if (Wt == null || Wt == f)
            return dt.name;
        }
        return y;
      }
      function ka(f) {
        var y = zr.call(Ft, "placeholder") ? Ft : f;
        return y.placeholder;
      }
      function or() {
        var f = Ft.iteratee || ic;
        return f = f === ic ? sd : f, arguments.length ? f(arguments[0], arguments[1]) : f;
      }
      function el(f, y) {
        var w = f.__data__;
        return um(y) ? w[typeof y == "string" ? "string" : "hash"] : w.map;
      }
      function Nu(f) {
        for (var y = oi(f), w = y.length; w--; ) {
          var Y = y[w], dt = f[Y];
          y[w] = [Y, dt, zd(dt)];
        }
        return y;
      }
      function ha(f, y) {
        var w = ip(f, y);
        return id(w) ? w : l;
      }
      function nm(f) {
        var y = zr.call(f, sa), w = f[sa];
        try {
          f[sa] = l;
          var Y = !0;
        } catch {
        }
        var dt = go.call(f);
        return Y && (y ? f[sa] = w : delete f[sa]), dt;
      }
      var Fu = iu ? function(f) {
        return f == null ? [] : (f = Gr(f), Bs(iu(f), function(y) {
          return Hc.call(f, y);
        }));
      } : oc, Md = iu ? function(f) {
        for (var y = []; f; )
          zs(y, Fu(f)), f = xo(f);
        return y;
      } : oc, Ei = Ai;
      (su && Ei(new su(new ArrayBuffer(1))) != hn || za && Ei(new za()) != kn || au && Ei(au.resolve()) != bn || wa && Ei(new wa()) != Bn || ja && Ei(new ja()) != Mn) && (Ei = function(f) {
        var y = Ai(f), w = y == er ? f.constructor : l, Y = w ? ma(w) : "";
        if (Y)
          switch (Y) {
            case Fp:
              return hn;
            case Dp:
              return kn;
            case Rp:
              return bn;
            case Op:
              return Bn;
            case Lp:
              return Mn;
          }
        return y;
      });
      function rm(f, y, w) {
        for (var Y = -1, dt = w.length; ++Y < dt; ) {
          var Wt = w[Y], sn = Wt.size;
          switch (Wt.type) {
            case "drop":
              f += sn;
              break;
            case "dropRight":
              y -= sn;
              break;
            case "take":
              y = wi(y, f + sn);
              break;
            case "takeRight":
              f = ri(f, y - sn);
              break;
          }
        }
        return { start: f, end: y };
      }
      function im(f) {
        var y = f.match(Is);
        return y ? y[1].split(Fa) : [];
      }
      function Vd(f, y, w) {
        y = Gs(y, f);
        for (var Y = -1, dt = y.length, Wt = !1; ++Y < dt; ) {
          var sn = Ts(y[Y]);
          if (!(Wt = f != null && w(f, sn)))
            break;
          f = f[sn];
        }
        return Wt || ++Y != dt ? Wt : (dt = f == null ? 0 : f.length, !!dt && Pl(dt) && Rs(sn, dt) && (pr(f) || ga(f)));
      }
      function sm(f) {
        var y = f.length, w = new f.constructor(y);
        return y && typeof f[0] == "string" && zr.call(f, "index") && (w.index = f.index, w.input = f.input), w;
      }
      function Bd(f) {
        return typeof f.constructor == "function" && !to(f) ? Pa(xo(f)) : {};
      }
      function am(f, y, w) {
        var Y = f.constructor;
        switch (y) {
          case Rn:
            return _u(f);
          case _n:
          case Nn:
            return new Y(+f);
          case hn:
            return Hh(f, w);
          case Qn:
          case rr:
          case tr:
          case Cr:
          case Fr:
          case An:
          case Hn:
          case ir:
          case dr:
            return Sd(f, w);
          case kn:
            return new Y();
          case Yn:
          case Fn:
            return new Y(f);
          case Kn:
            return Uh(f);
          case Bn:
            return new Y();
          case Gn:
            return Kh(f);
        }
      }
      function om(f, y) {
        var w = y.length;
        if (!w)
          return f;
        var Y = w - 1;
        return y[Y] = (w > 1 ? "& " : "") + y[Y], y = y.join(w > 2 ? ", " : " "), f.replace(_s, `{
/* [wrapped with ` + y + `] */
`);
      }
      function lm(f) {
        return pr(f) || ga(f) || !!(Uc && f && f[Uc]);
      }
      function Rs(f, y) {
        var w = typeof f;
        return y = y ?? vt, !!y && (w == "number" || w != "symbol" && Ma.test(f)) && f > -1 && f % 1 == 0 && f < y;
      }
      function Ni(f, y, w) {
        if (!Xr(w))
          return !1;
        var Y = typeof y;
        return (Y == "number" ? Bi(w) && Rs(y, w.length) : Y == "string" && y in w) ? $s(w[y], f) : !1;
      }
      function Du(f, y) {
        if (pr(f))
          return !1;
        var w = typeof f;
        return w == "number" || w == "symbol" || w == "boolean" || f == null || Wi(f) ? !0 : Mi.test(f) || !Ti.test(f) || y != null && f in Gr(y);
      }
      function um(f) {
        var y = typeof f;
        return y == "string" || y == "number" || y == "symbol" || y == "boolean" ? f !== "__proto__" : f === null;
      }
      function Ru(f) {
        var y = Jo(f), w = Ft[y];
        if (typeof w != "function" || !(y in Pr.prototype))
          return !1;
        if (f === w)
          return !0;
        var Y = Au(w);
        return !!Y && f === Y[0];
      }
      function cm(f) {
        return !!Bc && Bc in f;
      }
      var dm = ho ? Os : lc;
      function to(f) {
        var y = f && f.constructor, w = typeof y == "function" && y.prototype || $a;
        return f === w;
      }
      function zd(f) {
        return f === f && !Xr(f);
      }
      function jd(f, y) {
        return function(w) {
          return w == null ? !1 : w[f] === y && (y !== l || f in Gr(w));
        };
      }
      function fm(f) {
        var y = $l(f, function(Y) {
          return w.size === S && w.clear(), Y;
        }), w = y.cache;
        return y;
      }
      function pm(f, y) {
        var w = f[1], Y = y[1], dt = w | Y, Wt = dt < (Q | W | Re), sn = Y == Re && w == te || Y == Re && w == wt && f[7].length <= y[8] || Y == (Re | wt) && y[7].length <= y[8] && w == te;
        if (!(Wt || sn))
          return f;
        Y & Q && (f[2] = y[2], dt |= w & Q ? 0 : ue);
        var cn = y[3];
        if (cn) {
          var pn = f[3];
          f[3] = pn ? wd(pn, cn, y[4]) : cn, f[4] = pn ? Hs(f[3], E) : y[4];
        }
        return cn = y[5], cn && (pn = f[5], f[5] = pn ? _d(pn, cn, y[6]) : cn, f[6] = pn ? Hs(f[5], E) : y[6]), cn = y[7], cn && (f[7] = cn), Y & Re && (f[8] = f[8] == null ? y[8] : wi(f[8], y[8])), f[9] == null && (f[9] = y[9]), f[0] = y[0], f[1] = dt, f;
      }
      function hm(f) {
        var y = [];
        if (f != null)
          for (var w in Gr(f))
            y.push(w);
        return y;
      }
      function mm(f) {
        return go.call(f);
      }
      function Hd(f, y, w) {
        return y = ri(y === l ? f.length - 1 : y, 0), function() {
          for (var Y = arguments, dt = -1, Wt = ri(Y.length - y, 0), sn = xn(Wt); ++dt < Wt; )
            sn[dt] = Y[y + dt];
          dt = -1;
          for (var cn = xn(y + 1); ++dt < y; )
            cn[dt] = Y[dt];
          return cn[y] = w(sn), Hi(f, this, cn);
        };
      }
      function Ud(f, y) {
        return y.length < 2 ? f : pa(f, ms(y, 0, -1));
      }
      function gm(f, y) {
        for (var w = f.length, Y = wi(y.length, w), dt = Vi(f); Y--; ) {
          var Wt = y[Y];
          f[Y] = Rs(Wt, w) ? dt[Wt] : l;
        }
        return f;
      }
      function Ou(f, y) {
        if (!(y === "constructor" && typeof f[y] == "function") && y != "__proto__")
          return f[y];
      }
      var Kd = Gd(pd), no = _p || function(f, y) {
        return di.setTimeout(f, y);
      }, Lu = Gd(Vh);
      function Wd(f, y, w) {
        var Y = y + "";
        return Lu(f, om(Y, ym(im(Y), w)));
      }
      function Gd(f) {
        var y = 0, w = 0;
        return function() {
          var Y = Ip(), dt = ln - (Y - w);
          if (w = Y, dt > 0) {
            if (++y >= tn)
              return arguments[0];
          } else
            y = 0;
          return f.apply(l, arguments);
        };
      }
      function xl(f, y) {
        var w = -1, Y = f.length, dt = Y - 1;
        for (y = y === l ? Y : y; ++w < y; ) {
          var Wt = yu(w, dt), sn = f[Wt];
          f[Wt] = f[w], f[w] = sn;
        }
        return f.length = y, f;
      }
      var qd = fm(function(f) {
        var y = [];
        return f.charCodeAt(0) === 46 && y.push(""), f.replace(ui, function(w, Y, dt, Wt) {
          y.push(dt ? Wt.replace(oo, "$1") : Y || w);
        }), y;
      });
      function Ts(f) {
        if (typeof f == "string" || Wi(f))
          return f;
        var y = f + "";
        return y == "0" && 1 / f == -nn ? "-0" : y;
      }
      function ma(f) {
        if (f != null) {
          try {
            return mo.call(f);
          } catch {
          }
          try {
            return f + "";
          } catch {
          }
        }
        return "";
      }
      function ym(f, y) {
        return Xi(yn, function(w) {
          var Y = "_." + w[0];
          y & w[1] && !uo(f, Y) && f.push(Y);
        }), f.sort();
      }
      function Yd(f) {
        if (f instanceof Pr)
          return f.clone();
        var y = new Ji(f.__wrapped__, f.__chain__);
        return y.__actions__ = Vi(f.__actions__), y.__index__ = f.__index__, y.__values__ = f.__values__, y;
      }
      function vm(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = ri(hr(y), 0);
        var Y = f == null ? 0 : f.length;
        if (!Y || y < 1)
          return [];
        for (var dt = 0, Wt = 0, sn = xn(So(Y / y)); dt < Y; )
          sn[Wt++] = ms(f, dt, dt += y);
        return sn;
      }
      function xm(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = 0, dt = []; ++y < w; ) {
          var Wt = f[y];
          Wt && (dt[Y++] = Wt);
        }
        return dt;
      }
      function bm() {
        var f = arguments.length;
        if (!f)
          return [];
        for (var y = xn(f - 1), w = arguments[0], Y = f; Y--; )
          y[Y - 1] = arguments[Y];
        return zs(pr(w) ? Vi(w) : [w], $i(y, 1));
      }
      var Cm = vr(function(f, y) {
        return ei(f) ? Ga(f, $i(y, 1, ei, !0)) : [];
      }), Sm = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), or(w, 2)) : [];
      }), $m = vr(function(f, y) {
        var w = ys(y);
        return ei(w) && (w = l), ei(f) ? Ga(f, $i(y, 1, ei, !0), l, w) : [];
      });
      function wm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function _m(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function Em(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0, !0) : [];
      }
      function Pm(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !0) : [];
      }
      function Tm(f, y, w, Y) {
        var dt = f == null ? 0 : f.length;
        return dt ? (w && typeof w != "number" && Ni(f, y, w) && (w = 0, Y = dt), bh(f, y, w, Y)) : [];
      }
      function Xd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), co(f, or(y, 3), dt);
      }
      function Zd(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y - 1;
        return w !== l && (dt = hr(w), dt = w < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), co(f, or(y, 3), dt, !0);
      }
      function Jd(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, 1) : [];
      }
      function Im(f) {
        var y = f == null ? 0 : f.length;
        return y ? $i(f, nn) : [];
      }
      function km(f, y) {
        var w = f == null ? 0 : f.length;
        return w ? (y = y === l ? 1 : hr(y), $i(f, y)) : [];
      }
      function Am(f) {
        for (var y = -1, w = f == null ? 0 : f.length, Y = {}; ++y < w; ) {
          var dt = f[y];
          Y[dt[0]] = dt[1];
        }
        return Y;
      }
      function Qd(f) {
        return f && f.length ? f[0] : l;
      }
      function Nm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = w == null ? 0 : hr(w);
        return dt < 0 && (dt = ri(Y + dt, 0)), xa(f, y, dt);
      }
      function Fm(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 0, -1) : [];
      }
      var Dm = vr(function(f) {
        var y = qr(f, Su);
        return y.length && y[0] === f[0] ? fu(y) : [];
      }), Rm = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y === ys(w) ? y = l : w.pop(), w.length && w[0] === f[0] ? fu(w, or(y, 2)) : [];
      }), Om = vr(function(f) {
        var y = ys(f), w = qr(f, Su);
        return y = typeof y == "function" ? y : l, y && w.pop(), w.length && w[0] === f[0] ? fu(w, l, y) : [];
      });
      function Lm(f, y) {
        return f == null ? "" : Pp.call(f, y);
      }
      function ys(f) {
        var y = f == null ? 0 : f.length;
        return y ? f[y - 1] : l;
      }
      function Mm(f, y, w) {
        var Y = f == null ? 0 : f.length;
        if (!Y)
          return -1;
        var dt = Y;
        return w !== l && (dt = hr(w), dt = dt < 0 ? ri(Y + dt, 0) : wi(dt, Y - 1)), y === y ? up(f, y, dt) : co(f, Nc, dt, !0);
      }
      function Vm(f, y) {
        return f && f.length ? ud(f, hr(y)) : l;
      }
      var Bm = vr(ef);
      function ef(f, y) {
        return f && f.length && y && y.length ? gu(f, y) : f;
      }
      function zm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, or(w, 2)) : f;
      }
      function jm(f, y, w) {
        return f && f.length && y && y.length ? gu(f, y, l, w) : f;
      }
      var Hm = Ds(function(f, y) {
        var w = f == null ? 0 : f.length, Y = lu(f, y);
        return fd(f, qr(y, function(dt) {
          return Rs(dt, w) ? +dt : dt;
        }).sort($d)), Y;
      });
      function Um(f, y) {
        var w = [];
        if (!(f && f.length))
          return w;
        var Y = -1, dt = [], Wt = f.length;
        for (y = or(y, 3); ++Y < Wt; ) {
          var sn = f[Y];
          y(sn, Y, f) && (w.push(sn), dt.push(Y));
        }
        return fd(f, dt), w;
      }
      function Mu(f) {
        return f == null ? f : Np.call(f);
      }
      function Km(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (w && typeof w != "number" && Ni(f, y, w) ? (y = 0, w = Y) : (y = y == null ? 0 : hr(y), w = w === l ? Y : hr(w)), ms(f, y, w)) : [];
      }
      function Wm(f, y) {
        return Do(f, y);
      }
      function Gm(f, y, w) {
        return xu(f, y, or(w, 2));
      }
      function qm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y);
          if (Y < w && $s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Ym(f, y) {
        return Do(f, y, !0);
      }
      function Xm(f, y, w) {
        return xu(f, y, or(w, 2), !0);
      }
      function Zm(f, y) {
        var w = f == null ? 0 : f.length;
        if (w) {
          var Y = Do(f, y, !0) - 1;
          if ($s(f[Y], y))
            return Y;
        }
        return -1;
      }
      function Jm(f) {
        return f && f.length ? hd(f) : [];
      }
      function Qm(f, y) {
        return f && f.length ? hd(f, or(y, 2)) : [];
      }
      function eg(f) {
        var y = f == null ? 0 : f.length;
        return y ? ms(f, 1, y) : [];
      }
      function tg(f, y, w) {
        return f && f.length ? (y = w || y === l ? 1 : hr(y), ms(f, 0, y < 0 ? 0 : y)) : [];
      }
      function ng(f, y, w) {
        var Y = f == null ? 0 : f.length;
        return Y ? (y = w || y === l ? 1 : hr(y), y = Y - y, ms(f, y < 0 ? 0 : y, Y)) : [];
      }
      function rg(f, y) {
        return f && f.length ? Ro(f, or(y, 3), !1, !0) : [];
      }
      function ig(f, y) {
        return f && f.length ? Ro(f, or(y, 3)) : [];
      }
      var ag = vr(function(f) {
        return Ws($i(f, 1, ei, !0));
      }), og = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Ws($i(f, 1, ei, !0), or(y, 2));
      }), lg = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Ws($i(f, 1, ei, !0), l, y);
      });
      function ug(f) {
        return f && f.length ? Ws(f) : [];
      }
      function cg(f, y) {
        return f && f.length ? Ws(f, or(y, 2)) : [];
      }
      function ey(f, y) {
        return y = typeof y == "function" ? y : l, f && f.length ? Ws(f, l, y) : [];
      }
      function Bu(f) {
        if (!(f && f.length))
          return [];
        var y = 0;
        return f = Bs(f, function(w) {
          if (ei(w))
            return y = ri(w.length, y), !0;
        }), eu(y, function(w) {
          return qr(f, Zl(w));
        });
      }
      function tf(f, y) {
        if (!(f && f.length))
          return [];
        var w = Bu(f);
        return y == null ? w : qr(w, function(Y) {
          return Hi(y, l, Y);
        });
      }
      var ty = vr(function(f, y) {
        return ei(f) ? Ga(f, y) : [];
      }), ny = vr(function(f) {
        return Cu(Bs(f, ei));
      }), ry = vr(function(f) {
        var y = ys(f);
        return ei(y) && (y = l), Cu(Bs(f, ei), or(y, 2));
      }), iy = vr(function(f) {
        var y = ys(f);
        return y = typeof y == "function" ? y : l, Cu(Bs(f, ei), l, y);
      }), sy = vr(Bu);
      function ay(f, y) {
        return xd(f || [], y || [], Wa);
      }
      function oy(f, y) {
        return xd(f || [], y || [], Xa);
      }
      var ly = vr(function(f) {
        var y = f.length, w = y > 1 ? f[y - 1] : l;
        return w = typeof w == "function" ? (f.pop(), w) : l, tf(f, w);
      });
      function nf(f) {
        var y = Ft(f);
        return y.__chain__ = !0, y;
      }
      function uy(f, y) {
        return y(f), f;
      }
      function bl(f, y) {
        return y(f);
      }
      var cy = Ds(function(f) {
        var y = f.length, w = y ? f[0] : 0, Y = this.__wrapped__, dt = function(Wt) {
          return lu(Wt, f);
        };
        return y > 1 || this.__actions__.length || !(Y instanceof Pr) || !Rs(w) ? this.thru(dt) : (Y = Y.slice(w, +w + (y ? 1 : 0)), Y.__actions__.push({
          func: bl,
          args: [dt],
          thisArg: l
        }), new Ji(Y, this.__chain__).thru(function(Wt) {
          return y && !Wt.length && Wt.push(l), Wt;
        }));
      });
      function dy() {
        return nf(this);
      }
      function fy() {
        return new Ji(this.value(), this.__chain__);
      }
      function py() {
        this.__values__ === l && (this.__values__ = yf(this.value()));
        var f = this.__index__ >= this.__values__.length, y = f ? l : this.__values__[this.__index__++];
        return { done: f, value: y };
      }
      function hy() {
        return this;
      }
      function my(f) {
        for (var y, w = this; w instanceof Po; ) {
          var Y = Yd(w);
          Y.__index__ = 0, Y.__values__ = l, y ? dt.__wrapped__ = Y : y = Y;
          var dt = Y;
          w = w.__wrapped__;
        }
        return dt.__wrapped__ = f, y;
      }
      function gy() {
        var f = this.__wrapped__;
        if (f instanceof Pr) {
          var y = f;
          return this.__actions__.length && (y = new Pr(this)), y = y.reverse(), y.__actions__.push({
            func: bl,
            args: [Mu],
            thisArg: l
          }), new Ji(y, this.__chain__);
        }
        return this.thru(Mu);
      }
      function yy() {
        return vd(this.__wrapped__, this.__actions__);
      }
      var vy = Oo(function(f, y, w) {
        zr.call(f, w) ? ++f[w] : Ns(f, w, 1);
      });
      function xy(f, y, w) {
        var Y = pr(f) ? kc : xh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      function by(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, or(y, 3));
      }
      var Cy = Id(Xd), Sy = Id(Zd);
      function $y(f, y) {
        return $i(Cl(f, y), 1);
      }
      function wy(f, y) {
        return $i(Cl(f, y), nn);
      }
      function _y(f, y, w) {
        return w = w === l ? 1 : hr(w), $i(Cl(f, y), w);
      }
      function rf(f, y) {
        var w = pr(f) ? Xi : Ks;
        return w(f, or(y, 3));
      }
      function sf(f, y) {
        var w = pr(f) ? Wf : Qc;
        return w(f, or(y, 3));
      }
      var Ey = Oo(function(f, y, w) {
        zr.call(f, w) ? f[w].push(y) : Ns(f, w, [y]);
      });
      function Py(f, y, w, Y) {
        f = Bi(f) ? f : Na(f), w = w && !Y ? hr(w) : 0;
        var dt = f.length;
        return w < 0 && (w = ri(dt + w, 0)), Tl(f) ? w <= dt && f.indexOf(y, w) > -1 : !!dt && xa(f, y, w) > -1;
      }
      var Ty = vr(function(f, y, w) {
        var Y = -1, dt = typeof y == "function", Wt = Bi(f) ? xn(f.length) : [];
        return Ks(f, function(sn) {
          Wt[++Y] = dt ? Hi(y, sn, w) : qa(sn, y, w);
        }), Wt;
      }), Iy = Oo(function(f, y, w) {
        Ns(f, w, y);
      });
      function Cl(f, y) {
        var w = pr(f) ? qr : ad;
        return w(f, or(y, 3));
      }
      function ky(f, y, w, Y) {
        return f == null ? [] : (pr(y) || (y = y == null ? [] : [y]), w = Y ? l : w, pr(w) || (w = w == null ? [] : [w]), cd(f, y, w));
      }
      var Ay = Oo(function(f, y, w) {
        f[w ? 0 : 1].push(y);
      }, function() {
        return [[], []];
      });
      function Ny(f, y, w) {
        var Y = pr(f) ? Yl : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Ks);
      }
      function Fy(f, y, w) {
        var Y = pr(f) ? Gf : Dc, dt = arguments.length < 3;
        return Y(f, or(y, 4), w, dt, Qc);
      }
      function Dy(f, y) {
        var w = pr(f) ? Bs : ed;
        return w(f, El(or(y, 3)));
      }
      function Ry(f) {
        var y = pr(f) ? Yc : Lh;
        return y(f);
      }
      function Oy(f, y, w) {
        (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y);
        var Y = pr(f) ? hh : Mh;
        return Y(f, y);
      }
      function Ly(f) {
        var y = pr(f) ? mh : Bh;
        return y(f);
      }
      function My(f) {
        if (f == null)
          return 0;
        if (Bi(f))
          return Tl(f) ? Ca(f) : f.length;
        var y = Ei(f);
        return y == kn || y == Bn ? f.size : hu(f).length;
      }
      function Vy(f, y, w) {
        var Y = pr(f) ? Xl : zh;
        return w && Ni(f, y, w) && (y = l), Y(f, or(y, 3));
      }
      var By = vr(function(f, y) {
        if (f == null)
          return [];
        var w = y.length;
        return w > 1 && Ni(f, y[0], y[1]) ? y = [] : w > 2 && Ni(y[0], y[1], y[2]) && (y = [y[0]]), cd(f, $i(y, 1), []);
      }), Sl = wp || function() {
        return di.Date.now();
      };
      function zy(f, y) {
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          if (--f < 1)
            return y.apply(this, arguments);
        };
      }
      function af(f, y, w) {
        return y = w ? l : y, y = f && y == null ? f.length : y, Fs(f, Re, l, l, l, l, y);
      }
      function of(f, y) {
        var w;
        if (typeof y != "function")
          throw new Zi(g);
        return f = hr(f), function() {
          return --f > 0 && (w = y.apply(this, arguments)), f <= 1 && (y = l), w;
        };
      }
      var zu = vr(function(f, y, w) {
        var Y = Q;
        if (w.length) {
          var dt = Hs(w, ka(zu));
          Y |= ve;
        }
        return Fs(f, Y, y, w, dt);
      }), lf = vr(function(f, y, w) {
        var Y = Q | W;
        if (w.length) {
          var dt = Hs(w, ka(lf));
          Y |= ve;
        }
        return Fs(y, Y, f, w, dt);
      });
      function uf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, te, l, l, l, l, l, y);
        return Y.placeholder = uf.placeholder, Y;
      }
      function cf(f, y, w) {
        y = w ? l : y;
        var Y = Fs(f, K, l, l, l, l, l, y);
        return Y.placeholder = cf.placeholder, Y;
      }
      function df(f, y, w) {
        var Y, dt, Wt, sn, cn, pn, En = 0, In = !1, Dn = !1, qn = !0;
        if (typeof f != "function")
          throw new Zi(g);
        y = xs(y) || 0, Xr(w) && (In = !!w.leading, Dn = "maxWait" in w, Wt = Dn ? ri(xs(w.maxWait) || 0, y) : Wt, qn = "trailing" in w ? !!w.trailing : qn);
        function nr(ti) {
          var ws = Y, Ms = dt;
          return Y = dt = l, En = ti, sn = f.apply(Ms, ws), sn;
        }
        function lr(ti) {
          return En = ti, cn = no($r, y), In ? nr(ti) : sn;
        }
        function gr(ti) {
          var ws = ti - pn, Ms = ti - En, kf = y - ws;
          return Dn ? wi(kf, Wt - Ms) : kf;
        }
        function ur(ti) {
          var ws = ti - pn, Ms = ti - En;
          return pn === l || ws >= y || ws < 0 || Dn && Ms >= Wt;
        }
        function $r() {
          var ti = Sl();
          if (ur(ti))
            return Ir(ti);
          cn = no($r, gr(ti));
        }
        function Ir(ti) {
          return cn = l, qn && Y ? nr(ti) : (Y = dt = l, sn);
        }
        function Gi() {
          cn !== l && bd(cn), En = 0, Y = pn = dt = cn = l;
        }
        function Fi() {
          return cn === l ? sn : Ir(Sl());
        }
        function qi() {
          var ti = Sl(), ws = ur(ti);
          if (Y = arguments, dt = this, pn = ti, ws) {
            if (cn === l)
              return lr(pn);
            if (Dn)
              return bd(cn), cn = no($r, y), nr(pn);
          }
          return cn === l && (cn = no($r, y)), sn;
        }
        return qi.cancel = Gi, qi.flush = Fi, qi;
      }
      var jy = vr(function(f, y) {
        return Jc(f, 1, y);
      }), Hy = vr(function(f, y, w) {
        return Jc(f, xs(y) || 0, w);
      });
      function Uy(f) {
        return Fs(f, yt);
      }
      function $l(f, y) {
        if (typeof f != "function" || y != null && typeof y != "function")
          throw new Zi(g);
        var w = function() {
          var Y = arguments, dt = y ? y.apply(this, Y) : Y[0], Wt = w.cache;
          if (Wt.has(dt))
            return Wt.get(dt);
          var sn = f.apply(this, Y);
          return w.cache = Wt.set(dt, sn) || Wt, sn;
        };
        return w.cache = new ($l.Cache || As)(), w;
      }
      $l.Cache = As;
      function El(f) {
        if (typeof f != "function")
          throw new Zi(g);
        return function() {
          var y = arguments;
          switch (y.length) {
            case 0:
              return !f.call(this);
            case 1:
              return !f.call(this, y[0]);
            case 2:
              return !f.call(this, y[0], y[1]);
            case 3:
              return !f.call(this, y[0], y[1], y[2]);
          }
          return !f.apply(this, y);
        };
      }
      function Ky(f) {
        return of(2, f);
      }
      var Wy = jh(function(f, y) {
        y = y.length == 1 && pr(y[0]) ? qr(y[0], Ui(or())) : qr($i(y, 1), Ui(or()));
        var w = y.length;
        return vr(function(Y) {
          for (var dt = -1, Wt = wi(Y.length, w); ++dt < Wt; )
            Y[dt] = y[dt].call(this, Y[dt]);
          return Hi(f, this, Y);
        });
      }), Uu = vr(function(f, y) {
        var w = Hs(y, ka(Uu));
        return Fs(f, ve, l, y, w);
      }), ff = vr(function(f, y) {
        var w = Hs(y, ka(ff));
        return Fs(f, ee, l, y, w);
      }), Gy = Ds(function(f, y) {
        return Fs(f, wt, l, l, l, y);
      });
      function qy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y === l ? y : hr(y), vr(f, y);
      }
      function Yy(f, y) {
        if (typeof f != "function")
          throw new Zi(g);
        return y = y == null ? 0 : ri(hr(y), 0), vr(function(w) {
          var Y = w[y], dt = qs(w, 0, y);
          return Y && zs(dt, Y), Hi(f, this, dt);
        });
      }
      function Xy(f, y, w) {
        var Y = !0, dt = !0;
        if (typeof f != "function")
          throw new Zi(g);
        return Xr(w) && (Y = "leading" in w ? !!w.leading : Y, dt = "trailing" in w ? !!w.trailing : dt), df(f, y, {
          leading: Y,
          maxWait: y,
          trailing: dt
        });
      }
      function Zy(f) {
        return af(f, 1);
      }
      function Jy(f, y) {
        return Uu(wu(y), f);
      }
      function Qy() {
        if (!arguments.length)
          return [];
        var f = arguments[0];
        return pr(f) ? f : [f];
      }
      function ev(f) {
        return Qi(f, N);
      }
      function tv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, N, y);
      }
      function nv(f) {
        return Qi(f, P | N);
      }
      function rv(f, y) {
        return y = typeof y == "function" ? y : l, Qi(f, P | N, y);
      }
      function iv(f, y) {
        return y == null || Zc(f, y, oi(y));
      }
      function $s(f, y) {
        return f === y || f !== f && y !== y;
      }
      var sv = Zo(du), av = Zo(function(f, y) {
        return f >= y;
      }), ga = rd(/* @__PURE__ */ function() {
        return arguments;
      }()) ? rd : function(f) {
        return Qr(f) && zr.call(f, "callee") && !Hc.call(f, "callee");
      }, pr = xn.isArray, ov = wc ? Ui(wc) : _h;
      function Bi(f) {
        return f != null && Pl(f.length) && !Os(f);
      }
      function ei(f) {
        return Qr(f) && Bi(f);
      }
      function lv(f) {
        return f === !0 || f === !1 || Qr(f) && Ai(f) == _n;
      }
      var Ys = Ep || lc, uv = _c ? Ui(_c) : Eh;
      function cv(f) {
        return Qr(f) && f.nodeType === 1 && !ro(f);
      }
      function dv(f) {
        if (f == null)
          return !0;
        if (Bi(f) && (pr(f) || typeof f == "string" || typeof f.splice == "function" || Ys(f) || Aa(f) || ga(f)))
          return !f.length;
        var y = Ei(f);
        if (y == kn || y == Bn)
          return !f.size;
        if (to(f))
          return !hu(f).length;
        for (var w in f)
          if (zr.call(f, w))
            return !1;
        return !0;
      }
      function fv(f, y) {
        return Ya(f, y);
      }
      function pv(f, y, w) {
        w = typeof w == "function" ? w : l;
        var Y = w ? w(f, y) : l;
        return Y === l ? Ya(f, y, l, w) : !!Y;
      }
      function Wu(f) {
        if (!Qr(f))
          return !1;
        var y = Ai(f);
        return y == Xn || y == Un || typeof f.message == "string" && typeof f.name == "string" && !ro(f);
      }
      function hv(f) {
        return typeof f == "number" && Kc(f);
      }
      function Os(f) {
        if (!Xr(f))
          return !1;
        var y = Ai(f);
        return y == zn || y == jn || y == On || y == Ln;
      }
      function pf(f) {
        return typeof f == "number" && f == hr(f);
      }
      function Pl(f) {
        return typeof f == "number" && f > -1 && f % 1 == 0 && f <= vt;
      }
      function Xr(f) {
        var y = typeof f;
        return f != null && (y == "object" || y == "function");
      }
      function Qr(f) {
        return f != null && typeof f == "object";
      }
      var hf = Ec ? Ui(Ec) : Th;
      function mv(f, y) {
        return f === y || pu(f, y, Nu(y));
      }
      function gv(f, y, w) {
        return w = typeof w == "function" ? w : l, pu(f, y, Nu(y), w);
      }
      function yv(f) {
        return mf(f) && f != +f;
      }
      function vv(f) {
        if (dm(f))
          throw new fr(m);
        return id(f);
      }
      function xv(f) {
        return f === null;
      }
      function bv(f) {
        return f == null;
      }
      function mf(f) {
        return typeof f == "number" || Qr(f) && Ai(f) == Yn;
      }
      function ro(f) {
        if (!Qr(f) || Ai(f) != er)
          return !1;
        var y = xo(f);
        if (y === null)
          return !0;
        var w = zr.call(y, "constructor") && y.constructor;
        return typeof w == "function" && w instanceof w && mo.call(w) == xp;
      }
      var Zu = Pc ? Ui(Pc) : Ih;
      function Cv(f) {
        return pf(f) && f >= -vt && f <= vt;
      }
      var gf = Tc ? Ui(Tc) : kh;
      function Tl(f) {
        return typeof f == "string" || !pr(f) && Qr(f) && Ai(f) == Fn;
      }
      function Wi(f) {
        return typeof f == "symbol" || Qr(f) && Ai(f) == Gn;
      }
      var Aa = Ic ? Ui(Ic) : Ah;
      function Sv(f) {
        return f === l;
      }
      function $v(f) {
        return Qr(f) && Ei(f) == Mn;
      }
      function wv(f) {
        return Qr(f) && Ai(f) == Tn;
      }
      var _v = Zo(mu), Ev = Zo(function(f, y) {
        return f <= y;
      });
      function yf(f) {
        if (!f)
          return [];
        if (Bi(f))
          return Tl(f) ? Cs(f) : Vi(f);
        if (Ba && f[Ba])
          return ap(f[Ba]());
        var y = Ei(f), w = y == kn ? nu : y == Bn ? fo : Na;
        return w(f);
      }
      function Ls(f) {
        if (!f)
          return f === 0 ? f : 0;
        if (f = xs(f), f === nn || f === -nn) {
          var y = f < 0 ? -1 : 1;
          return y * Et;
        }
        return f === f ? f : 0;
      }
      function hr(f) {
        var y = Ls(f), w = y % 1;
        return y === y ? w ? y - w : y : 0;
      }
      function vf(f) {
        return f ? fa(hr(f), 0, un) : 0;
      }
      function xs(f) {
        if (typeof f == "number")
          return f;
        if (Wi(f))
          return Qt;
        if (Xr(f)) {
          var y = typeof f.valueOf == "function" ? f.valueOf() : f;
          f = Xr(y) ? y + "" : y;
        }
        if (typeof f != "string")
          return f === 0 ? f : +f;
        f = Rc(f);
        var w = kl.test(f);
        return w || Vl.test(f) ? Hf(f.slice(2), w ? 2 : 8) : Ol.test(f) ? Qt : +f;
      }
      function xf(f) {
        return Ps(f, zi(f));
      }
      function Pv(f) {
        return f ? fa(hr(f), -vt, vt) : f === 0 ? f : 0;
      }
      function Vr(f) {
        return f == null ? "" : Ki(f);
      }
      var Tv = Ta(function(f, y) {
        if (to(y) || Bi(y)) {
          Ps(y, oi(y), f);
          return;
        }
        for (var w in y)
          zr.call(y, w) && Wa(f, w, y[w]);
      }), bf = Ta(function(f, y) {
        Ps(y, zi(y), f);
      }), Il = Ta(function(f, y, w, Y) {
        Ps(y, zi(y), f, Y);
      }), Iv = Ta(function(f, y, w, Y) {
        Ps(y, oi(y), f, Y);
      }), kv = Ds(lu);
      function Av(f, y) {
        var w = Pa(f);
        return y == null ? w : Xc(w, y);
      }
      var Nv = vr(function(f, y) {
        f = Gr(f);
        var w = -1, Y = y.length, dt = Y > 2 ? y[2] : l;
        for (dt && Ni(y[0], y[1], dt) && (Y = 1); ++w < Y; )
          for (var Wt = y[w], sn = zi(Wt), cn = -1, pn = sn.length; ++cn < pn; ) {
            var En = sn[cn], In = f[En];
            (In === l || $s(In, $a[En]) && !zr.call(f, En)) && (f[En] = Wt[En]);
          }
        return f;
      }), Fv = vr(function(f) {
        return f.push(l, Od), Hi(Cf, l, f);
      });
      function Dv(f, y) {
        return Ac(f, or(y, 3), Es);
      }
      function Rv(f, y) {
        return Ac(f, or(y, 3), cu);
      }
      function Ov(f, y) {
        return f == null ? f : uu(f, or(y, 3), zi);
      }
      function Lv(f, y) {
        return f == null ? f : td(f, or(y, 3), zi);
      }
      function Mv(f, y) {
        return f && Es(f, or(y, 3));
      }
      function Vv(f, y) {
        return f && cu(f, or(y, 3));
      }
      function Bv(f) {
        return f == null ? [] : Ao(f, oi(f));
      }
      function zv(f) {
        return f == null ? [] : Ao(f, zi(f));
      }
      function ec(f, y, w) {
        var Y = f == null ? l : pa(f, y);
        return Y === l ? w : Y;
      }
      function jv(f, y) {
        return f != null && Vd(f, y, Ch);
      }
      function tc(f, y) {
        return f != null && Vd(f, y, Sh);
      }
      var Hv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), f[y] = w;
      }, rc(ji)), Uv = Ad(function(f, y, w) {
        y != null && typeof y.toString != "function" && (y = go.call(y)), zr.call(f, y) ? f[y].push(w) : f[y] = [w];
      }, or), Kv = vr(qa);
      function oi(f) {
        return Bi(f) ? qc(f) : hu(f);
      }
      function zi(f) {
        return Bi(f) ? qc(f, !0) : Nh(f);
      }
      function Wv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, y(Y, dt, Wt), Y);
        }), w;
      }
      function Gv(f, y) {
        var w = {};
        return y = or(y, 3), Es(f, function(Y, dt, Wt) {
          Ns(w, dt, y(Y, dt, Wt));
        }), w;
      }
      var qv = Ta(function(f, y, w) {
        No(f, y, w);
      }), Cf = Ta(function(f, y, w, Y) {
        No(f, y, w, Y);
      }), Yv = Ds(function(f, y) {
        var w = {};
        if (f == null)
          return w;
        var Y = !1;
        y = qr(y, function(Wt) {
          return Wt = Gs(Wt, f), Y || (Y = Wt.length > 1), Wt;
        }), Ps(f, Iu(f), w), Y && (w = Qi(w, P | T | N, Qh));
        for (var dt = y.length; dt--; )
          bu(w, y[dt]);
        return w;
      });
      function Xv(f, y) {
        return Sf(f, El(or(y)));
      }
      var Zv = Ds(function(f, y) {
        return f == null ? {} : Dh(f, y);
      });
      function Sf(f, y) {
        if (f == null)
          return {};
        var w = qr(Iu(f), function(Y) {
          return [Y];
        });
        return y = or(y), dd(f, w, function(Y, dt) {
          return y(Y, dt[0]);
        });
      }
      function Jv(f, y, w) {
        y = Gs(y, f);
        var Y = -1, dt = y.length;
        for (dt || (dt = 1, f = l); ++Y < dt; ) {
          var Wt = f == null ? l : f[Ts(y[Y])];
          Wt === l && (Y = dt, Wt = w), f = Os(Wt) ? Wt.call(f) : Wt;
        }
        return f;
      }
      function Qv(f, y, w) {
        return f == null ? f : Xa(f, y, w);
      }
      function e1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : Xa(f, y, w, Y);
      }
      var $f = Dd(oi), wf = Dd(zi);
      function t1(f, y, w) {
        var Y = pr(f), dt = Y || Ys(f) || Aa(f);
        if (y = or(y, 4), w == null) {
          var Wt = f && f.constructor;
          dt ? w = Y ? new Wt() : [] : Xr(f) ? w = Os(Wt) ? Pa(xo(f)) : {} : w = {};
        }
        return (dt ? Xi : Es)(f, function(sn, cn, pn) {
          return y(w, sn, cn, pn);
        }), w;
      }
      function n1(f, y) {
        return f == null ? !0 : bu(f, y);
      }
      function r1(f, y, w) {
        return f == null ? f : yd(f, y, wu(w));
      }
      function i1(f, y, w, Y) {
        return Y = typeof Y == "function" ? Y : l, f == null ? f : yd(f, y, wu(w), Y);
      }
      function Na(f) {
        return f == null ? [] : tu(f, oi(f));
      }
      function s1(f) {
        return f == null ? [] : tu(f, zi(f));
      }
      function a1(f, y, w) {
        return w === l && (w = y, y = l), w !== l && (w = xs(w), w = w === w ? w : 0), y !== l && (y = xs(y), y = y === y ? y : 0), fa(xs(f), y, w);
      }
      function o1(f, y, w) {
        return y = Ls(y), w === l ? (w = y, y = 0) : w = Ls(w), f = xs(f), $h(f, y, w);
      }
      function l1(f, y, w) {
        if (w && typeof w != "boolean" && Ni(f, y, w) && (y = w = l), w === l && (typeof y == "boolean" ? (w = y, y = l) : typeof f == "boolean" && (w = f, f = l)), f === l && y === l ? (f = 0, y = 1) : (f = Ls(f), y === l ? (y = f, f = 0) : y = Ls(y)), f > y) {
          var Y = f;
          f = y, y = Y;
        }
        if (w || f % 1 || y % 1) {
          var dt = Wc();
          return wi(f + dt * (y - f + jf("1e-" + ((dt + "").length - 1))), y);
        }
        return yu(f, y);
      }
      var u1 = Ia(function(f, y, w) {
        return y = y.toLowerCase(), f + (w ? _f(y) : y);
      });
      function _f(f) {
        return nc(Vr(f).toLowerCase());
      }
      function Ef(f) {
        return f = Vr(f), f && f.replace(Ll, tp).replace(Li, "");
      }
      function c1(f, y, w) {
        f = Vr(f), y = Ki(y);
        var Y = f.length;
        w = w === l ? Y : fa(hr(w), 0, Y);
        var dt = w;
        return w -= y.length, w >= 0 && f.slice(w, dt) == y;
      }
      function d1(f) {
        return f = Vr(f), f && _r.test(f) ? f.replace(Nr, np) : f;
      }
      function f1(f) {
        return f = Vr(f), f && bs.test(f) ? f.replace(Ii, "\\$&") : f;
      }
      var p1 = Ia(function(f, y, w) {
        return f + (w ? "-" : "") + y.toLowerCase();
      }), m1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toLowerCase();
      }), g1 = Td("toLowerCase");
      function y1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        if (!y || Y >= y)
          return f;
        var dt = (y - Y) / 2;
        return Bo(wo(dt), w) + f + Bo(So(dt), w);
      }
      function v1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? f + Bo(y - Y, w) : f;
      }
      function x1(f, y, w) {
        f = Vr(f), y = hr(y);
        var Y = y ? Ca(f) : 0;
        return y && Y < y ? Bo(y - Y, w) + f : f;
      }
      function b1(f, y, w) {
        return w || y == null ? y = 0 : y && (y = +y), Ap(Vr(f).replace(Oi, ""), y || 0);
      }
      function C1(f, y, w) {
        return (w ? Ni(f, y, w) : y === l) ? y = 1 : y = hr(y), vu(Vr(f), y);
      }
      function S1() {
        var f = arguments, y = Vr(f[0]);
        return f.length < 3 ? y : y.replace(f[1], f[2]);
      }
      var $1 = Ia(function(f, y, w) {
        return f + (w ? "_" : "") + y.toLowerCase();
      });
      function w1(f, y, w) {
        return w && typeof w != "number" && Ni(f, y, w) && (y = w = l), w = w === l ? un : w >>> 0, w ? (f = Vr(f), f && (typeof y == "string" || y != null && !Zu(y)) && (y = Ki(y), !y && ba(f)) ? qs(Cs(f), 0, w) : f.split(y, w)) : [];
      }
      var _1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + nc(y);
      });
      function E1(f, y, w) {
        return f = Vr(f), w = w == null ? 0 : fa(hr(w), 0, f.length), y = Ki(y), f.slice(w, w + y.length) == y;
      }
      function P1(f, y, w) {
        var Y = Ft.templateSettings;
        w && Ni(f, y, w) && (y = l), f = Vr(f), y = Il({}, y, Y, Rd);
        var dt = Il({}, y.imports, Y.imports, Rd), Wt = oi(dt), sn = tu(dt, Wt), cn, pn, En = 0, In = y.interpolate || Oa, Dn = "__p += '", qn = ru(
          (y.escape || Oa).source + "|" + In.source + "|" + (In === ii ? Xs : Oa).source + "|" + (y.evaluate || Oa).source + "|$",
          "g"
        ), nr = "//# sourceURL=" + (zr.call(y, "sourceURL") ? (y.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++mc + "]") + `
`;
        f.replace(qn, function(ur, $r, Ir, Gi, Fi, qi) {
          return Ir || (Ir = Gi), Dn += f.slice(En, qi).replace(cc, rp), $r && (cn = !0, Dn += `' +
__e(` + $r + `) +
'`), Fi && (pn = !0, Dn += `';
` + Fi + `;
__p += '`), Ir && (Dn += `' +
((__t = (` + Ir + `)) == null ? '' : __t) +
'`), En = qi + ur.length, ur;
        }), Dn += `';
`;
        var lr = zr.call(y, "variable") && y.variable;
        if (!lr)
          Dn = `with (obj) {
` + Dn + `
}
`;
        else if (Da.test(lr))
          throw new fr(v);
        Dn = (pn ? Dn.replace(ar, "") : Dn).replace(Or, "$1").replace(Sr, "$1;"), Dn = "function(" + (lr || "obj") + `) {
` + (lr ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (cn ? ", __e = _.escape" : "") + (pn ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + Dn + `return __p
}`;
        var gr = Tf(function() {
          return Mr(Wt, nr + "return " + Dn).apply(l, sn);
        });
        if (gr.source = Dn, Wu(gr))
          throw gr;
        return gr;
      }
      function T1(f) {
        return Vr(f).toLowerCase();
      }
      function I1(f) {
        return Vr(f).toUpperCase();
      }
      function k1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return Rc(f);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Cs(y), Wt = Oc(Y, dt), sn = Lc(Y, dt) + 1;
        return qs(Y, Wt, sn).join("");
      }
      function A1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.slice(0, Vc(f) + 1);
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Lc(Y, Cs(y)) + 1;
        return qs(Y, 0, dt).join("");
      }
      function N1(f, y, w) {
        if (f = Vr(f), f && (w || y === l))
          return f.replace(Oi, "");
        if (!f || !(y = Ki(y)))
          return f;
        var Y = Cs(f), dt = Oc(Y, Cs(y));
        return qs(Y, dt).join("");
      }
      function F1(f, y) {
        var w = xt, Y = Kt;
        if (Xr(y)) {
          var dt = "separator" in y ? y.separator : dt;
          w = "length" in y ? hr(y.length) : w, Y = "omission" in y ? Ki(y.omission) : Y;
        }
        f = Vr(f);
        var Wt = f.length;
        if (ba(f)) {
          var sn = Cs(f);
          Wt = sn.length;
        }
        if (w >= Wt)
          return f;
        var cn = w - Ca(Y);
        if (cn < 1)
          return Y;
        var pn = sn ? qs(sn, 0, cn).join("") : f.slice(0, cn);
        if (dt === l)
          return pn + Y;
        if (sn && (cn += pn.length - cn), Zu(dt)) {
          if (f.slice(cn).search(dt)) {
            var En, In = pn;
            for (dt.global || (dt = ru(dt.source, Vr(so.exec(dt)) + "g")), dt.lastIndex = 0; En = dt.exec(In); )
              var Dn = En.index;
            pn = pn.slice(0, Dn === l ? cn : Dn);
          }
        } else if (f.indexOf(Ki(dt), cn) != cn) {
          var qn = pn.lastIndexOf(dt);
          qn > -1 && (pn = pn.slice(0, qn));
        }
        return pn + Y;
      }
      function D1(f) {
        return f = Vr(f), f && Ur.test(f) ? f.replace(kr, cp) : f;
      }
      var R1 = Ia(function(f, y, w) {
        return f + (w ? " " : "") + y.toUpperCase();
      }), nc = Td("toUpperCase");
      function Pf(f, y, w) {
        return f = Vr(f), y = w ? l : y, y === l ? sp(f) ? hp(f) : Xf(f) : f.match(y) || [];
      }
      var Tf = vr(function(f, y) {
        try {
          return Hi(f, l, y);
        } catch (w) {
          return Wu(w) ? w : new fr(w);
        }
      }), O1 = Ds(function(f, y) {
        return Xi(y, function(w) {
          w = Ts(w), Ns(f, w, zu(f[w], f));
        }), f;
      });
      function L1(f) {
        var y = f == null ? 0 : f.length, w = or();
        return f = y ? qr(f, function(Y) {
          if (typeof Y[1] != "function")
            throw new Zi(g);
          return [w(Y[0]), Y[1]];
        }) : [], vr(function(Y) {
          for (var dt = -1; ++dt < y; ) {
            var Wt = f[dt];
            if (Hi(Wt[0], this, Y))
              return Hi(Wt[1], this, Y);
          }
        });
      }
      function M1(f) {
        return vh(Qi(f, P));
      }
      function rc(f) {
        return function() {
          return f;
        };
      }
      function V1(f, y) {
        return f == null || f !== f ? y : f;
      }
      var B1 = kd(), z1 = kd(!0);
      function ji(f) {
        return f;
      }
      function ic(f) {
        return sd(typeof f == "function" ? f : Qi(f, P));
      }
      function j1(f) {
        return od(Qi(f, P));
      }
      function H1(f, y) {
        return ld(f, Qi(y, P));
      }
      var U1 = vr(function(f, y) {
        return function(w) {
          return qa(w, f, y);
        };
      }), K1 = vr(function(f, y) {
        return function(w) {
          return qa(f, w, y);
        };
      });
      function sc(f, y, w) {
        var Y = oi(y), dt = Ao(y, Y);
        w == null && !(Xr(y) && (dt.length || !Y.length)) && (w = y, y = f, f = this, dt = Ao(y, oi(y)));
        var Wt = !(Xr(w) && "chain" in w) || !!w.chain, sn = Os(f);
        return Xi(dt, function(cn) {
          var pn = y[cn];
          f[cn] = pn, sn && (f.prototype[cn] = function() {
            var En = this.__chain__;
            if (Wt || En) {
              var In = f(this.__wrapped__), Dn = In.__actions__ = Vi(this.__actions__);
              return Dn.push({ func: pn, args: arguments, thisArg: f }), In.__chain__ = En, In;
            }
            return pn.apply(f, zs([this.value()], arguments));
          });
        }), f;
      }
      function W1() {
        return di._ === this && (di._ = bp), this;
      }
      function ac() {
      }
      function G1(f) {
        return f = hr(f), vr(function(y) {
          return ud(y, f);
        });
      }
      var q1 = Eu(qr), Y1 = Eu(kc), X1 = Eu(Xl);
      function If(f) {
        return Du(f) ? Zl(Ts(f)) : Rh(f);
      }
      function Z1(f) {
        return function(y) {
          return f == null ? l : pa(f, y);
        };
      }
      var J1 = Nd(), Q1 = Nd(!0);
      function oc() {
        return [];
      }
      function lc() {
        return !1;
      }
      function ex() {
        return {};
      }
      function tx() {
        return "";
      }
      function nx() {
        return !0;
      }
      function rx(f, y) {
        if (f = hr(f), f < 1 || f > vt)
          return [];
        var w = un, Y = wi(f, un);
        y = or(y), f -= un;
        for (var dt = eu(Y, y); ++w < f; )
          y(w);
        return dt;
      }
      function ix(f) {
        return pr(f) ? qr(f, Ts) : Wi(f) ? [f] : Vi(qd(Vr(f)));
      }
      function sx(f) {
        var y = ++vp;
        return Vr(f) + y;
      }
      var ax = Mo(function(f, y) {
        return f + y;
      }, 0), ox = Pu("ceil"), lx = Mo(function(f, y) {
        return f / y;
      }, 1), ux = Pu("floor");
      function cx(f) {
        return f && f.length ? Io(f, ji, du) : l;
      }
      function dx(f, y) {
        return f && f.length ? Io(f, or(y, 2), du) : l;
      }
      function fx(f) {
        return Fc(f, ji);
      }
      function px(f, y) {
        return Fc(f, or(y, 2));
      }
      function hx(f) {
        return f && f.length ? Io(f, ji, mu) : l;
      }
      function mx(f, y) {
        return f && f.length ? Io(f, or(y, 2), mu) : l;
      }
      var gx = Mo(function(f, y) {
        return f * y;
      }, 1), yx = Pu("round"), vx = Mo(function(f, y) {
        return f - y;
      }, 0);
      function xx(f) {
        return f && f.length ? Ql(f, ji) : 0;
      }
      function bx(f, y) {
        return f && f.length ? Ql(f, or(y, 2)) : 0;
      }
      return Ft.after = zy, Ft.ary = af, Ft.assign = Tv, Ft.assignIn = bf, Ft.assignInWith = Il, Ft.assignWith = Iv, Ft.at = kv, Ft.before = of, Ft.bind = zu, Ft.bindAll = O1, Ft.bindKey = lf, Ft.castArray = Qy, Ft.chain = nf, Ft.chunk = vm, Ft.compact = xm, Ft.concat = bm, Ft.cond = L1, Ft.conforms = M1, Ft.constant = rc, Ft.countBy = vy, Ft.create = Av, Ft.curry = uf, Ft.curryRight = cf, Ft.debounce = df, Ft.defaults = Nv, Ft.defaultsDeep = Fv, Ft.defer = jy, Ft.delay = Hy, Ft.difference = Cm, Ft.differenceBy = Sm, Ft.differenceWith = $m, Ft.drop = wm, Ft.dropRight = _m, Ft.dropRightWhile = Em, Ft.dropWhile = Pm, Ft.fill = Tm, Ft.filter = by, Ft.flatMap = $y, Ft.flatMapDeep = wy, Ft.flatMapDepth = _y, Ft.flatten = Jd, Ft.flattenDeep = Im, Ft.flattenDepth = km, Ft.flip = Uy, Ft.flow = B1, Ft.flowRight = z1, Ft.fromPairs = Am, Ft.functions = Bv, Ft.functionsIn = zv, Ft.groupBy = Ey, Ft.initial = Fm, Ft.intersection = Dm, Ft.intersectionBy = Rm, Ft.intersectionWith = Om, Ft.invert = Hv, Ft.invertBy = Uv, Ft.invokeMap = Ty, Ft.iteratee = ic, Ft.keyBy = Iy, Ft.keys = oi, Ft.keysIn = zi, Ft.map = Cl, Ft.mapKeys = Wv, Ft.mapValues = Gv, Ft.matches = j1, Ft.matchesProperty = H1, Ft.memoize = $l, Ft.merge = qv, Ft.mergeWith = Cf, Ft.method = U1, Ft.methodOf = K1, Ft.mixin = sc, Ft.negate = El, Ft.nthArg = G1, Ft.omit = Yv, Ft.omitBy = Xv, Ft.once = Ky, Ft.orderBy = ky, Ft.over = q1, Ft.overArgs = Wy, Ft.overEvery = Y1, Ft.overSome = X1, Ft.partial = Uu, Ft.partialRight = ff, Ft.partition = Ay, Ft.pick = Zv, Ft.pickBy = Sf, Ft.property = If, Ft.propertyOf = Z1, Ft.pull = Bm, Ft.pullAll = ef, Ft.pullAllBy = zm, Ft.pullAllWith = jm, Ft.pullAt = Hm, Ft.range = J1, Ft.rangeRight = Q1, Ft.rearg = Gy, Ft.reject = Dy, Ft.remove = Um, Ft.rest = qy, Ft.reverse = Mu, Ft.sampleSize = Oy, Ft.set = Qv, Ft.setWith = e1, Ft.shuffle = Ly, Ft.slice = Km, Ft.sortBy = By, Ft.sortedUniq = Jm, Ft.sortedUniqBy = Qm, Ft.split = w1, Ft.spread = Yy, Ft.tail = eg, Ft.take = tg, Ft.takeRight = ng, Ft.takeRightWhile = rg, Ft.takeWhile = ig, Ft.tap = uy, Ft.throttle = Xy, Ft.thru = bl, Ft.toArray = yf, Ft.toPairs = $f, Ft.toPairsIn = wf, Ft.toPath = ix, Ft.toPlainObject = xf, Ft.transform = t1, Ft.unary = Zy, Ft.union = ag, Ft.unionBy = og, Ft.unionWith = lg, Ft.uniq = ug, Ft.uniqBy = cg, Ft.uniqWith = ey, Ft.unset = n1, Ft.unzip = Bu, Ft.unzipWith = tf, Ft.update = r1, Ft.updateWith = i1, Ft.values = Na, Ft.valuesIn = s1, Ft.without = ty, Ft.words = Pf, Ft.wrap = Jy, Ft.xor = ny, Ft.xorBy = ry, Ft.xorWith = iy, Ft.zip = sy, Ft.zipObject = ay, Ft.zipObjectDeep = oy, Ft.zipWith = ly, Ft.entries = $f, Ft.entriesIn = wf, Ft.extend = bf, Ft.extendWith = Il, sc(Ft, Ft), Ft.add = ax, Ft.attempt = Tf, Ft.camelCase = u1, Ft.capitalize = _f, Ft.ceil = ox, Ft.clamp = a1, Ft.clone = ev, Ft.cloneDeep = nv, Ft.cloneDeepWith = rv, Ft.cloneWith = tv, Ft.conformsTo = iv, Ft.deburr = Ef, Ft.defaultTo = V1, Ft.divide = lx, Ft.endsWith = c1, Ft.eq = $s, Ft.escape = d1, Ft.escapeRegExp = f1, Ft.every = xy, Ft.find = Cy, Ft.findIndex = Xd, Ft.findKey = Dv, Ft.findLast = Sy, Ft.findLastIndex = Zd, Ft.findLastKey = Rv, Ft.floor = ux, Ft.forEach = rf, Ft.forEachRight = sf, Ft.forIn = Ov, Ft.forInRight = Lv, Ft.forOwn = Mv, Ft.forOwnRight = Vv, Ft.get = ec, Ft.gt = sv, Ft.gte = av, Ft.has = jv, Ft.hasIn = tc, Ft.head = Qd, Ft.identity = ji, Ft.includes = Py, Ft.indexOf = Nm, Ft.inRange = o1, Ft.invoke = Kv, Ft.isArguments = ga, Ft.isArray = pr, Ft.isArrayBuffer = ov, Ft.isArrayLike = Bi, Ft.isArrayLikeObject = ei, Ft.isBoolean = lv, Ft.isBuffer = Ys, Ft.isDate = uv, Ft.isElement = cv, Ft.isEmpty = dv, Ft.isEqual = fv, Ft.isEqualWith = pv, Ft.isError = Wu, Ft.isFinite = hv, Ft.isFunction = Os, Ft.isInteger = pf, Ft.isLength = Pl, Ft.isMap = hf, Ft.isMatch = mv, Ft.isMatchWith = gv, Ft.isNaN = yv, Ft.isNative = vv, Ft.isNil = bv, Ft.isNull = xv, Ft.isNumber = mf, Ft.isObject = Xr, Ft.isObjectLike = Qr, Ft.isPlainObject = ro, Ft.isRegExp = Zu, Ft.isSafeInteger = Cv, Ft.isSet = gf, Ft.isString = Tl, Ft.isSymbol = Wi, Ft.isTypedArray = Aa, Ft.isUndefined = Sv, Ft.isWeakMap = $v, Ft.isWeakSet = wv, Ft.join = Lm, Ft.kebabCase = p1, Ft.last = ys, Ft.lastIndexOf = Mm, Ft.lowerCase = m1, Ft.lowerFirst = g1, Ft.lt = _v, Ft.lte = Ev, Ft.max = cx, Ft.maxBy = dx, Ft.mean = fx, Ft.meanBy = px, Ft.min = hx, Ft.minBy = mx, Ft.stubArray = oc, Ft.stubFalse = lc, Ft.stubObject = ex, Ft.stubString = tx, Ft.stubTrue = nx, Ft.multiply = gx, Ft.nth = Vm, Ft.noConflict = W1, Ft.noop = ac, Ft.now = Sl, Ft.pad = y1, Ft.padEnd = v1, Ft.padStart = x1, Ft.parseInt = b1, Ft.random = l1, Ft.reduce = Ny, Ft.reduceRight = Fy, Ft.repeat = C1, Ft.replace = S1, Ft.result = Jv, Ft.round = yx, Ft.runInContext = fn, Ft.sample = Ry, Ft.size = My, Ft.snakeCase = $1, Ft.some = Vy, Ft.sortedIndex = Wm, Ft.sortedIndexBy = Gm, Ft.sortedIndexOf = qm, Ft.sortedLastIndex = Ym, Ft.sortedLastIndexBy = Xm, Ft.sortedLastIndexOf = Zm, Ft.startCase = _1, Ft.startsWith = E1, Ft.subtract = vx, Ft.sum = xx, Ft.sumBy = bx, Ft.template = P1, Ft.times = rx, Ft.toFinite = Ls, Ft.toInteger = hr, Ft.toLength = vf, Ft.toLower = T1, Ft.toNumber = xs, Ft.toSafeInteger = Pv, Ft.toString = Vr, Ft.toUpper = I1, Ft.trim = k1, Ft.trimEnd = A1, Ft.trimStart = N1, Ft.truncate = F1, Ft.unescape = D1, Ft.uniqueId = sx, Ft.upperCase = R1, Ft.upperFirst = nc, Ft.each = rf, Ft.eachRight = sf, Ft.first = Qd, sc(Ft, function() {
        var f = {};
        return Es(Ft, function(y, w) {
          zr.call(Ft.prototype, w) || (f[w] = y);
        }), f;
      }(), { chain: !1 }), Ft.VERSION = u, Xi(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(f) {
        Ft[f].placeholder = Ft;
      }), Xi(["drop", "take"], function(f, y) {
        Pr.prototype[f] = function(w) {
          w = w === l ? 1 : ri(hr(w), 0);
          var Y = this.__filtered__ && !y ? new Pr(this) : this.clone();
          return Y.__filtered__ ? Y.__takeCount__ = wi(w, Y.__takeCount__) : Y.__views__.push({
            size: wi(w, un),
            type: f + (Y.__dir__ < 0 ? "Right" : "")
          }), Y;
        }, Pr.prototype[f + "Right"] = function(w) {
          return this.reverse()[f](w).reverse();
        };
      }), Xi(["filter", "map", "takeWhile"], function(f, y) {
        var w = y + 1, Y = w == rn || w == Gt;
        Pr.prototype[f] = function(dt) {
          var Wt = this.clone();
          return Wt.__iteratees__.push({
            iteratee: or(dt, 3),
            type: w
          }), Wt.__filtered__ = Wt.__filtered__ || Y, Wt;
        };
      }), Xi(["head", "last"], function(f, y) {
        var w = "take" + (y ? "Right" : "");
        Pr.prototype[f] = function() {
          return this[w](1).value()[0];
        };
      }), Xi(["initial", "tail"], function(f, y) {
        var w = "drop" + (y ? "" : "Right");
        Pr.prototype[f] = function() {
          return this.__filtered__ ? new Pr(this) : this[w](1);
        };
      }), Pr.prototype.compact = function() {
        return this.filter(ji);
      }, Pr.prototype.find = function(f) {
        return this.filter(f).head();
      }, Pr.prototype.findLast = function(f) {
        return this.reverse().find(f);
      }, Pr.prototype.invokeMap = vr(function(f, y) {
        return typeof f == "function" ? new Pr(this) : this.map(function(w) {
          return qa(w, f, y);
        });
      }), Pr.prototype.reject = function(f) {
        return this.filter(El(or(f)));
      }, Pr.prototype.slice = function(f, y) {
        f = hr(f);
        var w = this;
        return w.__filtered__ && (f > 0 || y < 0) ? new Pr(w) : (f < 0 ? w = w.takeRight(-f) : f && (w = w.drop(f)), y !== l && (y = hr(y), w = y < 0 ? w.dropRight(-y) : w.take(y - f)), w);
      }, Pr.prototype.takeRightWhile = function(f) {
        return this.reverse().takeWhile(f).reverse();
      }, Pr.prototype.toArray = function() {
        return this.take(un);
      }, Es(Pr.prototype, function(f, y) {
        var w = /^(?:filter|find|map|reject)|While$/.test(y), Y = /^(?:head|last)$/.test(y), dt = Ft[Y ? "take" + (y == "last" ? "Right" : "") : y], Wt = Y || /^find/.test(y);
        dt && (Ft.prototype[y] = function() {
          var sn = this.__wrapped__, cn = Y ? [1] : arguments, pn = sn instanceof Pr, En = cn[0], In = pn || pr(sn), Dn = function($r) {
            var Ir = dt.apply(Ft, zs([$r], cn));
            return Y && qn ? Ir[0] : Ir;
          };
          In && w && typeof En == "function" && En.length != 1 && (pn = In = !1);
          var qn = this.__chain__, nr = !!this.__actions__.length, lr = Wt && !qn, gr = pn && !nr;
          if (!Wt && In) {
            sn = gr ? sn : new Pr(this);
            var ur = f.apply(sn, cn);
            return ur.__actions__.push({ func: bl, args: [Dn], thisArg: l }), new Ji(ur, qn);
          }
          return lr && gr ? f.apply(this, cn) : (ur = this.thru(Dn), lr ? Y ? ur.value()[0] : ur.value() : ur);
        });
      }), Xi(["pop", "push", "shift", "sort", "splice", "unshift"], function(f) {
        var y = po[f], w = /^(?:push|sort|unshift)$/.test(f) ? "tap" : "thru", Y = /^(?:pop|shift)$/.test(f);
        Ft.prototype[f] = function() {
          var dt = arguments;
          if (Y && !this.__chain__) {
            var Wt = this.value();
            return y.apply(pr(Wt) ? Wt : [], dt);
          }
          return this[w](function(sn) {
            return y.apply(pr(sn) ? sn : [], dt);
          });
        };
      }), Es(Pr.prototype, function(f, y) {
        var w = Ft[y];
        if (w) {
          var Y = w.name + "";
          zr.call(Ea, Y) || (Ea[Y] = []), Ea[Y].push({ name: y, func: w });
        }
      }), Ea[Lo(l, W).name] = [{
        name: "wrapper",
        func: l
      }], Pr.prototype.clone = Mp, Pr.prototype.reverse = Bp, Pr.prototype.value = zp, Ft.prototype.at = cy, Ft.prototype.chain = dy, Ft.prototype.commit = fy, Ft.prototype.next = py, Ft.prototype.plant = my, Ft.prototype.reverse = gy, Ft.prototype.toJSON = Ft.prototype.valueOf = Ft.prototype.value = yy, Ft.prototype.first = Ft.prototype.head, Ba && (Ft.prototype[Ba] = hy), Ft;
    }, Sa = mp();
    Qs ? ((Qs.exports = Sa)._ = Sa, Wl._ = Sa) : di._ = Sa;
  }).call(Dr);
})(ke$1, ke$1.exports);
var Zg = ke$1.exports;
const Jg = "Droppable", Qg = {
  timeout: 25
};
function t0({
  data: s,
  disabled: o,
  id: l,
  resizeObserverConfig: u
}) {
  const c = ll(Jg), m = pl(), g = shallowRef({ disabled: o.value }), v = shallowRef(!1), b = shallowRef(null), S = shallowRef(null), {
    disabled: E,
    updateMeasurementsFor: P,
    timeout: T
  } = {
    ...Qg,
    ...u
  }, N = computed(() => l.value), O = computed(() => (P == null ? void 0 : P.value) ?? N.value), z = hi(O), Q = $g({
    callback: () => {
      if (!v.value) {
        v.value = !0;
        return;
      }
      S.value != null && clearTimeout(S.value), S.value = setTimeout(() => {
        m.value.measureDroppableContainers(
          Array.isArray(z.value) ? z.value : [z.value]
        ), S.value = null;
      }, T);
    },
    disabled: E || !m.value.active
  }), W = (Re, wt) => {
    Q.value && (wt && (Q.value.unobserve(wt), v.value = !1), Re && Q.value.observe(Re));
  }, [ue, te] = vi(W), K = hi(computed(() => s == null ? void 0 : s.value));
  watch([ue, Q], () => {
    !Q.value || !ue.value || (Q.value.disconnect(), v.value = !1, Q.value.observe(ue.value));
  }, { immediate: !0 }), watch(
    () => l.value,
    (Re, wt, yt) => {
      m.value.dispatch({
        type: Te$1.RegisterDroppable,
        element: {
          id: Re,
          key: c,
          disabled: o.value,
          node: ue,
          rect: b,
          data: K
        }
      }), yt(() => m.value.dispatch({
        type: Te$1.UnregisterDroppable,
        key: c,
        id: Re
      }));
    },
    { immediate: !0 }
  ), watch([l, c, () => o.value, () => m.value.dispatch], () => {
    o.value !== g.value.disabled && (m.value.dispatch({
      type: Te$1.SetDroppableDisabled,
      id: l.value,
      key: c,
      disabled: o.value
    }), g.value.disabled = o.value);
  });
  const ve = computed(() => {
    var Re;
    return ((Re = m.value.over) == null ? void 0 : Re.id) === l.value;
  }), ee = ref$1(b.value);
  return watch(b, (Re, wt, yt) => {
    Zg.isEqual(Re, wt) || (ee.value = Re);
  }), {
    // active: internalContext.value.active,
    rect: ee,
    isOver: ve,
    node: ue,
    // over: internalContext.value.over,
    setNodeRef: te
  };
}
function fi(s, o) {
  const l = ref$1(s());
  return watch(o, () => {
    l.value = s();
  }, { immediate: !0 }), l;
}
function n0(...s) {
  return (o) => {
    s.forEach((l) => l(o));
  };
}
function r0(s) {
  const o = Object.prototype.toString.call(s);
  return o === "[object Window]" || // In Electron context the Window object serializes to [object global]
  o === "[object global]";
}
function e0(s) {
  return "nodeType" in s;
}
function u0(s) {
  var o;
  return s ? r0(s) ? s : e0(s) ? ((o = s.ownerDocument) == null ? void 0 : o.defaultView) ?? window : window : window;
}
let si = {};
function i0(s, o) {
  return computed(() => {
    if (o)
      return o;
    const l = si[s] == null ? 0 : si[s] + 1;
    return si[s] = l, `${s}-${l}`;
  });
}
function o0(s) {
  return (o, ...l) => l.reduce(
    (u, c) => {
      const m = Object.entries(c);
      for (const [g, v] of m) {
        const b = u[g];
        b != null && (u[g] = b + s * v);
      }
      return u;
    },
    {
      ...o
    }
  );
}
const a0 = o0(-1);
function l0(s) {
  if (!s)
    return !1;
  const { KeyboardEvent: o } = u0(s.target);
  return o && s instanceof o;
}
const Oe$1 = Object.freeze({
  Translate: {
    toString(s) {
      if (!s)
        return;
      const { x: o, y: l } = s;
      return `translate3d(${o ? Math.round(o) : 0}px, ${l ? Math.round(l) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(s) {
      if (!s)
        return;
      const { scaleX: o, scaleY: l } = s;
      return `scaleX(${o}) scaleY(${l})`;
    }
  },
  Transform: {
    toString(s) {
      if (s)
        return [
          Oe$1.Translate.toString(s),
          Oe$1.Scale.toString(s)
        ].join(" ");
    }
  },
  Transition: {
    toString({ property: s, duration: o, easing: l }) {
      return `${s} ${o}ms ${l}`;
    }
  }
});
function dl(s, o, l) {
  const u = s.slice();
  return u.splice(
    l < 0 ? u.length + l : l,
    0,
    u.splice(o, 1)[0]
  ), u;
}
function c0(s, o) {
  return s.reduce((l, u, c) => {
    const m = o.get(u);
    return m && (l[c] = m), l;
  }, Array(s.length));
}
function De$1(s) {
  return s !== null && s >= 0;
}
function f0(s, o) {
  if (s === o)
    return !0;
  if (s.length !== o.length)
    return !1;
  for (let l = 0; l < s.length; l++)
    if (s[l] !== o[l])
      return !1;
  return !0;
}
function s0(s) {
  return typeof s == "boolean" ? {
    draggable: s,
    droppable: s
  } : s;
}
const je$1 = {
  scaleX: 1,
  scaleY: 1
}, T0 = ({
  rects: s,
  activeNodeRect: o,
  activeIndex: l,
  overIndex: u,
  index: c
}) => {
  const m = s[l] ?? o;
  if (!m)
    return null;
  const g = h0(s, c, l);
  if (c === l) {
    const v = s[u];
    return v ? {
      x: l < u ? v.left + v.width - (m.left + m.width) : v.left - m.left,
      y: 0,
      ...je$1
    } : null;
  }
  return c > l && c <= u ? {
    x: -m.width - g,
    y: 0,
    ...je$1
  } : c < l && c >= u ? {
    x: m.width + g,
    y: 0,
    ...je$1
  } : {
    x: 0,
    y: 0,
    ...je$1
  };
};
function h0(s, o, l) {
  const u = s[o], c = s[o - 1], m = s[o + 1];
  return !u || !c && !m ? 0 : l < o ? c ? u.left - (c.left + c.width) : m.left - (u.left + u.width) : m ? m.left - (u.left + u.width) : u.left - (c.left + c.width);
}
const gl = ({
  rects: s,
  activeIndex: o,
  overIndex: l,
  index: u
}) => {
  const c = dl(s, l, o), m = s[u], g = c[u];
  return !g || !m ? null : {
    x: g.left - m.left,
    y: g.top - m.top,
    scaleX: g.width / m.width,
    scaleY: g.height / m.height
  };
}, Ee$1 = {
  scaleX: 1,
  scaleY: 1
}, k0 = ({
  activeIndex: s,
  activeNodeRect: o,
  index: l,
  rects: u,
  overIndex: c
}) => {
  const m = u[s] ?? o;
  if (!m)
    return null;
  if (l === s) {
    const v = u[c];
    return v ? {
      x: 0,
      y: s < c ? v.top + v.height - (m.top + m.height) : v.top - m.top,
      ...Ee$1
    } : null;
  }
  const g = v0(u, l, s);
  return l > s && l <= c ? {
    x: 0,
    y: -m.height - g,
    ...Ee$1
  } : l < s && l >= c ? {
    x: 0,
    y: m.height + g,
    ...Ee$1
  } : {
    x: 0,
    y: 0,
    ...Ee$1
  };
};
function v0(s, o, l) {
  const u = s[o], c = s[o - 1], m = s[o + 1];
  return u ? l < o ? c ? u.top - (c.top + c.height) : m ? m.top - (u.top + u.height) : 0 : m ? m.top - (u.top + u.height) : c ? u.top - (c.top + c.height) : 0 : 0;
}
const p0 = {
  value: Object
}, d0 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("SortableContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: p0,
  name: "SortableProvider"
});
function _l() {
  return {
    context: inject("SortableContext", ref$1({
      activeIndex: -1,
      containerId: yl,
      disableTransforms: !1,
      items: [],
      overIndex: -1,
      useDragOverlay: !1,
      sortedRects: [],
      strategy: gl,
      disabled: {
        draggable: !1,
        droppable: !1
      }
    }))
  };
}
const g0 = {
  name: String
}, _0 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = _l();
  return () => s.default ? s.default(o) : null;
}, {
  props: g0,
  name: "SortableConsumer"
}), yl = "Sortable", y0 = {
  Provider: d0,
  Consumer: _0
}, m0 = {
  id: String,
  items: {
    type: [Array]
  },
  strategy: {
    type: Function,
    default: gl
  },
  disabled: {
    type: Boolean,
    default: !1
  }
}, O0 = /* @__PURE__ */ defineComponent((s, {}) => {
  const o = useSlots(), l = Hg(), u = i0(yl, s.id), c = computed(() => l.value.dragOverlay.rect !== null), m = computed(() => s.items.map((T) => typeof T == "object" && "id" in T ? T.id : T)), g = computed(() => l.value.active != null), v = computed(() => l.value.active ? m.value.indexOf(l.value.active.id) : -1), b = ref$1(-1);
  watch(() => {
    var T;
    return (T = l.value.over) == null ? void 0 : T.id;
  }, () => {
    b.value = l.value.over ? m.value.indexOf(l.value.over.id) : -1;
  }, {
    immediate: !0
  });
  const S = ref$1(m.value), E = computed(() => !f0(m.value, S.value)), P = computed(() => b.value !== -1 && v.value === -1 || E.value);
  return watch([E, m, () => g.value, () => l.value.measureDroppableContainers, () => l.value.measuringScheduled], (T, N, O) => {
    E.value && g.value && !l.value.measuringScheduled && l.value.measureDroppableContainers(m.value);
  }, {
    immediate: !0
  }), watchEffect(() => {
    S.value = m.value;
  }), () => {
    const T = s0(s.disabled), N = {
      activeIndex: v.value,
      containerId: u.value,
      disabled: T,
      disableTransforms: P.value,
      items: m.value,
      overIndex: b.value,
      useDragOverlay: c.value,
      sortedRects: c0(m.value, l.value.droppableRects),
      strategy: s.strategy
    };
    return createVNode(y0.Provider, {
      value: N
    }, {
      default: () => {
        var O;
        return [(O = o.default) == null ? void 0 : O.call(o)];
      }
    });
  };
}, {
  props: m0,
  name: "SortableContext"
}), w0 = ({
  id: s,
  items: o,
  activeIndex: l,
  overIndex: u
}) => dl(o, l, u).indexOf(s), b0 = ({
  containerId: s,
  isSorting: o,
  wasDragging: l,
  index: u,
  items: c,
  newIndex: m,
  previousItems: g,
  previousContainerId: v,
  transition: b
}) => !b || !l || g !== c && u === m ? !1 : o ? !0 : m !== u && s === v, x0 = {
  duration: 200,
  easing: "ease"
}, ml = "transform", S0 = Oe$1.Transition.toString({
  property: ml,
  duration: 0,
  easing: "linear"
}), A0 = {
  roleDescription: "sortable"
};
function I0({ disabled: s, index: o, node: l, rect: u }) {
  const c = ref$1(null);
  function m(v) {
    c.value = v;
  }
  const g = ref$1(o.value);
  return watch([s, o, l, u], (v, b, S) => {
    if (s.value && o.value !== g.value && l.value) {
      const E = u.value;
      if (E && l.value) {
        const P = Be$1(l.value, {
          ignoreTransform: !0
        }), T = {
          x: E.left - P.left,
          y: E.top - P.top,
          scaleX: E.width / P.width,
          scaleY: E.height / P.height
        };
        (T.x || T.y) && m(T);
      }
    }
    o.value !== g.value && (g.value = o.value);
  }, { immediate: !0 }), watch(c, (v, b, S) => {
    c.value && requestAnimationFrame(() => {
      m(null);
    });
  }, { immediate: !0 }), c;
}
function z0({
  animateLayoutChanges: s = b0,
  attributes: o,
  disabled: l,
  data: u,
  getNewIndex: c = w0,
  id: m,
  strategy: g,
  resizeObserverConfig: v,
  transition: b = x0
}) {
  const { context: S } = _l(), E = computed(() => R0(
    l,
    S.value.disabled
  )), P = ref$1(-1);
  watch([() => S.value.items, () => m.value], () => {
    P.value = S.value.items.indexOf(m.value);
  }, { immediate: !0 });
  const T = computed(
    () => ({ sortable: { containerId: S.value.containerId, index: P.value, items: S.value.items }, ...u })
  ), N = computed(
    () => S.value.items.slice(S.value.items.indexOf(m.value))
  ), O = computed(() => E.value.droppable || !1), { rect: z, node: Q, isOver: W, setNodeRef: ue } = t0({
    id: m,
    data: T,
    disabled: O,
    resizeObserverConfig: {
      updateMeasurementsFor: N,
      ...v
    }
  }), te = computed(() => E.value.draggable || !1), {
    internalContext: K,
    attributes: ve,
    setNodeRef: ee,
    listeners: Re,
    isDragging: wt,
    setActivatorNodeRef: yt,
    transform: xt
  } = Gg({
    id: m,
    data: T,
    attributes: {
      ...A0,
      ...o
    },
    disabled: te
  }), Kt = n0(ue, ee), tn = fi(() => !!K.value.active, [() => K.value.active]), ln = computed(() => tn.value && !S.value.disableTransforms && De$1(S.value.activeIndex) && De$1(S.value.overIndex)), rn = computed(() => !S.value.useDragOverlay && wt.value), an = computed(() => rn.value && ln.value ? xt.value : null), Gt = computed(() => {
    const vn = g ?? S.value.strategy;
    return ln.value ? an.value ?? vn({
      rects: S.value.sortedRects,
      activeNodeRect: K.value.activeNodeRect,
      activeIndex: S.value.activeIndex,
      overIndex: S.value.overIndex,
      index: P.value
    }) : null;
  }), nn = ref$1(-1);
  watch([
    () => S.value.activeIndex,
    () => S.value.overIndex,
    () => S.value.items,
    () => P.value,
    () => m.value
  ], (vn, Pn, On) => {
    nn.value = De$1(S.value.activeIndex) && De$1(S.value.overIndex) ? c({ id: m.value, items: S.value.items, activeIndex: S.value.activeIndex, overIndex: S.value.overIndex }) : P.value;
  }, { immediate: !0 });
  const vt = fi(() => {
    var vn;
    return (vn = K.value.active) == null ? void 0 : vn.id;
  }, [() => {
    var vn;
    return (vn = K.value.active) == null ? void 0 : vn.id;
  }]), Et = shallowRef({
    activeId: vt.value,
    items: S.value.items,
    newIndex: nn.value,
    containerId: S.value.containerId
  }), Qt = computed(() => S.value.items !== Et.value.items), un = fi(() => {
    var vn;
    return s({
      active: K.value.active,
      containerId: S.value.containerId,
      isDragging: wt.value,
      isSorting: tn.value,
      id: m.value,
      index: P.value,
      items: S.value.items,
      newIndex: Et.value.newIndex,
      previousItems: Et.value.items,
      previousContainerId: Et.value.containerId,
      transition: b,
      wasDragging: ((vn = Et.value) == null ? void 0 : vn.activeId) != null
    });
  }, [
    () => K.value.active,
    () => S.value.containerId,
    () => wt.value,
    () => tn.value,
    () => m.value,
    () => P.value,
    () => S.value.items,
    () => Et.value.newIndex,
    () => Et.value.items,
    () => Et.value.containerId,
    () => {
      var vn;
      return (vn = Et.value) == null ? void 0 : vn.activeId;
    }
  ]), gn = I0({
    disabled: un,
    index: P,
    node: Q,
    rect: z
  });
  watch([tn, nn, () => S.value.containerId, () => S.value.items], () => {
    tn.value && Et.value.newIndex !== nn.value && (Et.value.newIndex = nn.value), S.value.containerId !== Et.value.containerId && (Et.value.containerId = S.value.containerId), S.value.items !== Et.value.items && (Et.value.items = S.value.items);
  }), watch([vt], (vn, Pn, On) => {
    if (vt.value === Et.value.activeId)
      return;
    if (vt.value && !Et.value.activeId) {
      Et.value.activeId = vt.value;
      return;
    }
    const _n = setTimeout(() => {
      Et.value.activeId = vt.value;
    }, 50);
    On(() => clearTimeout(_n));
  });
  const dn = ref$1(yn());
  watch([
    () => gn.value,
    () => Qt.value,
    () => Et.value.newIndex,
    () => P.value,
    () => un.value
  ], () => {
    dn.value = yn();
  }, { immediate: !0 });
  function yn() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      gn.value || // Or to prevent items jumping to back to their "new" position when items change
      Qt.value && Et.value.newIndex === P.value
    )
      return S0;
    if (!(rn.value && !l0(K.value.activatorEvent) || !b) && (tn.value || un.value))
      return Oe$1.Transition.toString({
        ...b,
        property: ml
      });
  }
  return {
    internalContext: K,
    context: S,
    // active: internalContext.value.active,
    // activeIndex: context.value.activeIndex,
    // items: context.value.items,
    // overIndex: context.value.overIndex,
    // over: internalContext.value.over,
    attributes: ve,
    data: T,
    rect: z,
    index: P,
    newIndex: nn,
    isOver: W,
    isSorting: tn,
    isDragging: wt,
    listeners: Re,
    node: Q,
    setNodeRef: Kt,
    setActivatorNodeRef: yt,
    setDroppableNodeRef: ue,
    setDraggableNodeRef: ee,
    transform: gn.value ? gn : Gt,
    transition: dn
  };
}
function R0(s, o) {
  return typeof s == "boolean" ? {
    draggable: s,
    // Backwards compatibility
    droppable: !1
  } : {
    draggable: (s == null ? void 0 : s.draggable) ?? o.draggable,
    droppable: (s == null ? void 0 : s.droppable) ?? o.droppable
  };
}
function ze(s) {
  if (!s)
    return !1;
  const o = s.data.current;
  return !!(o && "sortable" in o && typeof o.sortable == "object" && "containerId" in o.sortable && "items" in o.sortable && "index" in o.sortable);
}
const C0 = [
  q$1.Down,
  q$1.Right,
  q$1.Up,
  q$1.Left
], M0 = (s, {
  context: {
    active: o,
    collisionRect: l,
    droppableRects: u,
    droppableContainers: c,
    over: m,
    scrollableAncestors: g
  }
}) => {
  if (C0.includes(s.code)) {
    if (s.preventDefault(), !(o != null && o.value) || !l)
      return;
    const v = [];
    c.getEnabled().forEach((E) => {
      if (!E || E != null && E.disabled)
        return;
      const P = u.get(E.id);
      if (P)
        switch (s.code) {
          case q$1.Down:
            l.top < P.top && v.push(E);
            break;
          case q$1.Up:
            l.top > P.top && v.push(E);
            break;
          case q$1.Left:
            l.left > P.left && v.push(E);
            break;
          case q$1.Right:
            l.left < P.left && v.push(E);
            break;
        }
    });
    const b = bg({
      active: o.value,
      collisionRect: l,
      droppableRects: u,
      droppableContainers: v,
      pointerCoordinates: null
    });
    let S = wg(b, "id");
    if (S === (m == null ? void 0 : m.id) && b.length > 1 && (S = b[1].id), S != null) {
      const E = c.get(o.value.id), P = c.get(S), T = P ? u.get(P.id) : null, N = P == null ? void 0 : P.node.current;
      if (N && T && E && P) {
        const O = fl(N).some(
          (te, K) => g[K] !== te
        ), z = wl(E, P), Q = D0(E, P), W = O || !z ? {
          x: 0,
          y: 0
        } : {
          x: Q ? l.width - T.width : 0,
          y: Q ? l.height - T.height : 0
        }, ue = {
          x: T.left,
          y: T.top
        };
        return W.x && W.y ? ue : a0(ue, W);
      }
    }
  }
};
function wl(s, o) {
  return !ze(s) || !ze(o) ? !1 : s.data.current.sortable.containerId === o.data.current.sortable.containerId;
}
function D0(s, o) {
  return !ze(s) || !ze(o) || !wl(s, o) ? !1 : s.data.current.sortable.index < o.data.current.sortable.index;
}
const d = Object.freeze({
  Translate: {
    toString(s) {
      if (!s)
        return;
      const { x: o, y: l } = s;
      return `translate3d(${o ? Math.round(o) : 0}px, ${l ? Math.round(l) : 0}px, 0)`;
    }
  },
  Scale: {
    toString(s) {
      if (!s)
        return;
      const { scaleX: o, scaleY: l } = s;
      return `scaleX(${o}) scaleY(${l})`;
    }
  },
  Transform: {
    toString(s) {
      if (s)
        return [
          d.Translate.toString(s),
          d.Scale.toString(s)
        ].join(" ");
    }
  },
  Transition: {
    toString({ property: s, duration: o, easing: l }) {
      return `${s} ${o}ms ${l}`;
    }
  }
}), vuePropsType$2t = {
  id: {
    type: [String, Number],
    required: !0
  },
  item: {
    type: Function,
    required: !0
  }
}, SortableItem$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2t
  },
  name: "SortableItem",
  setup(s, {}) {
    const o = {
      id: computed(() => s.id)
    }, {
      attributes: l,
      listeners: u,
      setNodeRef: c,
      transform: m,
      transition: g,
      isDragging: v
    } = z0(o);
    return () => {
      const b = {
        transform: d.Transform.toString(m.value),
        // @ts-ignore
        transition: g.value
      };
      return s.item({
        setNodeRef: c,
        style: b,
        attributes: l == null ? void 0 : l.value,
        listeners: u == null ? void 0 : u.value
      });
    };
  }
});
function _isSlot$H(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const vuePropsType$2s = {
  items: Array,
  onSortEnd: Function,
  useDragHandle: [Boolean],
  helperClass: String,
  axis: String
}, SortableList$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2s
  },
  name: "SortableList",
  setup(s, {}) {
    useSlots();
    const o = z_(U_(os, {
      activationConstraint: {
        // distance: 5,
        delay: 100,
        tolerance: 100
      }
    }), U_(ls, {
      coordinateGetter: M0
    })), l = {
      sideEffects: T_({
        styles: {
          active: {
            opacity: "0.5"
          }
        }
      })
    }, u = ref$1("");
    function c(m) {
      var g;
      u.value = "" + ((g = m.active) == null ? void 0 : g.id);
    }
    return () => {
      let m, g;
      return createVNode(K_, {
        sensors: o.value,
        collisionDetection: $_,
        onDragStart: c,
        onDragEnd: s.onSortEnd
      }, {
        default: () => [createVNode(O0, {
          items: s.items,
          strategy: T0
        }, _isSlot$H(m = s.items.map((v) => createVNode(SortableItem$1, {
          key: v.key,
          id: v.key,
          item: v.item
        }, null))) ? m : {
          default: () => [m]
        }), createVNode(Teleport, {
          to: document.body
        }, {
          default: () => [createVNode(X_, {
            adjustScale: !1,
            dropAnimation: l
          }, _isSlot$H(g = s.items.filter((v) => v.id === u.value).map((v) => v.item({}))) ? g : {
            default: () => [g]
          })]
        })]
      });
    };
  }
});
function _isSlot$G(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$G = cssClasses$J.PREFIX, propTypes$1w = {
  // children: PropTypes.node as PropType<TagInputProps['children']>,
  clearIcon: node$1,
  style: object$1,
  className: string$3,
  disabled: bool,
  allowDuplicates: bool,
  max: number$2,
  maxTagCount: number$2,
  maxLength: number$2,
  showRestTagsPopover: bool,
  restTagsPopoverProps: object$1,
  showContentTooltip: bool,
  defaultValue: array$1,
  value: array$1,
  inputValue: string$3,
  placeholder: string$3,
  separator: oneOfType([string$3, array$1]),
  showClear: bool,
  addOnBlur: bool,
  draggable: bool,
  expandRestTagsOnClick: bool,
  autoFocus: bool,
  renderTagItem: func,
  onBlur: func,
  onFocus: func,
  onChange: func,
  onInputChange: func,
  onExceed: func,
  onInputExceed: func,
  onAdd: func,
  onRemove: func,
  onKeyDown: func,
  size: string$3,
  validateStatus: string$3,
  prefix: oneOfType([string$3, node$1]),
  suffix: oneOfType([string$3, node$1]),
  "aria-label": string$3,
  preventScroll: bool,
  insetLabel: node$1,
  insetLabelId: string$3
}, defaultProps$1q = {
  showClear: !1,
  addOnBlur: !1,
  allowDuplicates: !0,
  showRestTagsPopover: !0,
  autoFocus: !1,
  draggable: !1,
  expandRestTagsOnClick: !0,
  showContentTooltip: !0,
  separator: ",",
  size: "default",
  validateStatus: "default",
  onBlur: lodashExports.noop,
  onFocus: lodashExports.noop,
  onChange: lodashExports.noop,
  onInputChange: lodashExports.noop,
  onExceed: lodashExports.noop,
  onInputExceed: lodashExports.noop,
  onAdd: lodashExports.noop,
  onRemove: lodashExports.noop,
  onKeyDown: lodashExports.noop
}, vuePropsType$2r = vuePropsMake(propTypes$1w, defaultProps$1q), Index$3 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2r
  },
  name: "TagInput",
  setup(s, {
    expose: o
  }) {
    const {
      getProps: l
    } = useHasInProps();
    useSlots();
    const u = ref$1(null), c = ref$1(null);
    let m = null;
    const g = reactive({
      tagsArray: s.defaultValue || [],
      inputValue: "",
      focusing: !1,
      hovering: !1,
      active: !1,
      entering: !1
    }), {
      adapter: v,
      getDataAttr: b
    } = useBaseComponent(s, g), S = new TagInputFoundation(E());
    function E() {
      return {
        ...v(),
        setInputValue: (vt) => {
          g.inputValue = vt;
        },
        setTagsArray: (vt) => {
          g.tagsArray = vt;
        },
        setFocusing: (vt) => {
          g.focusing = vt;
        },
        toggleFocusing: (vt) => {
          const {
            preventScroll: Et
          } = s, Qt = u.value;
          vt ? Qt && Qt.focus({
            preventScroll: Et
          }) : Qt && Qt.blur(), g.focusing = vt;
        },
        setHovering: (vt) => {
          g.hovering = vt;
        },
        setActive: (vt) => {
          g.active = vt;
        },
        setEntering: (vt) => {
          g.entering = vt;
        },
        getClickOutsideHandler: () => m,
        notifyBlur: (vt) => {
          s.onBlur(vt);
        },
        notifyFocus: (vt) => {
          s.onFocus(vt);
        },
        notifyInputChange: (vt, Et) => {
          s.onInputChange(vt, Et);
        },
        notifyTagChange: (vt) => {
          s.onChange(vt);
        },
        notifyTagAdd: (vt) => {
          s.onAdd(vt);
        },
        notifyTagRemove: (vt, Et) => {
          s.onRemove(vt, Et);
        },
        notifyKeyDown: (vt) => {
          s.onKeyDown(vt);
        },
        registerClickOutsideHandler: (vt) => {
          m = (Et) => {
            const Qt = c.value, un = Et.target, gn = Et.composedPath && Et.composedPath() || [un];
            Qt && !Qt.contains(un) && !gn.includes(Qt) && vt(Et);
          }, document.addEventListener("click", m, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("click", m, !1), m = null;
        }
      };
    }
    function P(vt, Et) {
      const {
        value: Qt,
        inputValue: un
      } = vt, {
        tagsArray: gn
      } = Et;
      let dn;
      return lodashExports.isArray(Qt) ? dn = Qt : "value" in l(vt) && !Qt ? dn = [] : dn = gn, {
        tagsArray: dn,
        inputValue: lodashExports.isString(un) ? un : Et.inputValue
      };
    }
    watch([() => s.value, () => s.inputValue, () => g.inputValue], (vt) => {
      const Et = P({
        ...s
      }, {
        ...g
      });
      Et && Object.keys(Et).forEach((Qt) => {
        g[Qt] = Et[Qt];
      });
    }, {
      deep: !0,
      immediate: !0
    }), onMounted(() => {
      const {
        disabled: vt,
        autoFocus: Et,
        preventScroll: Qt
      } = s;
      !vt && Et && (u.value.focus({
        preventScroll: Qt
      }), S.handleClick()), S.init();
    });
    const T = (vt) => {
      S.handleInputChange(vt);
    }, N = (vt) => {
      S.handleKeyDown(vt);
    }, O = (vt) => {
      S.handleInputFocus(vt);
    }, z = (vt) => {
      S.handleInputBlur(vt);
    }, Q = (vt) => {
      S.handleClearBtn(vt);
    }, W = (vt) => {
      S.handleClearEnterPress(vt);
    }, ue = (vt) => {
      S.handleTagClose(vt);
    }, te = (vt) => {
      S.handleInputMouseLeave();
    }, K = (vt) => {
      S.handleClick(vt);
    }, ve = (vt) => {
      S.handleInputMouseEnter();
    }, ee = (vt) => {
      S.handleClickPrefixOrSuffix(vt);
    }, Re = (vt) => {
      S.handlePreventMouseDown(vt);
    };
    function wt() {
      const {
        hovering: vt,
        tagsArray: Et,
        inputValue: Qt
      } = g, {
        showClear: un,
        disabled: gn,
        clearIcon: dn
      } = s, yn = cls(`${prefixCls$G}-clearBtn`, {
        [`${prefixCls$G}-clearBtn-invisible`]: !vt || Qt === "" && Et.length === 0 || gn
      });
      return un ? createVNode("div", {
        role: "button",
        tabindex: 0,
        "aria-label": "Clear TagInput value",
        class: yn,
        onClick: (vn) => Q(vn),
        onKeypress: (vn) => W(vn)
      }, [dn || createVNode(IconComponent$w, null, null)]) : null;
    }
    function yt() {
      const {
        prefix: vt,
        insetLabel: Et,
        insetLabelId: Qt
      } = s, un = vt || Et;
      if (lodashExports.isNull(vt) || lodashExports.isUndefined(vt))
        return null;
      const gn = cls(`${prefixCls$G}-prefix`, {
        [`${prefixCls$G}-inset-label`]: Et,
        [`${prefixCls$G}-prefix-text`]: un && lodashExports.isString(un),
        // eslint-disable-next-line max-len
        [`${prefixCls$G}-prefix-icon`]: isSemiIcon(un)
      });
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions,jsx-a11y/click-events-have-key-events
        createVNode("div", {
          class: gn,
          onMousedown: Re,
          onClick: ee,
          id: Qt,
          "x-semi-prop": "prefix"
        }, [un])
      );
    }
    function xt() {
      const {
        suffix: vt
      } = s;
      if (lodashExports.isNull(vt) || lodashExports.isUndefined(vt))
        return null;
      const Et = cls(`${prefixCls$G}-suffix`, {
        [`${prefixCls$G}-suffix-text`]: vt && lodashExports.isString(vt),
        // eslint-disable-next-line max-len
        [`${prefixCls$G}-suffix-icon`]: isSemiIcon(vt)
      });
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        createVNode("div", {
          class: Et,
          onMousedown: Re,
          onClick: ee,
          "x-semi-prop": "suffix"
        }, [vt])
      );
    }
    const Kt = () => {
      const {
        size: vt,
        disabled: Et,
        renderTagItem: Qt,
        showContentTooltip: un,
        draggable: gn
      } = s, {
        tagsArray: dn,
        active: yn
      } = g, vn = yn && gn, Pn = cls(`${prefixCls$G}-wrapper-tag`, {
        [`${prefixCls$G}-wrapper-tag-size-${vt}`]: vt,
        [`${prefixCls$G}-wrapper-tag-icon`]: vn
      }), On = cls(`${prefixCls$G}-wrapper-typo`, {
        [`${prefixCls$G}-wrapper-typo-disabled`]: Et
      }), _n = cls({
        [`${prefixCls$G}-drag-item`]: vn,
        [`${prefixCls$G}-wrapper-tag-icon`]: vn
      });
      return dn.map((Nn, Un) => {
        const Xn = vn ? Nn : `${Un}${Nn}`, zn = () => {
          !Et && ue(Un);
        };
        return lodashExports.isFunction(Qt) ? (jn) => vn ? createVNode("div", mergeProps$1({
          class: _n,
          key: Xn,
          ref: jn.setNodeRef,
          style: jn.style
        }, jn.attributes), [createVNode(IconComponent$j, mergeProps$1({
          className: `${prefixCls$G}-drag-handler`
        }, jn.listeners), null), Qt(Nn, Un, zn)]) : Qt(Nn, Un, zn) : (jn) => createVNode("div", mergeProps$1({
          key: Xn,
          ref: jn.setNodeRef,
          style: jn.style
        }, jn.attributes, vn ? {} : jn.listeners), [createVNode(Tag, {
          className: Pn,
          color: "white",
          size: vt === "small" ? "small" : "large",
          type: "light",
          onClose: zn,
          closable: !Et,
          key: Xn,
          visible: !0,
          "aria-label": `${Et ? "" : "Closable "}Tag: ${Nn}`
        }, {
          default: () => [vn && createVNode(IconComponent$j, mergeProps$1({
            className: `${prefixCls$G}-drag-handler`
          }, jn.listeners), null), createVNode(Paragraph$1, {
            className: On,
            ellipsis: {
              showTooltip: un,
              rows: 1
            }
          }, _isSlot$G(Nn) ? Nn : {
            default: () => [Nn]
          })]
        })]);
      });
    }, tn = (vt) => {
      const Et = g.tagsArray, {
        active: Qt,
        over: un
      } = vt;
      if (!(!Qt || !un) && Qt.id !== un.id) {
        const gn = Et.indexOf("" + Qt.id), dn = Et.indexOf("" + un.id);
        E().setTagsArray(dl(Et, gn, dn));
      }
    };
    function ln() {
      const {
        disabled: vt,
        maxTagCount: Et,
        showRestTagsPopover: Qt,
        restTagsPopoverProps: un = {},
        draggable: gn,
        expandRestTagsOnClick: dn
      } = s, {
        tagsArray: yn,
        active: vn
      } = g, Pn = cls(`${prefixCls$G}-wrapper-n`, {
        [`${prefixCls$G}-wrapper-n-disabled`]: vt
      }), On = Kt();
      let _n = [];
      const Nn = On.map((jn) => jn({}));
      let Un = [...Nn];
      (!vn || !dn) && Et && Et < Nn.length && (Un = Nn.slice(0, Et), _n = Nn.slice(Et));
      const Xn = createVNode("span", {
        class: Pn
      }, [createTextVNode("+"), yn.length - Et]), zn = On.map((jn, kn) => ({
        item: jn,
        key: yn[kn],
        id: yn[kn]
      }));
      return vn && gn && zn.length > 0 ? createVNode(SortableList$1, {
        useDragHandle: !0,
        items: zn,
        helperClass: `${prefixCls$G}-drag-item-move`,
        onSortEnd: tn,
        axis: "xy"
      }, _isSlot$G(zn) ? zn : {
        default: () => [zn]
      }) : createVNode(Fragment, null, [Un, _n.length > 0 && (Qt ? createVNode(Popover$1, mergeProps$1({
        content: _n,
        showArrow: !0,
        trigger: "hover",
        position: "top",
        autoAdjustOverflow: !0
      }, un), _isSlot$G(Xn) ? Xn : {
        default: () => [Xn]
      }) : Xn)]);
    }
    function rn() {
      u.value.blur(), S.clickOutsideCallBack();
    }
    function an() {
      var Qt;
      const {
        preventScroll: vt,
        disabled: Et
      } = s;
      (Qt = u.value) == null || Qt.focus(), Et || S.handleClick();
    }
    const Gt = (vt) => {
      S.handleInputCompositionStart(vt);
    }, nn = (vt) => {
      S.handleInputCompositionEnd(vt);
    };
    return o({
      blur: rn,
      focus: an
    }), () => {
      const {
        size: vt,
        style: Et,
        className: Qt,
        disabled: un,
        placeholder: gn,
        validateStatus: dn,
        prefix: yn,
        insetLabel: vn,
        suffix: Pn
      } = s, {
        focusing: On,
        hovering: _n,
        tagsArray: Nn,
        inputValue: Un,
        active: Xn
      } = g, zn = cls(prefixCls$G, Qt, {
        [`${prefixCls$G}-focus`]: On || Xn,
        [`${prefixCls$G}-disabled`]: un,
        [`${prefixCls$G}-hover`]: _n && !un,
        [`${prefixCls$G}-error`]: dn === "error",
        [`${prefixCls$G}-warning`]: dn === "warning",
        [`${prefixCls$G}-small`]: vt === "small",
        [`${prefixCls$G}-large`]: vt === "large",
        [`${prefixCls$G}-with-prefix`]: !!yn || !!vn,
        [`${prefixCls$G}-with-suffix`]: !!Pn
      }), jn = cls(`${prefixCls$G}-wrapper-input`, `${prefixCls$G}-wrapper-input-${vt}`), kn = cls(`${prefixCls$G}-wrapper`);
      return createVNode("div", mergeProps$1({
        ref: c,
        style: Et,
        class: zn,
        "aria-disabled": un,
        "aria-label": s["aria-label"],
        "aria-invalid": dn === "error",
        onMouseenter: (Yn) => {
          ve();
        },
        onMouseleave: (Yn) => {
          te();
        },
        onClick: (Yn) => {
          K(Yn);
        }
      }, b()), [yt(), createVNode("div", {
        class: kn
      }, [ln(), createVNode(Input$1, {
        "aria-label": "input value",
        ref: u,
        className: jn,
        disabled: un,
        value: Un,
        size: vt,
        placeholder: Nn.length === 0 ? gn : "",
        onKeyDown: (Yn) => {
          N(Yn);
        },
        onChange: (Yn, Zn) => {
          T(Zn);
        },
        onBlur: (Yn) => {
          z(Yn);
        },
        onFocus: (Yn) => {
          O(Yn);
        },
        onCompositionstart: Gt,
        onCompositionend: nn
      }, null)]), wt(), xt()]);
    };
  }
}), TagInput = Index$3;
function _isSlot$F(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$7 = cssClasses$L.PREFIX, resetkey = 0, propTypes$1v = {
  "aria-labelledby": string$3,
  "aria-invalid": [bool, string$3],
  "aria-errormessage": string$3,
  "aria-describedby": string$3,
  "aria-required": bool,
  "aria-label": string$3,
  arrowIcon: node$1,
  borderless: bool,
  changeOnSelect: bool,
  defaultValue: oneOfType([string$3, array$1]),
  disabled: bool,
  dropdownClassName: string$3,
  dropdownStyle: object$1,
  emptyContent: node$1,
  motion: bool,
  /* show search input, if passed in a function, used as custom filter */
  filterTreeNode: oneOfType([func, bool]),
  filterLeafOnly: bool,
  placeholder: string$3,
  searchPlaceholder: string$3,
  size: String,
  style: object$1,
  className: string$3,
  treeData: [String, Number, Object, Array],
  treeNodeFilterProp: string$3,
  suffix: node$1,
  prefix: node$1,
  insetLabel: node$1,
  insetLabelId: string$3,
  id: string$3,
  displayProp: string$3,
  displayRender: func,
  onChange: func,
  onSearch: func,
  onSelect: func,
  onBlur: func,
  onFocus: func,
  children: node$1,
  getPopupContainer: func,
  zIndex: number$2,
  value: oneOfType([string$3, number$2, array$1]),
  validateStatus: string$3,
  showNext: string$3,
  stopPropagation: oneOfType([bool, string$3]),
  showClear: bool,
  defaultOpen: bool,
  autoAdjustOverflow: bool,
  onDropdownVisibleChange: func,
  triggerRender: func,
  onListScroll: func,
  onChangeWithObject: bool,
  bottomSlot: node$1,
  topSlot: node$1,
  multiple: bool,
  autoMergeValue: bool,
  maxTagCount: number$2,
  showRestTagsPopover: bool,
  restTagsPopoverProps: object$1,
  max: number$2,
  separator: string$3,
  onExceed: func,
  onClear: func,
  loadData: func,
  onLoad: func,
  loadedKeys: array$1,
  disableStrictly: bool,
  leafOnly: bool,
  enableLeafClick: bool,
  preventScroll: bool,
  position: string$3,
  searchPosition: string$3,
  autoClearSearchValue: {
    type: Boolean,
    default: !0
  },
  mouseEnterDelay: Number,
  mouseLeaveDelay: Number,
  virtualizeInSearch: Object,
  filterSorter: func,
  filterRender: func
}, defaultProps$1p = {
  borderless: !1,
  leafOnly: !1,
  arrowIcon: createVNode(IconComponent$A, null, null),
  stopPropagation: !0,
  motion: !0,
  defaultOpen: !1,
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  showClear: !1,
  autoClearSearchValue: !0,
  changeOnSelect: !1,
  disableStrictly: !1,
  autoMergeValue: !0,
  multiple: !1,
  filterTreeNode: !1,
  filterLeafOnly: !0,
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  separator: " / ",
  size: "default",
  treeNodeFilterProp: "label",
  displayProp: "label",
  treeData: [],
  showNext: strings$i.SHOW_NEXT_BY_CLICK,
  onExceed: lodashExports.noop,
  onClear: lodashExports.noop,
  onDropdownVisibleChange: lodashExports.noop,
  onListScroll: lodashExports.noop,
  enableLeafClick: !1,
  "aria-label": "Cascader",
  searchPosition: strings$i.SEARCH_POSITION_TRIGGER
}, vuePropsType$2q = vuePropsMake(propTypes$1v, defaultProps$1p), Index$2 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2q
  },
  name: "Cascader",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const {
      getProps: l
    } = useHasInProps(), u = reactive({
      disabledKeys: /* @__PURE__ */ new Set(),
      isOpen: s.defaultOpen,
      /* By changing rePosKey, the dropdown position can be refreshed */
      rePosKey: resetkey,
      /* A data structure for storing cascader data items */
      keyEntities: {},
      /* Selected and show tick icon */
      selectedKeys: /* @__PURE__ */ new Set([]),
      /* The key of the activated node */
      activeKeys: /* @__PURE__ */ new Set([]),
      /* The key of the filtered node */
      filteredKeys: /* @__PURE__ */ new Set([]),
      /* Value of input box */
      inputValue: "",
      /* Is searching */
      isSearching: !1,
      /* The placeholder of input box */
      inputPlaceHolder: s.searchPlaceholder || s.placeholder,
      /* Cache props */
      prevProps: {},
      /* Is hovering */
      isHovering: !1,
      /* Key of checked node, when multiple */
      checkedKeys: /* @__PURE__ */ new Set([]),
      /* Key of half checked node, when multiple */
      halfCheckedKeys: /* @__PURE__ */ new Set([]),
      /* Auto merged checkedKeys or leaf checkedKeys, when multiple */
      resolvedCheckedKeys: /* @__PURE__ */ new Set([]),
      /* Keys of loaded item */
      loadedKeys: /* @__PURE__ */ new Set(),
      /* Keys of loading item */
      loadingKeys: /* @__PURE__ */ new Set(),
      /* Mark whether this rendering has triggered asynchronous loading of data */
      loading: !1,
      isFocus: void 0,
      isInput: void 0
    }), c = calcMergeType(s.autoMergeValue, s.leafOnly), m = ref$1(null), g = ref$1(null), v = ref$1(null);
    let b = null;
    const S = shallowRef(), E = shallowRef(), {
      adapter: P,
      context: T,
      getDataAttr: N
    } = useBaseComponent(s, u), O = new CascaderFoundation(z());
    function z() {
      const zn = {
        updateInputValue: (kn) => {
          u.inputValue = kn;
        },
        updateInputPlaceHolder: (kn) => {
          u.inputPlaceHolder = kn;
        },
        focusInput: () => {
          const {
            preventScroll: kn
          } = s;
          m.value && m.value.focus({
            preventScroll: kn
          });
        },
        blurInput: () => {
          m.value && m.value.blur();
        }
      }, jn = {
        registerClickOutsideHandler: (kn) => {
          b = (Zn) => {
            var Fn;
            const er = v.value, bn = g.value, Ln = (Fn = er == null ? void 0 : er.getRef) == null ? void 0 : Fn.call(er).vnode.el, Kn = Zn.target, Bn = Zn.composedPath && Zn.composedPath() || [Kn];
            Ln && (!Ln.contains(Kn) || !Ln.contains(Kn.parentNode)) && bn && !bn.contains(Kn) && !(Bn.includes(bn) || Bn.includes(Ln)) && kn(Zn);
          }, document.addEventListener("mousedown", b, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("mousedown", b, !1);
        },
        rePositionDropdown: () => {
          let {
            rePosKey: kn
          } = u;
          kn = kn + 1, u.rePosKey = kn;
        }
      };
      return {
        ...P(),
        ...zn,
        ...jn,
        updateStates: (kn) => {
          for (let Yn in kn)
            u[Yn] = kn[Yn];
        },
        openMenu: () => {
          u.isOpen = !0;
        },
        closeMenu: (kn) => {
          u.isOpen = !1, kn && kn();
        },
        updateSelection: (kn) => {
          u.selectedKeys = kn;
        },
        notifyChange: (kn) => {
          s.onChange && s.onChange(kn);
        },
        notifySelect: (kn) => {
          s.onSelect && s.onSelect(kn);
        },
        notifyOnSearch: (kn) => {
          s.onSearch && s.onSearch(kn);
        },
        notifyFocus: (...kn) => {
          s.onFocus && s.onFocus(...kn);
        },
        notifyBlur: (...kn) => {
          s.onBlur && s.onBlur(...kn);
        },
        notifyDropdownVisibleChange: (kn) => {
          s.onDropdownVisibleChange(kn);
        },
        toggleHovering: (kn) => {
          u.isHovering = kn;
        },
        notifyLoadData: (kn, Yn) => {
          const {
            loadData: Zn
          } = s;
          Zn && new Promise((er) => {
            Zn(kn).then(() => {
              Yn(), u.loading = !0, er();
            });
          });
        },
        notifyOnLoad: (kn, Yn) => {
          const {
            onLoad: Zn
          } = s;
          Zn && Zn(kn, Yn);
        },
        notifyListScroll: (kn, {
          panelIndex: Yn,
          activeNode: Zn
        }) => {
          s.onListScroll(kn, {
            panelIndex: Yn,
            activeNode: Zn
          });
        },
        notifyOnExceed: (kn) => s.onExceed(kn),
        notifyClear: () => s.onClear(),
        toggleInputShow: (kn, Yn) => {
          u.showInput = kn, nextTick(() => {
            Yn();
          });
        },
        updateFocusState: (kn) => {
          u.isFocus = kn;
        },
        updateLoadingKeyRefValue: (kn) => {
          S.value = kn;
        },
        getLoadingKeyRefValue: () => S.value,
        updateLoadedKeyRefValue: (kn) => {
          E.value = kn;
        },
        getLoadedKeyRefValue: () => E.value
      };
    }
    function Q(zn) {
      const {
        multiple: jn,
        value: kn,
        defaultValue: Yn,
        onChangeWithObject: Zn,
        leafOnly: er,
        autoMergeValue: bn
      } = zn, {
        prevProps: Ln
      } = u;
      let Kn = u.keyEntities || {};
      const Bn = {}, Fn = (Mn) => {
        const Tn = lodashExports.isEmpty(Ln) && Mn in zn, Rn = Ln && !lodashExports.isEqual(Ln[Mn], zn[Mn]);
        return Tn || Rn;
      }, Gn = () => {
        const Mn = !Ln && "treeData" in zn, Tn = Ln && Ln.treeData !== zn.treeData;
        return Mn || Tn;
      }, Wn = (Mn, Tn) => {
        let Rn = [];
        Array.isArray(Mn) ? Rn = Array.isArray(Mn[0]) ? Mn : [Mn] : Mn !== void 0 && (Rn = [[Mn]]);
        const hn = [];
        return Rn.forEach((rr) => {
          const tr = Zn && lodashExports.isObject(rr[0]) ? rr.map((Cr) => Cr == null ? void 0 : Cr.value) : rr;
          tr.length > 0 && hn.push(tr);
        }), hn.reduce((rr, tr) => {
          const Cr = getKeyByValuePath(tr);
          return Tn[Cr] && rr.push(Cr), rr;
        }, []);
      };
      if (jn) {
        const Mn = Fn("treeData") || Gn(), Tn = Fn("value") || lodashExports.isEmpty(Ln) && Yn;
        if (Mn || Tn) {
          Mn && (Bn.treeData = zn.treeData, Kn = convertDataToEntities(zn.treeData), Bn.keyEntities = Kn);
          let Rn = u.checkedKeys;
          if (Tn) {
            const Cr = Fn("value") ? kn : Yn;
            Rn = Wn(Cr, Kn);
          } else
            Mn && "value" in l(zn) && (Rn = Wn(kn, Kn));
          lodashExports.isSet(Rn) && (Rn = [...Rn]);
          const hn = calcCheckedKeys(Rn, Kn), Qn = new Set(hn.checkedKeys), rr = new Set(hn.halfCheckedKeys);
          zn.disableStrictly && (Bn.disabledKeys = calcDisabledKeys(Kn));
          const tr = calcMergeType(bn, er) === strings$i.LEAF_ONLY_MERGE_TYPE;
          Bn.prevProps = zn, Bn.checkedKeys = Qn, Bn.halfCheckedKeys = rr, Bn.resolvedCheckedKeys = new Set(normalizeKeyList(Qn, Kn, tr));
        }
      }
      return Bn;
    }
    watch([() => s.multiple, () => s.value, () => s.defaultValue, () => s.onChangeWithObject, () => s.leafOnly, () => s.autoMergeValue, () => s.treeData, () => s.disableStrictly], (zn) => {
      const jn = Q({
        ...l(s)
      });
      jn && Object.keys(jn).forEach((kn) => {
        u[kn] = jn[kn];
      });
    }, {
      immediate: !0
    }), onMounted(() => {
      O.init();
    }), onUnmounted(() => {
      O.destroy();
    }), watch([() => s.treeData, () => s.value, () => s.multiple], (zn, [jn, kn]) => {
      if (s.multiple)
        return;
      let Yn = !1;
      lodashExports.isEqual(jn, s.treeData) || (Yn = !0, O.collectOptions()), kn !== s.value && !Yn && O.handleValueChange(s.value);
    });
    const W = (zn) => {
      O.handleInputChange(zn);
    }, ue = (zn) => {
      O.handleTagRemoveInTrigger(zn);
    }, te = (zn, jn, kn) => {
      jn.preventDefault(), O.handleTagRemoveByKey("" + kn);
    }, K = (zn, jn) => {
      const {
        keyEntities: kn,
        disabledKeys: Yn
      } = u, {
        size: Zn,
        disabled: er,
        displayProp: bn,
        displayRender: Ln,
        disableStrictly: Kn
      } = s;
      if (kn[zn]) {
        const Bn = er || kn[zn].data.disabled || Kn && Yn.has(zn), Fn = cls(`${prefixcls$7}-selection-tag`, {
          [`${prefixcls$7}-selection-tag-disabled`]: Bn
        });
        return lodashExports.isFunction(Ln) ? Ln(kn[zn], jn) : createVNode(Tag, {
          size: Zn === "default" ? "large" : Zn,
          key: `tag-${zn}-${jn}`,
          color: "white",
          tagKey: zn,
          className: Fn,
          closable: !0,
          onClose: te
        }, {
          default: () => [kn[zn].data[bn]]
        });
      }
      return null;
    }, ve = (zn) => {
      O.handleTagRemoveByKey(zn);
    };
    function ee() {
      const {
        size: zn,
        disabled: jn,
        placeholder: kn,
        maxTagCount: Yn,
        showRestTagsPopover: Zn,
        restTagsPopoverProps: er
      } = s, {
        inputValue: bn,
        checkedKeys: Ln,
        keyEntities: Kn,
        resolvedCheckedKeys: Bn
      } = u, Fn = cls(`${prefixcls$7}-tagInput-wrapper`), Gn = c === strings$i.NONE_MERGE_TYPE ? Ln : Bn;
      return createVNode(TagInput, {
        className: Fn,
        ref: m,
        disabled: jn,
        size: zn,
        value: [...Gn],
        showRestTagsPopover: Zn,
        restTagsPopoverProps: er,
        maxTagCount: Yn,
        renderTagItem: K,
        inputValue: bn,
        onInputChange: W,
        onRemove: ve,
        placeholder: kn,
        expandRestTagsOnClick: !1
      }, null);
    }
    function Re() {
      const {
        size: zn,
        disabled: jn
      } = s, kn = cls(`${prefixcls$7}-input`), {
        inputValue: Yn,
        inputPlaceHolder: Zn,
        showInput: er
      } = u, bn = {
        disabled: jn,
        value: Yn,
        className: kn,
        onChange: W
      }, Ln = cls({
        [`${prefixcls$7}-search-wrapper`]: !0,
        [`${prefixcls$7}-search-wrapper-${zn}`]: zn !== "default"
      }), Kn = Et(), Bn = cls({
        [`${prefixcls$7}-selection-placeholder`]: !Kn,
        [`${prefixcls$7}-selection-text-hide`]: er && Yn,
        [`${prefixcls$7}-selection-text-inactive`]: er && !Yn
      });
      return createVNode("div", {
        class: Ln
      }, [createVNode("span", {
        class: Bn
      }, [Kn || Zn]), er && createVNode(Input$1, mergeProps$1({
        forwardRef: m,
        size: zn
      }, bn), null)]);
    }
    const wt = (zn, jn) => {
      O.handleItemClick(zn, jn);
    }, yt = (zn, jn) => {
      O.handleItemHover(zn, jn);
    }, xt = (zn) => {
      O.onItemCheckboxClick(zn);
    }, Kt = (zn, jn) => {
      O.handleListScroll(zn, jn);
    };
    function tn(zn) {
      O.close(zn);
    }
    function ln() {
      O.open();
    }
    function rn() {
      O.focus();
    }
    function an() {
      O.blur();
    }
    o({
      focus: rn,
      blur: an,
      close: tn,
      open: ln
    });
    const Gt = () => {
      const {
        inputValue: zn,
        isSearching: jn,
        activeKeys: kn,
        selectedKeys: Yn,
        checkedKeys: Zn,
        halfCheckedKeys: er,
        loadedKeys: bn,
        loadingKeys: Ln
      } = u, {
        filterTreeNode: Kn,
        dropdownClassName: Bn,
        dropdownStyle: Fn,
        loadData: Gn,
        emptyContent: Wn,
        separator: Mn,
        topSlot: Tn,
        bottomSlot: Rn,
        showNext: hn,
        multiple: Qn,
        filterRender: rr,
        virtualizeInSearch: tr
      } = l(s), Cr = !!Kn && jn, Fr = cls(Bn, `${prefixcls$7}-popover`), An = O.getRenderData();
      return createVNode("div", {
        class: Fr,
        role: "listbox",
        style: Fn,
        onKeydown: O.handleKeyDown
      }, [Tn, createVNode(Item$4, {
        activeKeys: kn,
        selectedKeys: Yn,
        separator: Mn,
        loadedKeys: bn,
        loadingKeys: Ln,
        onItemClick: wt,
        onItemHover: yt,
        showNext: hn,
        onItemCheckboxClick: xt,
        onListScroll: Kt,
        searchable: Cr,
        keyword: zn,
        emptyContent: Wn,
        loadData: Gn,
        data: An,
        multiple: Qn,
        checkedKeys: Zn,
        halfCheckedKeys: er,
        filterRender: rr,
        virtualize: tr
      }, null), Rn]);
    }, nn = (zn) => {
      const {
        disabled: jn,
        showRestTagsPopover: kn,
        restTagsPopoverProps: Yn
      } = s, Zn = cls(`${prefixcls$7}-selection-n`, {
        [`${prefixcls$7}-selection-n-disabled`]: jn
      }), er = createVNode("span", {
        class: Zn
      }, [createTextVNode("+"), zn.length]);
      return kn ? createVNode(Popover$1, mergeProps$1({
        content: zn,
        showArrow: !0,
        trigger: "hover",
        position: "top",
        autoAdjustOverflow: !0
      }, Yn), _isSlot$F(er) ? er : {
        default: () => [er]
      }) : er;
    }, vt = () => {
      const {
        autoMergeValue: zn,
        maxTagCount: jn
      } = s, {
        checkedKeys: kn,
        resolvedCheckedKeys: Yn
      } = u, Zn = c === strings$i.NONE_MERGE_TYPE ? kn : Yn, er = [], bn = [];
      return [...Zn].forEach((Ln, Kn) => {
        const Bn = !lodashExports.isNumber(jn) || jn >= Kn + 1, Fn = K(Ln, Kn);
        Bn ? er.push(Fn) : bn.push(Fn);
      }), createVNode(Fragment, null, [er, !lodashExports.isEmpty(bn) && nn(bn)]);
    }, Et = () => {
      const {
        displayProp: zn,
        separator: jn,
        displayRender: kn
      } = s, {
        selectedKeys: Yn
      } = u;
      let Zn = "";
      if (Yn.size) {
        const er = O.getItemPropPath([...Yn][0], zn);
        kn && typeof kn == "function" ? Zn = kn(er) : Zn = er.map((bn, Ln) => createVNode(Fragment, {
          key: `${bn}-${Ln}`
        }, [Ln < er.length - 1 ? createVNode(Fragment, null, [bn, jn]) : bn]));
      }
      return Zn;
    }, Qt = () => {
      const {
        placeholder: zn,
        filterTreeNode: jn,
        multiple: kn,
        searchPosition: Yn
      } = s, {
        checkedKeys: Zn
      } = u;
      if (!(!!jn && Yn === strings$i.SEARCH_POSITION_TRIGGER)) {
        if (kn)
          return Zn.size === 0 ? createVNode("span", {
            class: `${prefixcls$7}-selection-placeholder`
          }, [zn]) : vt();
        {
          const Ln = Et(), Kn = cls({
            [`${prefixcls$7}-selection-placeholder`]: !Ln
          });
          return createVNode("span", {
            class: Kn
          }, [Ln || zn]);
        }
      }
      return kn ? ee() : Re();
    }, un = () => {
      const {
        suffix: zn
      } = s, jn = cls({
        [`${prefixcls$7}-suffix`]: !0,
        [`${prefixcls$7}-suffix-text`]: zn && lodashExports.isString(zn),
        [`${prefixcls$7}-suffix-icon`]: isSemiIcon(zn)
      });
      return createVNode("div", {
        class: jn,
        "x-semi-prop": "suffix"
      }, [zn]);
    }, gn = () => {
      const {
        prefix: zn,
        insetLabel: jn,
        insetLabelId: kn
      } = s, Yn = zn || jn, Zn = cls({
        [`${prefixcls$7}-prefix`]: !0,
        // to be doublechecked
        [`${prefixcls$7}-inset-label`]: jn,
        [`${prefixcls$7}-prefix-text`]: Yn && lodashExports.isString(Yn),
        [`${prefixcls$7}-prefix-icon`]: isSemiIcon(Yn)
      });
      return createVNode("div", {
        class: Zn,
        id: kn,
        "x-semi-prop": "prefix,insetLabel"
      }, [Yn]);
    }, dn = () => {
      var Fn;
      const {
        disabled: zn,
        triggerRender: jn,
        multiple: kn
      } = s, {
        selectedKeys: Yn,
        inputValue: Zn,
        inputPlaceHolder: er,
        resolvedCheckedKeys: bn,
        checkedKeys: Ln,
        keyEntities: Kn
      } = u;
      let Bn;
      return kn ? c === strings$i.NONE_MERGE_TYPE ? (Bn = /* @__PURE__ */ new Set(), Ln.forEach((Gn) => {
        var Wn;
        Bn.add((Wn = Kn[Gn]) == null ? void 0 : Wn.pos);
      })) : (Bn = /* @__PURE__ */ new Set(), bn.forEach((Gn) => {
        var Wn;
        Bn.add((Wn = Kn[Gn]) == null ? void 0 : Wn.pos);
      })) : Bn = (Fn = Kn[[...Yn][0]]) == null ? void 0 : Fn.pos, createVNode(Index$6, {
        value: Bn,
        inputValue: Zn,
        onChange: W,
        onClear: Pn,
        placeholder: er,
        disabled: zn,
        triggerRender: jn,
        componentName: "Cascader",
        componentProps: {
          ...l(s)
        },
        onSearch: W,
        onRemove: ue
      }, null);
    }, yn = () => {
      O.toggleHoverState(!0);
    }, vn = () => {
      O.toggleHoverState(!1);
    }, Pn = (zn) => {
      zn && zn.stopPropagation(), O.handleClear();
    }, On = (zn) => {
      zn && zn.stopPropagation(), O.handleClearEnterPress(zn);
    }, _n = () => {
      const {
        showClear: zn,
        disabled: jn,
        multiple: kn
      } = s, {
        selectedKeys: Yn,
        isOpen: Zn,
        isHovering: er,
        checkedKeys: bn,
        inputValue: Ln
      } = u, Kn = Yn.size, Bn = kn && bn.size;
      return zn && (Ln || Kn || Bn) && !jn && (Zn || er);
    }, Nn = () => {
      const zn = cls(`${prefixcls$7}-clearbtn`);
      return _n() ? createVNode("div", {
        class: zn,
        onClick: Pn,
        onKeypress: On,
        role: "button",
        tabindex: 0
      }, [createVNode(IconComponent$w, null, null)]) : null;
    }, Un = () => {
      const {
        arrowIcon: zn
      } = s;
      return _n() ? null : zn ? createVNode("div", {
        class: cls(`${prefixcls$7}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, [zn]) : null;
    }, Xn = () => {
      const {
        disabled: zn,
        multiple: jn,
        filterTreeNode: kn,
        style: Yn,
        size: Zn,
        className: er,
        validateStatus: bn,
        prefix: Ln,
        suffix: Kn,
        insetLabel: Bn,
        triggerRender: Fn,
        showClear: Gn,
        id: Wn,
        borderless: Mn
      } = s, {
        isOpen: Tn,
        isFocus: Rn,
        isInput: hn,
        checkedKeys: Qn
      } = u, rr = !!kn, tr = typeof Fn == "function", Cr = tr ? cls(er) : cls(prefixcls$7, er, {
        [`${prefixcls$7}-borderless`]: Mn,
        [`${prefixcls$7}-focus`]: Rn || Tn && !hn,
        [`${prefixcls$7}-disabled`]: zn,
        [`${prefixcls$7}-single`]: !0,
        [`${prefixcls$7}-filterable`]: rr,
        [`${prefixcls$7}-error`]: bn === "error",
        [`${prefixcls$7}-warning`]: bn === "warning",
        [`${prefixcls$7}-small`]: Zn === "small",
        [`${prefixcls$7}-large`]: Zn === "large",
        [`${prefixcls$7}-with-prefix`]: Ln || Bn,
        [`${prefixcls$7}-with-suffix`]: Kn
      }), Fr = Gn ? {
        onMouseEnter: () => yn(),
        onMouseLeave: () => vn()
      } : {}, An = cls(`${prefixcls$7}-selection`, {
        [`${prefixcls$7}-selection-multiple`]: jn && !lodashExports.isEmpty(Qn)
      }), Hn = tr ? dn() : [createVNode(Fragment, {
        key: "prefix"
      }, [Ln || Bn ? gn() : null]), createVNode(Fragment, {
        key: "selection"
      }, [createVNode("div", {
        class: An
      }, [Qt()])]), createVNode(Fragment, {
        key: "clearbtn"
      }, [Nn()]), createVNode(Fragment, {
        key: "suffix"
      }, [Kn ? un() : null]), createVNode(Fragment, {
        key: "arrow"
      }, [Un()])];
      return createVNode("div", mergeProps$1({
        class: Cr,
        style: Yn,
        ref: g,
        onClick: (ir) => O.handleClick(ir),
        onKeypress: (ir) => O.handleSelectionEnterPress(ir),
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-label": s["aria-label"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-required": s["aria-required"],
        id: Wn
      }, Fr, {
        role: "combobox",
        tabindex: 0
      }, N()), [Hn]);
    };
    return () => {
      const {
        zIndex: zn,
        getPopupContainer: jn,
        autoAdjustOverflow: kn,
        stopPropagation: Yn,
        mouseLeaveDelay: Zn,
        mouseEnterDelay: er,
        position: bn,
        motion: Ln
      } = s, {
        isOpen: Kn,
        rePosKey: Bn
      } = u, {
        direction: Fn
      } = T.value, Gn = Gt(), Wn = Xn();
      return createVNode(Popover$1, {
        getPopupContainer: jn,
        zIndex: zn,
        motion: Ln,
        ref: v,
        content: Gn,
        visible: Kn,
        trigger: "custom",
        rePosKey: Bn,
        position: Fn === "rtl" ? "bottomRight" : "bottomLeft",
        autoAdjustOverflow: kn,
        stopPropagation: Yn,
        mouseLeaveDelay: Zn,
        mouseEnterDelay: er,
        afterClose: () => O.updateSearching(!1)
      }, _isSlot$F(Wn) ? Wn : {
        default: () => [Wn]
      });
    };
  }
}), Cascader = Index$2, dayItemClasses = {
  DAY_TODAY: `${BASE_CLASS_PREFIX$1}-datepicker-day-today`,
  DAY_IN_RANGE: `${BASE_CLASS_PREFIX$1}-datepicker-day-inrange`,
  DAY_HOVER: `${BASE_CLASS_PREFIX$1}-datepicker-day-inhover`,
  DAY_SELECTED: `${BASE_CLASS_PREFIX$1}-datepicker-day-selected`,
  DAY_SELECTED_START: `${BASE_CLASS_PREFIX$1}-datepicker-day-selected-start`,
  DAY_SELECTED_END: `${BASE_CLASS_PREFIX$1}-datepicker-day-selected-end`,
  DAY_DISABLED: `${BASE_CLASS_PREFIX$1}-datepicker-day-disabled`,
  DAY_HOVER_DAY: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday`,
  DAY_HOVER_DAY_OFFSET: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday-offset`,
  DAY_IN_OFFSET_RANGE: `${BASE_CLASS_PREFIX$1}-datepicker-day-inoffsetrange`,
  DAY_SELECTED_RANGE_HOVER: `${BASE_CLASS_PREFIX$1}-datepicker-day-selectedrange-hover`,
  DAY_OFFSET_RANGE_START: `${BASE_CLASS_PREFIX$1}-datepicker-day-offsetrange-start`,
  DAY_OFFSET_RANGE_END: `${BASE_CLASS_PREFIX$1}-datepicker-day-offsetrange-end`,
  DAY_SELECTED_START_AFTER_HOVER: `${BASE_CLASS_PREFIX$1}-datepicker-day-selected-start-afterhover`,
  DAY_SELECTED_END_BEFORE_HOVER: `${BASE_CLASS_PREFIX$1}-datepicker-day-selected-end-beforehover`,
  DAY_HOVER_DAY_BEFORE_RANGE: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday-beforerange`,
  DAY_HOVER_DAY_AFTER_RANGE: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday-afterrange`,
  DAY_HOVER_DAY_IN_RANGE: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday-inrange`,
  DAY_HOVER_DAY_AROUND_SINGLE_SELECTED: `${BASE_CLASS_PREFIX$1}-datepicker-day-hoverday-around-singleselected`
}, cssClasses$I = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-datepicker`,
  NAVIGATION: `${BASE_CLASS_PREFIX$1}-datepicker-navigation`,
  PANEL_YAM: `${BASE_CLASS_PREFIX$1}-datepicker-panel-yam`,
  MONTH: `${BASE_CLASS_PREFIX$1}-datepicker-month`,
  WEEKDAY: `${BASE_CLASS_PREFIX$1}-datepicker-weekday`,
  WEEKS: `${BASE_CLASS_PREFIX$1}-datepicker-weeks`,
  WEEK: `${BASE_CLASS_PREFIX$1}-datepicker-week`,
  DAY: `${BASE_CLASS_PREFIX$1}-datepicker-day`,
  ...dayItemClasses
}, formatToken = {
  FORMAT_FULL_DATE: "yyyy-MM-dd",
  FORMAT_TIME_PICKER: "HH:mm:ss",
  FORMAT_DATE_TIME: "yyyy-MM-dd HH:mm:ss",
  FORMAT_YEAR_MONTH: "yyyy-MM"
}, strings$f = {
  DEFAULT_SEPARATOR_MULTIPLE: ",",
  DEFAULT_SEPARATOR_RANGE: " ~ ",
  SIZE_SET: ["small", "default", "large"],
  TYPE_SET: ["date", "dateRange", "year", "month", "monthRange", "dateTime", "dateTimeRange"],
  PRESET_POSITION_SET: ["left", "right", "top", "bottom"],
  DENSITY_SET: ["default", "compact"],
  PANEL_TYPE_LEFT: "left",
  PANEL_TYPE_RIGHT: "right",
  STATUS: VALIDATE_STATUS,
  POSITION_SET: strings$o.POSITION_SET,
  POSITION_INLINE_INPUT: "leftTopOver",
  ...formatToken
}, numbers$d = {
  WEEK_START_ON: 0,
  // Take the day of the week as the first day of the week, 0 for Sunday, 1 for Monday, and so on
  WEEK_HEIGHT: 36,
  // Date per line height 36px
  SPACING: numbers$f.SPACING,
  // Floating distance trigger interval
  SPACING_INSET_INPUT: 1
};
function isString(s) {
  return typeof s == "string";
}
function isAfter(s, o) {
  const l = isString(s) ? parseISO(s) : s, u = isString(o) ? parseISO(o) : o;
  return isAfter$1(l, u);
}
function isBefore(s, o) {
  const l = isString(s) ? parseISO(s) : s, u = isString(o) ? parseISO(o) : o;
  return isBefore$1(l, u);
}
function isBetween(s, { start: o, end: l }) {
  const u = isString(s) ? parseISO(s) : s, c = isString(o) ? parseISO(o) : o, m = isString(l) ? parseISO(l) : l;
  return isBefore$1(c, m) && isWithinInterval(u, { start: c, end: m }) && !isEqual$1(u, c) && !isEqual$1(u, m);
}
function isSameDay(s, o) {
  const l = isString(s) ? parseISO(s) : s, u = isString(o) ? parseISO(o) : o;
  return isSameDay$1(l, u);
}
function isValidDate(s) {
  return s && Object.prototype.toString.call(s) === "[object Date]" && !isNaN(s);
}
function isNumber(s) {
  return typeof s == "number" || Object.prototype.toString.call(s) === "[object Number]";
}
function isTimestamp(s) {
  return isNumber(s) && isValidDate(new Date(s));
}
const defaultFormatTokens = {
  date: strings$f.FORMAT_FULL_DATE,
  dateTime: strings$f.FORMAT_DATE_TIME,
  dateRange: strings$f.FORMAT_FULL_DATE,
  dateTimeRange: strings$f.FORMAT_DATE_TIME,
  month: strings$f.FORMAT_YEAR_MONTH,
  monthRange: strings$f.FORMAT_YEAR_MONTH
}, getDefaultFormatToken = (s) => defaultFormatTokens;
function getDefaultFormatTokenByType(s) {
  return s && defaultFormatTokens[s];
}
const getYears = (s, o) => {
  const l = (/* @__PURE__ */ new Date()).getFullYear();
  let u = typeof s == "number" ? s : l - 100, c = typeof o == "number" ? o : l + 100;
  return c < u && ([u, c] = [c, u]), Array.from({ length: c - u + 1 }, (m, g) => u + g);
}, getFullDateOffset = (s, o) => {
  if (!o)
    return "";
  const l = new Date(o), u = lodashExports.isFunction(s) ? s(l) : l;
  return format$3(new Date(u), strings$f.FORMAT_FULL_DATE);
};
var format$2 = { exports: {} }, format$1 = { exports: {} }, interopRequireDefault = { exports: {} };
(function(s) {
  function o(l) {
    return l && l.__esModule ? l : {
      default: l
    };
  }
  s.exports = o, s.exports.__esModule = !0, s.exports.default = s.exports;
})(interopRequireDefault);
var interopRequireDefaultExports = interopRequireDefault.exports, isValid$2 = { exports: {} }, isDate = { exports: {} }, _typeof = { exports: {} };
(function(s) {
  function o(l) {
    "@babel/helpers - typeof";
    return s.exports = o = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(u) {
      return typeof u;
    } : function(u) {
      return u && typeof Symbol == "function" && u.constructor === Symbol && u !== Symbol.prototype ? "symbol" : typeof u;
    }, s.exports.__esModule = !0, s.exports.default = s.exports, o(l);
  }
  s.exports = o, s.exports.__esModule = !0, s.exports.default = s.exports;
})(_typeof);
var _typeofExports = _typeof.exports, requiredArgs = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u, c) {
    if (c.length < u)
      throw new TypeError(u + " argument" + (u > 1 ? "s" : "") + " required, but only " + c.length + " present");
  }
  s.exports = o.default;
})(requiredArgs, requiredArgs.exports);
var requiredArgsExports = requiredArgs.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = m;
  var u = l(_typeofExports), c = l(requiredArgsExports);
  function m(g) {
    return (0, c.default)(1, arguments), g instanceof Date || (0, u.default)(g) === "object" && Object.prototype.toString.call(g) === "[object Date]";
  }
  s.exports = o.default;
})(isDate, isDate.exports);
var isDateExports = isDate.exports, toDate$1 = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = m;
  var u = l(_typeofExports), c = l(requiredArgsExports);
  function m(g) {
    (0, c.default)(1, arguments);
    var v = Object.prototype.toString.call(g);
    return g instanceof Date || (0, u.default)(g) === "object" && v === "[object Date]" ? new Date(g.getTime()) : typeof g == "number" || v === "[object Number]" ? new Date(g) : ((typeof g == "string" || v === "[object String]") && typeof console < "u" && (console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"), console.warn(new Error().stack)), /* @__PURE__ */ new Date(NaN));
  }
  s.exports = o.default;
})(toDate$1, toDate$1.exports);
var toDateExports$1 = toDate$1.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(isDateExports), c = l(toDateExports$1), m = l(requiredArgsExports);
  function g(v) {
    if ((0, m.default)(1, arguments), !(0, u.default)(v) && typeof v != "number")
      return !1;
    var b = (0, c.default)(v);
    return !isNaN(Number(b));
  }
  s.exports = o.default;
})(isValid$2, isValid$2.exports);
var isValidExports = isValid$2.exports, subMilliseconds = { exports: {} }, addMilliseconds = { exports: {} }, toInteger = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u) {
    if (u === null || u === !0 || u === !1)
      return NaN;
    var c = Number(u);
    return isNaN(c) ? c : c < 0 ? Math.ceil(c) : Math.floor(c);
  }
  s.exports = o.default;
})(toInteger, toInteger.exports);
var toIntegerExports = toInteger.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(toIntegerExports), c = l(toDateExports$1), m = l(requiredArgsExports);
  function g(v, b) {
    (0, m.default)(2, arguments);
    var S = (0, c.default)(v).getTime(), E = (0, u.default)(b);
    return new Date(S + E);
  }
  s.exports = o.default;
})(addMilliseconds, addMilliseconds.exports);
var addMillisecondsExports = addMilliseconds.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(addMillisecondsExports), c = l(requiredArgsExports), m = l(toIntegerExports);
  function g(v, b) {
    (0, c.default)(2, arguments);
    var S = (0, m.default)(b);
    return (0, u.default)(v, -S);
  }
  s.exports = o.default;
})(subMilliseconds, subMilliseconds.exports);
var subMillisecondsExports = subMilliseconds.exports, formatters$1 = { exports: {} }, getUTCDayOfYear = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(toDateExports$1), c = l(requiredArgsExports), m = 864e5;
  function g(v) {
    (0, c.default)(1, arguments);
    var b = (0, u.default)(v), S = b.getTime();
    b.setUTCMonth(0, 1), b.setUTCHours(0, 0, 0, 0);
    var E = b.getTime(), P = S - E;
    return Math.floor(P / m) + 1;
  }
  s.exports = o.default;
})(getUTCDayOfYear, getUTCDayOfYear.exports);
var getUTCDayOfYearExports = getUTCDayOfYear.exports, getUTCISOWeek = { exports: {} }, startOfUTCISOWeek = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = m;
  var u = l(toDateExports$1), c = l(requiredArgsExports);
  function m(g) {
    (0, c.default)(1, arguments);
    var v = 1, b = (0, u.default)(g), S = b.getUTCDay(), E = (S < v ? 7 : 0) + S - v;
    return b.setUTCDate(b.getUTCDate() - E), b.setUTCHours(0, 0, 0, 0), b;
  }
  s.exports = o.default;
})(startOfUTCISOWeek, startOfUTCISOWeek.exports);
var startOfUTCISOWeekExports = startOfUTCISOWeek.exports, startOfUTCISOWeekYear = { exports: {} }, getUTCISOWeekYear = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(toDateExports$1), c = l(requiredArgsExports), m = l(startOfUTCISOWeekExports);
  function g(v) {
    (0, c.default)(1, arguments);
    var b = (0, u.default)(v), S = b.getUTCFullYear(), E = /* @__PURE__ */ new Date(0);
    E.setUTCFullYear(S + 1, 0, 4), E.setUTCHours(0, 0, 0, 0);
    var P = (0, m.default)(E), T = /* @__PURE__ */ new Date(0);
    T.setUTCFullYear(S, 0, 4), T.setUTCHours(0, 0, 0, 0);
    var N = (0, m.default)(T);
    return b.getTime() >= P.getTime() ? S + 1 : b.getTime() >= N.getTime() ? S : S - 1;
  }
  s.exports = o.default;
})(getUTCISOWeekYear, getUTCISOWeekYear.exports);
var getUTCISOWeekYearExports = getUTCISOWeekYear.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var u = l(getUTCISOWeekYearExports), c = l(startOfUTCISOWeekExports), m = l(requiredArgsExports);
  function g(v) {
    (0, m.default)(1, arguments);
    var b = (0, u.default)(v), S = /* @__PURE__ */ new Date(0);
    S.setUTCFullYear(b, 0, 4), S.setUTCHours(0, 0, 0, 0);
    var E = (0, c.default)(S);
    return E;
  }
  s.exports = o.default;
})(startOfUTCISOWeekYear, startOfUTCISOWeekYear.exports);
var startOfUTCISOWeekYearExports = startOfUTCISOWeekYear.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var u = l(toDateExports$1), c = l(startOfUTCISOWeekExports), m = l(startOfUTCISOWeekYearExports), g = l(requiredArgsExports), v = 6048e5;
  function b(S) {
    (0, g.default)(1, arguments);
    var E = (0, u.default)(S), P = (0, c.default)(E).getTime() - (0, m.default)(E).getTime();
    return Math.round(P / v) + 1;
  }
  s.exports = o.default;
})(getUTCISOWeek, getUTCISOWeek.exports);
var getUTCISOWeekExports = getUTCISOWeek.exports, getUTCWeek = { exports: {} }, startOfUTCWeek = { exports: {} }, defaultOptions$2 = {};
Object.defineProperty(defaultOptions$2, "__esModule", {
  value: !0
});
defaultOptions$2.getDefaultOptions = getDefaultOptions;
defaultOptions$2.setDefaultOptions = setDefaultOptions;
var defaultOptions$1 = {};
function getDefaultOptions() {
  return defaultOptions$1;
}
function setDefaultOptions(s) {
  defaultOptions$1 = s;
}
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = v;
  var u = l(toDateExports$1), c = l(requiredArgsExports), m = l(toIntegerExports), g = defaultOptions$2;
  function v(b, S) {
    var E, P, T, N, O, z, Q, W;
    (0, c.default)(1, arguments);
    var ue = (0, g.getDefaultOptions)(), te = (0, m.default)((E = (P = (T = (N = S == null ? void 0 : S.weekStartsOn) !== null && N !== void 0 ? N : S == null || (O = S.locale) === null || O === void 0 || (z = O.options) === null || z === void 0 ? void 0 : z.weekStartsOn) !== null && T !== void 0 ? T : ue.weekStartsOn) !== null && P !== void 0 ? P : (Q = ue.locale) === null || Q === void 0 || (W = Q.options) === null || W === void 0 ? void 0 : W.weekStartsOn) !== null && E !== void 0 ? E : 0);
    if (!(te >= 0 && te <= 6))
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    var K = (0, u.default)(b), ve = K.getUTCDay(), ee = (ve < te ? 7 : 0) + ve - te;
    return K.setUTCDate(K.getUTCDate() - ee), K.setUTCHours(0, 0, 0, 0), K;
  }
  s.exports = o.default;
})(startOfUTCWeek, startOfUTCWeek.exports);
var startOfUTCWeekExports = startOfUTCWeek.exports, startOfUTCWeekYear = { exports: {} }, getUTCWeekYear = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var u = l(toDateExports$1), c = l(requiredArgsExports), m = l(startOfUTCWeekExports), g = l(toIntegerExports), v = defaultOptions$2;
  function b(S, E) {
    var P, T, N, O, z, Q, W, ue;
    (0, c.default)(1, arguments);
    var te = (0, u.default)(S), K = te.getUTCFullYear(), ve = (0, v.getDefaultOptions)(), ee = (0, g.default)((P = (T = (N = (O = E == null ? void 0 : E.firstWeekContainsDate) !== null && O !== void 0 ? O : E == null || (z = E.locale) === null || z === void 0 || (Q = z.options) === null || Q === void 0 ? void 0 : Q.firstWeekContainsDate) !== null && N !== void 0 ? N : ve.firstWeekContainsDate) !== null && T !== void 0 ? T : (W = ve.locale) === null || W === void 0 || (ue = W.options) === null || ue === void 0 ? void 0 : ue.firstWeekContainsDate) !== null && P !== void 0 ? P : 1);
    if (!(ee >= 1 && ee <= 7))
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var Re = /* @__PURE__ */ new Date(0);
    Re.setUTCFullYear(K + 1, 0, ee), Re.setUTCHours(0, 0, 0, 0);
    var wt = (0, m.default)(Re, E), yt = /* @__PURE__ */ new Date(0);
    yt.setUTCFullYear(K, 0, ee), yt.setUTCHours(0, 0, 0, 0);
    var xt = (0, m.default)(yt, E);
    return te.getTime() >= wt.getTime() ? K + 1 : te.getTime() >= xt.getTime() ? K : K - 1;
  }
  s.exports = o.default;
})(getUTCWeekYear, getUTCWeekYear.exports);
var getUTCWeekYearExports = getUTCWeekYear.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var u = l(getUTCWeekYearExports), c = l(requiredArgsExports), m = l(startOfUTCWeekExports), g = l(toIntegerExports), v = defaultOptions$2;
  function b(S, E) {
    var P, T, N, O, z, Q, W, ue;
    (0, c.default)(1, arguments);
    var te = (0, v.getDefaultOptions)(), K = (0, g.default)((P = (T = (N = (O = E == null ? void 0 : E.firstWeekContainsDate) !== null && O !== void 0 ? O : E == null || (z = E.locale) === null || z === void 0 || (Q = z.options) === null || Q === void 0 ? void 0 : Q.firstWeekContainsDate) !== null && N !== void 0 ? N : te.firstWeekContainsDate) !== null && T !== void 0 ? T : (W = te.locale) === null || W === void 0 || (ue = W.options) === null || ue === void 0 ? void 0 : ue.firstWeekContainsDate) !== null && P !== void 0 ? P : 1), ve = (0, u.default)(S, E), ee = /* @__PURE__ */ new Date(0);
    ee.setUTCFullYear(ve, 0, K), ee.setUTCHours(0, 0, 0, 0);
    var Re = (0, m.default)(ee, E);
    return Re;
  }
  s.exports = o.default;
})(startOfUTCWeekYear, startOfUTCWeekYear.exports);
var startOfUTCWeekYearExports = startOfUTCWeekYear.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var u = l(toDateExports$1), c = l(startOfUTCWeekExports), m = l(startOfUTCWeekYearExports), g = l(requiredArgsExports), v = 6048e5;
  function b(S, E) {
    (0, g.default)(1, arguments);
    var P = (0, u.default)(S), T = (0, c.default)(P, E).getTime() - (0, m.default)(P, E).getTime();
    return Math.round(T / v) + 1;
  }
  s.exports = o.default;
})(getUTCWeek, getUTCWeek.exports);
var getUTCWeekExports = getUTCWeek.exports, addLeadingZeros = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u, c) {
    for (var m = u < 0 ? "-" : "", g = Math.abs(u).toString(); g.length < c; )
      g = "0" + g;
    return m + g;
  }
  s.exports = o.default;
})(addLeadingZeros, addLeadingZeros.exports);
var addLeadingZerosExports = addLeadingZeros.exports, lightFormatters = { exports: {} };
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(addLeadingZerosExports), c = {
    // Year
    y: function(v, b) {
      var S = v.getUTCFullYear(), E = S > 0 ? S : 1 - S;
      return (0, u.default)(b === "yy" ? E % 100 : E, b.length);
    },
    // Month
    M: function(v, b) {
      var S = v.getUTCMonth();
      return b === "M" ? String(S + 1) : (0, u.default)(S + 1, 2);
    },
    // Day of the month
    d: function(v, b) {
      return (0, u.default)(v.getUTCDate(), b.length);
    },
    // AM or PM
    a: function(v, b) {
      var S = v.getUTCHours() / 12 >= 1 ? "pm" : "am";
      switch (b) {
        case "a":
        case "aa":
          return S.toUpperCase();
        case "aaa":
          return S;
        case "aaaaa":
          return S[0];
        case "aaaa":
        default:
          return S === "am" ? "a.m." : "p.m.";
      }
    },
    // Hour [1-12]
    h: function(v, b) {
      return (0, u.default)(v.getUTCHours() % 12 || 12, b.length);
    },
    // Hour [0-23]
    H: function(v, b) {
      return (0, u.default)(v.getUTCHours(), b.length);
    },
    // Minute
    m: function(v, b) {
      return (0, u.default)(v.getUTCMinutes(), b.length);
    },
    // Second
    s: function(v, b) {
      return (0, u.default)(v.getUTCSeconds(), b.length);
    },
    // Fraction of second
    S: function(v, b) {
      var S = b.length, E = v.getUTCMilliseconds(), P = Math.floor(E * Math.pow(10, S - 3));
      return (0, u.default)(P, b.length);
    }
  }, m = c;
  o.default = m, s.exports = o.default;
})(lightFormatters, lightFormatters.exports);
var lightFormattersExports = lightFormatters.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(getUTCDayOfYearExports), c = l(getUTCISOWeekExports), m = l(getUTCISOWeekYearExports), g = l(getUTCWeekExports), v = l(getUTCWeekYearExports), b = l(addLeadingZerosExports), S = l(lightFormattersExports), E = {
    am: "am",
    pm: "pm",
    midnight: "midnight",
    noon: "noon",
    morning: "morning",
    afternoon: "afternoon",
    evening: "evening",
    night: "night"
  }, P = {
    // Era
    G: function(W, ue, te) {
      var K = W.getUTCFullYear() > 0 ? 1 : 0;
      switch (ue) {
        case "G":
        case "GG":
        case "GGG":
          return te.era(K, {
            width: "abbreviated"
          });
        case "GGGGG":
          return te.era(K, {
            width: "narrow"
          });
        case "GGGG":
        default:
          return te.era(K, {
            width: "wide"
          });
      }
    },
    // Year
    y: function(W, ue, te) {
      if (ue === "yo") {
        var K = W.getUTCFullYear(), ve = K > 0 ? K : 1 - K;
        return te.ordinalNumber(ve, {
          unit: "year"
        });
      }
      return S.default.y(W, ue);
    },
    // Local week-numbering year
    Y: function(W, ue, te, K) {
      var ve = (0, v.default)(W, K), ee = ve > 0 ? ve : 1 - ve;
      if (ue === "YY") {
        var Re = ee % 100;
        return (0, b.default)(Re, 2);
      }
      return ue === "Yo" ? te.ordinalNumber(ee, {
        unit: "year"
      }) : (0, b.default)(ee, ue.length);
    },
    // ISO week-numbering year
    R: function(W, ue) {
      var te = (0, m.default)(W);
      return (0, b.default)(te, ue.length);
    },
    // Extended year. This is a single number designating the year of this calendar system.
    // The main difference between `y` and `u` localizers are B.C. years:
    // | Year | `y` | `u` |
    // |------|-----|-----|
    // | AC 1 |   1 |   1 |
    // | BC 1 |   1 |   0 |
    // | BC 2 |   2 |  -1 |
    // Also `yy` always returns the last two digits of a year,
    // while `uu` pads single digit years to 2 characters and returns other years unchanged.
    u: function(W, ue) {
      var te = W.getUTCFullYear();
      return (0, b.default)(te, ue.length);
    },
    // Quarter
    Q: function(W, ue, te) {
      var K = Math.ceil((W.getUTCMonth() + 1) / 3);
      switch (ue) {
        case "Q":
          return String(K);
        case "QQ":
          return (0, b.default)(K, 2);
        case "Qo":
          return te.ordinalNumber(K, {
            unit: "quarter"
          });
        case "QQQ":
          return te.quarter(K, {
            width: "abbreviated",
            context: "formatting"
          });
        case "QQQQQ":
          return te.quarter(K, {
            width: "narrow",
            context: "formatting"
          });
        case "QQQQ":
        default:
          return te.quarter(K, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone quarter
    q: function(W, ue, te) {
      var K = Math.ceil((W.getUTCMonth() + 1) / 3);
      switch (ue) {
        case "q":
          return String(K);
        case "qq":
          return (0, b.default)(K, 2);
        case "qo":
          return te.ordinalNumber(K, {
            unit: "quarter"
          });
        case "qqq":
          return te.quarter(K, {
            width: "abbreviated",
            context: "standalone"
          });
        case "qqqqq":
          return te.quarter(K, {
            width: "narrow",
            context: "standalone"
          });
        case "qqqq":
        default:
          return te.quarter(K, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Month
    M: function(W, ue, te) {
      var K = W.getUTCMonth();
      switch (ue) {
        case "M":
        case "MM":
          return S.default.M(W, ue);
        case "Mo":
          return te.ordinalNumber(K + 1, {
            unit: "month"
          });
        case "MMM":
          return te.month(K, {
            width: "abbreviated",
            context: "formatting"
          });
        case "MMMMM":
          return te.month(K, {
            width: "narrow",
            context: "formatting"
          });
        case "MMMM":
        default:
          return te.month(K, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone month
    L: function(W, ue, te) {
      var K = W.getUTCMonth();
      switch (ue) {
        case "L":
          return String(K + 1);
        case "LL":
          return (0, b.default)(K + 1, 2);
        case "Lo":
          return te.ordinalNumber(K + 1, {
            unit: "month"
          });
        case "LLL":
          return te.month(K, {
            width: "abbreviated",
            context: "standalone"
          });
        case "LLLLL":
          return te.month(K, {
            width: "narrow",
            context: "standalone"
          });
        case "LLLL":
        default:
          return te.month(K, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // Local week of year
    w: function(W, ue, te, K) {
      var ve = (0, g.default)(W, K);
      return ue === "wo" ? te.ordinalNumber(ve, {
        unit: "week"
      }) : (0, b.default)(ve, ue.length);
    },
    // ISO week of year
    I: function(W, ue, te) {
      var K = (0, c.default)(W);
      return ue === "Io" ? te.ordinalNumber(K, {
        unit: "week"
      }) : (0, b.default)(K, ue.length);
    },
    // Day of the month
    d: function(W, ue, te) {
      return ue === "do" ? te.ordinalNumber(W.getUTCDate(), {
        unit: "date"
      }) : S.default.d(W, ue);
    },
    // Day of year
    D: function(W, ue, te) {
      var K = (0, u.default)(W);
      return ue === "Do" ? te.ordinalNumber(K, {
        unit: "dayOfYear"
      }) : (0, b.default)(K, ue.length);
    },
    // Day of week
    E: function(W, ue, te) {
      var K = W.getUTCDay();
      switch (ue) {
        case "E":
        case "EE":
        case "EEE":
          return te.day(K, {
            width: "abbreviated",
            context: "formatting"
          });
        case "EEEEE":
          return te.day(K, {
            width: "narrow",
            context: "formatting"
          });
        case "EEEEEE":
          return te.day(K, {
            width: "short",
            context: "formatting"
          });
        case "EEEE":
        default:
          return te.day(K, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Local day of week
    e: function(W, ue, te, K) {
      var ve = W.getUTCDay(), ee = (ve - K.weekStartsOn + 8) % 7 || 7;
      switch (ue) {
        case "e":
          return String(ee);
        case "ee":
          return (0, b.default)(ee, 2);
        case "eo":
          return te.ordinalNumber(ee, {
            unit: "day"
          });
        case "eee":
          return te.day(ve, {
            width: "abbreviated",
            context: "formatting"
          });
        case "eeeee":
          return te.day(ve, {
            width: "narrow",
            context: "formatting"
          });
        case "eeeeee":
          return te.day(ve, {
            width: "short",
            context: "formatting"
          });
        case "eeee":
        default:
          return te.day(ve, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Stand-alone local day of week
    c: function(W, ue, te, K) {
      var ve = W.getUTCDay(), ee = (ve - K.weekStartsOn + 8) % 7 || 7;
      switch (ue) {
        case "c":
          return String(ee);
        case "cc":
          return (0, b.default)(ee, ue.length);
        case "co":
          return te.ordinalNumber(ee, {
            unit: "day"
          });
        case "ccc":
          return te.day(ve, {
            width: "abbreviated",
            context: "standalone"
          });
        case "ccccc":
          return te.day(ve, {
            width: "narrow",
            context: "standalone"
          });
        case "cccccc":
          return te.day(ve, {
            width: "short",
            context: "standalone"
          });
        case "cccc":
        default:
          return te.day(ve, {
            width: "wide",
            context: "standalone"
          });
      }
    },
    // ISO day of week
    i: function(W, ue, te) {
      var K = W.getUTCDay(), ve = K === 0 ? 7 : K;
      switch (ue) {
        case "i":
          return String(ve);
        case "ii":
          return (0, b.default)(ve, ue.length);
        case "io":
          return te.ordinalNumber(ve, {
            unit: "day"
          });
        case "iii":
          return te.day(K, {
            width: "abbreviated",
            context: "formatting"
          });
        case "iiiii":
          return te.day(K, {
            width: "narrow",
            context: "formatting"
          });
        case "iiiiii":
          return te.day(K, {
            width: "short",
            context: "formatting"
          });
        case "iiii":
        default:
          return te.day(K, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM or PM
    a: function(W, ue, te) {
      var K = W.getUTCHours(), ve = K / 12 >= 1 ? "pm" : "am";
      switch (ue) {
        case "a":
        case "aa":
          return te.dayPeriod(ve, {
            width: "abbreviated",
            context: "formatting"
          });
        case "aaa":
          return te.dayPeriod(ve, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "aaaaa":
          return te.dayPeriod(ve, {
            width: "narrow",
            context: "formatting"
          });
        case "aaaa":
        default:
          return te.dayPeriod(ve, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // AM, PM, midnight, noon
    b: function(W, ue, te) {
      var K = W.getUTCHours(), ve;
      switch (K === 12 ? ve = E.noon : K === 0 ? ve = E.midnight : ve = K / 12 >= 1 ? "pm" : "am", ue) {
        case "b":
        case "bb":
          return te.dayPeriod(ve, {
            width: "abbreviated",
            context: "formatting"
          });
        case "bbb":
          return te.dayPeriod(ve, {
            width: "abbreviated",
            context: "formatting"
          }).toLowerCase();
        case "bbbbb":
          return te.dayPeriod(ve, {
            width: "narrow",
            context: "formatting"
          });
        case "bbbb":
        default:
          return te.dayPeriod(ve, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // in the morning, in the afternoon, in the evening, at night
    B: function(W, ue, te) {
      var K = W.getUTCHours(), ve;
      switch (K >= 17 ? ve = E.evening : K >= 12 ? ve = E.afternoon : K >= 4 ? ve = E.morning : ve = E.night, ue) {
        case "B":
        case "BB":
        case "BBB":
          return te.dayPeriod(ve, {
            width: "abbreviated",
            context: "formatting"
          });
        case "BBBBB":
          return te.dayPeriod(ve, {
            width: "narrow",
            context: "formatting"
          });
        case "BBBB":
        default:
          return te.dayPeriod(ve, {
            width: "wide",
            context: "formatting"
          });
      }
    },
    // Hour [1-12]
    h: function(W, ue, te) {
      if (ue === "ho") {
        var K = W.getUTCHours() % 12;
        return K === 0 && (K = 12), te.ordinalNumber(K, {
          unit: "hour"
        });
      }
      return S.default.h(W, ue);
    },
    // Hour [0-23]
    H: function(W, ue, te) {
      return ue === "Ho" ? te.ordinalNumber(W.getUTCHours(), {
        unit: "hour"
      }) : S.default.H(W, ue);
    },
    // Hour [0-11]
    K: function(W, ue, te) {
      var K = W.getUTCHours() % 12;
      return ue === "Ko" ? te.ordinalNumber(K, {
        unit: "hour"
      }) : (0, b.default)(K, ue.length);
    },
    // Hour [1-24]
    k: function(W, ue, te) {
      var K = W.getUTCHours();
      return K === 0 && (K = 24), ue === "ko" ? te.ordinalNumber(K, {
        unit: "hour"
      }) : (0, b.default)(K, ue.length);
    },
    // Minute
    m: function(W, ue, te) {
      return ue === "mo" ? te.ordinalNumber(W.getUTCMinutes(), {
        unit: "minute"
      }) : S.default.m(W, ue);
    },
    // Second
    s: function(W, ue, te) {
      return ue === "so" ? te.ordinalNumber(W.getUTCSeconds(), {
        unit: "second"
      }) : S.default.s(W, ue);
    },
    // Fraction of second
    S: function(W, ue) {
      return S.default.S(W, ue);
    },
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = ve.getTimezoneOffset();
      if (ee === 0)
        return "Z";
      switch (ue) {
        case "X":
          return N(ee);
        case "XXXX":
        case "XX":
          return O(ee);
        case "XXXXX":
        case "XXX":
        default:
          return O(ee, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = ve.getTimezoneOffset();
      switch (ue) {
        case "x":
          return N(ee);
        case "xxxx":
        case "xx":
          return O(ee);
        case "xxxxx":
        case "xxx":
        default:
          return O(ee, ":");
      }
    },
    // Timezone (GMT)
    O: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = ve.getTimezoneOffset();
      switch (ue) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + T(ee, ":");
        case "OOOO":
        default:
          return "GMT" + O(ee, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = ve.getTimezoneOffset();
      switch (ue) {
        case "z":
        case "zz":
        case "zzz":
          return "GMT" + T(ee, ":");
        case "zzzz":
        default:
          return "GMT" + O(ee, ":");
      }
    },
    // Seconds timestamp
    t: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = Math.floor(ve.getTime() / 1e3);
      return (0, b.default)(ee, ue.length);
    },
    // Milliseconds timestamp
    T: function(W, ue, te, K) {
      var ve = K._originalDate || W, ee = ve.getTime();
      return (0, b.default)(ee, ue.length);
    }
  };
  function T(Q, W) {
    var ue = Q > 0 ? "-" : "+", te = Math.abs(Q), K = Math.floor(te / 60), ve = te % 60;
    if (ve === 0)
      return ue + String(K);
    var ee = W;
    return ue + String(K) + ee + (0, b.default)(ve, 2);
  }
  function N(Q, W) {
    if (Q % 60 === 0) {
      var ue = Q > 0 ? "-" : "+";
      return ue + (0, b.default)(Math.abs(Q) / 60, 2);
    }
    return O(Q, W);
  }
  function O(Q, W) {
    var ue = W || "", te = Q > 0 ? "-" : "+", K = Math.abs(Q), ve = (0, b.default)(Math.floor(K / 60), 2), ee = (0, b.default)(K % 60, 2);
    return te + ve + ue + ee;
  }
  var z = P;
  o.default = z, s.exports = o.default;
})(formatters$1, formatters$1.exports);
var formattersExports$1 = formatters$1.exports, longFormatters = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var l = function(b, S) {
    switch (b) {
      case "P":
        return S.date({
          width: "short"
        });
      case "PP":
        return S.date({
          width: "medium"
        });
      case "PPP":
        return S.date({
          width: "long"
        });
      case "PPPP":
      default:
        return S.date({
          width: "full"
        });
    }
  }, u = function(b, S) {
    switch (b) {
      case "p":
        return S.time({
          width: "short"
        });
      case "pp":
        return S.time({
          width: "medium"
        });
      case "ppp":
        return S.time({
          width: "long"
        });
      case "pppp":
      default:
        return S.time({
          width: "full"
        });
    }
  }, c = function(b, S) {
    var E = b.match(/(P+)(p+)?/) || [], P = E[1], T = E[2];
    if (!T)
      return l(b, S);
    var N;
    switch (P) {
      case "P":
        N = S.dateTime({
          width: "short"
        });
        break;
      case "PP":
        N = S.dateTime({
          width: "medium"
        });
        break;
      case "PPP":
        N = S.dateTime({
          width: "long"
        });
        break;
      case "PPPP":
      default:
        N = S.dateTime({
          width: "full"
        });
        break;
    }
    return N.replace("{{date}}", l(P, S)).replace("{{time}}", u(T, S));
  }, m = {
    p: u,
    P: c
  }, g = m;
  o.default = g, s.exports = o.default;
})(longFormatters, longFormatters.exports);
var longFormattersExports = longFormatters.exports, getTimezoneOffsetInMilliseconds = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u) {
    var c = new Date(Date.UTC(u.getFullYear(), u.getMonth(), u.getDate(), u.getHours(), u.getMinutes(), u.getSeconds(), u.getMilliseconds()));
    return c.setUTCFullYear(u.getFullYear()), u.getTime() - c.getTime();
  }
  s.exports = o.default;
})(getTimezoneOffsetInMilliseconds, getTimezoneOffsetInMilliseconds.exports);
var getTimezoneOffsetInMillisecondsExports = getTimezoneOffsetInMilliseconds.exports, protectedTokens = {};
Object.defineProperty(protectedTokens, "__esModule", {
  value: !0
});
protectedTokens.isProtectedDayOfYearToken = isProtectedDayOfYearToken;
protectedTokens.isProtectedWeekYearToken = isProtectedWeekYearToken;
protectedTokens.throwProtectedError = throwProtectedError;
var protectedDayOfYearTokens = ["D", "DD"], protectedWeekYearTokens = ["YY", "YYYY"];
function isProtectedDayOfYearToken(s) {
  return protectedDayOfYearTokens.indexOf(s) !== -1;
}
function isProtectedWeekYearToken(s) {
  return protectedWeekYearTokens.indexOf(s) !== -1;
}
function throwProtectedError(s, o, l) {
  if (s === "YYYY")
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(o, "`) for formatting years to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "YY")
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(o, "`) for formatting years to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "D")
    throw new RangeError("Use `d` instead of `D` (in `".concat(o, "`) for formatting days of the month to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  if (s === "DD")
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(o, "`) for formatting days of the month to the input `").concat(l, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
}
var defaultLocale = { exports: {} }, enUS = { exports: {} }, formatDistance = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var l = {
    lessThanXSeconds: {
      one: "less than a second",
      other: "less than {{count}} seconds"
    },
    xSeconds: {
      one: "1 second",
      other: "{{count}} seconds"
    },
    halfAMinute: "half a minute",
    lessThanXMinutes: {
      one: "less than a minute",
      other: "less than {{count}} minutes"
    },
    xMinutes: {
      one: "1 minute",
      other: "{{count}} minutes"
    },
    aboutXHours: {
      one: "about 1 hour",
      other: "about {{count}} hours"
    },
    xHours: {
      one: "1 hour",
      other: "{{count}} hours"
    },
    xDays: {
      one: "1 day",
      other: "{{count}} days"
    },
    aboutXWeeks: {
      one: "about 1 week",
      other: "about {{count}} weeks"
    },
    xWeeks: {
      one: "1 week",
      other: "{{count}} weeks"
    },
    aboutXMonths: {
      one: "about 1 month",
      other: "about {{count}} months"
    },
    xMonths: {
      one: "1 month",
      other: "{{count}} months"
    },
    aboutXYears: {
      one: "about 1 year",
      other: "about {{count}} years"
    },
    xYears: {
      one: "1 year",
      other: "{{count}} years"
    },
    overXYears: {
      one: "over 1 year",
      other: "over {{count}} years"
    },
    almostXYears: {
      one: "almost 1 year",
      other: "almost {{count}} years"
    }
  }, u = function(g, v, b) {
    var S, E = l[g];
    return typeof E == "string" ? S = E : v === 1 ? S = E.one : S = E.other.replace("{{count}}", v.toString()), b != null && b.addSuffix ? b.comparison && b.comparison > 0 ? "in " + S : S + " ago" : S;
  }, c = u;
  o.default = c, s.exports = o.default;
})(formatDistance, formatDistance.exports);
var formatDistanceExports = formatDistance.exports, formatLong = { exports: {} }, buildFormatLongFn = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u) {
    return function() {
      var c = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, m = c.width ? String(c.width) : u.defaultWidth, g = u.formats[m] || u.formats[u.defaultWidth];
      return g;
    };
  }
  s.exports = o.default;
})(buildFormatLongFn, buildFormatLongFn.exports);
var buildFormatLongFnExports = buildFormatLongFn.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(buildFormatLongFnExports), c = {
    full: "EEEE, MMMM do, y",
    long: "MMMM do, y",
    medium: "MMM d, y",
    short: "MM/dd/yyyy"
  }, m = {
    full: "h:mm:ss a zzzz",
    long: "h:mm:ss a z",
    medium: "h:mm:ss a",
    short: "h:mm a"
  }, g = {
    full: "{{date}} 'at' {{time}}",
    long: "{{date}} 'at' {{time}}",
    medium: "{{date}}, {{time}}",
    short: "{{date}}, {{time}}"
  }, v = {
    date: (0, u.default)({
      formats: c,
      defaultWidth: "full"
    }),
    time: (0, u.default)({
      formats: m,
      defaultWidth: "full"
    }),
    dateTime: (0, u.default)({
      formats: g,
      defaultWidth: "full"
    })
  }, b = v;
  o.default = b, s.exports = o.default;
})(formatLong, formatLong.exports);
var formatLongExports = formatLong.exports, formatRelative = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var l = {
    lastWeek: "'last' eeee 'at' p",
    yesterday: "'yesterday at' p",
    today: "'today at' p",
    tomorrow: "'tomorrow at' p",
    nextWeek: "eeee 'at' p",
    other: "P"
  }, u = function(g, v, b, S) {
    return l[g];
  }, c = u;
  o.default = c, s.exports = o.default;
})(formatRelative, formatRelative.exports);
var formatRelativeExports = formatRelative.exports, localize = { exports: {} }, buildLocalizeFn = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u) {
    return function(c, m) {
      var g = m != null && m.context ? String(m.context) : "standalone", v;
      if (g === "formatting" && u.formattingValues) {
        var b = u.defaultFormattingWidth || u.defaultWidth, S = m != null && m.width ? String(m.width) : b;
        v = u.formattingValues[S] || u.formattingValues[b];
      } else {
        var E = u.defaultWidth, P = m != null && m.width ? String(m.width) : u.defaultWidth;
        v = u.values[P] || u.values[E];
      }
      var T = u.argumentCallback ? u.argumentCallback(c) : c;
      return v[T];
    };
  }
  s.exports = o.default;
})(buildLocalizeFn, buildLocalizeFn.exports);
var buildLocalizeFnExports = buildLocalizeFn.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(buildLocalizeFnExports), c = {
    narrow: ["B", "A"],
    abbreviated: ["BC", "AD"],
    wide: ["Before Christ", "Anno Domini"]
  }, m = {
    narrow: ["1", "2", "3", "4"],
    abbreviated: ["Q1", "Q2", "Q3", "Q4"],
    wide: ["1st quarter", "2nd quarter", "3rd quarter", "4th quarter"]
  }, g = {
    narrow: ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
    abbreviated: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    wide: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
  }, v = {
    narrow: ["S", "M", "T", "W", "T", "F", "S"],
    short: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
    abbreviated: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
    wide: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"]
  }, b = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "morning",
      afternoon: "afternoon",
      evening: "evening",
      night: "night"
    }
  }, S = {
    narrow: {
      am: "a",
      pm: "p",
      midnight: "mi",
      noon: "n",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    abbreviated: {
      am: "AM",
      pm: "PM",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    },
    wide: {
      am: "a.m.",
      pm: "p.m.",
      midnight: "midnight",
      noon: "noon",
      morning: "in the morning",
      afternoon: "in the afternoon",
      evening: "in the evening",
      night: "at night"
    }
  }, E = function(O, z) {
    var Q = Number(O), W = Q % 100;
    if (W > 20 || W < 10)
      switch (W % 10) {
        case 1:
          return Q + "st";
        case 2:
          return Q + "nd";
        case 3:
          return Q + "rd";
      }
    return Q + "th";
  }, P = {
    ordinalNumber: E,
    era: (0, u.default)({
      values: c,
      defaultWidth: "wide"
    }),
    quarter: (0, u.default)({
      values: m,
      defaultWidth: "wide",
      argumentCallback: function(O) {
        return O - 1;
      }
    }),
    month: (0, u.default)({
      values: g,
      defaultWidth: "wide"
    }),
    day: (0, u.default)({
      values: v,
      defaultWidth: "wide"
    }),
    dayPeriod: (0, u.default)({
      values: b,
      defaultWidth: "wide",
      formattingValues: S,
      defaultFormattingWidth: "wide"
    })
  }, T = P;
  o.default = T, s.exports = o.default;
})(localize, localize.exports);
var localizeExports = localize.exports, match = { exports: {} }, buildMatchFn = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(m) {
    return function(g) {
      var v = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, b = v.width, S = b && m.matchPatterns[b] || m.matchPatterns[m.defaultMatchWidth], E = g.match(S);
      if (!E)
        return null;
      var P = E[0], T = b && m.parsePatterns[b] || m.parsePatterns[m.defaultParseWidth], N = Array.isArray(T) ? c(T, function(Q) {
        return Q.test(P);
      }) : u(T, function(Q) {
        return Q.test(P);
      }), O;
      O = m.valueCallback ? m.valueCallback(N) : N, O = v.valueCallback ? v.valueCallback(O) : O;
      var z = g.slice(P.length);
      return {
        value: O,
        rest: z
      };
    };
  }
  function u(m, g) {
    for (var v in m)
      if (m.hasOwnProperty(v) && g(m[v]))
        return v;
  }
  function c(m, g) {
    for (var v = 0; v < m.length; v++)
      if (g(m[v]))
        return v;
  }
  s.exports = o.default;
})(buildMatchFn, buildMatchFn.exports);
var buildMatchFnExports = buildMatchFn.exports, buildMatchPatternFn = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u) {
    return function(c) {
      var m = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, g = c.match(u.matchPattern);
      if (!g) return null;
      var v = g[0], b = c.match(u.parsePattern);
      if (!b) return null;
      var S = u.valueCallback ? u.valueCallback(b[0]) : b[0];
      S = m.valueCallback ? m.valueCallback(S) : S;
      var E = c.slice(v.length);
      return {
        value: S,
        rest: E
      };
    };
  }
  s.exports = o.default;
})(buildMatchPatternFn, buildMatchPatternFn.exports);
var buildMatchPatternFnExports = buildMatchPatternFn.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(buildMatchFnExports), c = l(buildMatchPatternFnExports), m = /^(\d+)(th|st|nd|rd)?/i, g = /\d+/i, v = {
    narrow: /^(b|a)/i,
    abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
    wide: /^(before christ|before common era|anno domini|common era)/i
  }, b = {
    any: [/^b/i, /^(a|c)/i]
  }, S = {
    narrow: /^[1234]/i,
    abbreviated: /^q[1234]/i,
    wide: /^[1234](th|st|nd|rd)? quarter/i
  }, E = {
    any: [/1/i, /2/i, /3/i, /4/i]
  }, P = {
    narrow: /^[jfmasond]/i,
    abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
    wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
  }, T = {
    narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
    any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
  }, N = {
    narrow: /^[smtwf]/i,
    short: /^(su|mo|tu|we|th|fr|sa)/i,
    abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
    wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
  }, O = {
    narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
    any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
  }, z = {
    narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
    any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
  }, Q = {
    any: {
      am: /^a/i,
      pm: /^p/i,
      midnight: /^mi/i,
      noon: /^no/i,
      morning: /morning/i,
      afternoon: /afternoon/i,
      evening: /evening/i,
      night: /night/i
    }
  }, W = {
    ordinalNumber: (0, c.default)({
      matchPattern: m,
      parsePattern: g,
      valueCallback: function(K) {
        return parseInt(K, 10);
      }
    }),
    era: (0, u.default)({
      matchPatterns: v,
      defaultMatchWidth: "wide",
      parsePatterns: b,
      defaultParseWidth: "any"
    }),
    quarter: (0, u.default)({
      matchPatterns: S,
      defaultMatchWidth: "wide",
      parsePatterns: E,
      defaultParseWidth: "any",
      valueCallback: function(K) {
        return K + 1;
      }
    }),
    month: (0, u.default)({
      matchPatterns: P,
      defaultMatchWidth: "wide",
      parsePatterns: T,
      defaultParseWidth: "any"
    }),
    day: (0, u.default)({
      matchPatterns: N,
      defaultMatchWidth: "wide",
      parsePatterns: O,
      defaultParseWidth: "any"
    }),
    dayPeriod: (0, u.default)({
      matchPatterns: z,
      defaultMatchWidth: "any",
      parsePatterns: Q,
      defaultParseWidth: "any"
    })
  }, ue = W;
  o.default = ue, s.exports = o.default;
})(match, match.exports);
var matchExports = match.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(formatDistanceExports), c = l(formatLongExports), m = l(formatRelativeExports), g = l(localizeExports), v = l(matchExports), b = {
    code: "en-US",
    formatDistance: u.default,
    formatLong: c.default,
    formatRelative: m.default,
    localize: g.default,
    match: v.default,
    options: {
      weekStartsOn: 0,
      firstWeekContainsDate: 1
    }
  }, S = b;
  o.default = S, s.exports = o.default;
})(enUS, enUS.exports);
var enUSExports = enUS.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var u = l(enUSExports), c = u.default;
  o.default = c, s.exports = o.default;
})(defaultLocale, defaultLocale.exports);
var defaultLocaleExports = defaultLocale.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = te;
  var u = l(isValidExports), c = l(subMillisecondsExports), m = l(toDateExports$1), g = l(formattersExports$1), v = l(longFormattersExports), b = l(getTimezoneOffsetInMillisecondsExports), S = protectedTokens, E = l(toIntegerExports), P = l(requiredArgsExports), T = defaultOptions$2, N = l(defaultLocaleExports), O = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g, z = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g, Q = /^'([^]*?)'?$/, W = /''/g, ue = /[a-zA-Z]/;
  function te(ve, ee, Re) {
    var wt, yt, xt, Kt, tn, ln, rn, an, Gt, nn, vt, Et, Qt, un, gn, dn, yn, vn;
    (0, P.default)(2, arguments);
    var Pn = String(ee), On = (0, T.getDefaultOptions)(), _n = (wt = (yt = Re == null ? void 0 : Re.locale) !== null && yt !== void 0 ? yt : On.locale) !== null && wt !== void 0 ? wt : N.default, Nn = (0, E.default)((xt = (Kt = (tn = (ln = Re == null ? void 0 : Re.firstWeekContainsDate) !== null && ln !== void 0 ? ln : Re == null || (rn = Re.locale) === null || rn === void 0 || (an = rn.options) === null || an === void 0 ? void 0 : an.firstWeekContainsDate) !== null && tn !== void 0 ? tn : On.firstWeekContainsDate) !== null && Kt !== void 0 ? Kt : (Gt = On.locale) === null || Gt === void 0 || (nn = Gt.options) === null || nn === void 0 ? void 0 : nn.firstWeekContainsDate) !== null && xt !== void 0 ? xt : 1);
    if (!(Nn >= 1 && Nn <= 7))
      throw new RangeError("firstWeekContainsDate must be between 1 and 7 inclusively");
    var Un = (0, E.default)((vt = (Et = (Qt = (un = Re == null ? void 0 : Re.weekStartsOn) !== null && un !== void 0 ? un : Re == null || (gn = Re.locale) === null || gn === void 0 || (dn = gn.options) === null || dn === void 0 ? void 0 : dn.weekStartsOn) !== null && Qt !== void 0 ? Qt : On.weekStartsOn) !== null && Et !== void 0 ? Et : (yn = On.locale) === null || yn === void 0 || (vn = yn.options) === null || vn === void 0 ? void 0 : vn.weekStartsOn) !== null && vt !== void 0 ? vt : 0);
    if (!(Un >= 0 && Un <= 6))
      throw new RangeError("weekStartsOn must be between 0 and 6 inclusively");
    if (!_n.localize)
      throw new RangeError("locale must contain localize property");
    if (!_n.formatLong)
      throw new RangeError("locale must contain formatLong property");
    var Xn = (0, m.default)(ve);
    if (!(0, u.default)(Xn))
      throw new RangeError("Invalid time value");
    var zn = (0, b.default)(Xn), jn = (0, c.default)(Xn, zn), kn = {
      firstWeekContainsDate: Nn,
      weekStartsOn: Un,
      locale: _n,
      _originalDate: Xn
    }, Yn = Pn.match(z).map(function(Zn) {
      var er = Zn[0];
      if (er === "p" || er === "P") {
        var bn = v.default[er];
        return bn(Zn, _n.formatLong);
      }
      return Zn;
    }).join("").match(O).map(function(Zn) {
      if (Zn === "''")
        return "'";
      var er = Zn[0];
      if (er === "'")
        return K(Zn);
      var bn = g.default[er];
      if (bn)
        return !(Re != null && Re.useAdditionalWeekYearTokens) && (0, S.isProtectedWeekYearToken)(Zn) && (0, S.throwProtectedError)(Zn, ee, String(ve)), !(Re != null && Re.useAdditionalDayOfYearTokens) && (0, S.isProtectedDayOfYearToken)(Zn) && (0, S.throwProtectedError)(Zn, ee, String(ve)), bn(jn, Zn, _n.localize, kn);
      if (er.match(ue))
        throw new RangeError("Format string contains an unescaped latin alphabet character `" + er + "`");
      return Zn;
    }).join("");
    return Yn;
  }
  function K(ve) {
    var ee = ve.match(Q);
    return ee ? ee[1].replace(W, "'") : ve;
  }
  s.exports = o.default;
})(format$1, format$1.exports);
var formatExports$1 = format$1.exports, formatters = { exports: {} }, tzIntlTimeZoneName = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(g, v, b) {
    var S = m(g, b.timeZone, b.locale);
    return S.formatToParts ? u(S, v) : c(S, v);
  }
  function u(g, v) {
    for (var b = g.formatToParts(v), S = b.length - 1; S >= 0; --S)
      if (b[S].type === "timeZoneName")
        return b[S].value;
  }
  function c(g, v) {
    var b = g.format(v).replace(/\u200E/g, ""), S = / [\w-+ ]+$/.exec(b);
    return S ? S[0].substr(1) : "";
  }
  function m(g, v, b) {
    if (b && !b.code)
      throw new Error("date-fns-tz error: Please set a language code on the locale object imported from date-fns, e.g. `locale.code = 'en-US'`");
    return new Intl.DateTimeFormat(b ? [b.code, "en-US"] : void 0, {
      timeZone: v,
      timeZoneName: g
    });
  }
  s.exports = o.default;
})(tzIntlTimeZoneName, tzIntlTimeZoneName.exports);
var tzIntlTimeZoneNameExports = tzIntlTimeZoneName.exports, tzParseTimezone = { exports: {} }, tzTokenizeDate = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(b, S) {
    var E = v(S);
    return E.formatToParts ? c(E, b) : m(E, b);
  }
  var u = {
    year: 0,
    month: 1,
    day: 2,
    hour: 3,
    minute: 4,
    second: 5
  };
  function c(b, S) {
    try {
      for (var E = b.formatToParts(S), P = [], T = 0; T < E.length; T++) {
        var N = u[E[T].type];
        N >= 0 && (P[N] = parseInt(E[T].value, 10));
      }
      return P;
    } catch (O) {
      if (O instanceof RangeError)
        return [NaN];
      throw O;
    }
  }
  function m(b, S) {
    var E = b.format(S).replace(/\u200E/g, ""), P = /(\d+)\/(\d+)\/(\d+),? (\d+):(\d+):(\d+)/.exec(E);
    return [P[3], P[1], P[2], P[4], P[5], P[6]];
  }
  var g = {};
  function v(b) {
    if (!g[b]) {
      var S = new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: "America/New_York",
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }).format(/* @__PURE__ */ new Date("2014-06-25T04:00:00.123Z")), E = S === "06/25/2014, 00:00:00" || S === "‎06‎/‎25‎/‎2014‎ ‎00‎:‎00‎:‎00";
      g[b] = E ? new Intl.DateTimeFormat("en-US", {
        hour12: !1,
        timeZone: b,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      }) : new Intl.DateTimeFormat("en-US", {
        hourCycle: "h23",
        timeZone: b,
        year: "numeric",
        month: "numeric",
        day: "2-digit",
        hour: "2-digit",
        minute: "2-digit",
        second: "2-digit"
      });
    }
    return g[b];
  }
  s.exports = o.default;
})(tzTokenizeDate, tzTokenizeDate.exports);
var tzTokenizeDateExports = tzTokenizeDate.exports, newDateUTC = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u, c, m, g, v, b, S) {
    var E = /* @__PURE__ */ new Date(0);
    return E.setUTCFullYear(u, c, m), E.setUTCHours(g, v, b, S), E;
  }
  s.exports = o.default;
})(newDateUTC, newDateUTC.exports);
var newDateUTCExports = newDateUTC.exports;
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var l = c(tzTokenizeDateExports), u = c(newDateUTCExports);
  function c(z) {
    return z && z.__esModule ? z : { default: z };
  }
  var m = 36e5, g = 6e4, v = {
    timezone: /([Z+-].*)$/,
    timezoneZ: /^(Z)$/,
    timezoneHH: /^([+-]\d{2})$/,
    timezoneHHMM: /^([+-]\d{2}):?(\d{2})$/
  };
  function b(z, Q, W) {
    var ue, te;
    if (!z || (ue = v.timezoneZ.exec(z), ue))
      return 0;
    var K;
    if (ue = v.timezoneHH.exec(z), ue)
      return K = parseInt(ue[1], 10), T(K) ? -(K * m) : NaN;
    if (ue = v.timezoneHHMM.exec(z), ue) {
      K = parseInt(ue[1], 10);
      var ve = parseInt(ue[2], 10);
      return T(K, ve) ? (te = Math.abs(K) * m + ve * g, K > 0 ? -te : te) : NaN;
    }
    if (O(z)) {
      Q = new Date(Q || Date.now());
      var ee = W ? Q : S(Q), Re = E(ee, z), wt = W ? Re : P(Q, Re, z);
      return -wt;
    }
    return NaN;
  }
  function S(z) {
    return (0, u.default)(z.getFullYear(), z.getMonth(), z.getDate(), z.getHours(), z.getMinutes(), z.getSeconds(), z.getMilliseconds());
  }
  function E(z, Q) {
    var W = (0, l.default)(z, Q), ue = (0, u.default)(W[0], W[1] - 1, W[2], W[3] % 24, W[4], W[5], 0).getTime(), te = z.getTime(), K = te % 1e3;
    return te -= K >= 0 ? K : 1e3 + K, ue - te;
  }
  function P(z, Q, W) {
    var ue = z.getTime(), te = ue - Q, K = E(new Date(te), W);
    if (Q === K)
      return Q;
    te -= K - Q;
    var ve = E(new Date(te), W);
    return K === ve ? K : Math.max(K, ve);
  }
  function T(z, Q) {
    return -23 <= z && z <= 23 && (Q == null || 0 <= Q && Q <= 59);
  }
  var N = {};
  function O(z) {
    if (N[z]) return !0;
    try {
      return new Intl.DateTimeFormat(void 0, {
        timeZone: z
      }), N[z] = !0, !0;
    } catch {
      return !1;
    }
  }
  s.exports = o.default;
})(tzParseTimezone, tzParseTimezone.exports);
var tzParseTimezoneExports = tzParseTimezone.exports;
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var l = c(tzIntlTimeZoneNameExports), u = c(tzParseTimezoneExports);
  function c(N) {
    return N && N.__esModule ? N : { default: N };
  }
  var m = 60 * 1e3, g = {
    // Timezone (ISO-8601. If offset is 0, output is always `'Z'`)
    X: function(N, O, z, Q) {
      var W = v(Q.timeZone, Q._originalDate || N);
      if (W === 0)
        return "Z";
      switch (O) {
        case "X":
          return E(W);
        case "XXXX":
        case "XX":
          return S(W);
        case "XXXXX":
        case "XXX":
        default:
          return S(W, ":");
      }
    },
    // Timezone (ISO-8601. If offset is 0, output is `'+00:00'` or equivalent)
    x: function(N, O, z, Q) {
      var W = v(Q.timeZone, Q._originalDate || N);
      switch (O) {
        case "x":
          return E(W);
        case "xxxx":
        case "xx":
          return S(W);
        case "xxxxx":
        case "xxx":
        default:
          return S(W, ":");
      }
    },
    // Timezone (GMT)
    O: function(N, O, z, Q) {
      var W = v(Q.timeZone, Q._originalDate || N);
      switch (O) {
        case "O":
        case "OO":
        case "OOO":
          return "GMT" + P(W, ":");
        case "OOOO":
        default:
          return "GMT" + S(W, ":");
      }
    },
    // Timezone (specific non-location)
    z: function(N, O, z, Q) {
      var W = Q._originalDate || N;
      switch (O) {
        case "z":
        case "zz":
        case "zzz":
          return (0, l.default)("short", W, Q);
        case "zzzz":
        default:
          return (0, l.default)("long", W, Q);
      }
    }
  };
  function v(N, O) {
    var z = N ? (0, u.default)(N, O, !0) / m : O.getTimezoneOffset();
    if (Number.isNaN(z))
      throw new RangeError("Invalid time zone specified: " + N);
    return z;
  }
  function b(N, O) {
    for (var z = N < 0 ? "-" : "", Q = Math.abs(N).toString(); Q.length < O; )
      Q = "0" + Q;
    return z + Q;
  }
  function S(N, O) {
    var z = O || "", Q = N > 0 ? "-" : "+", W = Math.abs(N), ue = b(Math.floor(W / 60), 2), te = b(Math.floor(W % 60), 2);
    return Q + ue + z + te;
  }
  function E(N, O) {
    if (N % 60 === 0) {
      var z = N > 0 ? "-" : "+";
      return z + b(Math.abs(N) / 60, 2);
    }
    return S(N, O);
  }
  function P(N, O) {
    var z = N > 0 ? "-" : "+", Q = Math.abs(N), W = Math.floor(Q / 60), ue = Q % 60;
    if (ue === 0)
      return z + String(W);
    var te = O;
    return z + String(W) + te + b(ue, 2);
  }
  var T = g;
  o.default = T, s.exports = o.default;
})(formatters, formatters.exports);
var formattersExports = formatters.exports, toDate = { exports: {} }, tzPattern = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = void 0;
  var l = /(Z|[+-]\d{2}(?::?\d{2})?| UTC| [a-zA-Z]+\/[a-zA-Z_]+(?:\/[a-zA-Z_]+)?)$/, u = l;
  o.default = u, s.exports = o.default;
})(tzPattern, tzPattern.exports);
var tzPatternExports = tzPattern.exports;
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = P;
  var l = g(toIntegerExports), u = g(getTimezoneOffsetInMillisecondsExports), c = g(tzParseTimezoneExports), m = g(tzPatternExports);
  function g(wt) {
    return wt && wt.__esModule ? wt : { default: wt };
  }
  var v = 36e5, b = 6e4, S = 2, E = {
    dateTimePattern: /^([0-9W+-]+)(T| )(.*)/,
    datePattern: /^([0-9W+-]+)(.*)/,
    plainTime: /:/,
    // year tokens
    YY: /^(\d{2})$/,
    YYY: [
      /^([+-]\d{2})$/,
      // 0 additional digits
      /^([+-]\d{3})$/,
      // 1 additional digit
      /^([+-]\d{4})$/
      // 2 additional digits
    ],
    YYYY: /^(\d{4})/,
    YYYYY: [
      /^([+-]\d{4})/,
      // 0 additional digits
      /^([+-]\d{5})/,
      // 1 additional digit
      /^([+-]\d{6})/
      // 2 additional digits
    ],
    // date tokens
    MM: /^-(\d{2})$/,
    DDD: /^-?(\d{3})$/,
    MMDD: /^-?(\d{2})-?(\d{2})$/,
    Www: /^-?W(\d{2})$/,
    WwwD: /^-?W(\d{2})-?(\d{1})$/,
    HH: /^(\d{2}([.,]\d*)?)$/,
    HHMM: /^(\d{2}):?(\d{2}([.,]\d*)?)$/,
    HHMMSS: /^(\d{2}):?(\d{2}):?(\d{2}([.,]\d*)?)$/,
    // time zone tokens (to identify the presence of a tz)
    timeZone: m.default
  };
  function P(wt, yt) {
    if (arguments.length < 1)
      throw new TypeError("1 argument required, but only " + arguments.length + " present");
    if (wt === null)
      return /* @__PURE__ */ new Date(NaN);
    var xt = yt || {}, Kt = xt.additionalDigits == null ? S : (0, l.default)(xt.additionalDigits);
    if (Kt !== 2 && Kt !== 1 && Kt !== 0)
      throw new RangeError("additionalDigits must be 0, 1 or 2");
    if (wt instanceof Date || typeof wt == "object" && Object.prototype.toString.call(wt) === "[object Date]")
      return new Date(wt.getTime());
    if (typeof wt == "number" || Object.prototype.toString.call(wt) === "[object Number]")
      return new Date(wt);
    if (!(typeof wt == "string" || Object.prototype.toString.call(wt) === "[object String]"))
      return /* @__PURE__ */ new Date(NaN);
    var tn = T(wt), ln = N(tn.date, Kt), rn = ln.year, an = ln.restDateString, Gt = O(an, rn);
    if (isNaN(Gt))
      return /* @__PURE__ */ new Date(NaN);
    if (Gt) {
      var nn = Gt.getTime(), vt = 0, Et;
      if (tn.time && (vt = z(tn.time), isNaN(vt)))
        return /* @__PURE__ */ new Date(NaN);
      if (tn.timeZone || xt.timeZone) {
        if (Et = (0, c.default)(tn.timeZone || xt.timeZone, new Date(nn + vt)), isNaN(Et))
          return /* @__PURE__ */ new Date(NaN);
      } else
        Et = (0, u.default)(new Date(nn + vt)), Et = (0, u.default)(new Date(nn + vt + Et));
      return new Date(nn + vt + Et);
    } else
      return /* @__PURE__ */ new Date(NaN);
  }
  function T(wt) {
    var yt = {}, xt = E.dateTimePattern.exec(wt), Kt;
    if (xt ? (yt.date = xt[1], Kt = xt[3]) : (xt = E.datePattern.exec(wt), xt ? (yt.date = xt[1], Kt = xt[2]) : (yt.date = null, Kt = wt)), Kt) {
      var tn = E.timeZone.exec(Kt);
      tn ? (yt.time = Kt.replace(tn[1], ""), yt.timeZone = tn[1].trim()) : yt.time = Kt;
    }
    return yt;
  }
  function N(wt, yt) {
    var xt = E.YYY[yt], Kt = E.YYYYY[yt], tn;
    if (tn = E.YYYY.exec(wt) || Kt.exec(wt), tn) {
      var ln = tn[1];
      return {
        year: parseInt(ln, 10),
        restDateString: wt.slice(ln.length)
      };
    }
    if (tn = E.YY.exec(wt) || xt.exec(wt), tn) {
      var rn = tn[1];
      return {
        year: parseInt(rn, 10) * 100,
        restDateString: wt.slice(rn.length)
      };
    }
    return {
      year: null
    };
  }
  function O(wt, yt) {
    if (yt === null)
      return null;
    var xt, Kt, tn, ln;
    if (wt.length === 0)
      return Kt = /* @__PURE__ */ new Date(0), Kt.setUTCFullYear(yt), Kt;
    if (xt = E.MM.exec(wt), xt)
      return Kt = /* @__PURE__ */ new Date(0), tn = parseInt(xt[1], 10) - 1, K(yt, tn) ? (Kt.setUTCFullYear(yt, tn), Kt) : /* @__PURE__ */ new Date(NaN);
    if (xt = E.DDD.exec(wt), xt) {
      Kt = /* @__PURE__ */ new Date(0);
      var rn = parseInt(xt[1], 10);
      return ve(yt, rn) ? (Kt.setUTCFullYear(yt, 0, rn), Kt) : /* @__PURE__ */ new Date(NaN);
    }
    if (xt = E.MMDD.exec(wt), xt) {
      Kt = /* @__PURE__ */ new Date(0), tn = parseInt(xt[1], 10) - 1;
      var an = parseInt(xt[2], 10);
      return K(yt, tn, an) ? (Kt.setUTCFullYear(yt, tn, an), Kt) : /* @__PURE__ */ new Date(NaN);
    }
    if (xt = E.Www.exec(wt), xt)
      return ln = parseInt(xt[1], 10) - 1, ee(yt, ln) ? Q(yt, ln) : /* @__PURE__ */ new Date(NaN);
    if (xt = E.WwwD.exec(wt), xt) {
      ln = parseInt(xt[1], 10) - 1;
      var Gt = parseInt(xt[2], 10) - 1;
      return ee(yt, ln, Gt) ? Q(yt, ln, Gt) : /* @__PURE__ */ new Date(NaN);
    }
    return null;
  }
  function z(wt) {
    var yt, xt, Kt;
    if (yt = E.HH.exec(wt), yt)
      return xt = parseFloat(yt[1].replace(",", ".")), Re(xt) ? xt % 24 * v : NaN;
    if (yt = E.HHMM.exec(wt), yt)
      return xt = parseInt(yt[1], 10), Kt = parseFloat(yt[2].replace(",", ".")), Re(xt, Kt) ? xt % 24 * v + Kt * b : NaN;
    if (yt = E.HHMMSS.exec(wt), yt) {
      xt = parseInt(yt[1], 10), Kt = parseInt(yt[2], 10);
      var tn = parseFloat(yt[3].replace(",", "."));
      return Re(xt, Kt, tn) ? xt % 24 * v + Kt * b + tn * 1e3 : NaN;
    }
    return null;
  }
  function Q(wt, yt, xt) {
    yt = yt || 0, xt = xt || 0;
    var Kt = /* @__PURE__ */ new Date(0);
    Kt.setUTCFullYear(wt, 0, 4);
    var tn = Kt.getUTCDay() || 7, ln = yt * 7 + xt + 1 - tn;
    return Kt.setUTCDate(Kt.getUTCDate() + ln), Kt;
  }
  var W = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], ue = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  function te(wt) {
    return wt % 400 === 0 || wt % 4 === 0 && wt % 100 !== 0;
  }
  function K(wt, yt, xt) {
    if (yt < 0 || yt > 11)
      return !1;
    if (xt != null) {
      if (xt < 1)
        return !1;
      var Kt = te(wt);
      if (Kt && xt > ue[yt] || !Kt && xt > W[yt])
        return !1;
    }
    return !0;
  }
  function ve(wt, yt) {
    if (yt < 1)
      return !1;
    var xt = te(wt);
    return !(xt && yt > 366 || !xt && yt > 365);
  }
  function ee(wt, yt, xt) {
    return !(yt < 0 || yt > 52 || xt != null && (xt < 0 || xt > 6));
  }
  function Re(wt, yt, xt) {
    return !(wt != null && (wt < 0 || wt >= 25) || yt != null && (yt < 0 || yt >= 60) || xt != null && (xt < 0 || xt >= 60));
  }
  s.exports = o.default;
})(toDate, toDate.exports);
var toDateExports = toDate.exports;
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = v;
  var l = m(formatExports$1), u = m(formattersExports), c = m(toDateExports);
  function m(b) {
    return b && b.__esModule ? b : { default: b };
  }
  var g = /([xXOz]+)|''|'(''|[^'])+('|$)/g;
  function v(b, S, E) {
    var P = String(S), T = E || {}, N = P.match(g);
    if (N) {
      var O = (0, c.default)(b, T);
      P = N.reduce(function(z, Q) {
        if (Q[0] === "'")
          return z;
        var W = z.indexOf(Q), ue = z[W - 1] === "'", te = z.replace(Q, "'" + u.default[Q[0]](O, Q, null, T) + "'");
        return ue ? te.substring(0, W - 1) + te.substring(W + 1) : te;
      }, P);
    }
    return (0, l.default)(b, P, T);
  }
  s.exports = o.default;
})(format$2, format$2.exports);
var formatExports = format$2.exports, formatInTimeZone = { exports: {} }, cloneObject = { exports: {} }, assign$1 = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = l;
  function l(u, c) {
    if (u == null)
      throw new TypeError("assign requires that input parameter not be null or undefined");
    for (var m in c)
      Object.prototype.hasOwnProperty.call(c, m) && (u[m] = c[m]);
    return u;
  }
  s.exports = o.default;
})(assign$1, assign$1.exports);
var assignExports = assign$1.exports;
(function(s, o) {
  var l = interopRequireDefaultExports.default;
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = c;
  var u = l(assignExports);
  function c(m) {
    return (0, u.default)({}, m);
  }
  s.exports = o.default;
})(cloneObject, cloneObject.exports);
var cloneObjectExports = cloneObject.exports, utcToZonedTime$1 = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = m;
  var l = c(tzParseTimezoneExports), u = c(toDateExports);
  function c(g) {
    return g && g.__esModule ? g : { default: g };
  }
  function m(g, v, b) {
    var S = (0, u.default)(g, b), E = (0, l.default)(v, S, !0), P = new Date(S.getTime() - E), T = /* @__PURE__ */ new Date(0);
    return T.setFullYear(P.getUTCFullYear(), P.getUTCMonth(), P.getUTCDate()), T.setHours(P.getUTCHours(), P.getUTCMinutes(), P.getUTCSeconds(), P.getUTCMilliseconds()), T;
  }
  s.exports = o.default;
})(utcToZonedTime$1, utcToZonedTime$1.exports);
var utcToZonedTimeExports = utcToZonedTime$1.exports;
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = g;
  var l = m(cloneObjectExports), u = m(formatExports), c = m(utcToZonedTimeExports);
  function m(v) {
    return v && v.__esModule ? v : { default: v };
  }
  function g(v, b, S, E) {
    var P = (0, l.default)(E);
    return P.timeZone = b, (0, u.default)((0, c.default)(v, b), S, P);
  }
  s.exports = o.default;
})(formatInTimeZone, formatInTimeZone.exports);
var formatInTimeZoneExports = formatInTimeZone.exports, getTimezoneOffset = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = c;
  var l = u(tzParseTimezoneExports);
  function u(m) {
    return m && m.__esModule ? m : { default: m };
  }
  function c(m, g) {
    return -(0, l.default)(m, g);
  }
  s.exports = o.default;
})(getTimezoneOffset, getTimezoneOffset.exports);
var getTimezoneOffsetExports = getTimezoneOffset.exports, zonedTimeToUtc$1 = { exports: {} };
(function(s, o) {
  Object.defineProperty(o, "__esModule", {
    value: !0
  }), o.default = b;
  var l = v(cloneObjectExports), u = v(toDateExports), c = v(tzPatternExports), m = v(tzParseTimezoneExports), g = v(newDateUTCExports);
  function v(S) {
    return S && S.__esModule ? S : { default: S };
  }
  function b(S, E, P) {
    if (typeof S == "string" && !S.match(c.default)) {
      var T = (0, l.default)(P);
      return T.timeZone = E, (0, u.default)(S, T);
    }
    var N = (0, u.default)(S, P), O = (0, g.default)(N.getFullYear(), N.getMonth(), N.getDate(), N.getHours(), N.getMinutes(), N.getSeconds(), N.getMilliseconds()).getTime(), z = (0, m.default)(E, new Date(O));
    return new Date(O + z);
  }
  s.exports = o.default;
})(zonedTimeToUtc$1, zonedTimeToUtc$1.exports);
var zonedTimeToUtcExports = zonedTimeToUtc$1.exports, dateFnsTz = {
  format: formatExports,
  formatInTimeZone: formatInTimeZoneExports,
  getTimezoneOffset: getTimezoneOffsetExports,
  toDate: toDateExports,
  utcToZonedTime: utcToZonedTimeExports,
  zonedTimeToUtc: zonedTimeToUtcExports
};
const IANAOffsetMap = [
  [-11, ["Pacific/Midway"]],
  [-10, ["Pacific/Honolulu"]],
  [-9.5, ["Pacific/Marquesas"]],
  [-9, ["Pacific/Gambier"]],
  [-8, ["Pacific/Pitcairn"]],
  [-7, ["America/Phoenix"]],
  [-6, ["America/Tegucigalpa"]],
  [-5, ["America/Bogota"]],
  [-4, ["America/Puerto_Rico"]],
  [-3.5, ["America/St_Johns"]],
  // No alternative daylight saving time zone
  [-3, ["America/Montevideo"]],
  [-2, ["Atlantic/South_Georgia"]],
  [-1, ["Atlantic/Cape_Verde"]],
  [0, ["Africa/Accra"]],
  [1, ["Africa/Bangui"]],
  [2, ["Africa/Cairo"]],
  [3, ["Asia/Bahrain", "Indian/Antananarivo"]],
  [3.5, ["Asia/Tehran"]],
  // No alternative daylight saving time zone
  [4, ["Asia/Dubai", "Asia/Muscat"]],
  [4.5, ["Asia/Kabul"]],
  [5, ["Asia/Samarkand", "Asia/Karachi"]],
  [5.5, ["Asia/Kolkata"]],
  [5.75, ["Asia/Kathmandu"]],
  [6, ["Asia/Dhaka"]],
  [6.5, ["Asia/Rangoon", "Asia/Rangoon"]],
  [7, ["Asia/Jakarta", "Asia/Phnom_Penh", "Asia/Bangkok"]],
  [8, ["Asia/Shanghai", "Asia/Singapore"]],
  [8.75, ["Australia/Eucla"]],
  [9, ["Asia/Tokyo", "Asia/Seoul", "Asia/Pyongyang"]],
  [9.5, ["Australia/Darwin"]],
  [10, ["Pacific/Guam"]],
  [10.5, ["Australia/Adelaide"]],
  // No alternative daylight saving time zone
  [11, ["Pacific/Guadalcanal"]],
  [12, ["Pacific/Funafuti"]],
  [13, ["Pacific/Enderbury"]],
  [13.75, ["Pacific/Chatham"]],
  // No alternative daylight saving time zone
  [14, ["Pacific/Kiritimati"]]
], IANAEtcGMTOffsetMap = {
  0: "Etc/GMT",
  1: "Etc/GMT-1",
  2: "Etc/GMT-2",
  3: "Etc/GMT-3",
  4: "Etc/GMT-4",
  5: "Etc/GMT-5",
  6: "Etc/GMT-6",
  7: "Etc/GMT-7",
  8: "Etc/GMT-8",
  9: "Etc/GMT-9",
  10: "Etc/GMT-10",
  11: "Etc/GMT-11",
  12: "Etc/GMT-12",
  13: "Etc/GMT-13",
  14: "Etc/GMT-14",
  "-1": "Etc/GMT+1",
  "-2": "Etc/GMT+2",
  "-3": "Etc/GMT+3",
  "-4": "Etc/GMT+4",
  "-5": "Etc/GMT+5",
  "-6": "Etc/GMT+6",
  "-7": "Etc/GMT+7",
  "-8": "Etc/GMT+8",
  "-9": "Etc/GMT+9",
  "-10": "Etc/GMT+10",
  "-11": "Etc/GMT+11",
  "-12": "Etc/GMT+12"
}, GMTStringReg = /([\-\+]{1})(\d{2})\:(\d{2})/, toIANA = (s) => {
  let o = null;
  if (typeof s == "string") {
    if (o = s.match(GMTStringReg), !o)
      return s;
    const l = parseInt(o[1] + 1, 10), u = parseInt(o[2], 10), c = parseInt(o[3], 10);
    s = l * (u + c / 60);
  }
  if (typeof s == "number") {
    if (s in IANAEtcGMTOffsetMap) {
      const u = IANAEtcGMTOffsetMap[s];
      if (isValidTimezoneIANAString(u))
        return u;
    }
    const l = IANAOffsetMap.find((u) => u[0] === s);
    return l && l[1][0];
  }
}, validIANATimezoneCache = {};
function isValidTimezoneIANAString(s) {
  if (validIANATimezoneCache[s]) return !0;
  try {
    return new Intl.DateTimeFormat(void 0, { timeZone: s }), validIANATimezoneCache[s] = !0, !0;
  } catch {
    return !1;
  }
}
const utcToZonedTime = (s, o, l) => dateFnsTz.utcToZonedTime(s, toIANA(o), l), zonedTimeToUtc = (s, o, l) => dateFnsTz.zonedTimeToUtc(s, toIANA(o), l);
function compatibleParse(s, o, l, u) {
  let c = null;
  if (s) {
    o && (l = l || /* @__PURE__ */ new Date(), c = parse$2(s, o, l, { locale: u })), isValid$5(c) || (c = parseISO(s)), isValid$5(c) || (c = new Date(Date.parse(s)));
    const m = isValid$5(c) && String(c.getFullYear()).length > 4;
    (!isValid$5(c) || m) && (c = null);
  }
  return c;
}
function getInsetInputFormatToken(s) {
  const { format: o, type: l } = s, u = /([yMd]{0,4}[^a-z\s]*[yMd]{0,4}[^a-z\s]*[yMd]{0,4})/i, c = /([yMd]{0,4}[^a-z\s]*[yMd]{0,4}[^a-z\s]*[yMd]{0,4}) (H{0,2}[^a-z\s]*m{0,2}[^a-z\s]*s{0,2})/i, m = getDefaultFormatTokenByType(l);
  let g;
  switch (l) {
    case "dateTime":
    case "dateTimeRange":
      const v = c.exec(o);
      g = v && v[1] && v[2] ? `${v[1]} ${v[2]}` : m;
      break;
    case "date":
    case "month":
    case "monthRange":
    case "dateRange":
    default:
      const b = u.exec(o);
      g = b && b[1] || m;
      break;
  }
  return g;
}
function getInsetInputValueFromInsetInputStr(s) {
  const o = " ", { inputValue: l = "", rangeSeparator: u, type: c } = s;
  let m, g, v, b;
  const S = {
    monthLeft: {
      dateInput: "",
      timeInput: ""
    },
    monthRight: {
      dateInput: "",
      timeInput: ""
    }
  };
  switch (c) {
    case "date":
    case "month":
    case "monthRange":
      S.monthLeft.dateInput = l;
      break;
    case "dateRange":
      [m = "", v = ""] = l.split(u), S.monthLeft.dateInput = m, S.monthRight.dateInput = v;
      break;
    case "dateTime":
      [m = "", g = ""] = l.split(o), S.monthLeft.dateInput = m, S.monthLeft.timeInput = g;
      break;
    case "dateTimeRange":
      const [E = "", P = ""] = l.split(u);
      [m = "", g = ""] = E.split(o), [v = "", b = ""] = P.split(o), S.monthLeft.dateInput = m, S.monthLeft.timeInput = g, S.monthRight.dateInput = v, S.monthRight.timeInput = b;
      break;
  }
  return S;
}
function isValidTimeZone(s) {
  return ["string", "number"].includes(typeof s) && s !== "";
}
class DatePickerFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.clearRangeInputFocus = () => {
      const { type: l } = this._adapter.getProps(), { rangeInputFocus: u } = this._adapter.getStates();
      l === "dateTimeRange" && u && this._adapter.setRangeInputFocus(!1);
    }, this._isRangeType = () => {
      const l = this._adapter.getProp("type");
      return /range/i.test(l);
    }, this._isRangeValueComplete = (l) => {
      let u = !1;
      return Array.isArray(l) && (u = !l.some((c) => isNullOrUndefined(c))), u;
    };
  }
  init() {
    const o = this.getProp("timeZone");
    this._isControlledComponent() ? this.initFromProps({ timeZone: o, value: this.getProp("value") }) : this._isInProps("defaultValue") && this.initFromProps({ timeZone: o, value: this.getProp("defaultValue") }), this.initPanelOpenStatus(this.getProp("defaultOpen"));
  }
  initFromProps({ value: o, timeZone: l, prevTimeZone: u }) {
    const c = (Array.isArray(o) ? [...o] : (o || o === 0) && [o]) || [], m = this.parseWithTimezone(c, l, u);
    this._adapter.updatePrevTimezone(u), this.clearInputValue(), this._adapter.updateValue(m), this.resetCachedSelectedValue(m), this.initRangeInputFocus(m), this._adapter.needConfirm() && this._adapter.updateCachedSelectedValue(m);
  }
  /**
   * 如果用户传了一个空的 value，需要把 range input focus 设置为 rangeStart，这样用户可以清除完之后继续从开始选择
   * 
   * If the user passes an empty value, you need to set the range input focus to rangeStart, so that the user can continue to select from the beginning after clearing
   */
  initRangeInputFocus(o) {
    const { triggerRender: l } = this.getProps();
    this._isRangeType() && lodashExports.isFunction(l) && o.length === 0 && this._adapter.setRangeInputFocus("rangeStart");
  }
  /**
   * value 可能是 UTC value 也可能是 zoned value
   * 
   * UTC value -> 受控传入的 value
   * 
   * zoned value -> statue.value，保存的是当前计算机时区下选择的日期
   * 
   * 如果是时区变化，则需要将旧 zoned value 转为新时区下的 zoned value
   * 
   * 如果是 value 变化，则不需要传入之前的时区，将 UTC value 转为 zoned value 即可
   * 
   */
  parseWithTimezone(o, l, u) {
    const c = [];
    if (Array.isArray(o) && o.length)
      for (const m of o) {
        let g = (m || m === 0) && this._parseValue(m);
        g ? (isValidTimeZone(u) && (g = zonedTimeToUtc(g, u)), c.push(isValidTimeZone(l) ? utcToZonedTime(g, l) : g)) : warning$1(!0, `[Semi DatePicker] value cannot be parsed, value: ${String(m)}`);
      }
    return c;
  }
  _isMultiple() {
    return !!this.getProp("multiple");
  }
  /**
       *
       *  Verify and parse the following three format inputs
       *
          1. Date object
          2. ISO 9601-compliant string
          3. ts timestamp
  
          Unified here to format the incoming value and output it as a Date object
       *
       */
  _parseValue(o) {
    const l = this._adapter.getProp("dateFnsLocale");
    let u;
    if (!o && o !== 0)
      return /* @__PURE__ */ new Date();
    if (isValidDate(o))
      u = o;
    else if (lodashExports.isString(o))
      u = compatibleParse(o, this.getProp("format"), void 0, l);
    else if (isTimestamp(o))
      u = new Date(o);
    else
      throw new TypeError("defaultValue should be valid Date object/timestamp or string");
    return u;
  }
  destroy() {
    this._adapter.togglePanel(!1), this._adapter.unregisterClickOutSide();
  }
  initPanelOpenStatus(o) {
    (this.getProp("open") || o) && !this.getProp("disabled") ? (this._adapter.togglePanel(!0), this._adapter.registerClickOutSide()) : (this._adapter.togglePanel(!1), this._adapter.unregisterClickOutSide());
  }
  openPanel() {
    this.getProp("disabled") || (this._isControlledComponent("open") || this.open(), this._adapter.notifyOpenChange(!0));
  }
  /**
   * clear inset input value when close panel
   */
  clearInsetInputValue() {
    const { insetInput: o } = this._adapter.getProps();
    o && this._adapter.updateInsetInputValue(null);
  }
  /**
   * call it when change state value or input value
   */
  resetCachedSelectedValue(o) {
    const { value: l, cachedSelectedValue: u } = this._adapter.getStates(), c = Array.isArray(o) ? o : l;
    lodashExports.isEqual(c, u) || this._adapter.updateCachedSelectedValue(c);
  }
  /**
   * timing to call closePanel
   *  1. click confirm button
   *  2. click cancel button
   *  3. select date, time, year, month
   *    - date type and not multiple, close panel after select date
   *    - dateRange type, close panel after select rangeStart and rangeEnd
   *  4. click outside
   * @param {Event} e
   * @param {String} inputValue
   * @param {Date[]} dates
   */
  closePanel(o, l = null, u) {
    const { value: c } = this._adapter.getStates(), m = isNullOrUndefined(u) ? c : u;
    this._isControlledComponent("open") ? this.resetInnerSelectedStates(m) : this.close(), this._adapter.notifyOpenChange(!1);
  }
  open() {
    this._adapter.togglePanel(!0), this._adapter.registerClickOutSide();
  }
  close() {
    this._adapter.togglePanel(!1, () => this.resetInnerSelectedStates()), this._adapter.unregisterClickOutSide();
  }
  focus(o) {
    if (this._isRangeType()) {
      const l = o ?? "rangeStart";
      this._adapter.setRangeInputFocus(l);
    } else
      this._adapter.setInputFocus();
  }
  blur() {
    this._isRangeType() ? this._adapter.setRangeInputBlur() : this._adapter.setInputBlur();
  }
  /**
   * reset cachedSelectedValue, inputValue when close panel
   */
  resetInnerSelectedStates(o) {
    const { value: l } = this._adapter.getStates();
    (!this.isCachedSelectedValueValid(o) || this._adapter.needConfirm() && !this.clickConfirmButton) && this.resetCachedSelectedValue(l), this.resetFocus(), this.clearInputValue(), this.clickConfirmButton = !1;
  }
  resetFocus(o) {
    this._adapter.setRangeInputFocus(!1), this._adapter.notifyBlur(o);
  }
  /**
   * cachedSelectedValue can be `(Date|null)[]` or `null`
   */
  isCachedSelectedValueValid(o) {
    const l = o || this._adapter.getState("cachedSelectedValue"), { type: u } = this._adapter.getProps();
    let c = !0;
    switch (!0) {
      case u === "dateRange":
      case u === "dateTimeRange":
        this._isRangeValueComplete(l) || (c = !1);
        break;
      default:
        const m = l == null ? void 0 : l.filter((g) => g);
        Array.isArray(m) && m.length || (c = !1);
        break;
    }
    return c;
  }
  /**
   * 将输入框内容置空
   */
  clearInputValue() {
    this._adapter.updateInputValue(null), this._adapter.updateInsetInputValue(null);
  }
  /**
   * Callback when the content of the input box changes
   * Update the date panel if the changed value is a legal date, otherwise only update the input box
   * @param {String} input The value of the input box after the change
   * @param {Event} e
   */
  handleInputChange(o, l) {
    const u = this._isMultiple() ? this.parseMultipleInput(o) : this.parseInput(o), { value: c } = this.getStates();
    if (this._updateCachedSelectedValueFromInput(o), u && u.length || o === "") {
      if (lodashExports.get(l, strings$l.CLEARBTN_CLICKED_EVENT_FLAG) && this._isControlledComponent("value")) {
        this._notifyChange(u);
        return;
      }
      this._updateValueAndInput(u, o === "", o);
      const m = this._getChangedDates(u);
      this._someDateDisabled(m, u) || lodashExports.isEqual(u, c) || this._notifyChange(u);
    } else
      this._adapter.updateInputValue(o);
  }
  /**
   * inset input 变化时需要更新以下 state 状态
   *  - insetInputValue（总是）
   *  - inputValue（可以解析为合法日期时）
   *  - value（可以解析为合法日期时）
   */
  handleInsetInputChange(o) {
    const { insetInputStr: l, format: u, insetInputValue: c } = o, m = this._isMultiple(), g = m ? this.parseMultipleInput(l, u) : this.parseInput(l, u), { value: v } = this.getStates();
    if (this._updateCachedSelectedValueFromInput(l), g && g.length) {
      const b = this._getChangedDates(g);
      if (!this._someDateDisabled(b, g)) {
        lodashExports.isEqual(g, v) || (!this._isControlledComponent() && !this._adapter.needConfirm() && this._adapter.updateValue(g), this._notifyChange(g));
        const S = m ? this.formatMultipleDates(g) : this.formatDates(g);
        this._adapter.updateInputValue(S);
      }
    }
    this._adapter.updateInsetInputValue(c);
  }
  /**
   * when input change we reset cached selected value
   */
  _updateCachedSelectedValueFromInput(o) {
    const l = this.getLooseDateFromInput(o), u = this._getChangedDates(l);
    this._someDateDisabled(u, l) || this.resetCachedSelectedValue(l);
  }
  /**
   * Input box blur
   * @param {String} input
   * @param {Event} e
   */
  handleInputBlur(o = "", l) {
  }
  /**
   * called when range type rangeEnd input tab press
   * @param {Event} e
   */
  handleRangeEndTabPress(o) {
    this._adapter.setRangeInputFocus(!1);
  }
  /**
   * called when the input box is focused
   * @param {Event} e input focus event
   * @param {String} range 'rangeStart' or 'rangeEnd', use when type is range
   */
  handleInputFocus(o, l) {
    const u = this._adapter.getState("rangeInputFocus");
    l && this._adapter.setRangeInputFocus(l), (!l || !["rangeStart", "rangeEnd"].includes(u)) && this._adapter.notifyFocus(o, l);
  }
  handleSetRangeFocus(o) {
    this._adapter.setRangeInputFocus(o);
  }
  handleInputClear(o) {
    this._adapter.notifyClear(o);
  }
  /**
   * 范围选择清除按钮回调
   * 因为清除按钮没有集成在Input内，因此需要手动清除 value、inputValue、cachedValue
   *
   * callback of range input clear button
   * Since the clear button is not integrated in Input, you need to manually clear value, inputValue, cachedValue
   */
  handleRangeInputClear(o) {
    const l = [];
    this._isControlledComponent("value") || (this._updateValueAndInput(l, !0, ""), this._adapter.updateInsetInputValue(null), this.resetCachedSelectedValue(l)), this._notifyChange(l), this._adapter.setRangeInputFocus(!1), this._adapter.notifyClear(o);
  }
  handleRangeInputBlur(o, l) {
  }
  // Parses input only after user returns
  handleInputComplete(o = "") {
    let l = o ? this._isMultiple() ? this.parseMultipleInput(o, ",", !0) : this.parseInput(o) : [];
    if (l = l && l.length ? l : this.getState("value"), !l || !l.length) {
      const m = /* @__PURE__ */ new Date();
      this._isRangeType() ? l = [m, m] : l = [m];
    }
    this._updateValueAndInput(l);
    const { value: u } = this.getStates(), c = this._getChangedDates(l);
    !this._someDateDisabled(c, l) && !lodashExports.isEqual(l, u) && this._notifyChange(l);
  }
  /**
   * Parse the input, return the time object if it is valid,
   *  otherwise return "
   *
   * @param {string} input
   * @returns  {Date [] | '}
   */
  parseInput(o = "", l) {
    let u = [];
    const { dateFnsLocale: c, rangeSeparator: m } = this.getProps();
    if (o && o.length) {
      const g = this.getProp("type"), v = l || this.getProp("format") || getDefaultFormatTokenByType(g);
      let b, S;
      const E = /* @__PURE__ */ new Date();
      switch (g) {
        case "date":
        case "dateTime":
        case "month":
          b = o ? compatibleParse(o, v, E, c) : "", S = b && isValid$5(b) && this.localeFormat(b, v), b && S === o && (u = [b]);
          break;
        case "dateRange":
        case "dateTimeRange":
        case "monthRange":
          const P = m, T = o.split(P);
          b = T && T.reduce((N, O) => {
            const z = O && compatibleParse(O, v, E, c);
            return z && N.push(z), N;
          }, []), S = b && b.map((N) => N && isValid$5(N) && this.localeFormat(N, v)).join(P), b && S === o && (b.sort((N, O) => N.getTime() - O.getTime()), u = b);
          break;
      }
    }
    return u;
  }
  /**
   * get date which may include null from input
   */
  getLooseDateFromInput(o) {
    return this._isMultiple() ? this.parseMultipleInputLoose(o) : this.parseInputLoose(o);
  }
  /**
   * parse input into `Array<Date|null>`, loose means return value includes `null`
   * 
   * @example
   * ```javascript
   * parseInputLoose('2022-03-15 ~ '); // [Date, null]
   * parseInputLoose(' ~ 2022-03-15 '); // [null, Date]
   * parseInputLoose(''); // []
   * parseInputLoose('2022-03- ~ 2022-0'); // [null, null]
   * ```
   */
  parseInputLoose(o = "") {
    let l = [];
    const { dateFnsLocale: u, rangeSeparator: c, type: m, format: g } = this.getProps();
    if (o && o.length) {
      const v = g || getDefaultFormatTokenByType(m);
      let b, S;
      const E = /* @__PURE__ */ new Date();
      switch (m) {
        case "date":
        case "dateTime":
        case "month":
          const P = compatibleParse(o, v, E, u);
          isValidDate(P) ? (S = this.localeFormat(P, v), S === o && (b = P)) : b = null, l = [b];
          break;
        case "dateRange":
        case "dateTimeRange":
          const T = c, N = o.split(T);
          b = N && N.reduce((O, z) => {
            let Q = null;
            const W = compatibleParse(z, v, E, u);
            return isValidDate(W) && (S = this.localeFormat(W, v), S === z && (Q = W)), O.push(Q), O;
          }, []), Array.isArray(b) && b.every((O) => isValid$5(O)) && b.sort((O, z) => O.getTime() - z.getTime()), l = b;
          break;
      }
    }
    return l;
  }
  /**
   * parse multiple into `Array<Date|null>`, loose means return value includes `null`
   * 
   * @example
   * ```javascript
   * parseMultipleInputLoose('2021-01-01,2021-10-15'); // [Date, Date];
   * parseMultipleInputLoose('2021-01-01,2021-10-'); // [Date, null];
   * parseMultipleInputLoose(''); // [];
   * ```
   */
  parseMultipleInputLoose(o = "", l = strings$f.DEFAULT_SEPARATOR_MULTIPLE, u = !1) {
    const c = this.getProp("max"), m = o.split(l), g = [];
    for (const v of m) {
      let b = v && this.parseInputLoose(v);
      if (b = Array.isArray(b) ? b : b && [b], b && b.length)
        u ? !g.filter((S) => !!b.find((E) => isSameSecond(S, E))) && g.push(...b) : g.push(...b);
      else
        return [];
      if (c && c > 0 && g.length > c)
        return [];
    }
    return g;
  }
  /**
   * Parses the input when multiple is true, if valid,
   *  returns a list of time objects, otherwise returns an array
   *
   * @param {string} [input='']
   * @param {string} [separator=',']
   * @param {boolean} [needDedupe=false]
   * @returns {Date[]}
   */
  parseMultipleInput(o = "", l = strings$f.DEFAULT_SEPARATOR_MULTIPLE, u = !1) {
    const c = this.getProp("max"), m = o.split(l), g = [];
    for (const v of m) {
      let b = v && this.parseInput(v);
      if (b = Array.isArray(b) ? b : b && [b], b && b.length)
        u ? !g.filter((S) => !!b.find((E) => isSameSecond(S, E))) && g.push(...b) : g.push(...b);
      else
        return [];
      if (c && c > 0 && g.length > c)
        return [];
    }
    return g;
  }
  /**
   * dates[] => string
   *
   * @param {Date[]} dates
   * @returns {string}
   */
  formatDates(o = [], l) {
    let u = "";
    const c = this.getProp("rangeSeparator");
    if (Array.isArray(o) && o.length) {
      const m = this.getProp("type"), g = l || this.getProp("format") || getDefaultFormatTokenByType(m);
      switch (m) {
        case "date":
        case "dateTime":
        case "month":
          u = this.localeFormat(o[0], g);
          break;
        case "dateRange":
        case "dateTimeRange":
        case "monthRange":
          const v = !isNullOrUndefined(o[0]), b = !isNullOrUndefined(o[1]);
          v && b ? u = `${this.localeFormat(o[0], g)}${c}${this.localeFormat(o[1], g)}` : v ? u = `${this.localeFormat(o[0], g)}${c}` : b && (u = `${c}${this.localeFormat(o[1], g)}`);
          break;
      }
    }
    return u;
  }
  /**
   * dates[] => string
   *
   * @param {Date[]} dates
   * @returns {string}
   */
  formatMultipleDates(o = [], l = strings$f.DEFAULT_SEPARATOR_MULTIPLE, u) {
    const c = [];
    if (Array.isArray(o) && o.length)
      switch (this.getProp("type")) {
        case "date":
        case "dateTime":
        case "month":
          o.forEach((g) => c.push(this.formatDates([g], u)));
          break;
        case "dateRange":
        case "dateTimeRange":
        case "monthRange":
          for (let g = 0; g < o.length; g += 2)
            c.push(this.formatDates(o.slice(g, g + 2), u));
          break;
      }
    return c.join(l);
  }
  /**
   * Update date value and the value of the input box
   * 1. Select Update
   * 2. Input Update
   * @param {Date|''} value
   * @param {Boolean} forceUpdateValue
   * @param {String} input
   */
  _updateValueAndInput(o, l, u) {
    let c;
    if (l || o) {
      Array.isArray(o) ? c = o : c = o ? [o] : [];
      const m = this._getChangedDates(c);
      !this._isControlledComponent() && !this._someDateDisabled(m, c) && !this._adapter.needConfirm() && this._adapter.updateValue(c);
    }
    this._adapter.updateInputValue(u);
  }
  /**
   * when changing the selected value through the date panel
   * @param {*} value
   * @param {*} options
   */
  handleSelectedChange(o, l) {
    const { type: u, format: c, rangeSeparator: m, insetInput: g } = this._adapter.getProps(), { value: v } = this.getStates(), b = this._isControlledComponent(), S = lodashExports.isObject(l) ? l.fromPreset : l, E = lodashExports.get(l, "closePanel", !0), P = lodashExports.get(l, "needCheckFocusRecord", !0), T = Array.isArray(o) ? [...o] : o ? [o] : [], N = this._getChangedDates(T);
    let O, z;
    if (!this._someDateDisabled(N, T)) {
      if (this.resetCachedSelectedValue(T), O = this._isMultiple() ? this.formatMultipleDates(T) : this.formatDates(T), g) {
        const ue = getInsetInputFormatToken({ format: c, type: u }), te = this._isMultiple() ? this.formatMultipleDates(T, void 0, ue) : this.formatDates(T, ue);
        z = getInsetInputValueFromInsetInputStr({ inputValue: te, type: u, rangeSeparator: m });
      }
      if (this._isRangeType() && !this._isRangeValueComplete(T)) {
        this._adapter.updateInputValue(O), this._adapter.updateInsetInputValue(z);
        return;
      } else
        (!b || S) && (this._updateValueAndInput(T, !0, O), this._adapter.updateInsetInputValue(z));
      lodashExports.isEqual(o, v) || this._notifyChange(o);
    }
    const Q = !P || P && this._adapter.couldPanelClosed();
    (u === "date" && !this._isMultiple() && E || u === "dateRange" && this._isRangeValueComplete(T) && E && Q) && this.closePanel(void 0, O, T);
  }
  /**
   * when changing the year and month through the panel when the type is year or month or monthRange
   * @param {*} item
   */
  handleYMSelectedChange(o = {}) {
    const { currentMonth: l, currentYear: u } = o, { type: c } = this.getProps();
    if (c === "month") {
      const m = new Date(u.left, l.left - 1);
      this.handleSelectedChange([m]);
    } else {
      const m = new Date(u.left, l.left - 1), g = new Date(u.right, l.right - 1);
      this.handleSelectedChange([m, g]);
    }
  }
  handleConfirm() {
    this.clickConfirmButton = !0;
    const { cachedSelectedValue: o, value: l } = this._adapter.getStates(), u = this._isRangeValueComplete(o), c = u ? o : l;
    if (this._adapter.needConfirm() && !this._isControlledComponent() && this._adapter.updateValue(c), this.closePanel(void 0, void 0, c), u) {
      const { notifyValue: m, notifyDate: g } = this.disposeCallbackArgs(o);
      this._adapter.notifyConfirm(g, m);
    }
  }
  handleCancel() {
    this.closePanel();
    const o = this.getState("value"), { notifyValue: l, notifyDate: u } = this.disposeCallbackArgs(o);
    this._adapter.notifyCancel(u, l);
  }
  handlePresetClick(o, l) {
    const { type: u, timeZone: c } = this.getProps(), m = this.getState("prevTimezone"), g = typeof o.start == "function" ? o.start() : o.start, v = typeof o.end == "function" ? o.end() : o.end;
    let b;
    switch (u) {
      case "month":
      case "dateTime":
      case "date":
        b = this.parseWithTimezone([g], c, m), this.handleSelectedChange(b);
        break;
      case "dateTimeRange":
      case "dateRange":
        b = this.parseWithTimezone([g, v], c, m), this.handleSelectedChange(b, { needCheckFocusRecord: !1 });
        break;
    }
    this._adapter.notifyPresetsClick(o, l);
  }
  /**
   * 根据 type 处理 onChange 返回的参数
   *
   *  - 返回的日期需要把用户时间转换为设置的时区时间
   *      - 用户时间：用户计算机系统时间
   *      - 时区时间：通过 ConfigProvider 设置的 timeZone
   *  - 例子：用户设置时区为+9，计算机所在时区为+8区，然后用户选择了22:00
   *      - DatePicker 内部保存日期 state 为 +8 的 22:00 => a = new Date("2021-05-25 22:00:00")
   *      - 传出去时，需要把 +8 的 22:00 => +9 的 22:00 => b = zonedTimeToUtc(a, "+09:00");
   *
   * According to the type processing onChange returned parameters
   *
   *   - the returned date needs to convert the user time to the set time zone time
   *       - user time: user computer system time
   *       - time zone time: timeZone set by ConfigProvider
   *   - example: the user sets the time zone to + 9, the computer's time zone is + 8 zone, and then the user selects 22:00
   *       - DatePicker internal save date state is + 8 22:00 = > a = new Date ("2021-05-25 22:00:00")
   *       - when passed out, you need to + 8 22:00 = > + 9 22:00 = > b = zonedTimeToUtc (a, "+ 09:00");
   *
   *  e.g.
   *  let a = new Date ("2021-05-25 22:00:00");
   *       = > Tue May 25 2021 22:00:00 GMT + 0800 (China Standard Time)
   *  let b = zonedTimeToUtc (a, "+ 09:00");
   *       = > Tue May 25 2021 21:00:00 GMT + 0800 (China Standard Time)
   *
   * @param {Date|Date[]} value
   * @return {{ notifyDate: Date|Date[], notifyValue: string|string[]}}
   */
  disposeCallbackArgs(o) {
    let l = Array.isArray(o) ? o : o && [o] || [];
    const u = this.getProp("timeZone");
    isValidTimeZone(u) && (l = l.map((b) => zonedTimeToUtc(b, u)));
    const c = this.getProp("type"), m = this.getProp("format") || getDefaultFormatTokenByType(c);
    let g, v;
    switch (c) {
      case "date":
      case "dateTime":
      case "month":
        this._isMultiple() ? (g = l.map((b) => b && this.localeFormat(b, m)), v = [...l]) : (g = l[0] && this.localeFormat(l[0], m), [v] = l);
        break;
      case "dateRange":
      case "dateTimeRange":
      case "monthRange":
        g = l.map((b) => b && this.localeFormat(b, m)), v = [...l];
        break;
    }
    return {
      notifyValue: g,
      notifyDate: v
    };
  }
  /**
   * Notice: Check whether the date is the same as the state value before calling
   * @param {Date[]} value
   */
  _notifyChange(o) {
    if (this._isRangeType() && !this._isRangeValueComplete(o))
      return;
    const { onChangeWithDateFirst: l } = this.getProps(), { notifyValue: u, notifyDate: c } = this.disposeCallbackArgs(o);
    l ? this._adapter.notifyChange(c, u) : this._adapter.notifyChange(u, c);
  }
  /**
   * Get the date changed through the date panel or enter
   */
  _getChangedDates(o) {
    const l = this._adapter.getProp("type"), { cachedSelectedValue: u } = this._adapter.getStates(), c = [];
    switch (l) {
      case "dateRange":
      case "dateTimeRange":
        const [m, g] = u, [v, b] = o;
        isEqual$1(v, m) || c.push(v), isEqual$1(b, g) || c.push(b);
        break;
      default:
        const S = /* @__PURE__ */ new Set();
        u.forEach((E) => S.add(isDate$1(E) && E.valueOf()));
        for (const E of o)
          S.has(isDate$1(E) && E.valueOf()) || c.push(E);
    }
    return c;
  }
  /**
   * Whether a date is disabled
   * @param value The date that needs to be judged whether to disable
   * @param selectedValue Selected date, when selecting a range, pass this date to the second parameter of `disabledDate`
   */
  _someDateDisabled(o, l) {
    const { rangeInputFocus: u } = this.getStates(), c = { rangeStart: "", rangeEnd: "", rangeInputFocus: u };
    if (this._isRangeType() && Array.isArray(l)) {
      if (isValid$5(l[0])) {
        const g = format$3(l[0], "yyyy-MM-dd");
        c.rangeStart = g;
      }
      if (isValid$5(l[1])) {
        const g = format$3(l[1], "yyyy-MM-dd");
        c.rangeEnd = g;
      }
    }
    let m = !1;
    for (const g of o)
      if (!isNullOrUndefined(g) && this.disabledDisposeDate(g, c)) {
        m = !0;
        break;
      }
    return m;
  }
  /**
   * Format locale date
   * locale get from LocaleProvider
   * @param {Date} date
   * @param {String} token
   */
  localeFormat(o, l) {
    const u = this._adapter.getProp("dateFnsLocale");
    return format$3(o, l, { locale: u });
  }
  /**
   * Convert computer date to UTC date
   * Before passing the date to the user, you need to convert the date to UTC time
   * dispose date from computer date to utc date
   * When given timeZone prop, you should convert computer date to utc date before passing to user
   * @param {(date: Date) => Boolean} fn
   * @param {Date|Date[]} date
   * @returns {Boolean}
   */
  disposeDateFn(o, l, ...u) {
    const { notifyDate: c } = this.disposeCallbackArgs(l), m = Array.isArray(l), g = Array.isArray(c);
    let v;
    return m === g ? v = c : v = m ? [c] : c[0], o(v, ...u);
  }
  /**
   * Determine whether the date is disabled
   * Whether the date is disabled
   * @param {Date} date
   * @returns {Boolean}
   */
  disabledDisposeDate(o, ...l) {
    const { disabledDate: u } = this.getProps();
    return this.disposeDateFn(u, o, ...l);
  }
  /**
   * Determine whether the date is disabled
   * Whether the date time is disabled
   * @param {Date|Date[]} date
   * @returns {Object}
   */
  disabledDisposeTime(o, ...l) {
    const { disabledTime: u } = this.getProps();
    return this.disposeDateFn(u, o, ...l);
  }
  /**
   * Trigger wrapper needs to do two things:
   *  1. Open Panel when clicking trigger;
   *  2. When clicking on a child but the child does not listen to the focus event, manually trigger focus
   *
   * @param {Event} e
   * @returns
   */
  handleTriggerWrapperClick(o) {
    const { disabled: l, triggerRender: u } = this._adapter.getProps(), { rangeInputFocus: c } = this._adapter.getStates();
    l || (this._isRangeType() && !c ? (this._adapter.isEventTarget(o) ? setTimeout(() => {
      this.handleInputFocus(o, "rangeStart");
    }, 0) : lodashExports.isFunction(u) && this._adapter.setRangeInputFocus("rangeStart"), this.openPanel()) : this.openPanel());
  }
  handlePanelVisibleChange(o) {
    o ? (this._adapter.setInsetInputFocus(), setTimeout(() => {
      this._adapter.setTriggerDisabled(!0);
    }, 0)) : this._adapter.setTriggerDisabled(!1);
  }
}
function formatDateValues(s, o, {
  groupInnerSeparator: l = strings$f.DEFAULT_SEPARATOR_RANGE,
  groupSize: u = 1,
  groupSeparator: c = strings$f.DEFAULT_SEPARATOR_MULTIPLE
} = {}, m) {
  let g = "";
  if ((u <= 0 || typeof u != "number") && (u = 1), Array.isArray(s) && s.length) {
    const v = [], { length: b } = s;
    for (let S = 0; S < b; S++) {
      S % u === 0 && v.push([]);
      const E = Math.floor(S / u);
      v[E].push(s[S]);
    }
    g = v.map(
      (S) => S.map((E) => E ? format$3(E, o, { locale: m }) : "").join(l)
    ).join(c);
  }
  return g;
}
function getDefaultPickerDate(s) {
  const { defaultPickerValue: o, format: l, dateFnsLocale: u } = s;
  let c = Array.isArray(o) ? o[0] : o, m = Array.isArray(o) ? o[1] : void 0;
  switch (!0) {
    case isValidDate(c):
      break;
    case isTimestamp(c):
      c = new Date(c);
      break;
    case typeof c == "string":
      c = compatibleParse(c, l, void 0, u);
      break;
    default:
      c = /* @__PURE__ */ new Date();
      break;
  }
  switch (!0) {
    case isValidDate(m):
      break;
    case isTimestamp(m):
      m = new Date(m);
      break;
    case typeof m == "string":
      m = compatibleParse(m, l, void 0, u);
      break;
    default:
      m = addMonths(c, 1);
      break;
  }
  return {
    nowDate: c,
    nextDate: m
  };
}
var toStringFunction = Function.prototype.toString, create$3 = Object.create, toStringObject = Object.prototype.toString, LegacyCache = (
  /** @class */
  function() {
    function s() {
      this._keys = [], this._values = [];
    }
    return s.prototype.has = function(o) {
      return !!~this._keys.indexOf(o);
    }, s.prototype.get = function(o) {
      return this._values[this._keys.indexOf(o)];
    }, s.prototype.set = function(o, l) {
      this._keys.push(o), this._values.push(l);
    }, s;
  }()
);
function createCacheLegacy() {
  return new LegacyCache();
}
function createCacheModern() {
  return /* @__PURE__ */ new WeakMap();
}
var createCache = typeof WeakMap < "u" ? createCacheModern : createCacheLegacy;
function getCleanClone(s) {
  if (!s)
    return create$3(null);
  var o = s.constructor;
  if (o === Object)
    return s === Object.prototype ? {} : create$3(s);
  if (o && ~toStringFunction.call(o).indexOf("[native code]"))
    try {
      return new o();
    } catch {
    }
  return create$3(s);
}
function getRegExpFlagsLegacy(s) {
  var o = "";
  return s.global && (o += "g"), s.ignoreCase && (o += "i"), s.multiline && (o += "m"), s.unicode && (o += "u"), s.sticky && (o += "y"), o;
}
function getRegExpFlagsModern(s) {
  return s.flags;
}
var getRegExpFlags = /test/g.flags === "g" ? getRegExpFlagsModern : getRegExpFlagsLegacy;
function getTagLegacy(s) {
  var o = toStringObject.call(s);
  return o.substring(8, o.length - 1);
}
function getTagModern(s) {
  return s[Symbol.toStringTag] || getTagLegacy(s);
}
var getTag = typeof Symbol < "u" ? getTagModern : getTagLegacy, defineProperty$1 = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, _a = Object.prototype, hasOwnProperty$2 = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable, SUPPORTS_SYMBOL = typeof getOwnPropertySymbols == "function";
function getStrictPropertiesModern(s) {
  return getOwnPropertyNames(s).concat(getOwnPropertySymbols(s));
}
var getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;
function copyOwnPropertiesStrict(s, o, l) {
  for (var u = getStrictProperties(s), c = 0, m = u.length, g = void 0, v = void 0; c < m; ++c)
    if (g = u[c], !(g === "callee" || g === "caller")) {
      if (v = getOwnPropertyDescriptor(s, g), !v) {
        o[g] = l.copier(s[g], l);
        continue;
      }
      !v.get && !v.set && (v.value = l.copier(v.value, l));
      try {
        defineProperty$1(o, g, v);
      } catch {
        o[g] = v.value;
      }
    }
  return o;
}
function copyArrayLoose(s, o) {
  var l = new o.Constructor();
  o.cache.set(s, l);
  for (var u = 0, c = s.length; u < c; ++u)
    l[u] = o.copier(s[u], o);
  return l;
}
function copyArrayStrict(s, o) {
  var l = new o.Constructor();
  return o.cache.set(s, l), copyOwnPropertiesStrict(s, l, o);
}
function copyArrayBuffer(s, o) {
  return s.slice(0);
}
function copyBlob(s, o) {
  return s.slice(0, s.size, s.type);
}
function copyDataView(s, o) {
  return new o.Constructor(copyArrayBuffer(s.buffer));
}
function copyDate(s, o) {
  return new o.Constructor(s.getTime());
}
function copyMapLoose(s, o) {
  var l = new o.Constructor();
  return o.cache.set(s, l), s.forEach(function(u, c) {
    l.set(c, o.copier(u, o));
  }), l;
}
function copyMapStrict(s, o) {
  return copyOwnPropertiesStrict(s, copyMapLoose(s, o), o);
}
function copyObjectLooseLegacy(s, o) {
  var l = getCleanClone(o.prototype);
  o.cache.set(s, l);
  for (var u in s)
    hasOwnProperty$2.call(s, u) && (l[u] = o.copier(s[u], o));
  return l;
}
function copyObjectLooseModern(s, o) {
  var l = getCleanClone(o.prototype);
  o.cache.set(s, l);
  for (var u in s)
    hasOwnProperty$2.call(s, u) && (l[u] = o.copier(s[u], o));
  for (var c = getOwnPropertySymbols(s), m = 0, g = c.length, v = void 0; m < g; ++m)
    v = c[m], propertyIsEnumerable.call(s, v) && (l[v] = o.copier(s[v], o));
  return l;
}
var copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;
function copyObjectStrict(s, o) {
  var l = getCleanClone(o.prototype);
  return o.cache.set(s, l), copyOwnPropertiesStrict(s, l, o);
}
function copyPrimitiveWrapper(s, o) {
  return new o.Constructor(s.valueOf());
}
function copyRegExp(s, o) {
  var l = new o.Constructor(s.source, getRegExpFlags(s));
  return l.lastIndex = s.lastIndex, l;
}
function copySelf(s, o) {
  return s;
}
function copySetLoose(s, o) {
  var l = new o.Constructor();
  return o.cache.set(s, l), s.forEach(function(u) {
    l.add(o.copier(u, o));
  }), l;
}
function copySetStrict(s, o) {
  return copyOwnPropertiesStrict(s, copySetLoose(s, o), o);
}
var isArray$2 = Array.isArray, assign = Object.assign, getPrototypeOf = Object.getPrototypeOf || function(s) {
  return s.__proto__;
}, DEFAULT_LOOSE_OPTIONS = {
  array: copyArrayLoose,
  arrayBuffer: copyArrayBuffer,
  blob: copyBlob,
  dataView: copyDataView,
  date: copyDate,
  error: copySelf,
  map: copyMapLoose,
  object: copyObjectLoose,
  regExp: copyRegExp,
  set: copySetLoose
}, DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {
  array: copyArrayStrict,
  map: copyMapStrict,
  object: copyObjectStrict,
  set: copySetStrict
});
function getTagSpecificCopiers(s) {
  return {
    Arguments: s.object,
    Array: s.array,
    ArrayBuffer: s.arrayBuffer,
    Blob: s.blob,
    Boolean: copyPrimitiveWrapper,
    DataView: s.dataView,
    Date: s.date,
    Error: s.error,
    Float32Array: s.arrayBuffer,
    Float64Array: s.arrayBuffer,
    Int8Array: s.arrayBuffer,
    Int16Array: s.arrayBuffer,
    Int32Array: s.arrayBuffer,
    Map: s.map,
    Number: copyPrimitiveWrapper,
    Object: s.object,
    Promise: copySelf,
    RegExp: s.regExp,
    Set: s.set,
    String: copyPrimitiveWrapper,
    WeakMap: copySelf,
    WeakSet: copySelf,
    Uint8Array: s.arrayBuffer,
    Uint8ClampedArray: s.arrayBuffer,
    Uint16Array: s.arrayBuffer,
    Uint32Array: s.arrayBuffer,
    Uint64Array: s.arrayBuffer
  };
}
function createCopier(s) {
  var o = assign({}, DEFAULT_LOOSE_OPTIONS, s), l = getTagSpecificCopiers(o), u = l.Array, c = l.Object;
  function m(g, v) {
    if (v.prototype = v.Constructor = void 0, !g || typeof g != "object")
      return g;
    if (v.cache.has(g))
      return v.cache.get(g);
    if (v.prototype = getPrototypeOf(g), v.Constructor = v.prototype && v.prototype.constructor, !v.Constructor || v.Constructor === Object)
      return c(g, v);
    if (isArray$2(g))
      return u(g, v);
    var b = l[getTag(g)];
    return b ? b(g, v) : typeof g.then == "function" ? g : c(g, v);
  }
  return function(v) {
    return m(v, {
      Constructor: void 0,
      cache: createCache(),
      copier: m,
      prototype: void 0
    });
  };
}
function createStrictCopier(s) {
  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, s));
}
createStrictCopier({});
var index$b = createCopier({});
const KEY_CODE_ENTER = "Enter", KEY_CODE_TAB = "Tab";
class InputFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
  }
  destroy() {
  }
  handleClick(o) {
    this._adapter.notifyClick(o);
  }
  handleChange(o, l) {
    this._adapter.notifyChange(o, l);
  }
  handleInputComplete(o) {
    o.key === KEY_CODE_ENTER && this._adapter.notifyEnter(o.target.value);
  }
  handleInputClear(o) {
    this._adapter.notifyClear(o);
  }
  handleRangeInputClear(o) {
    this.stopPropagation(o), this._adapter.notifyRangeInputClear(o);
  }
  handleRangeInputEnterPress(o, l) {
    o.key === KEY_CODE_ENTER && this._adapter.notifyEnter(l);
  }
  handleRangeInputEndKeyPress(o) {
    o.key === KEY_CODE_TAB && this._adapter.notifyTabPress(o);
  }
  handleRangeInputFocus(o, l) {
    this._adapter.notifyRangeInputFocus(o, l);
  }
  formatShowText(o, l) {
    const { type: u, dateFnsLocale: c, format: m, rangeSeparator: g } = this._adapter.getProps(), v = l || m || getDefaultFormatTokenByType(u);
    let b = "";
    switch (u) {
      case "date":
        b = formatDateValues(o, v, void 0, c);
        break;
      case "dateRange":
        b = formatDateValues(o, v, { groupSize: 2, groupInnerSeparator: g }, c);
        break;
      case "dateTime":
        b = formatDateValues(o, v, void 0, c);
        break;
      case "dateTimeRange":
        b = formatDateValues(o, v, { groupSize: 2, groupInnerSeparator: g }, c);
        break;
      case "month":
        b = formatDateValues(o, v, void 0, c);
        break;
      case "monthRange":
        b = formatDateValues(o, v, { groupSize: 2, groupInnerSeparator: g }, c);
        break;
    }
    return b;
  }
  handleInsetInputChange(o) {
    const { value: l, valuePath: u, insetInputValue: c } = o, { format: m, type: g, rangeSeparator: v } = this._adapter.getProps(), b = getInsetInputFormatToken({ type: g, format: m }), S = lodashExports.set(index$b(c), u, l), E = this.concatInsetInputValue({ insetInputValue: S }), P = getInsetInputValueFromInsetInputStr({ inputValue: E, type: g, rangeSeparator: v }), T = this._autoFillTimeToInsetInputValue({ insetInputValue: P, valuePath: u, format: b }), N = this.concatInsetInputValue({ insetInputValue: T });
    this._adapter.notifyInsetInputChange({ insetInputValue: T, format: b, insetInputStr: N });
  }
  _autoFillTimeToInsetInputValue(o) {
    const { valuePath: l, insetInputValue: u, format: c } = o, { type: m, defaultPickerValue: g, dateFnsLocale: v } = this._adapter.getProps(), b = index$b(u), { nowDate: S, nextDate: E } = getDefaultPickerDate({ defaultPickerValue: g, format: c, dateFnsLocale: v });
    if (m.includes("Time")) {
      let P = "";
      const T = lodashExports.get(c.split(" "), "0", strings$f.FORMAT_FULL_DATE), N = lodashExports.get(c.split(" "), "1", strings$f.FORMAT_TIME_PICKER);
      switch (l) {
        case "monthLeft.dateInput":
          const O = b.monthLeft.dateInput;
          if (!b.monthLeft.timeInput && O.length === T.length) {
            const Q = compatibleParse(b.monthLeft.dateInput, T);
            isValidDate(Q) && (P = format$3(S, N), b.monthLeft.timeInput = P);
          }
          break;
        case "monthRight.dateInput":
          const z = b.monthRight.dateInput;
          if (!b.monthRight.timeInput && z.length === T.length) {
            const Q = compatibleParse(z, T);
            isValidDate(Q) && (P = format$3(E, N), b.monthRight.timeInput = P);
          }
          break;
      }
    }
    return b;
  }
  /**
   * 只有传入的 format 符合 formatReg 时，才会使用用户传入的 format
   * 否则会使用默认的 format 作为 placeholder
   * 
   * The format passed in by the user will be used only if the incoming format conforms to formatReg
   * Otherwise the default format will be used as placeholder
   */
  getInsetInputPlaceholder() {
    const { type: o, format: l, rangeSeparator: u } = this._adapter.getProps(), c = getInsetInputFormatToken({ type: o, format: l });
    let m, g;
    switch (o) {
      case "date":
      case "month":
      case "dateRange":
        m = c;
        break;
      case "dateTime":
      case "dateTimeRange":
        [m, g] = c.split(" ");
        break;
      case "monthRange":
        m = c + u + c;
        break;
    }
    return {
      datePlaceholder: m,
      timePlaceholder: g
    };
  }
  /**
   * 从当前日期值或 inputValue 中解析出 insetInputValue
   * 
   * Parse out insetInputValue from current date value or inputValue
   */
  getInsetInputValue({ value: o, insetInputValue: l }) {
    const { type: u, rangeSeparator: c, format: m } = this._adapter.getProps();
    let g = "";
    if (lodashExports.isObject(l))
      g = this.concatInsetInputValue({ insetInputValue: l });
    else {
      const b = getInsetInputFormatToken({ format: m, type: u });
      g = this.formatShowText(o, b);
    }
    return getInsetInputValueFromInsetInputStr({ inputValue: g, type: u, rangeSeparator: c });
  }
  concatInsetDateAndTime({ date: o, time: l }) {
    return `${o} ${l}`;
  }
  concatInsetDateRange({ rangeStart: o, rangeEnd: l }) {
    const { rangeSeparator: u } = this._adapter.getProps();
    return `${o}${u}${l}`;
  }
  concatInsetInputValue({ insetInputValue: o }) {
    const { type: l } = this._adapter.getProps();
    let u = "";
    switch (l) {
      case "date":
      case "month":
      case "monthRange":
        u = o.monthLeft.dateInput;
        break;
      case "dateRange":
        u = this.concatInsetDateRange({ rangeStart: o.monthLeft.dateInput, rangeEnd: o.monthRight.dateInput });
        break;
      case "dateTime":
        u = this.concatInsetDateAndTime({ date: o.monthLeft.dateInput, time: o.monthLeft.timeInput });
        break;
      case "dateTimeRange":
        const c = this.concatInsetDateAndTime({ date: o.monthLeft.dateInput, time: o.monthLeft.timeInput }), m = this.concatInsetDateAndTime({ date: o.monthRight.dateInput, time: o.monthRight.timeInput });
        u = this.concatInsetDateRange({ rangeStart: c, rangeEnd: m });
        break;
    }
    return u;
  }
}
const vuePropsTypeInsetDateInput = {
  forwardRef: {
    type: [Function, Object],
    required: !0
  },
  insetInputValue: {
    type: Object,
    required: !0
  },
  placeholder: {
    type: String,
    required: !0
  },
  valuePath: {
    type: String,
    required: !0
  },
  onChange: {
    type: Function,
    required: !0
  },
  onFocus: {
    type: Function,
    required: !0
  }
}, InsetDateInput = /* @__PURE__ */ defineComponent({
  props: vuePropsTypeInsetDateInput,
  name: "InsetDateInput",
  setup(s, {}) {
    const {
      insetInputValue: o,
      valuePath: l,
      onFocus: u,
      onChange: c,
      placeholder: m,
      forwardRef: g
    } = s, v = lodashExports.get(o, l);
    return () => createVNode(Input$1, {
      value: v,
      onChange: (b, S) => {
        c({
          value: b,
          event: S,
          insetInputValue: o,
          valuePath: l
        });
      },
      onFocus: u,
      placeholder: m,
      ref: g
    }, null);
  }
}), vuePropsTypeInsetTimeInput = {
  disabled: {
    type: Boolean,
    required: !0
  },
  insetInputValue: {
    type: Object,
    required: !0
  },
  placeholder: {
    type: String,
    required: !0
  },
  valuePath: {
    type: String,
    required: !0
  },
  type: {
    type: String,
    required: !0
  },
  onChange: {
    type: Function,
    required: !0
  },
  onFocus: {
    type: Function,
    required: !0
  }
}, InsetTimeInput = /* @__PURE__ */ defineComponent((s, {}) => {
  const {
    insetInputValue: o,
    valuePath: l,
    type: u,
    onFocus: c,
    onChange: m,
    placeholder: g,
    disabled: v
  } = s;
  if (!u.includes("Time"))
    return null;
  const S = lodashExports.get(o, l);
  return () => createVNode(Input$1, {
    value: S,
    onChange: (E, P) => {
      m({
        value: E,
        event: P,
        insetInputValue: o,
        valuePath: l
      });
    },
    onFocus: c,
    placeholder: g,
    disabled: v
  }, null);
}, {
  props: vuePropsTypeInsetTimeInput,
  name: "InsetTimeInput"
}), propTypes$1u = {
  borderless: {
    type: bool,
    default: !1
  },
  onClick: {
    type: func,
    default: noop$1
  },
  onChange: {
    type: func,
    default: noop$1
  },
  onEnterPress: {
    type: func,
    default: noop$1
  },
  onBlur: {
    type: func,
    default: noop$1
  },
  onClear: {
    type: func,
    default: noop$1
  },
  onFocus: {
    type: func,
    default: noop$1
  },
  value: array$1,
  disabled: bool,
  type: {
    type: string$3,
    default: "date"
  },
  showClear: {
    type: bool,
    default: !0
  },
  format: string$3,
  // Attributes not used
  inputStyle: {
    type: object$1,
    default: () => ({})
  },
  inputReadOnly: {
    type: bool,
    default: !1
  },
  // Text box can be entered
  insetLabel: node$1,
  validateStatus: string$3,
  prefix: node$1,
  prefixCls: {
    type: string$3,
    default: cssClasses$I.PREFIX
  },
  dateFnsLocale: any$1,
  // Foundation useful to
  placeholder: any$1,
  rangeInputFocus: [string$3, bool],
  rangeInputStartRef: object$1,
  rangeInputEndRef: object$1,
  rangeSeparator: {
    type: string$3,
    default: strings$f.DEFAULT_SEPARATOR_RANGE
  },
  insetInput: [bool, object$1],
  insetInputValue: object$1,
  defaultPickerValue: any$1,
  clearIcon: node$1,
  inputValue: string$3,
  block: bool,
  insetLabelId: string$3,
  multiple: bool,
  size: string$3,
  autofocus: bool,
  onRangeBlur: func,
  onRangeClear: func,
  onRangeEndTabPress: func,
  inputRef: object$1,
  showClearIgnoreDisabled: bool,
  onInsetInputChange: func,
  panelType: string$3,
  density: string$3,
  onRangeInputClear: func,
  style: object$1,
  className: string$3,
  text: string$3,
  handleInsetDateFocus: func,
  handleInsetTimeFocus: func,
  suffix: node$1,
  inputCls: String
}, defaultProps$1o = {
  showClear: !0,
  onClick: noop$1,
  onChange: noop$1,
  onEnterPress: noop$1,
  onBlur: noop$1,
  onClear: noop$1,
  onFocus: noop$1,
  type: "date",
  inputStyle: {},
  inputReadOnly: !1,
  prefixCls: cssClasses$I.PREFIX,
  rangeSeparator: strings$f.DEFAULT_SEPARATOR_RANGE
}, vuePropsType$2p = vuePropsMake(propTypes$1u, defaultProps$1o), dateInput = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2p
  },
  name: "dateInput",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      isFocusing: !1
    }), {
      adapter: l
    } = useBaseComponent(s, o);
    function u() {
      return {
        ...l(),
        updateIsFocusing: (yt) => o.isFocusing = yt,
        notifyClick: (...yt) => s.onClick(...yt),
        notifyChange: (...yt) => s.onChange(...yt),
        notifyEnter: (...yt) => s.onEnterPress(...yt),
        notifyBlur: (...yt) => s.onBlur(...yt),
        notifyClear: (...yt) => s.onClear(...yt),
        notifyFocus: (...yt) => s.onFocus(...yt),
        notifyRangeInputClear: (...yt) => s.onRangeClear(...yt),
        notifyRangeInputFocus: (...yt) => s.onFocus(...yt),
        notifyTabPress: (...yt) => s.onRangeEndTabPress(...yt),
        notifyInsetInputChange: (yt) => s.onInsetInputChange(yt)
      };
    }
    onMounted(() => {
      c.init();
    }), onUnmounted(() => {
      c.destroy();
    });
    const c = new InputFoundation(u());
    function m(yt) {
      return yt && yt.length ? c.formatShowText(yt) : "";
    }
    const g = (yt, xt) => c.handleChange(yt, xt), v = (yt) => c.handleInputComplete(yt), b = (yt) => c.handleInputClear(yt), S = (yt, xt, Kt) => {
      const tn = Q(yt, xt);
      c.handleChange(tn, Kt);
    }, E = (yt) => {
      c.handleRangeInputClear(yt);
    }, P = (yt, xt, Kt) => {
      const tn = Q(xt, Kt);
      c.handleRangeInputEnterPress(yt, tn);
    }, T = (yt) => {
      c.handleRangeInputEndKeyPress(yt);
    }, N = (yt, xt) => {
      c.handleRangeInputFocus(yt, xt);
    }, O = (yt) => {
      N(yt, "rangeStart");
    }, z = (yt) => {
      c.handleInsetInputChange(yt);
    }, Q = (yt, xt) => {
      const {
        rangeSeparator: Kt
      } = s;
      return `${yt}${Kt}${xt}`;
    };
    function W() {
      const {
        prefix: yt,
        insetLabel: xt,
        prefixCls: Kt,
        disabled: tn,
        rangeInputFocus: ln
      } = s, rn = yt || xt;
      return rn ? createVNode("div", {
        class: `${Kt}-range-input-prefix`,
        onClick: (an) => !tn && !ln && O(an),
        "x-semi-prop": "prefix,insetLabel"
      }, [rn]) : null;
    }
    function ue(yt, xt) {
      const {
        disabled: Kt,
        rangeSeparator: tn
      } = s, ln = cls({
        [`${cssClasses$I.PREFIX}-range-input-separator`]: !0,
        [`${cssClasses$I.PREFIX}-range-input-separator-active`]: (yt || xt) && !Kt
      });
      return createVNode("span", {
        onClick: (rn) => !Kt && O(rn),
        class: ln
      }, [tn]);
    }
    function te(yt, xt) {
      const {
        showClear: Kt,
        prefixCls: tn,
        disabled: ln,
        clearIcon: rn,
        showClearIgnoreDisabled: an
      } = s;
      return (yt || xt) && Kt && !(ln && !an) ? createVNode("div", {
        role: "button",
        tabindex: 0,
        "aria-label": "Clear range input value",
        class: `${tn}-range-input-clearbtn`,
        onMousedown: (vt) => E(vt)
      }, [rn || createVNode(IconComponent$w, {
        "aria-hidden": !0
      }, null)]) : null;
    }
    function K(yt) {
      const {
        prefixCls: xt,
        disabled: Kt,
        rangeInputFocus: tn
      } = s;
      return yt ? createVNode("div", {
        class: `${xt}-range-input-suffix`,
        onClick: (rn) => !Kt && !tn && O(rn)
      }, [yt]) : null;
    }
    function ve(yt) {
      const {
        // this.props
        placeholder: xt,
        inputStyle: Kt,
        disabled: tn,
        inputReadOnly: ln,
        autofocus: rn,
        size: an,
        // compute props
        text: Gt,
        suffix: nn,
        inputCls: vt,
        // range only props
        rangeInputStartRef: Et,
        rangeInputEndRef: Qt,
        rangeInputFocus: un,
        prefixCls: gn,
        rangeSeparator: dn,
        borderless: yn
      } = yt, [vn, Pn = ""] = Gt.split(dn) || [], On = an === "large" ? "default" : "small", _n = Array.isArray(xt) ? xt : [xt, xt], [Nn, Un] = _n, Xn = cls(`${gn}-range-input-wrapper-start`, `${gn}-range-input-wrapper`, {
        [`${gn}-range-input-wrapper-active`]: un === "rangeStart" && !tn,
        [`${gn}-range-input-wrapper-start-with-prefix`]: s.prefix || s.insetLabel,
        [`${gn}-borderless`]: yn
      }), zn = cls(`${gn}-range-input-wrapper-end`, `${gn}-range-input-wrapper`, {
        [`${gn}-range-input-wrapper-active`]: un === "rangeEnd" && !tn,
        [`${gn}-borderless`]: yn
      });
      return createVNode(Fragment, null, [W(), createVNode("div", {
        onClick: (jn) => !tn && N(jn, "rangeStart"),
        class: `${vt} ${Xn}`
      }, [createVNode(Input$1, {
        borderless: yn,
        size: On,
        style: Kt,
        disabled: tn,
        readonly: ln,
        placeholder: Nn,
        value: vn,
        onChange: (jn, kn) => S(jn, Pn, kn),
        onEnterPress: (jn) => P(jn, vn, Pn),
        onFocus: (jn) => N(jn, "rangeStart"),
        autoFocus: rn,
        forwardRef: Et
      }, null)]), ue(vn, Pn), createVNode("div", {
        class: `${vt} ${zn}`,
        onClick: (jn) => !tn && N(jn, "rangeEnd")
      }, [createVNode(Input$1, {
        borderless: yn,
        size: On,
        style: Kt,
        disabled: tn,
        readonly: ln,
        placeholder: Un,
        value: Pn,
        onChange: (jn, kn) => S(vn, jn, kn),
        onEnterPress: (jn) => P(jn, vn, Pn),
        onFocus: (jn) => N(jn, "rangeEnd"),
        onKeyDown: T,
        forwardRef: Qt
      }, null)]), te(vn, Pn), K(nn)]);
    }
    function ee() {
      const {
        type: yt
      } = s;
      return yt.includes("Range") && yt !== "monthRange";
    }
    function Re() {
      const {
        type: yt,
        handleInsetDateFocus: xt,
        handleInsetTimeFocus: Kt,
        value: tn,
        insetInputValue: ln,
        prefixCls: rn,
        rangeInputStartRef: an,
        rangeInputEndRef: Gt,
        density: nn,
        insetInput: vt
      } = s, Et = c.getInsetInputValue({
        value: tn,
        insetInputValue: ln
      }), {
        dateStart: Qt,
        dateEnd: un,
        timeStart: gn,
        timeEnd: dn
      } = lodashExports.get(vt, "placeholder", {}), {
        datePlaceholder: yn,
        timePlaceholder: vn
      } = c.getInsetInputPlaceholder(), Pn = `${rn}-inset-input-wrapper`, On = `${rn}-inset-input-separator`;
      return createVNode("div", {
        class: Pn,
        "x-type": yt
      }, [createVNode(InsetDateInput, {
        forwardRef: an,
        insetInputValue: Et,
        placeholder: Qt ?? yn,
        valuePath: "monthLeft.dateInput",
        onChange: z,
        onFocus: (_n) => xt(_n, "rangeStart")
      }, null), createVNode(InsetTimeInput, {
        disabled: !Et.monthLeft.dateInput,
        insetInputValue: Et,
        placeholder: gn ?? vn,
        type: yt,
        valuePath: "monthLeft.timeInput",
        onChange: z,
        onFocus: Kt
      }, null), ee() && createVNode(Fragment, null, [createVNode("div", {
        class: On
      }, [nn === "compact" ? null : "-"]), createVNode(InsetDateInput, {
        forwardRef: Gt,
        insetInputValue: Et,
        placeholder: un ?? yn,
        valuePath: "monthRight.dateInput",
        onChange: z,
        onFocus: (_n) => xt(_n, "rangeEnd")
      }, null), createVNode(InsetTimeInput, {
        disabled: !Et.monthRight.dateInput,
        insetInputValue: Et,
        placeholder: dn ?? vn,
        type: yt,
        valuePath: "monthRight.timeInput",
        onChange: z,
        onFocus: Kt
      }, null)])]);
    }
    function wt() {
      const {
        placeholder: yt,
        type: xt,
        value: Kt,
        inputValue: tn,
        inputStyle: ln,
        disabled: rn,
        showClear: an,
        inputReadOnly: Gt,
        insetLabel: nn,
        validateStatus: vt,
        block: Et,
        prefixCls: Qt,
        multiple: un,
        // Whether to allow multiple values for email and file types
        dateFnsLocale: gn,
        // No need to pass to input
        onBlur: dn,
        onClear: yn,
        onFocus: vn,
        prefix: Pn,
        autofocus: On,
        size: _n,
        inputRef: Nn,
        // range input support props, no need passing to not range type
        rangeInputStartRef: Un,
        rangeInputEndRef: Xn,
        onRangeClear: zn,
        onRangeBlur: jn,
        onRangeEndTabPress: kn,
        rangeInputFocus: Yn,
        rangeSeparator: Zn,
        insetInput: er,
        insetInputValue: bn,
        defaultPickerValue: Ln,
        showClearIgnoreDisabled: Kn,
        ...Bn
      } = s, Fn = createVNode(IconComponent$G, {
        "aria-hidden": !0
      }, null), Gn = createVNode(IconComponent$F, {
        "aria-hidden": !0
      }, null), Wn = xt.includes("Time") ? Gn : Fn;
      let Mn = "";
      isNullOrUndefined(tn) ? Kt && (Mn = m(Kt)) : Mn = tn;
      const Tn = cls({
        [`${Qt}-input-readonly`]: Gt,
        [`${Qt}-monthRange-input`]: xt === "monthRange"
      }), Rn = {
        ...s,
        text: Mn,
        suffix: Wn,
        inputCls: Tn
      }, hn = {
        ...Bn,
        inputRef: Nn,
        insetLabel: nn,
        disabled: rn,
        showClearIgnoreDisabled: Kn,
        readonly: Gt,
        className: Tn,
        style: ln,
        hideSuffix: an,
        placeholder: xt === "monthRange" && Array.isArray(yt) ? yt[0] + Zn + yt[1] : yt,
        onEnterPress: v,
        onChange: g,
        onClear: b,
        suffix: Wn,
        showClear: an,
        value: Mn,
        validateStatus: vt,
        prefix: Pn,
        autoFocus: On,
        size: _n,
        onBlur: dn,
        onFocus: vn
      };
      return ee() ? ve(Rn) : createVNode(Input$1, hn, null);
    }
    return () => {
      const {
        insetInput: yt
      } = s;
      return yt ? Re() : wt();
    };
  }
});
function formatFullDate(s = "", o = "", l = "") {
  let u = "";
  const c = typeof o == "number" && o < 10 ? `0${o}` : o.toString(), m = typeof l == "number" && l < 10 ? `0${l}` : l.toString();
  return u = `${String(s)}-${c}-${m}`, u;
}
function getWeeks(s, o = 0) {
  const l = {
    dayNumber: "",
    dateNumberFull: "",
    fullDate: ""
  }, u = getDaysInMonth(s), c = format$3(s, "yyyy"), m = format$3(s, "MM"), g = lastDayOfMonth(s), v = startOfMonth(s), b = Number(format$3(v, "e", { weekStartsOn: o })), S = [];
  let E = [];
  for (let P = 1; P < b; P++)
    E.push(l);
  for (let P = 0; P < u; P++) {
    const T = P + 1, N = T < 10 ? `0${T}` : T.toString(), O = formatFullDate(c, m, T);
    E.push({
      dayNumber: T,
      dayNumberFull: N,
      fullDate: O
    }), E.length === 7 ? (S.push(E), E = []) : O === format$3(g, "yyyy-MM-dd") && (S.push(E), E = []);
  }
  return S;
}
const getMonthTable = (s, o) => {
  const l = getWeeks(s, o);
  return { monthText: format$3(s, "yyyy-MM"), weeks: l, month: s };
}, dateDiffFns = {
  month: differenceInCalendarMonths,
  year: differenceInCalendarYears
}, dateCalcFns = {
  prevMonth: subMonths,
  nextMonth: addMonths,
  prevYear: subYears,
  nextYear: addYears
};
class MonthsGridFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.newBiMonthPanelDate = [this.getState("monthLeft").pickerDate, this.getState("monthRight").pickerDate];
  }
  init() {
    const o = this.getProp("defaultValue");
    this.initDefaultPickerValue(), this.updateSelectedFromProps(o);
  }
  initDefaultPickerValue() {
    const o = compatibleParse(this.getProp("defaultPickerValue"));
    o && isValidDate(o) && (this._updatePanelDetail(strings$f.PANEL_TYPE_LEFT, {
      pickerDate: o
    }), this._updatePanelDetail(strings$f.PANEL_TYPE_RIGHT, {
      pickerDate: addMonths(o, 1)
    }));
  }
  updateSelectedFromProps(o, l = !0) {
    const u = this.getProp("type"), { selected: c, rangeStart: m, rangeEnd: g } = this.getStates();
    if (o && (o != null && o.length))
      switch (u) {
        case "date":
          this._initDatePickerFromValue(o, l);
          break;
        case "dateRange":
          this._initDateRangePickerFromValue(o);
          break;
        case "dateTime":
          this._initDateTimePickerFromValue(o);
          break;
        case "dateTimeRange":
          this._initDateTimeRangePickerFormValue(o);
          break;
      }
    else (Array.isArray(o) && !o.length || !o) && (lodashExports.isSet(c) && c.size && this._adapter.updateDaySelected(/* @__PURE__ */ new Set()), m && this._adapter.setRangeStart(""), g && this._adapter.setRangeEnd(""));
  }
  calcDisabledTime(o) {
    const { disabledTime: l, type: u } = this.getProps();
    if (typeof l == "function" && o && ["dateTime", "dateTimeRange"].includes(u)) {
      const { rangeStart: c, rangeEnd: m, monthLeft: g } = this.getStates(), v = [];
      u === "dateTimeRange" ? (c && v.push(c), c && m && v.push(m)) : g && g.showDate && v.push(g.showDate);
      const b = v.map((E) => E instanceof Date ? E : parseISO(E)), S = u === "dateTimeRange" ? b : b[0];
      return l(S, o);
    }
  }
  _initDatePickerFromValue(o, l = !0) {
    const { monthLeft: u } = this._adapter.getStates(), c = { ...u };
    this._adapter.updateMonthOnLeft(c);
    const m = /* @__PURE__ */ new Set(), g = this._isMultiple();
    g ? o.forEach((v) => {
      v && m.add(format$3(v, strings$f.FORMAT_FULL_DATE));
    }) : o[0] && m.add(format$3(o[0], strings$f.FORMAT_FULL_DATE)), l ? g ? !(o != null && o.some((b) => b && differenceInCalendarMonths(b, u.pickerDate) === 0)) && this.handleShowDateAndTime(strings$f.PANEL_TYPE_LEFT, o[0] || c.pickerDate) : this.handleShowDateAndTime(strings$f.PANEL_TYPE_LEFT, o[0] || c.pickerDate) : this.handleShowDateAndTime(strings$f.PANEL_TYPE_LEFT, c.pickerDate), this._adapter.updateDaySelected(m);
  }
  _initDateRangePickerFromValue(o, l = !1) {
    const u = this.getState("monthLeft"), c = this.getState("monthRight"), m = this._autoAdjustMonth(
      { ...u, pickerDate: o[0] || u.pickerDate },
      { ...c, pickerDate: o[1] || c.pickerDate }
    );
    if (Array.isArray(o) && o.filter((E) => E).length > 1)
      this.handleShowDateAndTime(strings$f.PANEL_TYPE_LEFT, m.monthLeft.pickerDate), this.handleShowDateAndTime(strings$f.PANEL_TYPE_RIGHT, m.monthRight.pickerDate);
    else {
      const E = o.find((P) => P);
      if (E) {
        const P = Math.abs(differenceInCalendarMonths(E, u.pickerDate)) > 0, T = Math.abs(differenceInCalendarMonths(E, c.pickerDate)) > 0;
        P && T && (this.handleShowDateAndTime(strings$f.PANEL_TYPE_LEFT, m.monthLeft.pickerDate), this.handleShowDateAndTime(strings$f.PANEL_TYPE_RIGHT, m.monthRight.pickerDate));
      }
    }
    const v = l ? strings$f.FORMAT_DATE_TIME : strings$f.FORMAT_FULL_DATE;
    let b = o[0] && format$3(o[0], v), S = o[1] && format$3(o[1], v);
    this._isNeedSwap(b, S) && ([b, S] = [S, b]), this._adapter.setRangeStart(b), this._adapter.setRangeEnd(S), this._adapter.setHoverDay(S);
  }
  _initDateTimePickerFromValue(o) {
    this._initDatePickerFromValue(o);
  }
  _initDateTimeRangePickerFormValue(o) {
    this._initDateRangePickerFromValue(o, !0);
  }
  destroy() {
  }
  /**
   * sync change another panel month when change months from the else yam panel
   * call it when
   *  - current change panel targe date month is same with another panel date
   *
   * @example
   *  - panelType=right, target=new Date('2022-09-01') and left panel is in '2022-09' => call it, left panel minus one month to '2022-08'
   *  - panelType=left, target=new Date('2021-12-01') and right panel is in '2021-12' => call it, right panel add one month to '2021-01'
   */
  handleSyncChangeMonths(o) {
    const { panelType: l, target: u } = o, { type: c } = this._adapter.getProps(), { monthLeft: m, monthRight: g } = this._adapter.getStates();
    this.isRangeType(c) && (l === "right" && differenceInCalendarMonths(u, m.pickerDate) === 0 ? this.handleYearOrMonthChange("prevMonth", "left", 1, !0) : l === "left" && differenceInCalendarMonths(g.pickerDate, u) === 0 && this.handleYearOrMonthChange("nextMonth", "right", 1, !0));
  }
  /**
   * Get the target date based on the panel type and switch type
   */
  getTargetChangeDate(o) {
    const { panelType: l, switchType: u } = o, { monthRight: c, monthLeft: m } = this._adapter.getStates(), g = l === "left" ? m.pickerDate : c.pickerDate;
    let v;
    switch (u) {
      case "prevMonth":
        v = addMonths(g, -1);
        break;
      case "nextMonth":
        v = addMonths(g, 1);
        break;
      case "prevYear":
        v = addYears(g, -1);
        break;
      case "nextYear":
        v = addYears(g, 1);
        break;
    }
    return v;
  }
  /**
   * Change month by yam panel
   */
  toMonth(o, l) {
    const { type: u } = this._adapter.getProps(), c = this._getDiff("month", l, o);
    this.handleYearOrMonthChange(c < 0 ? "prevMonth" : "nextMonth", o, Math.abs(c), !1), this.isRangeType(u) && this.handleSyncChangeMonths({ panelType: o, target: l });
  }
  toYear(o, l) {
    const u = this._getDiff("year", l, o);
    this.handleYearOrMonthChange(u < 0 ? "prevYear" : "nextYear", o, Math.abs(u), !1);
  }
  toYearMonth(o, l) {
    this.toYear(o, l), this.toMonth(o, l);
  }
  isRangeType(o) {
    const { type: l } = this.getProps(), u = o || l;
    return typeof u == "string" && /range/i.test(u);
  }
  handleSwitchMonthOrYear(o, l) {
    const { type: u, syncSwitchMonth: c } = this.getProps(), m = this.isRangeType(u);
    if (m && c)
      this.handleYearOrMonthChange(o, "left", 1, !0), this.handleYearOrMonthChange(o, "right", 1, !0);
    else if (this.handleYearOrMonthChange(o, l), m) {
      const g = this.getTargetChangeDate({ panelType: l, switchType: o });
      this.handleSyncChangeMonths({ panelType: l, target: g });
    }
  }
  prevMonth(o) {
    this.handleSwitchMonthOrYear("prevMonth", o);
  }
  nextMonth(o) {
    this.handleSwitchMonthOrYear("nextMonth", o);
  }
  prevYear(o) {
    this.handleSwitchMonthOrYear("prevYear", o);
  }
  nextYear(o) {
    this.handleSwitchMonthOrYear("nextYear", o);
  }
  /**
   * Calculate the year and month difference
   */
  _getDiff(o, l, u) {
    const c = this._getPanelDetail(u);
    return dateDiffFns[o] && dateDiffFns[o](l, c.pickerDate);
  }
  _getPanelDetail(o) {
    return o === strings$f.PANEL_TYPE_RIGHT ? this.getState("monthRight") : this.getState("monthLeft");
  }
  /**
   * Format locale date
   * locale get from LocaleProvider
   * @param {Date} date
   * @param {String} token
   * @returns
   */
  localeFormat(o, l) {
    const u = this._adapter.getProp("dateFnsLocale");
    return format$3(o, l, { locale: u });
  }
  /**
   * 根据 type 处理 onChange 返回的参数
   *
   *  - 返回的日期需要把用户时间转换为设置的时区时间
   *      - 用户时间：用户计算机系统时间
   *      - 时区时间：通过 ConfigProvider 设置的 timeZone
   *  - 例子：用户设置时区为+9，计算机所在时区为+8区，然后用户选择了22:00
   *      - DatePicker 内部保存日期 state 为 +8 的 22:00 => a = new Date("2021-05-25 22:00:00")
   *      - 传出去时，需要把 +8 的 22:00 => +9 的 22:00 => b = zonedTimeToUtc(a, "+09:00");
   *
   * The parameters returned by onChange are processed according to type
   *
   *  -The returned date needs to convert the user time to the set time zone time
   *      -User time: user computer system time
   *      -Time zone: timeZone set by ConfigProvider
   *  -Example: The user sets the time zone to + 9, and the time zone where the computer is located is + 8, and then the user selects 22:00
   *      -DatePicker internal save date state is + 8 22:00 = > a = new Date ("2021-05-25 22:00:00")
   *      -When passing out, you need to put + 8's 22:00 = > + 9's 22:00 = > b = zonedTimeToUtc (a, "+ 09:00");
   *
   *  e.g.
   *  let a = new Date ("2021-05-25 22:00:00");
   *       = > Tue May 25 2021 22:00:00 GMT + 0800 (China Standard Time)
   *  let b = zonedTimeToUtc (a, "+ 09:00");
   *       = > Tue May 25 2021 21:00:00 GMT + 0800 (China Standard Time)
   *
   * @param {Date|Date[]} value
   */
  disposeCallbackArgs(o) {
    let l = Array.isArray(o) ? o : o && [o] || [];
    const u = this.getProp("timeZone");
    isValidTimeZone(u) && (l = l.map((b) => zonedTimeToUtc(b, u)));
    const c = this.getProp("type"), m = this.getProp("format") || getDefaultFormatTokenByType(c);
    let g, v;
    switch (c) {
      case "date":
      case "dateTime":
      case "month":
        this._isMultiple() ? (g = l.map((b) => b && this.localeFormat(b, m)), v = [...l]) : (g = l[0] && this.localeFormat(l[0], m), [v] = l);
        break;
      case "dateRange":
      case "dateTimeRange":
        g = l.map((b) => b && this.localeFormat(b, m)), v = [...l];
        break;
    }
    return {
      notifyValue: g,
      notifyDate: v
    };
  }
  handleYearOrMonthChange(o, l = strings$f.PANEL_TYPE_LEFT, u = 1, c = !1) {
    const { autoSwitchDate: m, type: g } = this.getProps(), { monthLeft: v, monthRight: b } = this.getStates(), S = this.isRangeType(g), E = S && l === strings$f.PANEL_TYPE_LEFT, P = this._getPanelDetail(l), { pickerDate: T } = P, N = dateCalcFns[o], O = N(T, u), z = l === strings$f.PANEL_TYPE_LEFT && !lodashExports.isEqual(O, v.pickerDate) || l === strings$f.PANEL_TYPE_RIGHT && !lodashExports.isEqual(O, b.pickerDate);
    if (this._updatePanelDetail(l, { pickerDate: O }), z)
      if (S) {
        if (E ? this.newBiMonthPanelDate[0] = O : this.newBiMonthPanelDate[1] = O, !(E && c)) {
          const { notifyValue: Q, notifyDate: W } = this.disposeCallbackArgs(this.newBiMonthPanelDate);
          this._adapter.notifyPanelChange(W, Q);
        }
      } else {
        const { notifyValue: Q, notifyDate: W } = this.disposeCallbackArgs(O);
        this._adapter.notifyPanelChange(W, Q);
      }
    m && this.updateDateAfterChangeYM(o, O);
  }
  /**
   * You have chosen to switch the year and month in the future to directly update the Date without closing the date panel
   * @param {*} type
   * @param {*} targetDate
   */
  updateDateAfterChangeYM(o, l) {
    const { multiple: u, disabledDate: c, type: m } = this.getProps(), { selected: g, rangeStart: v, rangeEnd: b, monthLeft: S } = this.getStates(), E = ["dateRange", "dateTimeRange"].includes(o), P = { closePanel: !1 };
    if (!u && !E && g.size) {
      const T = Array.from(g)[0], N = new Date(T), O = l.getFullYear(), z = l.getMonth();
      let Q = set$1(N, { year: O, month: z });
      if (m === "dateTime" && (Q = this._mergeDateAndTime(Q, S.pickerDate)), c(Q, { rangeStart: v, rangeEnd: b }))
        return;
      this._adapter.notifySelectedChange([Q], P);
    }
  }
  _isMultiple() {
    return !!this.getProp("multiple") && this.getProp("type") === "date";
  }
  _isRange() {
  }
  handleDayClick(o, l) {
    const u = this.getProp("type");
    switch (!0) {
      case (u === "date" || u === "dateTime"):
        this.handleDateSelected(o, l);
        break;
      case (u === "dateRange" || u === "dateTimeRange"):
        this.handleRangeSelected(o);
        break;
    }
  }
  handleDateSelected(o, l) {
    const { max: u, type: c, isControlledComponent: m, dateFnsLocale: g } = this.getProps(), v = this._isMultiple(), { selected: b } = this.getStates(), S = this._getPanelDetail(l), E = new Set(v ? [...b] : []), { fullDate: P } = o, T = S.pickerDate, N = c === "dateTime" ? this._mergeDateAndTime(P, T) : P;
    v ? E.has(N) ? E.delete(N) : u && E.size === u ? this._adapter.notifyMaxLimit() : E.add(N) : E.add(N);
    const O = this.getValidDateFormat(), z = [...E].map((Q) => compatibleParse(Q, O, void 0, g));
    this.handleShowDateAndTime(l, T), m || this._adapter.updateDaySelected(E), this._adapter.notifySelectedChange(z);
  }
  handleShowDateAndTime(o, l, u) {
    const c = u || l;
    this._updatePanelDetail(o, { showDate: c, pickerDate: l });
  }
  /**
   * link date and time
   *
   * @param {Date|string} date
   * @param {Date|string} time
   * @returns {Date}
   */
  _mergeDateAndTime(o, l) {
    const u = this._adapter.getProp("dateFnsLocale"), c = format$3(
      isValidDate(o) ? o : compatibleParse(o, strings$f.FORMAT_FULL_DATE, void 0, u),
      strings$f.FORMAT_FULL_DATE
    ), m = format$3(
      isValidDate(l) ? l : compatibleParse(l, strings$f.FORMAT_TIME_PICKER, void 0, u),
      strings$f.FORMAT_TIME_PICKER
    ), g = this.getValidTimeFormat();
    return compatibleParse(`${c} ${m}`, g, void 0, u);
  }
  handleRangeSelected(o) {
    let { rangeStart: l, rangeEnd: u } = this.getStates();
    const { startDateOffset: c, endDateOffset: m, type: g, dateFnsLocale: v, rangeInputFocus: b, triggerRender: S } = this._adapter.getProps(), { fullDate: E } = o;
    let P = !1, T = !1;
    const N = (c || m) && g === "dateRange";
    N ? (l = getFullDateOffset(c, E), u = getFullDateOffset(m, E)) : b === "rangeEnd" ? (u = E, l && u && isBefore(u, l.trim().split(/\s+/)[0]) && (l = null, P = !0)) : (b === "rangeStart" || !b) && (l = E, l && u && isBefore(u.trim().split(/\s+/)[0], l) && (u = null, T = !0)), /range/i.test(g) && (N ? (this._adapter.setRangeStart(l), this._adapter.setRangeEnd(u)) : b === "rangeEnd" ? (this._adapter.setRangeEnd(u), P && this._adapter.setRangeStart(l), (!this._adapter.isAnotherPanelHasOpened("rangeEnd") || !l) && this._adapter.setRangeInputFocus("rangeStart")) : (b === "rangeStart" || !b) && (this._adapter.setRangeStart(l), T && this._adapter.setRangeEnd(u), (!this._adapter.isAnotherPanelHasOpened("rangeStart") || !u) && this._adapter.setRangeInputFocus("rangeEnd")));
    const z = this.getValidDateFormat();
    if (l || u) {
      const [Q, W] = [
        compatibleParse(l, z, void 0, v),
        compatibleParse(u, z, void 0, v)
      ];
      let ue = [Q, W];
      if (g === "dateTimeRange") {
        const K = this.getState("monthLeft").pickerDate, ve = this.getState("monthRight").pickerDate, ee = l ? this._mergeDateAndTime(l, K) : null, Re = u ? this._mergeDateAndTime(u, ve) : null;
        isSameDay$1(Q, W) && isBefore(Re, ee) ? ue = [ee, ee] : ue = [ee, Re];
      }
      const te = !(g === "dateRange" && N);
      this._adapter.notifySelectedChange(ue, { needCheckFocusRecord: te });
    }
  }
  _isNeedSwap(o, l) {
    return o && l && isBefore(l, o);
  }
  /**
   * Day may be empty, this is unhover state
   * @param {*} day
   */
  handleDayHover(o = { fullDate: "" }, l) {
    const { fullDate: u } = o, { startDateOffset: c, endDateOffset: m, type: g } = this.getProps();
    if (this._adapter.setHoverDay(u), (c || m) && g === "dateRange") {
      const v = getFullDateOffset(c, u), b = getFullDateOffset(m, u);
      this._adapter.setOffsetRangeStart(v), this._adapter.setOffsetRangeEnd(b);
    }
  }
  // Guarantee that monthLeft, monthRight will not appear in the same month or monthLeft is greater than MonthRight
  _autoAdjustMonth(o, l) {
    let u = o, c = l;
    const m = differenceInCalendarMonths(o.pickerDate, l.pickerDate);
    return m > 0 ? (u = { ...l }, c = { ...o }) : m === 0 && (u = o, c = { ...l, pickerDate: addMonths(l.pickerDate, 1) }), { monthLeft: u, monthRight: c };
  }
  getValidTimeFormat() {
    const o = this.getProp("format") || strings$f.FORMAT_TIME_PICKER, l = [];
    return (lodashExports.includes(o, "h") || lodashExports.includes(o, "H")) && l.push("HH"), lodashExports.includes(o, "m") && l.push("mm"), lodashExports.includes(o, "s") && l.push("ss"), l.join(":");
  }
  getValidDateFormat() {
    return this.getProp("format") || getDefaultFormatToken(this.getProp("type"));
  }
  handleTimeChange(o, l) {
    const { rangeEnd: u, rangeStart: c } = this.getStates(), m = this.getProp("dateFnsLocale"), g = o.timeStampValue, v = this.getProp("type"), b = this._getPanelDetail(l), { showDate: S } = b, E = new Date(g), P = this.getValidDateFormat(), T = l === strings$f.PANEL_TYPE_RIGHT ? u : c;
    let N, O, z;
    if (v === "dateTimeRange" && T) {
      const ee = compatibleParse(T, P, void 0, m);
      N = ee.getFullYear(), O = ee.getMonth(), z = ee.getDate();
    } else
      N = S.getFullYear(), O = S.getMonth(), z = S.getDate();
    const Q = E.getHours(), W = E.getMinutes(), ue = E.getSeconds(), te = E.getMilliseconds(), K = [N, O, z, Q, W, ue, te], ve = new Date(...K);
    if (v === "dateTimeRange")
      this.handleShowDateAndTime(l, ve, S), this._updateTimeInDateRange(l, ve);
    else {
      const ee = formatFullDate(N, O + 1, z);
      this.handleDateSelected(
        {
          fullDate: ee,
          fullValidDate: ve
        },
        l
      ), this.handleShowDateAndTime(l, ve), this._adapter.notifySelectedChange([ve]);
    }
  }
  /**
   * Update the time part in the range
   * @param {string} panelType
   * @param {Date} timeDate
   */
  _updateTimeInDateRange(o, l) {
    const { isControlledComponent: u, dateFnsLocale: c } = this.getProps();
    let m = this.getState("rangeStart"), g = this.getState("rangeEnd");
    const v = this.getValidDateFormat();
    if (m && g) {
      let b = compatibleParse(m, v, void 0, c), S = compatibleParse(g, v, void 0, c);
      o === strings$f.PANEL_TYPE_RIGHT ? (S = this._mergeDateAndTime(l, l), g = format$3(S, strings$f.FORMAT_DATE_TIME), this._isNeedSwap(m, g) && ([m, g] = [g, m], [b, S] = [S, b]), u || this._adapter.setRangeEnd(g)) : (b = this._mergeDateAndTime(l, l), m = format$3(b, strings$f.FORMAT_DATE_TIME), this._isNeedSwap(m, g) && ([m, g] = [g, m], [b, S] = [S, b]), u || this._adapter.setRangeStart(m)), this._adapter.notifySelectedChange([b, S]);
    }
  }
  _updatePanelDetail(o, l) {
    const { monthLeft: u, monthRight: c } = this.getStates();
    o === strings$f.PANEL_TYPE_RIGHT ? this._adapter.updateMonthOnRight({ ...c, ...l }) : this._adapter.updateMonthOnLeft({ ...u, ...l });
  }
  showYearPicker(o) {
    this._updatePanelDetail(o, { isTimePickerOpen: !1, isYearPickerOpen: !0 });
  }
  showTimePicker(o, l) {
    this.getProp("disabledTimePicker") || this._updatePanelDetail(o, { isTimePickerOpen: !0, isYearPickerOpen: !1 });
  }
  showDatePanel(o) {
    this._updatePanelDetail(o, { isTimePickerOpen: !1, isYearPickerOpen: !1 });
  }
  /**
   * Get year and month panel open type
   *
   * It is useful info to set minHeight of weeks.
   *  - When yam open type is 'left' or 'right', weeks minHeight should be set
   *    If the minHeight is not set, the change of the number of weeks will cause the scrollList to be unstable
   */
  getYAMOpenType() {
    const { monthLeft: o, monthRight: l } = this._adapter.getStates(), u = o.isYearPickerOpen, c = l.isYearPickerOpen;
    return u && c ? "both" : u ? "left" : c ? "right" : "none";
  }
}
const prefixCls$F = cssClasses$I.NAVIGATION, vuePropsType$2o = {
  monthText: {
    type: string$3,
    default: ""
  },
  density: string$3,
  onMonthClick: {
    type: func,
    default: lodashExports.noop
  },
  onNextMonth: {
    type: func,
    default: lodashExports.noop
  },
  onPrevMonth: {
    type: func,
    default: lodashExports.noop
  },
  onNextYear: {
    type: func,
    default: lodashExports.noop
  },
  onPrevYear: {
    type: func,
    default: lodashExports.noop
  },
  navPrev: node$1,
  navNext: node$1,
  // Whether to switch synchronously for two panels
  shouldBimonthSwitch: bool,
  // Panel type, divided into left panel and right panel
  panelType: string$3,
  forwardRef: [object$1, func]
}, navigation = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2o
  },
  name: "DatePickerNavigation",
  setup(s, {
    slots: o
  }) {
    const l = ref$1();
    return () => {
      const {
        forwardRef: u,
        monthText: c,
        onMonthClick: m,
        onNextMonth: g,
        onPrevMonth: v,
        onPrevYear: b,
        onNextYear: S,
        density: E,
        shouldBimonthSwitch: P,
        panelType: T
      } = s, N = "borderless", O = E === "compact" ? "default" : "large", z = !0, Q = E === "compact" ? "small" : "default", W = T === strings$f.PANEL_TYPE_LEFT, ue = T === strings$f.PANEL_TYPE_RIGHT, te = P && W, K = P && ue, ve = {}, ee = {};
      return K && (ve.visibility = "hidden"), te && (ee.visibility = "hidden"), createVNode("div", {
        class: prefixCls$F,
        ref: u || l
      }, [createVNode(Button$3, {
        key: "double-chevron-left",
        "aria-label": "Previous year",
        icon: createVNode(IconComponent$s, {
          "aria-hidden": !0,
          size: O
        }, null),
        size: Q,
        theme: N,
        noHorizontalPadding: z,
        onClick: b,
        style: ve
      }, null), createVNode(Button$3, {
        key: "chevron-left",
        "aria-label": "Previous month",
        icon: createVNode(IconComponent$z, {
          "aria-hidden": !0,
          size: O
        }, null),
        size: Q,
        onClick: v,
        theme: N,
        noHorizontalPadding: z,
        style: ve
      }, null), createVNode("div", {
        class: `${prefixCls$F}-month`
      }, [createVNode(Button$2, {
        onClick: m,
        theme: N,
        size: Q
      }, {
        default: () => [createVNode("span", null, [c])]
      })]), createVNode(Button$3, {
        key: "chevron-right",
        "aria-label": "Next month",
        icon: createVNode(IconComponent$y, {
          "aria-hidden": !0,
          size: O
        }, null),
        size: Q,
        onClick: g,
        theme: N,
        noHorizontalPadding: z,
        style: ee
      }, null), createVNode(Button$3, {
        key: "double-chevron-right",
        "aria-label": "Next year",
        icon: createVNode(IconComponent$r, {
          "aria-hidden": !0,
          size: O
        }, null),
        size: Q,
        theme: N,
        noHorizontalPadding: z,
        onClick: S,
        style: ee
      }, null)]);
    };
  }
}), getDayofWeek = ({ weekStartsOn: s = 0 }) => {
  const o = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
  for (let l = 0; l < s; l++)
    o.push(o.shift());
  return o;
};
class CalendarMonthFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    this._getToday(), this.getMonthTable();
  }
  _getToday() {
    const l = format$3(/* @__PURE__ */ new Date(), "yyyy-MM-dd");
    this._adapter.updateToday(l);
  }
  getMonthTable() {
    const o = this._adapter.getProp("month"), l = this.getState("weeksRowNum");
    if (o) {
      this.updateWeekDays();
      const u = this._adapter.getProp("weekStartsOn"), c = getMonthTable(o, u), { weeks: m } = c;
      this._adapter.updateMonthTable(c), isNullOrUndefined(l) ? this._adapter.setWeeksRowNum(m.length) : Array.isArray(m) && m.length !== l && this._adapter.setWeeksRowNum(m.length, () => {
        this._adapter.notifyWeeksRowNumChange(m.length);
      });
    }
  }
  updateWeekDays() {
    const o = this._adapter.getProp("weekStartsOn"), l = getDayofWeek({ weekStartsOn: o });
    this._adapter.setWeekDays(l);
  }
  destroy() {
  }
  handleClick(o) {
    this._adapter.notifyDayClick(o);
  }
  handleHover(o) {
    this._adapter.notifyDayHover(o);
  }
}
const prefixCls$E = cssClasses$I.PREFIX, propTypes$1t = {
  forwardRef: void 0,
  localeCode: void 0,
  month: {
    type: object$1,
    default: /* @__PURE__ */ new Date(),
    required: !0
  },
  selected: {
    type: object$1,
    default: /* @__PURE__ */ new Set(),
    required: !0
  },
  rangeStart: {
    type: string$3,
    default: "",
    required: !0
  },
  rangeEnd: {
    type: string$3,
    default: "",
    required: !0
  },
  offsetRangeStart: {
    type: string$3,
    required: !0
  },
  offsetRangeEnd: {
    type: string$3,
    required: !0
  },
  onDayClick: {
    type: func,
    default: lodashExports.noop,
    required: !0
  },
  onDayHover: {
    type: func,
    default: lodashExports.noop,
    required: !0
  },
  weekStartsOn: {
    type: number$2,
    default: numbers$d.WEEK_START_ON,
    required: !0
  },
  disabledDate: {
    type: func,
    default: lodashExports.stubFalse,
    required: !0
  },
  weeksRowNum: {
    type: number$2,
    default: 0,
    required: !0
  },
  onWeeksRowNumChange: {
    type: func,
    default: lodashExports.noop,
    required: !0
  },
  renderDate: {
    type: func,
    required: !0
  },
  renderFullDate: {
    type: func,
    required: !0
  },
  // Real-time hover date
  hoverDay: {
    type: string$3,
    required: !0
  },
  startDateOffset: {
    type: func,
    required: !0
  },
  endDateOffset: {
    type: func,
    required: !0
  },
  rangeInputFocus: {
    type: [string$3, bool],
    required: !0
  },
  focusRecordsRef: {
    type: object$1,
    required: !0
  },
  multiple: {
    type: bool,
    required: !0
  },
  locale: {
    type: Object,
    required: !0
  },
  style: object$1,
  className: string$3
}, defaultProps$1n = {
  month: /* @__PURE__ */ new Date(),
  selected: /* @__PURE__ */ new Set(),
  rangeStart: "",
  rangeEnd: "",
  onDayClick: lodashExports.noop,
  onDayHover: lodashExports.noop,
  onWeeksRowNumChange: lodashExports.noop,
  weekStartsOn: numbers$d.WEEK_START_ON,
  disabledDate: lodashExports.stubFalse,
  weeksRowNum: 0
}, vuePropsType$2n = vuePropsMake(propTypes$1t, defaultProps$1n), month = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2n
  },
  name: "Month",
  setup(s, {
    slots: o
  }) {
    const l = ref$1(), u = reactive({
      weekdays: [],
      month: {
        weeks: [],
        monthText: ""
      },
      todayText: "",
      weeksRowNum: s.weeksRowNum
    }), {
      adapter: c
    } = useBaseComponent(s, u);
    let m;
    function g() {
      return {
        ...c(),
        updateToday: (z) => u.todayText = z,
        setWeekDays: (z) => u.weekdays = z,
        setWeeksRowNum: (z, Q) => {
          u.weeksRowNum = z, nextTick(() => {
            Q();
          });
        },
        updateMonthTable: (z) => u.month = z,
        notifyDayClick: (z) => s.onDayClick(z),
        notifyDayHover: (z) => s.onDayHover(z),
        notifyWeeksRowNumChange: (z) => s.onWeeksRowNumChange(z)
      };
    }
    m = new CalendarMonthFoundation(g()), onMounted(() => {
      m.init();
    }), onUnmounted(() => {
      m.destroy();
    }), watch(() => s.month, () => {
      m.getMonthTable();
    }, {
      immediate: !0
    });
    function v(z) {
      const {
        rangeInputFocus: Q
      } = s, {
        fullDate: W,
        todayText: ue,
        selected: te,
        disabledDate: K,
        rangeStart: ve,
        rangeEnd: ee
      } = z, Re = {
        rangeStart: ve,
        rangeEnd: ee,
        rangeInputFocus: Q
      }, wt = W === ue, yt = te.has(W);
      let xt = K && K(parseISO(W), Re);
      return !xt && s.rangeInputFocus === "rangeStart" && ee && s.focusRecordsRef && s.focusRecordsRef.value.rangeEnd && (xt = isAfter(W, ee.trim().split(/\s+/)[0])), !xt && s.rangeInputFocus === "rangeEnd" && ve && s.focusRecordsRef && s.focusRecordsRef.value.rangeStart && (xt = isBefore(W, ve.trim().split(/\s+/)[0])), {
        isToday: wt,
        // Today
        isSelected: yt,
        // Selected
        isDisabled: xt
        // Disabled
      };
    }
    function b(z) {
      const {
        rangeStart: Q,
        rangeEnd: W,
        fullDate: ue,
        hoverDay: te,
        offsetRangeStart: K,
        offsetRangeEnd: ve,
        rangeInputFocus: ee
      } = z, Re = !!(Q || W), wt = !!(Q && W), yt = K || ve;
      if (!Re)
        return {};
      const xt = isSameDay(te, ue);
      let Kt, tn, ln, rn, an;
      Q && (ln = isSameDay(ue, Q), ee === "rangeEnd" && (Kt = isBetween(ue, {
        start: Q,
        end: te
      }))), W && (rn = isSameDay(ue, W), ee === "rangeStart" && (tn = isBetween(ue, {
        start: te,
        end: W
      }))), !wt && Re && (an = xt);
      let Gt;
      yt || (Gt = Kt || tn || xt);
      let nn, vt, Et, Qt, un, gn;
      return wt && (nn = isBetween(ue, {
        start: Q,
        end: W
      }), yt || (vt = ln && isAfter(Q, te), Et = rn && isBefore(W, te), Qt = xt && ee === "rangeStart", un = xt && ee === "rangeEnd", gn = xt && isBetween(te, {
        start: Q,
        end: W
      }))), {
        isHoverDay: xt,
        // Is the current hover date
        isSelectedStart: ln,
        // Select Start
        isSelectedEnd: rn,
        // End of selection
        isInRange: nn,
        // Range within the selected date
        isHover: Gt,
        // Date between selection and hover date
        isSelectedStartAfterHover: vt,
        // Choose to start behind the hover
        isSelectedEndBeforeHover: Et,
        // Choose to end in front of the hover
        isHoverDayInRange: gn,
        // Hover date within range
        isHoverDayInStartSelection: Qt,
        // Hover date when starting Date is selected
        isHoverDayInEndSelection: un,
        // Hover date when endDate is selected
        isHoverDayAroundOneSelected: an
        // Hover date and select a date
      };
    }
    function S(z) {
      const {
        offsetRangeStart: Q,
        offsetRangeEnd: W,
        rangeStart: ue,
        rangeEnd: te,
        fullDate: K,
        hoverDay: ve
      } = z;
      if (!(Q || W))
        return {};
      const Re = isBetween(K, {
        start: ue,
        end: te
      }), wt = isSameDay(ve, K), yt = ue && isSameDay(K, ue), xt = te && isSameDay(K, te), Kt = !!(ue && te), tn = isSameDay(K, Q), ln = isSameDay(K, W), rn = wt;
      let an, Gt;
      return Kt && (an = Re && wt), !!(Q && W) && (Gt = yt || isBetween(K, {
        start: Q,
        end: W
      }) || xt), {
        isOffsetRangeStart: tn,
        // Week selection start
        isOffsetRangeEnd: ln,
        // End of week selection
        isHoverInOffsetRange: an,
        // Hover in the week selection
        isHoverDayOffset: rn,
        // Week selection hover day
        isInOffsetRange: Gt
        // Include start and end within the week selection (start and end styles are the same as other dates, so start and end are included)
      };
    }
    function E(z, Q) {
      const {
        fullDate: W
      } = z, {
        hoverDay: ue,
        rangeStart: te,
        rangeEnd: K,
        todayText: ve,
        offsetRangeStart: ee,
        offsetRangeEnd: Re,
        disabledDate: wt,
        selected: yt,
        rangeInputFocus: xt
      } = Q, Kt = v({
        fullDate: W,
        todayText: ve,
        hoverDay: ue,
        selected: yt,
        disabledDate: wt,
        rangeStart: te,
        rangeEnd: K
      }), tn = b({
        fullDate: W,
        rangeStart: te,
        rangeEnd: K,
        hoverDay: ue,
        offsetRangeStart: ee,
        offsetRangeEnd: Re,
        rangeInputFocus: xt,
        ...Kt
      }), ln = S({
        offsetRangeStart: ee,
        offsetRangeEnd: Re,
        rangeStart: te,
        rangeEnd: K,
        fullDate: W,
        hoverDay: ue,
        ...Kt,
        ...tn
      });
      return {
        ...Kt,
        ...tn,
        ...ln
      };
    }
    function P() {
      const {
        locale: z
      } = s, Q = cls(cssClasses$I.WEEKDAY), W = cls(`${prefixCls$E}-weekday-item`), {
        weekdays: ue
      } = u, te = ue.map((K) => z.weeks[K]);
      return createVNode("div", {
        role: "row",
        class: Q
      }, [te.map((K, ve) => createVNode("div", {
        role: "columnheader",
        key: K + ve,
        class: W
      }, [K]))]);
    }
    function T() {
      const {
        month: z
      } = u, {
        weeks: Q
      } = z, {
        weeksRowNum: W
      } = s;
      let ue = {};
      W && (ue = {
        height: W * numbers$d.WEEK_HEIGHT
      });
      const te = cls(cssClasses$I.WEEKS);
      return createVNode("div", {
        class: te,
        style: ue
      }, [Q.map((K, ve) => N(K, ve))]);
    }
    function N(z, Q) {
      const W = cssClasses$I.WEEK;
      return createVNode("div", {
        role: "row",
        class: W,
        key: Q
      }, [z.map((ue, te) => O(ue, te))]);
    }
    function O(z, Q) {
      const {
        todayText: W
      } = u, {
        renderFullDate: ue,
        renderDate: te
      } = s, {
        fullDate: K,
        dayNumber: ve
      } = z;
      if (!K)
        return createVNode("div", {
          role: "gridcell",
          tabindex: -1,
          key: ve + Q,
          class: cssClasses$I.DAY
        }, [createVNode("span", null, null)]);
      const ee = E(z, {
        todayText: W,
        ...s
      }), Re = cls(cssClasses$I.DAY, {
        [cssClasses$I.DAY_TODAY]: ee.isToday,
        [cssClasses$I.DAY_IN_RANGE]: ee.isInRange,
        [cssClasses$I.DAY_HOVER]: ee.isHover,
        [cssClasses$I.DAY_SELECTED]: ee.isSelected,
        [cssClasses$I.DAY_SELECTED_START]: ee.isSelectedStart,
        [cssClasses$I.DAY_SELECTED_END]: ee.isSelectedEnd,
        [cssClasses$I.DAY_DISABLED]: ee.isDisabled,
        // offsetDate class
        [cssClasses$I.DAY_HOVER_DAY]: ee.isHoverDayOffset,
        [cssClasses$I.DAY_IN_OFFSET_RANGE]: ee.isInOffsetRange,
        [cssClasses$I.DAY_SELECTED_RANGE_HOVER]: ee.isHoverInOffsetRange,
        [cssClasses$I.DAY_OFFSET_RANGE_START]: ee.isOffsetRangeStart,
        [cssClasses$I.DAY_OFFSET_RANGE_END]: ee.isOffsetRangeEnd,
        // range input class
        [cssClasses$I.DAY_SELECTED_START_AFTER_HOVER]: ee.isSelectedStartAfterHover,
        [cssClasses$I.DAY_SELECTED_END_BEFORE_HOVER]: ee.isSelectedEndBeforeHover,
        [cssClasses$I.DAY_HOVER_DAY_BEFORE_RANGE]: ee.isHoverDayInStartSelection,
        [cssClasses$I.DAY_HOVER_DAY_AFTER_RANGE]: ee.isHoverDayInEndSelection,
        [cssClasses$I.DAY_HOVER_DAY_AROUND_SINGLE_SELECTED]: ee.isHoverDayAroundOneSelected
      }), wt = cls({
        [`${cssClasses$I.DAY}-main`]: !0
      }), yt = [ve, K, ee], xt = lodashExports.isFunction(ue);
      return createVNode("div", {
        role: "gridcell",
        tabindex: ee.isDisabled ? -1 : 0,
        "aria-disabled": ee.isDisabled,
        "aria-selected": ee.isSelected,
        "aria-label": K,
        class: xt ? cssClasses$I.DAY : Re,
        title: K,
        key: ve + Q,
        onClick: (Kt) => !ee.isDisabled && m.handleClick(z),
        onMouseenter: () => m.handleHover(z),
        onMouseleave: () => m.handleHover()
      }, [xt ? (
        // @ts-ignore
        ue(...yt)
      ) : createVNode("div", {
        class: wt
      }, [lodashExports.isFunction(te) ? te(ve, K) : createVNode("span", null, [ve])])]);
    }
    return () => {
      const {
        forwardRef: z,
        multiple: Q
      } = s, W = P(), ue = T(), te = cls(cssClasses$I.MONTH);
      return createVNode("div", {
        role: "grid",
        "aria-multiselectable": Q,
        ref: z || l,
        class: te
      }, [W, ue]);
    };
  }
}), TYPE_TIME_PICKER = "time", TYPE_TIME_RANGE_PICKER = "timeRange", DEFAULT_RANGE_SEPARATOR = " ~ ", DEFAULT_MULTIPLE_SEPARATOR = ",", cssClasses$H = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-timepicker`,
  RANGE_PICKER: `${BASE_CLASS_PREFIX$1}-timepicker-range-panel`,
  RANGE_PANEL_LISTS: `${BASE_CLASS_PREFIX$1}-timepicker-lists`
}, strings$e = {
  TYPES: [TYPE_TIME_PICKER, TYPE_TIME_RANGE_PICKER],
  TYPE_TIME_PICKER,
  TYPE_TIME_RANGE_PICKER,
  DEFAULT_TYPE: TYPE_TIME_PICKER,
  DEFAULT_RANGE_SEPARATOR,
  DEFAULT_MULTIPLE_SEPARATOR,
  SIZE: strings$l.SIZE,
  DEFAULT_FORMAT: "HH:mm:ss",
  DEFAULT_FORMAT_A: "a h:mm:ss",
  STATUS: VALIDATE_STATUS,
  DEFAULT_POSITION: {
    [TYPE_TIME_PICKER]: "bottomLeft",
    [TYPE_TIME_RANGE_PICKER]: "bottomLeft"
  }
}, cssClasses$G = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-scrolllist`,
  SELECTED: `${BASE_CLASS_PREFIX$1}-scrolllist-item-selected`
}, numbers$c = {
  DEFAULT_ITEM_HEIGHT: 36,
  DEFAULT_SCROLL_DURATION: 120
};
class ScrollListFoundation extends BaseFoundation$1 {
}
const vuePropsType$2m = {
  header: [Object, String],
  footer: [Object, String],
  children: [Object, String],
  bodyHeight: [Number, String],
  prefixCls: [String],
  className: String,
  style: Object
}, index$a = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2m
  },
  name: "ScrollList",
  setup(s, {}) {
    const o = useSlots(), {
      adapter: l,
      getDataAttr: u
    } = useBaseComponent(s, {});
    return new ScrollListFoundation(l()), () => {
      var N;
      const {
        header: c,
        footer: m,
        prefixCls: g,
        bodyHeight: v,
        className: b,
        style: S,
        ...E
      } = s, P = cls(b, {
        [g || cssClasses$G.PREFIX]: !0
      }), T = cls({
        [`${g || cssClasses$G.PREFIX}-header`]: !0
      });
      return createVNode("div", mergeProps$1({
        class: P,
        style: S
      }, u()), [c ? createVNode("div", {
        class: T
      }, [createVNode("div", {
        class: `${T}-title`
      }, [c]), createVNode("div", {
        class: `${P}-line`
      }, null)]) : null, createVNode("div", {
        class: `${P}-body`,
        style: {
          height: v || ""
        }
      }, [(N = o.default) == null ? void 0 : N.call(o)]), m ? createVNode("div", {
        class: `${P}-footer`
      }, [m]) : null]);
    };
  }
}), ScrollList = index$a;
let ItemFoundation$1 = class extends BaseFoundation$1 {
  constructor() {
    super(...arguments), this._cachedSelectedNode = null;
  }
  selectIndex(o, l) {
    const { type: u, list: c } = this.getProps();
    if (o > -1 && Array.isArray(c) && c.length && isElement$1(l)) {
      const m = o % c.length, g = c[m], v = l.children[o];
      this._adapter.setSelectedNode(v), this._adapter.notifySelectItem({
        ...g,
        value: g.value,
        type: u,
        index: m
      });
    }
  }
  selectNode(o, l) {
    const { type: u, list: c } = this.getProps();
    if (isElement$1(o) && isElement$1(l)) {
      const g = lodashExports.findIndex(l.children, (E) => E === o) % c.length, b = lodashExports.findIndex(l.children, (E) => E === this._cachedSelectedNode) % c.length, S = c[g];
      this._adapter.setSelectedNode(o), this._adapter.scrollToCenter(o), this._cachedSelectedNode !== o && (this._cachedSelectedNode = o, b !== g && this._adapter.notifySelectItem({
        ...S,
        value: S.value,
        type: u,
        index: g
      }));
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} scrollWrapper
   * @param {number} ratio
   * @returns {boolean}
   */
  shouldAppend(o, l, u = 2) {
    const c = "li";
    if (isElement$1(o) && isElement$1(l)) {
      const m = o.querySelectorAll(c), g = m[m.length - 1], { list: v } = this.getProps();
      if (g) {
        const b = l.getBoundingClientRect(), S = g.getBoundingClientRect(), E = S.height * v.length;
        let P = S.top, T = 0;
        for (; P <= b.top + b.height * u; )
          T += 1, P += E;
        return T;
      }
    }
    return !1;
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} scrollWrapper
   * @param {number} ratio
   *
   * @returns {boolean}
   */
  shouldPrepend(o, l, u = 2) {
    const c = "li";
    if (isElement$1(o) && isElement$1(l)) {
      const g = o.querySelectorAll(c)[0], { list: v } = this.getProps();
      if (g) {
        const b = l.getBoundingClientRect(), S = g.getBoundingClientRect(), E = S.height * v.length;
        let P = S.top, T = 0;
        for (; P + S.height >= b.top - b.height * u; )
          T += 1, P -= E;
        return T;
      }
    }
    return 0;
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} wrapper
   * @param {Function} [callback]
   */
  initWheelList(o, l, u) {
    const { list: c } = this.getProps();
    if (isElement$1(l) && isElement$1(o) && c && c.length) {
      const m = o.children;
      lodashExports.slice(m, 0, c.length);
      const g = this.shouldPrepend(o, l), v = this.shouldAppend(o, l);
      this._adapter.setState(
        {
          prependCount: g,
          appendCount: v
        },
        u
      );
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} wrapper
   * @param {HTMLElement} [nearestNode]
   */
  adjustInfiniteList(o, l, u) {
    const { list: c } = this.getProps(), m = "li";
    if (isElement$1(l) && isElement$1(o) && c && c.length) {
      const g = o.querySelectorAll(m), v = g.length, b = 1, S = this.shouldPrepend(o, l, b), E = this.shouldAppend(o, l, b);
      if (S)
        for (let P = 0; P < S; P++) {
          const T = lodashExports.slice(g, v - c.length * (P + 1), v - c.length * P);
          prepend(o, ...T);
        }
      if (E)
        for (let P = 0; P < E; P++) {
          const T = lodashExports.slice(g, P * c.length, (P + 1) * c.length);
          append(o, ...T);
        }
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   * @param {HTMLElement} selector
   *
   */
  getNearestNodeInfo(o, l) {
    if (isElement$1(o) && isElement$1(l)) {
      const c = l.getBoundingClientRect().top, m = o.querySelectorAll("li");
      let g = null, v = -1, b = 1 / 0;
      return Array.from(m).map((S, E) => {
        const T = S.getBoundingClientRect().top, N = Math.abs(T - c);
        N < b && !this._adapter.isDisabledIndex(E) && (b = N, g = S, v = E);
      }), { nearestNode: g, nearestIndex: v };
    }
  }
  /**
   *
   * @param {HTMLElement} listWrapper
   *
   * @param {HTMLElement|null}
   */
  getTargetNode(o, l) {
    if (o && isElement$1(l)) {
      const u = "li", c = o.target, m = l.querySelectorAll(u), g = this.getProp("list"), v = Array.isArray(g) ? g.length : 0;
      let b = -1, S = -1, E = null;
      const P = lodashExports.find(m, (T, N) => {
        if (T === c || T.contains(c))
          return b = N, v > 0 && (S = N % v), !0;
      });
      return S > -1 && (E = g[S]), {
        targetNode: P,
        targetIndex: b,
        indexInList: S,
        infoInList: E
      };
    }
    return null;
  }
};
var NEWTON_ITERATIONS = 4, NEWTON_MIN_SLOPE = 1e-3, SUBDIVISION_PRECISION = 1e-7, SUBDIVISION_MAX_ITERATIONS = 10, kSplineTableSize = 11, kSampleStepSize = 1 / (kSplineTableSize - 1), float32ArraySupported = typeof Float32Array == "function";
function A$1(s, o) {
  return 1 - 3 * o + 3 * s;
}
function B$1(s, o) {
  return 3 * o - 6 * s;
}
function C$1(s) {
  return 3 * s;
}
function calcBezier(s, o, l) {
  return ((A$1(o, l) * s + B$1(o, l)) * s + C$1(o)) * s;
}
function getSlope(s, o, l) {
  return 3 * A$1(o, l) * s * s + 2 * B$1(o, l) * s + C$1(o);
}
function binarySubdivide(s, o, l, u, c) {
  var m, g, v = 0;
  do
    g = o + (l - o) / 2, m = calcBezier(g, u, c) - s, m > 0 ? l = g : o = g;
  while (Math.abs(m) > SUBDIVISION_PRECISION && ++v < SUBDIVISION_MAX_ITERATIONS);
  return g;
}
function newtonRaphsonIterate(s, o, l, u) {
  for (var c = 0; c < NEWTON_ITERATIONS; ++c) {
    var m = getSlope(o, l, u);
    if (m === 0)
      return o;
    var g = calcBezier(o, l, u) - s;
    o -= g / m;
  }
  return o;
}
function LinearEasing(s) {
  return s;
}
var src = function(o, l, u, c) {
  if (!(0 <= o && o <= 1 && 0 <= u && u <= 1))
    throw new Error("bezier x values must be in [0, 1] range");
  if (o === l && u === c)
    return LinearEasing;
  for (var m = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize), g = 0; g < kSplineTableSize; ++g)
    m[g] = calcBezier(g * kSampleStepSize, o, u);
  function v(b) {
    for (var S = 0, E = 1, P = kSplineTableSize - 1; E !== P && m[E] <= b; ++E)
      S += kSampleStepSize;
    --E;
    var T = (b - m[E]) / (m[E + 1] - m[E]), N = S + T * kSampleStepSize, O = getSlope(N, o, u);
    return O >= NEWTON_MIN_SLOPE ? newtonRaphsonIterate(b, N, o, u) : O === 0 ? N : binarySubdivide(b, S, S + kSampleStepSize, o, u);
  }
  return function(S) {
    return S === 0 ? 0 : S === 1 ? 1 : calcBezier(v(S), l, c);
  };
};
const bezier = /* @__PURE__ */ getDefaultExportFromCjs(src);
function minMax(s, o, l) {
  return Math.min(Math.max(s, o), l);
}
function parseEasingParameters(s) {
  const o = /\(([^)]+)\)/.exec(s);
  return o ? o[1].split(",").map((l) => parseFloat(l)) : [];
}
function elastic() {
  let s = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1, o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0.5;
  const l = minMax(s, 1, 10), u = minMax(o, 0.1, 2);
  return (c) => c === 0 || c === 1 ? c : -l * Math.pow(2, 10 * (c - 1)) * Math.sin((c - 1 - u / (Math.PI * 2) * Math.asin(1 / l)) * (Math.PI * 2) / u);
}
const easingMap = (() => {
  const s = ["Quad", "Cubic", "Quart", "Quint", "Sine", "Expo", "Circ", "Back", "Elastic"], o = {
    In: [
      [0.55, 0.085, 0.68, 0.53],
      [0.55, 0.055, 0.675, 0.19],
      [0.895, 0.03, 0.685, 0.22],
      [0.755, 0.05, 0.855, 0.06],
      [0.47, 0, 0.745, 0.715],
      [0.95, 0.05, 0.795, 0.035],
      [0.6, 0.04, 0.98, 0.335],
      [0.6, -0.28, 0.735, 0.045],
      elastic
      /* inElastic */
    ],
    Out: [
      [0.25, 0.46, 0.45, 0.94],
      [0.215, 0.61, 0.355, 1],
      [0.165, 0.84, 0.44, 1],
      [0.23, 1, 0.32, 1],
      [0.39, 0.575, 0.565, 1],
      [0.19, 1, 0.22, 1],
      [0.075, 0.82, 0.165, 1],
      [0.175, 0.885, 0.32, 1.275],
      (u, c) => (m) => 1 - elastic(u, c)(1 - m)
      /* outElastic */
    ],
    InOut: [
      [0.455, 0.03, 0.515, 0.955],
      [0.645, 0.045, 0.355, 1],
      [0.77, 0, 0.175, 1],
      [0.86, 0, 0.07, 1],
      [0.445, 0.05, 0.55, 0.95],
      [1, 0, 0, 1],
      [0.785, 0.135, 0.15, 0.86],
      [0.68, -0.55, 0.265, 1.55],
      (u, c) => (m) => m < 0.5 ? elastic(u, c)(m * 2) / 2 : 1 - elastic(u, c)(m * -2 + 2) / 2
      /* inOutElastic */
    ]
  }, l = {
    linear: [0.25, 0.25, 0.75, 0.75]
  };
  for (const u of Object.keys(o))
    o[u].forEach((c, m) => {
      l["ease" + u + s[m]] = c;
    });
  return l;
})();
function getEasing(s) {
  if (typeof s == "function")
    return s;
  !s || typeof s != "string" ? s = "linear" : s = s.trim();
  let o = s.split("(")[0];
  const l = parseEasingParameters(s);
  let u;
  return o === "cubic-bezier" || o === "cubicBezier" ? bezier(...l.length ? l : easingMap.linear) : ((!o || typeof o != "string" || typeof o == "string" && easingMap[o] == null) && (o = "linear"), u = easingMap[o], typeof u == "function" ? u(...l) : l.length ? bezier(...l) : bezier(...u));
}
const events = ["start", "frame", "pause", "resume", "stop", "rest"];
class Event {
  constructor() {
    this._eventMap = /* @__PURE__ */ new Map();
  }
  on(o, l) {
    return o && typeof l == "function" && (this._eventMap.has(o) || this._eventMap.set(o, []), this._eventMap.get(o).push(l)), this;
  }
  once(o, l) {
    var u = this;
    if (o && typeof l == "function") {
      const c = function() {
        l(...arguments), u.off(o, c);
      };
      this.on(o, c);
    }
  }
  off(o, l) {
    if (o)
      if (typeof l == "function") {
        const u = this._eventMap.get(o);
        if (Array.isArray(u) && u.length) {
          let c = -1;
          for (; (c = u.findIndex((m) => m === l)) > -1; )
            u.splice(c, 1);
        }
      } else l == null && this._eventMap.delete(o);
    return this;
  }
  emit(o) {
    for (var l = arguments.length, u = new Array(l > 1 ? l - 1 : 0), c = 1; c < l; c++)
      u[c - 1] = arguments[c];
    return this._eventMap.has(o) ? (this._eventMap.get(o).forEach((m) => m(...u)), !0) : !1;
  }
}
function shouldUseBezier(s) {
  return !!(s && typeof s == "object" && (s.duration > 0 || typeof s.easing == "string" || typeof s.easing == "function"));
}
function shouldStopAnimation(s, o, l, u, c) {
  for (const m of Object.keys(o)) {
    const g = o[m], v = typeof g == "number" ? g : g.val;
    if (!(typeof g == "object" && g.done)) {
      if (shouldUseBezier(g) && u && c && g.duration) {
        if (g.duration + u <= c || v !== s[m])
          return !1;
      } else if (typeof l[m] == "number" && l[m] !== 0)
        return !1;
      if (s[m] !== v)
        return !1;
    }
  }
  return !0;
}
function stripStyle(s) {
  const o = {};
  for (const l in s)
    Object.prototype.hasOwnProperty.call(s, l) && (o[l] = typeof s[l] == "number" ? s[l] : s[l].val);
  return o;
}
const reusedTuple = [0, 0];
function stepper(s, o, l, u, c, m, g) {
  const v = -c * (o - u), b = -m * l, S = v + b, E = l + S * s, P = o + E * s;
  return Math.abs(E) < g && Math.abs(P - u) < g ? (reusedTuple[0] = u, reusedTuple[1] = 0, reusedTuple) : (reusedTuple[0] = P, reusedTuple[1] = E, reusedTuple);
}
function mapToZero(s) {
  const o = {}, l = s && Object.keys(s) || [];
  for (const u of l)
    o[u] = 0;
  return o;
}
const presets = {
  default: {
    tension: 170,
    friction: 26
  },
  gentle: {
    tension: 120,
    friction: 14
  },
  wobbly: {
    tension: 180,
    friction: 12
  },
  stiff: {
    tension: 210,
    friction: 20
  },
  slow: {
    tension: 280,
    friction: 60
  },
  molasses: {
    tension: 280,
    friction: 120
  }
}, defaultConfig$2 = Object.assign(Object.assign({}, presets.default), {
  precision: 0.01
});
function wrapValue(s) {
  let o = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (shouldUseBezier(o)) {
    const u = getEasing(o.easing), c = typeof o.duration == "number" && o.duration > 0 ? o.duration : 1e3;
    o = Object.assign(Object.assign({}, o), {
      easing: u,
      duration: c
    });
  }
  let l = Object.assign(Object.assign(Object.assign({}, defaultConfig$2), o), {
    done: !1
  });
  if (s && typeof s == "object" && "val" in s) {
    if (shouldUseBezier(s)) {
      const u = getEasing(s.easing), c = typeof s.duration == "number" && s.duration > 0 ? s.duration : parseInt(o.duration) || 1e3;
      s = Object.assign(Object.assign({}, s), {
        easing: u,
        duration: c
      });
    }
    l = Object.assign(Object.assign({}, l), s);
  } else
    l = Object.assign(Object.assign({}, l), {
      val: s
    });
  return l;
}
const now = () => Date.now(), msPerFrame$1 = 1e3 / 60;
class Animation extends Event {
  constructor() {
    let o = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, l = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super(), this._props = Object.assign({}, o), this._config = Object.assign({}, l), this.initStates();
  }
  _wrapConfig(o, l) {
    l = l && typeof l == "object" ? l : this._config;
    const u = {};
    for (const c of Object.keys(o))
      u[c] = wrapValue(o[c], l);
    return u;
  }
  initStates(o, l) {
    o = o && typeof o == "object" ? o : this._props, l = l && typeof l == "object" ? l : this._config;
    const {
      from: u,
      to: c
    } = o;
    if (this._from = {}, u)
      for (const v of Object.keys(u))
        this._from[v] = typeof u[v] == "object" && u[v].val ? u[v].val : u[v];
    this._to = this._wrapConfig(c, l), this._delay = parseInt(l.delay) || 0;
    const m = this._from && stripStyle(this._from) || stripStyle(this._to), g = mapToZero(m);
    this._currentStyle = Object.assign({}, m), this._currentVelocity = Object.assign({}, g), this._lastIdealStyle = Object.assign({}, m), this._lastIdealVelocity = Object.assign({}, g), this.resetPlayStates(), this._frameCount = 0, this._prevTime = 0;
  }
  animate() {
    this._timer == null && (this._timer = requestAnimationFrame((o) => {
      const l = now();
      if (shouldStopAnimation(this._currentStyle, this._to, this._currentVelocity, this._startedTime || l, l) || this._ended || this._stopped) {
        this._wasAnimating && !this._ended && !this._stopped && (this._timer = setTimeout(() => {
          clearTimeout(this._timer), this._timer = null, this._ended = !0, this.emit("rest", this.getCurrentStates());
        }, msPerFrame$1)), this.resetPlayStates();
        return;
      }
      this._started || (this._started = !0, this.emit("start", this.getCurrentStates())), this._stopped = !1, this._paused = !1, this._wasAnimating = !0, this._startedTime === 0 && (this._startedTime = l);
      const u = l, c = u - this._prevTime;
      this._prevTime = u, u - this._startedTime < this._delay && (this._timer = null, this.animate());
      const m = {}, g = {}, v = {}, b = {}, S = this._to && Object.keys(this._to) || [];
      for (const E of S) {
        const P = this._to[E];
        this._accumulatedTime[E] = typeof this._accumulatedTime[E] != "number" ? c : this._accumulatedTime[E] + c;
        const T = this._from[E] != null && typeof this._from[E] == "object" ? this._from[E].val : this._from[E], N = P.val;
        if (typeof P == "number")
          v[E] = P, b[E] = 0, m[E] = P, g[E] = 0;
        else {
          let O = this._lastIdealStyle[E], z = this._lastIdealVelocity[E];
          if (shouldUseBezier(this._config) || shouldUseBezier(P)) {
            const {
              easing: Q,
              duration: W
            } = P;
            O = T + Q((u - this._startedTime) / W) * (N - T), u >= this._startedTime + W && (O = N, P.done = !0), m[E] = O, v[E] = O;
          } else if (N != null && N === this._currentStyle[E])
            v[E] = N, b[E] = 0, m[E] = N, g[E] = 0;
          else {
            const Q = (this._accumulatedTime[E] - Math.floor(this._accumulatedTime[E] / msPerFrame$1) * msPerFrame$1) / msPerFrame$1, W = Math.floor(this._accumulatedTime[E] / msPerFrame$1);
            for (let K = 0; K < W; K++)
              [O, z] = stepper(msPerFrame$1 / 1e3, O, z, P.val, P.tension, P.friction, P.precision);
            const [ue, te] = stepper(msPerFrame$1 / 1e3, O, z, P.val, P.tension, P.friction, P.precision);
            v[E] = O + (ue - O) * Q, b[E] = z + (te - z) * Q, m[E] = O, g[E] = z, this._accumulatedTime[E] -= W * msPerFrame$1;
          }
        }
      }
      this._timer = null, this._currentStyle = Object.assign({}, v), this._currentVelocity = Object.assign({}, b), this._lastIdealStyle = Object.assign({}, m), this._lastIdealVelocity = Object.assign({}, g), this._destroyed || (this.emit("frame", this.getCurrentStates()), this.animate());
    }));
  }
  start() {
    this._prevTime = now(), this._startedTime = now(), this.animate();
  }
  end() {
    this._ended || (this._ended = !0, this._currentStyle = this.getFinalStates(), this.emit("frame", this.getFinalStates()), this.emit("rest", this.getFinalStates())), this.destroy();
  }
  pause() {
    this._paused || (this._pausedTime = now(), this._paused = !0, this.emit("pause", this.getCurrentStates()), this.destroy(), this._destroyed = !1);
  }
  resume() {
    if (this._started && this._paused) {
      const l = now() - this._pausedTime;
      this._paused = !1, this._startedTime += l, this._prevTime += l, this._pausedTime = 0, this.emit("resume", this.getCurrentStates()), this.animate();
    }
  }
  stop() {
    this.destroy(), this._stopped || (this._stopped = !0, this.emit("stop", this.getInitialStates()), this.initStates());
  }
  destroy() {
    cancelAnimationFrame(this._timer), clearTimeout(this._timer), this._timer = null, this._destroyed = !0;
  }
  resetPlayStates() {
    this._started = !1, this._stopped = !1, this._ended = !1, this._paused = !1, this._destroyed = !1, this._timer = null, this._wasAnimating = !1, this._accumulatedTime = {}, this._startedTime = 0, this._pausedTime = 0;
  }
  reset() {
    this.destroy(), this.initStates();
  }
  reverse() {
    this.destroy();
    const o = Object.assign({}, this._props), [l, u] = [o.to, o.from];
    o.from = l, o.to = u, this._props = Object.assign({}, o), this.initStates();
  }
  getCurrentStates() {
    return Object.assign({}, this._currentStyle);
  }
  getInitialStates() {
    return Object.assign({}, stripStyle(this._props.from));
  }
  getFinalStates() {
    return Object.assign({}, stripStyle(this._props.to));
  }
}
const scrollTo = (s, o, l) => {
  const u = new Animation(
    {
      from: { scrollTop: s.scrollTop },
      to: { scrollTop: o }
    },
    { duration: l }
  );
  return u.on("frame", ({ scrollTop: c }) => {
    s.scrollTop = c;
  }), u;
}, msPerFrame = 1e3 / 60, blankReg = /^\s*$/, wheelMode = "wheel";
function scrollItemFunc() {
  const s = {
    className: String,
    style: Object,
    class: String,
    selectedIndex: {
      type: Number,
      default: 0
    },
    motion: {
      type: [Object, String, Boolean, Function],
      default: !0
    },
    transform: Function,
    list: {
      type: [Array],
      default: []
    },
    onSelect: {
      type: Function,
      default: lodashExports.noop
    },
    cycled: {
      type: Boolean,
      default: !1
    },
    mode: {
      type: String,
      default: wheelMode
    },
    type: [String, Number],
    //used to identify the scrollItem, used internally by the semi component, and does not need to be exposed to the user
    "aria-label": String
  };
  return /* @__PURE__ */ defineComponent({
    props: {
      ...s
    },
    name: "ScrollItem",
    setup(l, {}) {
      useSlots();
      const u = reactive({
        prependCount: 0,
        appendCount: 0
        // selectedIndex: props.selectedIndex,
        // fakeSelectedIndex: props.selectedIndex,
      }), c = ref$1(), m = ref$1(), g = ref$1(), v = ref$1(), b = ref$1();
      let S, E, P;
      S = null;
      const {
        adapter: T
      } = useBaseComponent(l, u), N = (yn, vn, Pn) => {
        if (yn = yn || c.value, vn = vn || b.value, isElement$1(yn) && isElement$1(vn)) {
          const On = vn.getBoundingClientRect(), _n = yn.getBoundingClientRect(), Nn = vn.scrollTop + (_n.top - (On.top + On.height / 2 - _n.height / 2));
          nn(Nn, typeof Pn == "number" ? Pn : numbers$c.DEFAULT_SCROLL_DURATION);
        }
      }, O = (yn) => {
        if (Array.isArray(l.list) && l.list.length && yn > -1) {
          const vn = l.list.length, Pn = yn % vn;
          return xt(l.list[Pn]);
        }
        return !1;
      };
      function z() {
        return {
          ...T(),
          setState: (yn, vn) => {
            for (const Pn in yn)
              yn.hasOwnProperty(Pn) && (u[Pn] = yn[Pn]);
            nextTick(() => {
              vn();
            });
          },
          setPrependCount: (yn) => u.prependCount = yn,
          setAppendCount: (yn) => u.appendCount = yn,
          isDisabledIndex: O,
          setSelectedNode: (yn) => te(yn),
          notifySelectItem: (...yn) => l.onSelect(...yn),
          scrollToCenter: N
        };
      }
      const Q = new ItemFoundation$1(z());
      onMounted(() => {
        Q.init();
        const {
          mode: yn,
          cycled: vn,
          selectedIndex: Pn
        } = l, On = rn(typeof Pn == "number" && Pn > -1 ? Pn : 0);
        ue(On), te(On), yn === wheelMode && vn ? Q.initWheelList(g.value, b.value, () => {
          Gt(On, 0);
        }) : Gt(On, 0);
      }), onUnmounted(() => {
        l.cycled && (E.cancel(), P.cancel());
      }), E = lodashExports.throttle((yn, vn) => {
        Q.adjustInfiniteList(g.value, b.value, vn);
      }, msPerFrame), P = lodashExports.debounce((yn, vn) => {
        ue(vn), Q.selectNode(vn, g.value);
      }, msPerFrame * 5), watch([() => l.selectedIndex, m, g, c, v, b], (yn, [vn]) => {
        const {
          selectedIndex: Pn
        } = l;
        if (vn !== Pn) {
          const On = ln(m.value);
          if (!wt(On, Pn)) {
            const _n = Re(c.value, Pn - vn, g.value);
            te(_n);
          }
          ue(m.value), an(Pn);
        }
      });
      const W = (yn, vn) => {
        if (yn && vn)
          switch (yn) {
            case "selectedNode":
              c.value = vn;
              break;
            case "willSelectNode":
              m.value = vn;
              break;
            case "list":
              g.value = vn;
              break;
            case "selector":
              v.value = vn;
              break;
            case "wrapper":
              b.value = vn;
              break;
          }
      }, ue = (yn) => W("selectedNode", yn), te = (yn) => W("willSelectNode", yn), K = (yn) => W("list", yn), ve = (yn) => W("selector", yn), ee = (yn) => W("wrapper", yn);
      function Re(yn, vn, Pn) {
        const {
          list: On
        } = l;
        if (isElement$1(yn) && isElement$1(Pn) && typeof vn == "number" && Array.isArray(On) && On.length) {
          vn = vn % On.length;
          let Nn = ln(yn) + vn;
          for (; Nn < 0; )
            Nn += On.length;
          if (vn)
            return rn(Nn);
        }
        return yn;
      }
      const wt = (yn, vn) => {
        const {
          list: Pn
        } = l;
        if (Pn.length)
          return yn % Pn.length === vn % Pn.length;
      }, yt = (yn) => {
        const vn = g;
        if (isElement$1(yn) && isElement$1(vn.value)) {
          const Pn = lodashExports.findIndex(vn.value.children, (On) => On === yn);
          return O(Pn);
        }
        return !1;
      }, xt = (yn) => yn && typeof yn == "object" && yn.disabled, Kt = () => l.mode === wheelMode, tn = (yn, vn = cssClasses$G.SELECTED) => {
        if (yn = yn || c.value, isElement$1(yn) && isElement$1(g.value)) {
          const {
            children: Pn
          } = g.value, On = new RegExp(`\\s*${vn}\\s*`, "g");
          lodashExports.map(Pn, (_n) => {
            _n.className = _n.className && _n.className.replace(On, " "), blankReg.test(_n.className) && (_n.className = "");
          }), yn.className && !blankReg.test(yn.className) ? yn.className += ` ${vn}` : yn.className = vn;
        }
      }, ln = (yn) => lodashExports.findIndex(g.value.children, function(vn) {
        return vn == yn;
      }), rn = (yn) => yn > -1 ? lodashExports.find(g.value.children, (Pn, On) => (On === yn && Pn.scrollTop, On === yn)) : lodashExports.find(g.value.children, (Pn) => !yt(Pn)), an = (yn, vn) => {
        vn = typeof vn == "number" ? vn : numbers$c.DEFAULT_SCROLL_DURATION, yn = yn ?? l.selectedIndex, Gt(c.value, vn);
      }, Gt = (yn, vn) => {
        const Pn = b.value.offsetHeight, On = Qt(yn), _n = (yn.offsetTop || g.value.children.length * On / 2) - (Pn - On) / 2;
        nn(_n, vn);
      }, nn = (yn, vn = numbers$c.DEFAULT_SCROLL_DURATION) => {
        if (vn && l.motion)
          if (S && S.destroy(), b.value.scrollTop === yn) {
            if (Kt()) {
              const Pn = Q.getNearestNodeInfo(g.value, v.value);
              tn(Pn.nearestNode);
            }
          } else
            S = scrollTo(b.value, yn, vn), S.on("rest", () => {
              if (Kt()) {
                const Pn = Q.getNearestNodeInfo(g.value, v.value);
                tn(Pn.nearestNode);
              }
            }), S.start();
        else
          b.value.scrollTop = yn;
      }, vt = (yn) => {
        const {
          nearestNode: vn
        } = Q.getNearestNodeInfo(g.value, v.value);
        l.cycled && E(yn, vn), P(yn, vn);
      }, Et = (yn) => {
        yn && yn.stopImmediatePropagation && yn.stopImmediatePropagation();
        const {
          targetNode: vn,
          infoInList: Pn
        } = Q.getTargetNode(yn, g.value);
        vn && Pn && !Pn.disabled && P(null, vn);
      }, Qt = (yn) => yn && yn.offsetHeight || numbers$c.DEFAULT_ITEM_HEIGHT, un = (yn = "") => {
        const {
          selectedIndex: vn,
          mode: Pn,
          transform: On
        } = l;
        return l.list.map((_n, Nn) => {
          const {
            transform: Un
          } = _n, Xn = typeof Un == "function" ? Un : On, zn = vn === Nn, jn = cls({
            [`${cssClasses$G.PREFIX}-item-sel`]: zn && Pn !== wheelMode,
            [`${cssClasses$G.PREFIX}-item-disabled`]: !!_n.disabled
          });
          let kn = "";
          zn && typeof Xn == "function" ? kn = Xn(_n.value, _n.text) : kn = _n.text == null ? _n.value : _n.text;
          const Yn = {};
          return !Kt() && !_n.disabled && (Yn.onClick = () => Q.selectIndex(Nn, g.value)), // eslint-disable-next-line @typescript-eslint/restrict-plus-operands
          createVNode("li", mergeProps$1({
            key: yn + Nn
          }, Yn, {
            class: jn,
            role: "option",
            "aria-selected": zn,
            "aria-disabled": _n.disabled
          }), [kn]);
        });
      }, gn = () => {
        const {
          className: yn,
          style: vn
        } = l, Pn = un(), On = cls(`${cssClasses$G.PREFIX}-item`, yn);
        return createVNode("div", {
          style: vn,
          class: On,
          ref: ee
        }, [createVNode("ul", {
          role: "listbox",
          "aria-multiselectable": !1,
          "aria-label": l["aria-label"],
          ref: K
        }, [Pn])]);
      }, dn = () => {
        const {
          cycled: yn,
          className: vn,
          style: Pn
        } = l, {
          prependCount: On,
          appendCount: _n
        } = u, Nn = lodashExports.times(On).reduce((er, bn) => {
          const Ln = un(`pre_${bn}_`);
          return er.unshift(...Ln), er;
        }, []), Un = lodashExports.times(_n).reduce((er, bn) => {
          const Ln = un(`app_${bn}_`);
          return er.push(...Ln), er;
        }, []), Xn = un(), zn = cls(`${cssClasses$G.PREFIX}-list-outer`, {
          [`${cssClasses$G.PREFIX}-list-outer-nocycle`]: !yn
        }), jn = cls(`${cssClasses$G.PREFIX}-item-wheel`, vn), kn = cls(`${cssClasses$G.PREFIX}-selector`), Yn = cls(`${cssClasses$G.PREFIX}-shade`, `${cssClasses$G.PREFIX}-shade-pre`), Zn = cls(`${cssClasses$G.PREFIX}-shade`, `${cssClasses$G.PREFIX}-shade-post`);
        return createVNode("div", {
          class: jn,
          style: Pn
        }, [createVNode("div", {
          class: Yn
        }, null), createVNode("div", {
          class: kn,
          ref: ve
        }, null), createVNode("div", {
          class: Zn
        }, null), createVNode("div", {
          class: zn,
          ref: ee,
          onScroll: vt
        }, [createVNode("ul", {
          role: "listbox",
          "aria-label": l["aria-label"],
          "aria-multiselectable": !1,
          ref: K,
          onClick: Et
        }, [Nn, Xn, Un])])]);
      };
      return () => Kt() ? dn() : gn();
    }
  });
}
const ScrollItem = scrollItemFunc(), ScrollItem$1 = ScrollItem, HOUR = 1e3 * 60 * 60, DAY = 24 * HOUR, formatOption = (s, o) => {
  let l = `${s}`;
  s < 10 && (l = `0${s}`);
  let u = !1;
  return o && o.indexOf(s) >= 0 && (u = !0), {
    value: l,
    disabled: u
  };
};
function generateOptions(s, o, l, u = 1) {
  const c = [];
  for (let m = 0; m < s; m += u)
    (!o || o.indexOf(m) < 0 || !l) && c.push(m);
  return c;
}
class ComboboxFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  isAM() {
    return this.getProp("isAM");
  }
  initData() {
    const {
      timeStampValue: o,
      hourStep: l,
      disabledMinutes: u,
      disabledSeconds: c,
      hideDisabledOptions: m,
      minuteStep: g,
      secondStep: v
    } = this.getProps(), b = this.getValidFormat(), S = this.getDisplayDateFromTimeStamp(o), E = this.disabledHours(), P = u(S ? S.getHours() : null), T = c(
      S ? S.getHours() : null,
      S ? S.getMinutes() : null
    ), N = generateOptions(24, E, m, l), O = generateOptions(60, P, m, g), z = generateOptions(60, T, m, v);
    return {
      showHour: !!b.match(/HH|hh|H|h/g),
      showMinute: !!b.match(/mm/g),
      showSecond: !!b.match(/ss/g),
      hourOptions: N,
      minuteOptions: O,
      secondOptions: z
    };
  }
  getPosition() {
    const o = this.getProp("position"), l = this.getProp("type") || strings$e.DEFAULT_TYPE;
    return o || strings$e.DEFAULT_POSITION[l];
  }
  getDefaultFormatIfNeed() {
    return this._isInProps("format") ? this.getProp("format") : this.getProp("use12Hours") ? strings$e.DEFAULT_FORMAT_A : strings$e.DEFAULT_FORMAT;
  }
  disabledHours() {
    const { use12Hours: o, disabledHours: l } = this.getProps();
    let u = l && l();
    return o && Array.isArray(u) && (this.isAM() ? u = u.filter((c) => c < 12).map((c) => c === 0 ? 12 : c) : u = u.map((c) => c === 12 ? 12 : c - 12)), u;
  }
  getValidFormat(o) {
    let l = isNullOrUndefined(o) ? this.getProp("format") : o;
    return l = this.getDefaultFormatIfNeed(), l = typeof l == "string" ? l : strings$e.DEFAULT_FORMAT, l;
  }
  /**
   * from 13-bit timestamp  -> get display date
   * by combobox use
   */
  getDisplayDateFromTimeStamp(o) {
    let l;
    return o && (l = new Date(o)), !o || !isValidDate(l) ? this.createDateDefault() : l;
  }
  /**
   * create a date at 00:00:00
   */
  createDateDefault() {
    return new Date(parseInt(String(Date.now() / DAY), 10) * DAY - 8 * HOUR);
  }
}
const PlainTimeShape = [string$3, number$2, object$1], TimeShape = [
  ...PlainTimeShape,
  Array
], PanelShape = {
  panelHeader: node$1,
  panelFooter: node$1
}, PanelShapeDefaults = {}, timePickerPropTypes = {
  "aria-labelledby": string$3,
  "aria-invalid": bool,
  "aria-errormessage": string$3,
  "aria-describedby": string$3,
  "aria-required": bool,
  prefixCls: string$3,
  borderless: bool,
  clearText: { type: string$3, default: "clear" },
  value: TimeShape,
  inputReadOnly: bool,
  disabled: bool,
  showClear: bool,
  defaultValue: TimeShape,
  stopPropagation: bool,
  open: bool,
  defaultOpen: bool,
  onOpenChange: { type: func, default: lodashExports.noop },
  position: any$1,
  getPopupContainer: { type: func, default: () => document.body },
  placeholder: string$3,
  format: string$3,
  style: object$1,
  className: string$3,
  popupClassName: string$3,
  popupStyle: object$1,
  disabledHours: func,
  disabledMinutes: func,
  disabledSeconds: func,
  hideDisabledOptions: bool,
  onChange: func,
  use12Hours: bool,
  hourStep: number$2,
  minuteStep: number$2,
  secondStep: number$2,
  focusOnOpen: bool,
  autoFocus: bool,
  size: string$3,
  panels: array$1,
  onFocus: func,
  onBlur: func,
  locale: object$1,
  localeCode: string$3,
  dateFnsLocale: object$1,
  zIndex: {
    type: [number$2, string$3],
    default: numbers$f.DEFAULT_Z_INDEX
  },
  insetLabel: node$1,
  insetLabelId: string$3,
  validateStatus: string$3,
  type: string$3,
  rangeSeparator: { type: string$3, default: strings$e.DEFAULT_RANGE_SEPARATOR },
  triggerRender: func,
  timeZone: [string$3, number$2],
  scrollItemProps: object$1,
  motion: [bool, func, object$1],
  autoAdjustOverflow: { type: bool, default: !0 },
  ...PanelShape,
  inputStyle: object$1,
  clearIcon: node$1,
  dropdownMargin: oneOfType([number$2, object$1]),
  preventScroll: bool,
  id: string$3,
  onChangeWithDateFirst: bool
}, ScrollItemFormatOptionReturn = scrollItemFunc(), ScrollItemAMPMOptionItem = scrollItemFunc(), staticPropTypes = {
  class: [string$3, object$1],
  className: string$3,
  style: [string$3, object$1],
  format: string$3,
  defaultOpenValue: object$1,
  prefixCls: string$3,
  onChange: func,
  showHour: bool,
  showMinute: bool,
  showSecond: bool,
  disabledHours: func,
  disabledMinutes: func,
  disabledSeconds: func,
  hideDisabledOptions: bool,
  onCurrentSelectPanelChange: func,
  use12Hours: bool,
  isAM: bool,
  timeStampValue: any$1,
  scrollItemProps: object$1,
  panelHeader: string$3,
  ...lodashExports.omit(timePickerPropTypes, ["prefixCls", "format", "style", "disabledHours", "disabledMinutes", "disabledSeconds", "hideDisabledOptions", "onChange", "use12Hours", "scrollItemProps"]),
  panelFooter: node$1
}, staticDefaultProps = {
  disabledHours: lodashExports.noop,
  disabledMinutes: lodashExports.noop,
  disabledSeconds: lodashExports.noop,
  format: strings$e.DEFAULT_FORMAT
}, vuePropsType$2l = vuePropsMake(staticPropTypes, staticDefaultProps), Combobox = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2l
  },
  name: "Combobox",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      hourOptions: [],
      minuteOptions: [],
      secondOptions: [],
      showHour: !1,
      showMinute: !1,
      showSecond: !1
    }), {
      adapter: l
    } = useBaseComponent(s, o), u = new ComboboxFoundation(l());
    function c() {
      const T = u.initData();
      Object.keys(T).forEach((N) => {
        o[N] = T[N];
      });
    }
    c(), watch([() => s.timeStampValue, () => s.format], ([], [T, N]) => {
      (T !== s.timeStampValue || N !== s.format) && c();
    });
    const m = (T, N) => {
      T && typeof T == "string" && l().setCache(T, N);
    }, g = ({
      type: T,
      value: N,
      disabled: O
    }) => {
      let {
        onChange: z,
        use12Hours: Q,
        isAM: W,
        format: ue,
        timeStampValue: te
      } = s;
      const K = u.getDisplayDateFromTimeStamp(te);
      if (T === "hour")
        Q ? W ? K.setHours(Number(N) % 12) : K.setHours(Number(N) % 12 + 12) : K.setHours(Number(N));
      else if (T === "minute")
        K.setMinutes(Number(N));
      else if (T === "ampm") {
        const ve = N.toUpperCase();
        Q && (ve === "PM" && (W = !1, K.getHours() < 12 && K.setHours(K.getHours() % 12 + 12)), ve === "AM" && (W = !0, K.getHours() >= 12 && K.setHours(K.getHours() - 12)));
      } else
        K.setSeconds(Number(N));
      z && z({
        isAM: W,
        value: format$3(K, ue && ue.replace(/(\s+)A/g, "$1a")),
        // dateFns only supports "h: mm: ss a"
        timeStampValue: Number(K)
      });
    };
    function v(T, N) {
      const {
        prefixCls: O,
        disabledHours: z,
        use12Hours: Q,
        scrollItemProps: W
      } = s, {
        showHour: ue,
        hourOptions: te
      } = o;
      if (!ue)
        return null;
      const K = z();
      let ve, ee;
      Q ? (ve = [12].concat(te.filter((yt) => yt < 12 && yt > 0)), ee = T % 12 || 12) : (ve = te, ee = T);
      const Re = (yt) => yt + N.hour, wt = `${O}-list-hour`;
      return createVNode(ScrollItemFormatOptionReturn, mergeProps$1({
        ref: (yt) => m("hour", yt),
        mode: "normal",
        transform: Re,
        className: wt,
        list: ve.map((yt) => formatOption(yt, K)),
        selectedIndex: ve.indexOf(ee),
        type: "hour",
        onSelect: g
      }, W), null);
    }
    function b(T, N) {
      const {
        prefixCls: O,
        disabledMinutes: z,
        timeStampValue: Q,
        scrollItemProps: W
      } = s, {
        showMinute: ue,
        minuteOptions: te
      } = o;
      if (!ue)
        return null;
      const K = new Date(Q), ve = z && z(K.getHours()), ee = `${O}-list-minute`;
      return createVNode(ScrollItemFormatOptionReturn, mergeProps$1({
        ref: (wt) => m("minute", wt),
        mode: "normal",
        transform: (wt) => wt + N.minute,
        list: te.map((wt) => formatOption(wt, ve)),
        selectedIndex: te.indexOf(T),
        type: "minute",
        onSelect: g,
        className: ee
      }, W), null);
    }
    function S(T, N) {
      const {
        prefixCls: O,
        disabledSeconds: z,
        timeStampValue: Q,
        scrollItemProps: W
      } = s, {
        showSecond: ue,
        secondOptions: te
      } = o;
      if (!ue)
        return null;
      const K = new Date(Q), ve = z && z(K.getHours(), K.getMinutes()), ee = `${O}-list-second`;
      return createVNode(ScrollItemFormatOptionReturn, mergeProps$1({
        ref: (wt) => m("second", wt),
        mode: "normal",
        transform: (wt) => String(wt) + N.second,
        list: te.map((wt) => formatOption(wt, ve)),
        selectedIndex: te.indexOf(T),
        className: ee,
        type: "second",
        onSelect: g
      }, W), null);
    }
    function E(T, N) {
      const {
        prefixCls: O,
        use12Hours: z,
        isAM: Q,
        scrollItemProps: W
      } = s;
      if (!z)
        return null;
      const ue = [{
        value: "AM",
        text: T.AM || "上午"
      }, {
        value: "PM",
        text: T.PM || "下午"
      }], te = Q ? 0 : 1, K = `${O}-list-ampm`;
      return createVNode(ScrollItemAMPMOptionItem, mergeProps$1({
        ref: (ve) => m("ampm", ve),
        mode: "normal",
        className: K,
        list: ue,
        selectedIndex: te,
        type: "ampm",
        onSelect: g
      }, W), null);
    }
    const P = (T) => u.getDisplayDateFromTimeStamp(T);
    return () => {
      const {
        timeStampValue: T,
        panelHeader: N,
        panelFooter: O
      } = s, z = P(T);
      return createVNode(LocaleConsumer$6, {
        componentName: "TimePicker"
      }, {
        default: (Q, W) => createVNode(ScrollList, {
          header: N,
          footer: O,
          "x-semi-header-alias": "panelHeader",
          "x-semi-footer-alias": "panelFooter"
        }, {
          default: () => [E(Q), v(z.getHours(), Q), b(z.getMinutes(), Q), S(z.getSeconds(), Q)]
        })
      });
    };
  }
});
class YearAndMonthFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
  }
  destroy() {
  }
  selectYear(o, l) {
    const { currentYear: u, currentMonth: c } = this.getStates(), { type: m } = this.getProps(), g = strings$f.PANEL_TYPE_LEFT, v = strings$f.PANEL_TYPE_RIGHT, b = index$b(u);
    if (b[l] = o.value, m === "monthRange") {
      const S = b[g] === b[v] && c[g] > c[v];
      l === g && o.value > b[v] || l === g && S ? b[v] = o.value + 1 : l === v && S && (b[g] = o.value - 1);
    }
    this._adapter.setCurrentYear(b, () => this.autoSelectMonth(o, l, b)), this._adapter.notifySelectYear(b);
  }
  selectMonth(o, l) {
    const { currentMonth: u, currentYear: c } = this.getStates(), { type: m } = this.getProps(), g = strings$f.PANEL_TYPE_LEFT, v = strings$f.PANEL_TYPE_RIGHT, b = index$b(u);
    b[l] = o.month, m === "monthRange" && l === g && c[g] === c[v] && o.value > b[v] && (b[v] = o.month + 1), this._adapter.setCurrentMonth(b), this._adapter.notifySelectMonth(b);
  }
  /**
   * After selecting a year, if the currentMonth is disabled, automatically select a non-disabled month
   */
  autoSelectMonth(o, l, u) {
    const { disabledDate: c, locale: m } = this._adapter.getProps(), { months: g, currentMonth: v } = this._adapter.getStates(), b = setYear(Date.now(), o.year);
    if (c(setMonth(b, v[l] - 1))) {
      const E = g.findIndex(({ month: T }) => T === v[l]);
      let P;
      if (P = g.slice(E).find(({ month: T }) => !c(setMonth(b, T - 1))), P || (P = g.slice(0, E).find(({ month: T }) => !c(setMonth(b, T - 1)))), P) {
        const T = index$b(v);
        T[l] = P.month, this._adapter.setCurrentYearAndMonth(u, T), this._adapter.notifySelectYearAndMonth(u, T);
      }
    }
  }
  backToMain() {
    this._adapter.notifyBackToMain();
  }
}
const prefixCls$D = `${BASE_CLASS_PREFIX$1}-datepicker`, propTypes$1s = {
  currentYear: {
    type: object$1,
    required: !0
  },
  currentMonth: {
    type: object$1,
    required: !0
  },
  onSelect: func,
  locale: object$1,
  localeCode: string$3,
  monthCycled: bool,
  yearCycled: bool,
  noBackBtn: bool,
  disabledDate: func,
  density: string$3,
  presetPosition: string$3,
  renderQuickControls: node$1,
  renderDateInput: node$1,
  yearAndMonthOpts: any$1,
  type: string$3,
  startYear: number$2,
  endYear: number$2,
  onBackToMain: func,
  className: string$3,
  style: object$1
}, defaultProps$1m = {
  disabledDate: lodashExports.stubFalse,
  monthCycled: !1,
  yearCycled: !1,
  noBackBtn: !1,
  onSelect: lodashExports.noop,
  type: "month"
}, vuePropsType$2k = vuePropsMake(propTypes$1s, defaultProps$1m), yearAndMonth = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2k
  },
  name: "DatePickerYearAndMonth",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const l = /* @__PURE__ */ new Date();
    let {
      currentYear: u,
      currentMonth: c
    } = s;
    const m = reactive({
      years: getYears(s.startYear, s.endYear).map((te) => ({
        value: te,
        year: te
      })),
      months: Array(12).fill(0).map((te, K) => ({
        value: K + 1,
        month: K + 1
      })),
      currentYear: {
        left: u.left || l.getFullYear(),
        right: u.right || l.getFullYear()
      },
      currentMonth: {
        left: c.left || l.getMonth() + 1,
        right: c.right || l.getMonth() + 2
      }
    }), {
      adapter: g
    } = useBaseComponent(s, m), v = ref$1(), b = ref$1(), S = new YearAndMonthFoundation(E());
    function E() {
      return {
        ...g(),
        // updateYears: years => this.setState({ years }),
        // updateMonths: months => this.setState({ months }),
        setCurrentYear: (te) => m.currentYear = te,
        setCurrentMonth: (te) => m.currentMonth = te,
        setCurrentYearAndMonth: (te, K) => {
          m.currentYear = te, m.currentMonth = K;
        },
        notifySelectYear: (te) => s.onSelect({
          currentMonth: m.currentMonth,
          currentYear: te
        }),
        notifySelectMonth: (te) => s.onSelect({
          currentYear: m.currentYear,
          currentMonth: te
        }),
        notifySelectYearAndMonth: (te, K) => s.onSelect({
          currentYear: te,
          currentMonth: K
        }),
        notifyBackToMain: () => s.onBackToMain()
      };
    }
    function P(te, K) {
      const ve = {};
      if (!lodashExports.isEqual(te.currentYear, K.currentYear) && te.currentYear.left !== 0) {
        const ee = (/* @__PURE__ */ new Date()).getFullYear();
        ve.currentYear = {
          left: te.currentYear.left || ee,
          right: te.currentYear.right || ee
        };
      }
      if (!lodashExports.isEqual(te.currentMonth, K.currentMonth) && te.currentMonth.left !== 0) {
        const ee = (/* @__PURE__ */ new Date()).getMonth();
        ve.currentMonth = {
          left: te.currentMonth.left || ee + 1,
          right: te.currentMonth.right || ee + 2
        };
      }
      return ve;
    }
    watch([() => s.currentMonth, () => s.currentYear], (te) => {
      const K = P({
        ...s
      }, {
        ...m
      });
      K && Object.keys(K).forEach((ve) => {
        m[ve] = K[ve];
      });
    }, {
      immediate: !0
    });
    function T(te) {
      const {
        years: K,
        currentYear: ve,
        currentMonth: ee,
        months: Re
      } = m, {
        disabledDate: wt,
        localeCode: yt,
        yearCycled: xt,
        yearAndMonthOpts: Kt
      } = s, tn = setMonth(Date.now(), ee[te] - 1), ln = strings$f.PANEL_TYPE_LEFT, rn = strings$f.PANEL_TYPE_RIGHT, an = (vt) => te === rn && ve[ln] ? ee[ln] <= ee[rn] ? ve[ln] > vt : ve[ln] >= vt : !1, Gt = K.map(({
        value: vt,
        year: Et
      }) => {
        const Qt = Re.every(({
          month: gn
        }) => wt(set$1(tn, {
          year: Et,
          month: gn - 1
        }))), un = an(Et);
        return {
          year: Et,
          value: vt,
          // Actual rendered text
          disabled: Qt || un
        };
      });
      let nn = (vt) => vt;
      return (yt === "zh-CN" || yt === "zh-TW") && (nn = (vt) => `${vt}年`), createVNode(ScrollItem$1, mergeProps$1({
        ref: v
      }, {
        cycled: xt,
        list: Gt,
        transform: nn,
        selectedIndex: K.findIndex((vt) => vt.value === ve[te]),
        type: "year",
        onSelect: (vt) => N(vt, te),
        mode: "normal",
        ...Kt
      }), null);
    }
    const N = (te, K) => {
      S.selectYear(te, K);
    }, O = (te, K) => {
      S.selectMonth(te, K);
    };
    o({
      reselect: () => {
        [v, b].forEach((K) => {
          K.value && K.value.scrollToIndex && K.value.scrollToIndex();
        });
      }
    });
    function Q(te) {
      const {
        months: K,
        currentMonth: ve,
        currentYear: ee
      } = m, {
        locale: Re,
        localeCode: wt,
        monthCycled: yt,
        disabledDate: xt,
        yearAndMonthOpts: Kt
      } = s;
      let tn = (vt) => vt;
      const ln = setYear(Date.now(), ee[te]), rn = strings$f.PANEL_TYPE_LEFT, an = strings$f.PANEL_TYPE_RIGHT;
      (wt === "zh-CN" || wt === "zh-TW") && (tn = (vt) => `${vt}月`);
      const Gt = K.map(({
        value: vt,
        month: Et
      }) => {
        const Qt = te === an && ve[rn] && ee[rn] === ee[an] && ve[rn] > Et;
        return {
          month: Et,
          disabled: xt(setMonth(ln, Et - 1)) || Qt,
          value: Re.fullMonths[vt]
          // Actual rendered text
        };
      }), nn = Gt.findIndex((vt) => vt.month === ve[te]);
      return createVNode(ScrollItem$1, mergeProps$1({
        ref: b
      }, {
        cycled: yt,
        list: Gt,
        transform: tn,
        selectedIndex: nn,
        type: "month",
        onSelect: (vt) => O(vt, te),
        mode: "normal",
        ...Kt
      }), null);
    }
    const W = (te) => {
      te.stopImmediatePropagation(), S.backToMain();
    };
    function ue(te) {
      return createVNode(Fragment, null, [createVNode(ScrollList, null, {
        default: () => [T(te), Q(te)]
      })]);
    }
    return () => {
      const {
        locale: te,
        noBackBtn: K,
        density: ve,
        presetPosition: ee,
        renderQuickControls: Re,
        renderDateInput: wt,
        type: yt
      } = s, xt = `${prefixCls$D}-yearmonth-header`, Kt = `${prefixCls$D}-yearmonth-body`, tn = te.selectDate, ln = ve === "compact" ? "default" : "large", rn = ve === "compact" ? "small" : "default", an = strings$f.PANEL_TYPE_LEFT, Gt = strings$f.PANEL_TYPE_RIGHT;
      let nn = null;
      return yt === "month" ? nn = ue(an) : nn = createVNode("div", {
        class: Kt
      }, [ue(an), ue(Gt)]), createVNode(Fragment, null, [K ? null : createVNode("div", {
        class: xt
      }, [createVNode(Button$3, {
        noHorizontalPadding: !1,
        icon: createVNode(IconComponent$z, {
          "aria-hidden": !0,
          size: ln
        }, null),
        size: rn,
        onClick: W
      }, {
        default: () => [createVNode("span", null, [tn])]
      })]), ee ? createVNode("div", {
        style: {
          display: "flex"
        }
      }, [ee === "left" && yt !== "monthRange" && Re, createVNode("div", null, [wt, nn]), ee === "right" && yt !== "monthRange" && Re]) : createVNode(Fragment, null, [wt, nn])]);
    };
  }
}), prefixCls$C = cssClasses$I.PREFIX, propTypes$1r = {
  type: string$3,
  defaultValue: array$1,
  defaultPickerValue: oneOfType([string$3, number$2, object$1, array$1]),
  multiple: bool,
  max: number$2,
  // only work when multiple is true
  weekStartsOn: number$2,
  disabledDate: func,
  disabledTime: func,
  disabledTimePicker: bool,
  hideDisabledOptions: bool,
  navPrev: node$1,
  navNext: node$1,
  onMaxSelect: func,
  timePickerOpts: object$1,
  // Whether the outer datePicker is a controlled component
  isControlledComponent: bool,
  rangeStart: oneOfType([string$3]),
  rangeInputFocus: oneOfType([bool, string$3]),
  locale: object$1,
  localeCode: string$3,
  format: string$3,
  renderDate: func,
  renderFullDate: func,
  startDateOffset: func,
  endDateOffset: func,
  autoSwitchDate: bool,
  density: string$3,
  dateFnsLocale: any$1,
  timeZone: oneOfType([string$3, number$2]),
  // Support synchronous switching of months
  syncSwitchMonth: bool,
  // Callback function for panel date switching
  onPanelChange: func,
  focusRecordsRef: object$1,
  triggerRender: func,
  presetPosition: string$3,
  renderQuickControls: node$1,
  renderDateInput: node$1,
  style: [Object, String],
  className: String,
  motionEnd: bool,
  splitPanels: Boolean,
  onChange: Function,
  setRangeInputFocus: Function,
  isAnotherPanelHasOpened: Function,
  insetInput: {
    type: Boolean,
    required: !0
  },
  yearAndMonthOpts: Object,
  startYear: Number,
  endYear: Number
}, defaultProps$1l = {
  type: "date",
  rangeStart: "",
  multiple: !1,
  weekStartsOn: numbers$d.WEEK_START_ON,
  disabledDate: lodashExports.stubFalse,
  onMaxSelect: lodashExports.noop,
  locale: {}
}, vuePropsType$2j = vuePropsMake(propTypes$1r, defaultProps$1l), monthsGrid = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2j
  },
  name: "MonthsGrid",
  setup(s, {
    slots: o
  }) {
    const l = s.format || getDefaultFormatTokenByType(s.type), {
      nowDate: u,
      nextDate: c
    } = getDefaultPickerDate({
      defaultPickerValue: s.defaultPickerValue,
      format: l,
      dateFnsLocale: s.dateFnsLocale
    }), m = {
      // Direct use of full date string storage, mainly considering the month rendering comparison to save a conversion
      // The selected value for single or multiple selection, full date string, eg. {'2019-10-01', '2019-10-02'}
      selected: /* @__PURE__ */ new Set()
    }, g = {
      monthLeft: {
        pickerDate: u,
        showDate: u,
        isTimePickerOpen: !1,
        isYearPickerOpen: !1
      },
      monthRight: {
        pickerDate: c,
        showDate: c,
        isTimePickerOpen: !1,
        isYearPickerOpen: !1
      },
      maxWeekNum: 0,
      // Maximum number of weeks left and right for manual height adjustment
      hoverDay: "",
      // Real-time hover date
      rangeStart: s.rangeStart,
      // Start date for range selection
      rangeEnd: "",
      // End date of range selection
      currentPanelHeight: 0,
      // current month panel height,
      offsetRangeStart: "",
      offsetRangeEnd: ""
    }, v = reactive({
      ...m,
      ...g
    }), {
      adapter: b
    } = useBaseComponent(s, v), S = new MonthsGridFoundation(T());
    function E() {
      return {
        updateDaySelected: (xt) => v.selected = xt
      };
    }
    function P() {
      return {
        setRangeStart: (xt) => v.rangeStart = xt,
        setRangeEnd: (xt) => v.rangeEnd = xt,
        setHoverDay: (xt) => v.hoverDay = xt,
        setWeeksHeight: (xt) => v.maxWeekNum = xt,
        setOffsetRangeStart: (xt) => v.offsetRangeStart = xt,
        setOffsetRangeEnd: (xt) => v.offsetRangeEnd = xt
      };
    }
    function T() {
      return {
        ...b(),
        ...E(),
        ...P(),
        updateMonthOnLeft: (xt) => v.monthLeft = xt,
        updateMonthOnRight: (xt) => v.monthRight = xt,
        notifySelectedChange: (xt, Kt) => {
          s.onChange(xt, Kt);
        },
        notifyMaxLimit: (xt) => s.onMaxSelect(xt),
        notifyPanelChange: (xt, Kt) => s.onPanelChange(xt, Kt),
        setRangeInputFocus: (xt) => s.setRangeInputFocus(xt),
        isAnotherPanelHasOpened: (xt) => s.isAnotherPanelHasOpened(xt)
      };
    }
    onMounted(() => {
    }), watch(() => s.defaultValue, (xt) => {
      S.updateSelectedFromProps(xt);
    }, {
      immediate: !0
    }), watch(() => s.defaultPickerValue, (xt) => {
      S.initDefaultPickerValue();
    }, {
      immediate: !0
    }), watch(v, (xt, Kt, tn) => {
      if (S.isRangeType()) {
        const rn = O(Kt) && z(Kt), an = O(Kt) && !z(Kt) || !O(Kt) && z(Kt), Gt = O() && z(), nn = O() && !z() || !O() && z();
        an && Gt ? (v.currentPanelHeight = Q(), nextTick(() => {
          ve();
        })) : rn && nn && ve();
      }
    }, {
      immediate: !0
    });
    const N = (xt, Kt) => {
      typeof xt == "string" && xt.length && T().setCache(xt, Kt);
    };
    function O(xt) {
      const {
        monthLeft: Kt
      } = xt || v;
      return !!(Kt && (Kt.isTimePickerOpen || Kt.isYearPickerOpen));
    }
    function z(xt) {
      const {
        monthRight: Kt
      } = xt || v;
      return !!(Kt && (Kt.isTimePickerOpen || Kt.isYearPickerOpen));
    }
    const Q = () => {
      const xt = T().getCache(`wrap-${strings$f.PANEL_TYPE_LEFT}`), Kt = T().getCache(`wrap-${strings$f.PANEL_TYPE_RIGHT}`), tn = T().getCache(`switch-${strings$f.PANEL_TYPE_LEFT}`), ln = T().getCache(`switch-${strings$f.PANEL_TYPE_RIGHT}`), rn = xt && xt.getBoundingClientRect(), an = Kt && Kt.getBoundingClientRect();
      let Gt = rn && rn.height || 0, nn = an && an.height || 0;
      return tn && (Gt += tn.getBoundingClientRect().height), ln && (nn += ln.getBoundingClientRect().height), Math.max(Gt, nn);
    };
    function W(xt, Kt) {
      let tn = cls(`${prefixCls$C}-month-grid-${Kt}`);
      const {
        monthLeft: ln,
        monthRight: rn,
        currentPanelHeight: an
      } = v, {
        insetInput: Gt
      } = s, nn = Kt === strings$f.PANEL_TYPE_RIGHT ? rn : ln, {
        isTimePickerOpen: vt,
        isYearPickerOpen: Et
      } = nn, Qt = te(xt, Kt), un = Et ? createVNode("div", {
        class: `${prefixCls$C}-yam`
      }, [wt(Kt, nn)]) : null, gn = vt ? createVNode("div", {
        class: `${prefixCls$C}-tpk`
      }, [Re(Kt, nn)]) : null, dn = {}, yn = T().getCache(`wrap-${strings$f.PANEL_TYPE_LEFT}`), vn = T().getCache(`wrap-${strings$f.PANEL_TYPE_RIGHT}`), Pn = Kt === strings$f.PANEL_TYPE_RIGHT ? vn : yn;
      return S.isRangeType() ? ((Et || vt) && (dn.minWidth = Pn.getBoundingClientRect().width, dn.minWidth = typeof dn.minWidth == "string" ? dn.minWidth : dn.minWidth + "px"), O() && z() && !Gt && (dn.minHeight = an || Q(), dn.minHeight = dn.minHeight + "px")) : s.type !== "year" && s.type !== "month" && (vt || Et) && (tn = cls(tn, `${prefixCls$C}-yam-showing`)), createVNode("div", {
        class: tn,
        key: Kt,
        style: dn,
        "x-open-type": !(Et || vt) ? "date" : Et ? "year" : "time"
      }, [un, gn, S.isRangeType() ? Qt : Et || vt ? null : Qt, yt(Kt)]);
    }
    function ue(xt, Kt) {
      Kt.stopImmediatePropagation(), S.showYearPicker(xt);
    }
    function te(xt, Kt) {
      const {
        selected: tn,
        rangeStart: ln,
        rangeEnd: rn,
        hoverDay: an,
        maxWeekNum: Gt,
        offsetRangeStart: nn,
        offsetRangeEnd: vt
      } = v, {
        weekStartsOn: Et,
        disabledDate: Qt,
        locale: un,
        localeCode: gn,
        renderDate: dn,
        renderFullDate: yn,
        startDateOffset: vn,
        endDateOffset: Pn,
        density: On,
        rangeInputFocus: _n,
        syncSwitchMonth: Nn,
        multiple: Un
      } = s;
      let Xn = "";
      if (xt) {
        const Zn = xt ? format$3(xt, "yyyy") : "", er = xt ? format$3(xt, "L") : "", bn = un && un.months && un.months[er], Ln = un.monthText;
        Xn = Ln && Ln.replace("${year}", Zn).replace("${month}", bn);
      }
      let zn = {};
      const jn = Kt === strings$f.PANEL_TYPE_RIGHT ? v.monthRight : v.monthLeft, kn = S.isRangeType(), Yn = kn && Nn;
      return kn && jn && (jn.isYearPickerOpen || jn.isTimePickerOpen) && (zn = {
        visibility: "hidden",
        position: "absolute",
        pointerEvents: "none"
      }), createVNode("div", {
        ref: (Zn) => N(`wrap-${Kt}`, Zn),
        style: zn
      }, [createVNode(navigation, {
        forwardRef: (Zn) => N(`nav-${Kt}`, Zn),
        monthText: Xn,
        density: On,
        onMonthClick: (Zn) => ue(Kt, Zn),
        onPrevMonth: () => S.prevMonth(Kt),
        onNextMonth: () => S.nextMonth(Kt),
        onNextYear: () => S.nextYear(Kt),
        onPrevYear: () => S.prevYear(Kt),
        shouldBimonthSwitch: Yn,
        panelType: Kt
      }, null), createVNode(month, {
        locale: un,
        localeCode: gn,
        forwardRef: (Zn) => N(`month-${Kt}`, Zn),
        disabledDate: Qt,
        weekStartsOn: Et,
        month: xt,
        selected: tn,
        rangeStart: ln,
        rangeEnd: rn,
        rangeInputFocus: _n,
        offsetRangeStart: nn,
        offsetRangeEnd: vt,
        hoverDay: an,
        weeksRowNum: Gt,
        renderDate: dn,
        renderFullDate: yn,
        onDayClick: (Zn) => S.handleDayClick(Zn, Kt),
        onDayHover: (Zn) => S.handleDayHover(Zn, Kt),
        onWeeksRowNumChange: (Zn) => K(Zn, Kt),
        startDateOffset: vn,
        endDateOffset: Pn,
        focusRecordsRef: s.focusRecordsRef,
        multiple: Un
      }, null)]);
    }
    const K = (xt, Kt) => {
      const tn = Kt === strings$f.PANEL_TYPE_RIGHT, ln = Kt === strings$f.PANEL_TYPE_RIGHT, rn = O() && z();
      S.isRangeType() && !rn && (v.weeksRowNum = xt, v.currentPanelHeight = Q(), nextTick(() => {
        (O() && ln || z() && tn) && ve();
      }));
    }, ve = () => {
      [`timepicker-${strings$f.PANEL_TYPE_LEFT}`, `timepicker-${strings$f.PANEL_TYPE_RIGHT}`, `yam-${strings$f.PANEL_TYPE_LEFT}`, `yam-${strings$f.PANEL_TYPE_RIGHT}`].forEach((Kt) => {
        const tn = T().getCache(Kt);
        tn && typeof tn.reselect == "function" && tn.reselect();
      });
    }, ee = () => S.getYAMOpenType();
    function Re(xt, Kt) {
      const {
        type: tn,
        locale: ln,
        format: rn,
        hideDisabledOptions: an,
        timePickerOpts: Gt,
        dateFnsLocale: nn
      } = s, {
        pickerDate: vt
      } = Kt, Et = cls(`${prefixCls$C}-time`), Qt = {
        ...Gt,
        hideDisabledOptions: an
      }, un = S.calcDisabledTime(xt);
      un && ["disabledHours", "disabledMinutes", "disabledSeconds"].forEach((_n) => {
        un[_n] && (Qt[_n] = un[_n]);
      });
      const {
        rangeStart: gn,
        rangeEnd: dn
      } = v, yn = S.getValidDateFormat();
      let vn, Pn;
      tn === "dateTimeRange" && gn && dn && isSameDay$1(vn = compatibleParse(gn, yn, void 0, nn), Pn = compatibleParse(dn, yn, void 0, nn)) && (xt === strings$f.PANEL_TYPE_RIGHT ? gn && (Qt.startDate = vn) : dn && (Qt.endDate = Pn));
      const On = ln.selectTime;
      return createVNode("div", {
        class: Et
      }, [createVNode(Combobox, mergeProps$1({
        ref: (_n) => N(`timepicker-${xt}`, _n),
        panelHeader: On,
        format: rn || strings$f.FORMAT_TIME_PICKER,
        timeStampValue: vt,
        onChange: (_n) => S.handleTimeChange(_n, xt)
      }, Qt), null)]);
    }
    function wt(xt, Kt) {
      const {
        pickerDate: tn
      } = Kt, {
        locale: ln,
        localeCode: rn,
        density: an,
        yearAndMonthOpts: Gt,
        startYear: nn,
        endYear: vt
      } = s, Et = tn.getFullYear(), Qt = tn.getMonth() + 1;
      return createVNode(yearAndMonth, {
        ref: (un) => N(`yam-${xt}`, un),
        locale: ln,
        localeCode: rn,
        currentYear: {
          left: Et,
          right: 0
        },
        currentMonth: {
          left: Qt,
          right: 0
        },
        onSelect: (un) => S.toYearMonth(xt, new Date(un.currentYear.left, un.currentMonth.left - 1)),
        onBackToMain: () => {
          S.showDatePanel(xt);
          const un = T().getCache(`wrap-${xt}`);
          un && (un.style.height = "auto");
        },
        density: an,
        yearAndMonthOpts: Gt,
        startYear: nn,
        endYear: vt
      }, null);
    }
    function yt(xt) {
      const {
        rangeStart: Kt,
        rangeEnd: tn,
        monthLeft: ln,
        monthRight: rn
      } = v, {
        type: an,
        locale: Gt,
        disabledTimePicker: nn,
        density: vt,
        dateFnsLocale: Et,
        insetInput: Qt
      } = s;
      if (!an.includes("Time") || Qt)
        return null;
      let un, gn;
      const {
        FORMAT_SWITCH_DATE: dn
      } = Gt.localeFormatToken, yn = S.getValidTimeFormat(), vn = S.getValidDateFormat();
      xt === strings$f.PANEL_TYPE_LEFT ? (un = ln, gn = Kt ? format$3(compatibleParse(Kt, vn, void 0, Et), dn) : "") : (un = rn, gn = tn ? format$3(compatibleParse(tn, vn, void 0, Et), dn) : "");
      const {
        isTimePickerOpen: Pn,
        showDate: On
      } = un, _n = On ? format$3(On, dn) : "", Nn = On ? format$3(On, yn) : "", Un = ["default"].includes(vt), Xn = cls(`${prefixCls$C}-switch`), zn = cls({
        [`${prefixCls$C}-switch-date`]: !0,
        [`${prefixCls$C}-switch-date-active`]: !Pn
      }), jn = cls({
        [`${prefixCls$C}-switch-time`]: !0,
        [`${prefixCls$C}-switch-time-disabled`]: nn,
        [`${prefixCls$C}-switch-date-active`]: Pn
      }), kn = cls(`${prefixCls$C}-switch-text`);
      return createVNode("div", {
        class: Xn,
        ref: (Yn) => T().setCache(`switch-${xt}`, Yn)
      }, [createVNode("div", {
        role: "button",
        "aria-label": "Switch to date panel",
        class: zn,
        onClick: (Yn) => S.showDatePanel(xt)
      }, [Un && createVNode(IconComponent$G, {
        "aria-hidden": !0
      }, null), createVNode("span", {
        class: kn
      }, [gn || _n])]), createVNode("div", {
        role: "button",
        "aria-label": "Switch to time panel",
        class: jn,
        onClick: (Yn) => S.showTimePicker(xt, !0)
      }, [Un && createVNode(IconComponent$v, {
        "aria-hidden": !0
      }, null), createVNode("span", {
        class: kn
      }, [Nn])])]);
    }
    return () => {
      const {
        monthLeft: xt,
        monthRight: Kt
      } = v, {
        type: tn,
        insetInput: ln,
        presetPosition: rn,
        renderQuickControls: an,
        renderDateInput: Gt
      } = s, nn = cls({
        [`${prefixCls$C}-month-grid`]: !0
      }), vt = strings$f.PANEL_TYPE_LEFT, Et = strings$f.PANEL_TYPE_RIGHT;
      let Qt = null;
      tn === "date" || tn === "dateTime" ? Qt = W(xt.pickerDate, vt) : tn === "dateRange" || tn === "dateTimeRange" ? Qt = [W(xt.pickerDate, vt), W(Kt.pickerDate, Et)] : (tn === "year" || tn === "month") && (Qt = "year month");
      const un = ee();
      return createVNode("div", {
        style: {
          display: "flex"
        }
      }, [rn === "left" && an, createVNode("div", null, [Gt, createVNode("div", {
        class: nn,
        "x-type": tn,
        "x-panel-yearandmonth-open-type": un,
        "x-insetinput": ln ? "true" : "false",
        "x-preset-position": an === null ? "null" : rn,
        ref: (gn) => N("monthGrid", gn)
      }, [Qt])]), rn === "right" && an]);
    };
  }
}), prefixCls$B = cssClasses$I.PREFIX, propTypes$1q = {
  presets: {
    type: array$1,
    required: !0
  },
  presetPosition: {
    type: string$3,
    required: !0
  },
  onPresetClick: {
    type: func,
    required: !0
  },
  type: {
    type: string$3,
    required: !0
  },
  insetInput: {
    type: [bool, object$1],
    required: !0
  },
  locale: {
    type: object$1,
    required: !0
  }
}, defaultProps$1k = {
  presets: [],
  presetPosition: "bottom",
  onPresetClick: noop$1
}, vuePropsType$2i = vuePropsMake(propTypes$1q, defaultProps$1k), quickControl = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2i
  },
  name: "DatePicker_quickControl",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        presets: o,
        onPresetClick: l,
        type: u,
        presetPosition: c,
        insetInput: m,
        locale: g
      } = s, v = u === "dateRange" || u === "dateTimeRange", b = c === "top" || c === "bottom", S = u === "month", E = b && v, P = b && S, T = cls(`${prefixCls$B}-quick-control`, {
        [`${prefixCls$B}-quick-control-${u}`]: u,
        [`${prefixCls$B}-quick-control-${c}`]: !0
      }), N = cls({
        [`${prefixCls$B}-quick-control-header`]: !0
      }), O = cls({
        [`${prefixCls$B}-quick-control-${c}-content-wrapper`]: !0
      }), z = cls({
        [`${prefixCls$B}-quick-control-${c}-content`]: !E && !P,
        [`${prefixCls$B}-quick-control-${c}-range-content`]: E,
        [`${prefixCls$B}-quick-control-${c}-month-content`]: P
      }), Q = cls({
        [`${prefixCls$B}-quick-control-${c}-content-item`]: !E && !P,
        [`${prefixCls$B}-quick-control-${c}-range-content-item`]: E,
        [`${prefixCls$B}-quick-control-${c}-month-content-item`]: P
      }), W = cls({
        [`${prefixCls$B}-quick-control-${c}-content-item-ellipsis`]: !E && !P,
        [`${prefixCls$B}-quick-control-${c}-range-content-item-ellipsis`]: E,
        [`${prefixCls$B}-quick-control-${c}-month-content-item-ellipsis`]: P
      });
      return o.length ? createVNode("div", {
        class: T,
        "x-insetinput": m ? "true" : "false"
      }, [!b && createVNode("div", {
        class: N
      }, [g.presets]), createVNode("div", {
        class: O
      }, [createVNode("div", {
        class: z
      }, [o.map((ue, te) => {
        const K = typeof ue == "function" ? ue() : ue;
        return createVNode(Button$2, {
          size: "small",
          type: "primary",
          onClick: (ve) => l(typeof ue == "function" ? ue() : ue, ve),
          key: te
        }, {
          default: () => [createVNode("div", {
            class: Q
          }, [createVNode(TypographyText, {
            ellipsis: {
              showTooltip: !0
            },
            class: W
          }, {
            default: () => [K.text]
          })])]
        });
      })])])]) : null;
    };
  }
});
function _isSlot$E(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propsType$1 = {
  prefixCls: String,
  locale: {
    type: Object,
    required: !0
  },
  localeCode: {
    type: String,
    required: !0
  },
  onCancelClick: Function,
  onConfirmClick: Function
}, vuePropsType$2h = vuePropsMake(propsType$1, {}), Footer$2 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2h
  },
  name: "Footer",
  setup(s, {
    attrs: o
  }) {
    return useSlots(), () => {
      let l, u;
      const {
        prefixCls: c,
        locale: m,
        onCancelClick: g,
        onConfirmClick: v
      } = s, b = cls(`${c}-footer`);
      return createVNode("div", {
        class: b
      }, [createVNode(Button$2, {
        theme: "borderless",
        onClick: g
      }, _isSlot$E(l = lodashExports.get(m, "footer.cancel", "")) ? l : {
        default: () => [l]
      }), createVNode(Button$2, {
        theme: "solid",
        onClick: v
      }, _isSlot$E(u = lodashExports.get(m, "footer.confirm", "")) ? u : {
        default: () => [u]
      })]);
    };
  }
});
function _isSlot$D(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const triggerPropsKeys = Object.keys(vuePropsType$2E), propTypes$1p = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": [bool, string$3],
  "aria-labelledby": string$3,
  "aria-required": bool,
  borderless: bool,
  type: String,
  size: String,
  density: String,
  defaultValue: [string$3, number$2, object$1, array$1],
  value: [string$3, number$2, object$1, array$1],
  defaultPickerValue: [string$3, number$2, object$1, array$1],
  disabledTime: func,
  disabledTimePicker: bool,
  hideDisabledOptions: bool,
  format: string$3,
  disabled: bool,
  multiple: bool,
  max: number$2,
  // only work when multiple is true
  placeholder: [string$3, array$1],
  presets: array$1,
  onChange: func,
  onChangeWithDateFirst: bool,
  weekStartsOn: number$2,
  disabledDate: func,
  timePickerOpts: object$1,
  // When dateTime, dateTimeRange, pass through the props to timePicker
  showClear: bool,
  // Whether to show the clear button
  onOpenChange: func,
  open: bool,
  defaultOpen: bool,
  motion: [bool, func, object$1],
  className: string$3,
  prefixCls: string$3,
  prefix: node$1,
  insetLabel: node$1,
  insetLabelId: string$3,
  zIndex: number$2,
  position: String,
  getPopupContainer: func,
  onCancel: func,
  onConfirm: func,
  needConfirm: bool,
  inputStyle: object$1,
  timeZone: [string$3, number$2],
  triggerRender: func,
  stopPropagation: [bool, string$3],
  autoAdjustOverflow: bool,
  onBlur: func,
  onFocus: func,
  onClear: func,
  style: object$1,
  autoFocus: bool,
  inputReadOnly: bool,
  // Text box can be entered
  validateStatus: String,
  renderDate: func,
  renderFullDate: func,
  spacing: number$2,
  startDateOffset: func,
  endDateOffset: func,
  autoSwitchDate: bool,
  dropdownClassName: string$3,
  dropdownStyle: object$1,
  topSlot: [func, ...node$1],
  bottomSlot: [func, ...node$1],
  dateFnsLocale: object$1,
  // isRequired, but no need to add isRequired key. ForwardStatics function pass static properties to index.jsx, so there is no need for user to pass the prop.
  // Support synchronous switching of months
  syncSwitchMonth: bool,
  // Callback function for panel date switching
  onPanelChange: func,
  rangeSeparator: string$3,
  preventScroll: bool,
  yearAndMonthOpts: object$1,
  locale: Object,
  clearIcon: node$1,
  presetPosition: string$3,
  dropdownMargin: oneOfType([number$2, object$1]),
  id: string$3,
  onPresetClick: func,
  onClickOutSide: func,
  localeCode: string$3,
  insetInput: [bool, object$1],
  startYear: number$2,
  endYear: number$2
}, defaultProps$1j = {
  onChangeWithDateFirst: !0,
  borderless: !1,
  autoAdjustOverflow: !0,
  stopPropagation: !0,
  motion: !0,
  prefixCls: cssClasses$I.PREFIX,
  presetPosition: "bottom",
  // position: 'bottomLeft',
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  type: "date",
  size: "default",
  density: "default",
  multiple: !1,
  defaultOpen: !1,
  disabledHours: lodashExports.noop,
  disabledMinutes: lodashExports.noop,
  disabledSeconds: lodashExports.noop,
  hideDisabledOptions: !1,
  onBlur: lodashExports.noop,
  onFocus: lodashExports.noop,
  onClear: lodashExports.noop,
  onCancel: lodashExports.noop,
  onConfirm: lodashExports.noop,
  onChange: lodashExports.noop,
  onOpenChange: lodashExports.noop,
  onPanelChange: lodashExports.noop,
  onPresetClick: lodashExports.noop,
  weekStartsOn: numbers$d.WEEK_START_ON,
  disabledDate: lodashExports.stubFalse,
  disabledTime: lodashExports.stubFalse,
  inputReadOnly: !1,
  spacing: numbers$d.SPACING,
  autoSwitchDate: !0,
  syncSwitchMonth: !1,
  rangeSeparator: strings$f.DEFAULT_SEPARATOR_RANGE,
  insetInput: !1,
  onClickOutSide: lodashExports.noop
}, vuePropsTypeDatePickerProps = vuePropsMake(propTypes$1p, defaultProps$1j), DatePicker$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsTypeDatePickerProps
  },
  name: "DatePicker",
  setup(s, {
    expose: o
  }) {
    useSlots();
    let l;
    const u = reactive({
      panelShow: s.open || s.defaultOpen,
      isRange: !1,
      inputValue: null,
      // Staging input values
      value: [],
      // The currently selected date, each date is a Date object
      cachedSelectedValue: [],
      // Save last selected date, maybe include null
      prevTimeZone: null,
      rangeInputFocus: void 0,
      // Optional'rangeStart ',' rangeEnd ', false
      autofocus: s.autoFocus || W(s.type, s.triggerRender) && (s.open || s.defaultOpen),
      insetInputValue: null,
      triggerDisabled: void 0
    }), c = ref$1(), m = ref$1(), g = ref$1(), v = ref$1(), b = ref$1(), S = ref$1(), E = ref$1({
      rangeStart: !1,
      rangeEnd: !1
    }), {
      adapter: P,
      isControlled: T,
      getDataAttr: N
    } = useBaseComponent(s, u);
    function O() {
      return {
        ...P(),
        togglePanel: (bn, Ln) => {
          u.panelShow = bn, bn || (E.value.rangeEnd = !1, E.value.rangeStart = !1), nextTick(Ln);
        },
        registerClickOutSide: () => {
          l && (z.unregisterClickOutSide(), l = null), l = (bn) => {
            const Ln = c.value, Kn = m.value, Bn = bn.target, Fn = bn.composedPath && bn.composedPath() || [Bn];
            !(Ln && Ln.contains(Bn)) && !(Kn && Kn.contains(Bn)) && !(Fn.includes(Ln) || Fn.includes(Kn)) && (s.onClickOutSide(), z.needConfirm() || Q.closePanel(bn));
          }, document.addEventListener("mousedown", l);
        },
        unregisterClickOutSide: () => {
          document.removeEventListener("mousedown", l);
        },
        notifyBlur: (...bn) => s.onBlur(...bn),
        notifyFocus: (...bn) => {
          s.onFocus(...bn);
        },
        notifyClear: (...bn) => s.onClear(...bn),
        notifyChange: (...bn) => s.onChange(...bn),
        notifyCancel: (...bn) => s.onCancel(...bn),
        notifyConfirm: (...bn) => s.onConfirm(...bn),
        notifyOpenChange: (...bn) => s.onOpenChange(...bn),
        notifyPresetsClick: (...bn) => s.onPresetClick(...bn),
        updateValue: (bn) => u.value = bn,
        updatePrevTimezone: (bn) => u.prevTimeZone = bn,
        updateCachedSelectedValue: (bn) => {
          let Ln = bn;
          bn && !Array.isArray(bn) && (Ln = [...bn]), u.cachedSelectedValue = Ln;
        },
        updateInputValue: (bn) => {
          u.inputValue = bn;
        },
        updateInsetInputValue: (bn) => {
          const {
            insetInput: Ln
          } = s;
          Ln && !lodashExports.isEqual(bn, u.insetInputValue) && (u.insetInputValue = bn);
        },
        needConfirm: () => ["dateTime", "dateTimeRange"].includes(s.type) && s.needConfirm === !0,
        typeIsYearOrMonth: () => ["month", "year", "monthRange"].includes(s.type),
        // setMotionEnd: motionEnd => state.motionEnd = motionEnd,
        setRangeInputFocus: (bn) => {
          const {
            preventScroll: Ln
          } = s;
          switch (bn !== u.rangeInputFocus && (u.rangeInputFocus = bn), bn) {
            case "rangeStart":
              const Kn = b.value;
              Kn && Kn.focus({
                preventScroll: Ln
              }), setTimeout(() => {
                E.value.rangeStart = !0;
              }, 0);
              break;
            case "rangeEnd":
              const Bn = S.value;
              Bn && Bn.focus({
                preventScroll: Ln
              }), setTimeout(() => {
                E.value.rangeEnd = !0;
              }, 0);
              break;
            default:
              return;
          }
        },
        couldPanelClosed: () => E.value.rangeStart && E.value.rangeEnd,
        isEventTarget: (bn) => bn && bn.target === bn.currentTarget,
        setInsetInputFocus: () => {
          const {
            preventScroll: bn
          } = s, {
            rangeInputFocus: Ln
          } = u;
          switch (Ln) {
            case "rangeEnd":
              if (document.activeElement !== S.value) {
                const Kn = S.value;
                Kn && Kn.focus({
                  preventScroll: bn
                });
              }
              break;
            case "rangeStart":
            default:
              if (document.activeElement !== S.value) {
                const Kn = b.value;
                Kn && Kn.focus({
                  preventScroll: bn
                });
              }
              break;
          }
        },
        setInputFocus: () => {
          const {
            preventScroll: bn
          } = s, Ln = v.value;
          Ln && Ln.focus({
            preventScroll: bn
          });
        },
        setInputBlur: () => {
          const bn = v.value;
          bn && bn.blur();
        },
        setRangeInputBlur: () => {
          const {
            rangeInputFocus: bn
          } = u;
          if (bn === "rangeStart") {
            const Ln = b.value;
            Ln && Ln.blur();
          } else if (bn === "rangeEnd") {
            const Ln = S.value;
            Ln && Ln.blur();
          }
          z.setRangeInputFocus(!1);
        },
        setTriggerDisabled: (bn) => {
          u.triggerDisabled = bn;
        }
      };
    }
    const z = O(), Q = new DatePickerFoundation(z);
    z.setCache("cachedSelectedValue", null);
    function W(bn, Ln) {
      return /range/i.test(bn) && !lodashExports.isFunction(Ln);
    }
    watch(() => s.value, (bn, Ln, Kn) => {
      ue([Ln, s.timeZone]);
    }, {
      immediate: !0
    }), watch(() => s.timeZone, (bn, Ln, Kn) => {
      ue([s.value, Ln]);
    }, {
      immediate: !0
    });
    function ue([bn, Ln]) {
      lodashExports.isEqual(bn, s.value) ? s.timeZone !== Ln && Q.initFromProps({
        value: u.value,
        timeZone: s.timeZone,
        prevTimeZone: Ln
      }) : Q.initFromProps({
        ...s
      });
    }
    watch(() => s.open, () => {
      Q.initPanelOpenStatus(), s.open || Q.clearRangeInputFocus();
    }, {
      immediate: !0
    }), onMounted(() => {
    }), onUnmounted(() => {
    });
    function te() {
      Q.open();
    }
    function K() {
      Q.close();
    }
    function ve(bn) {
      Q.focus(bn);
    }
    function ee() {
      Q.blur();
    }
    o({
      open: te,
      close: K,
      focus: ve,
      blur: ee
    });
    const Re = (bn) => c.value = bn, wt = (bn, Ln) => Q.handleSelectedChange(bn, Ln), yt = (bn) => Q.handleYMSelectedChange(bn), xt = (bn, ...Ln) => Q.disabledDisposeDate(bn, ...Ln), Kt = (bn, ...Ln) => Q.disabledDisposeTime(bn, ...Ln);
    function tn(bn, Ln, Kn) {
      const {
        type: Bn,
        multiple: Fn,
        max: Gn,
        weekStartsOn: Wn,
        timePickerOpts: Mn,
        defaultPickerValue: Tn,
        format: Rn,
        hideDisabledOptions: hn,
        disabledTimePicker: Qn,
        renderDate: rr,
        renderFullDate: tr,
        startDateOffset: Cr,
        endDateOffset: Fr,
        autoSwitchDate: An,
        density: Hn,
        syncSwitchMonth: ir,
        onPanelChange: dr,
        timeZone: ar,
        triggerRender: Or,
        insetInput: Sr,
        presetPosition: kr,
        yearAndMonthOpts: Nr,
        startYear: Ur,
        endYear: _r
      } = s, {
        cachedSelectedValue: Zr,
        rangeInputFocus: Jr
      } = u;
      return createVNode(monthsGrid, {
        ref: g,
        locale: bn,
        localeCode: Ln,
        dateFnsLocale: Kn,
        weekStartsOn: Wn,
        type: Bn,
        multiple: Fn,
        max: Gn,
        format: Rn,
        disabledDate: xt,
        hideDisabledOptions: hn,
        disabledTimePicker: Qn,
        disabledTime: Kt,
        defaultValue: Zr,
        defaultPickerValue: Tn,
        timePickerOpts: Mn,
        isControlledComponent: !z.needConfirm() && T("value"),
        onChange: wt,
        renderDate: rr,
        renderFullDate: tr,
        startDateOffset: Cr,
        endDateOffset: Fr,
        autoSwitchDate: An,
        density: Hn,
        rangeInputFocus: Jr,
        setRangeInputFocus: gn,
        isAnotherPanelHasOpened: Pn,
        syncSwitchMonth: ir,
        onPanelChange: dr,
        timeZone: ar,
        focusRecordsRef: E,
        triggerRender: Or,
        insetInput: Sr,
        presetPosition: kr,
        renderQuickControls: ln(),
        renderDateInput: rn(),
        yearAndMonthOpts: Nr,
        startYear: Ur,
        endYear: _r
      }, null);
    }
    function ln() {
      const {
        presets: bn,
        type: Ln,
        presetPosition: Kn,
        insetInput: Bn,
        locale: Fn
      } = s;
      return createVNode(quickControl, {
        type: Ln,
        presets: bn,
        insetInput: Bn,
        presetPosition: Kn,
        onPresetClick: (Gn, Wn) => Q.handlePresetClick(Gn, Wn),
        locale: Fn
      }, null);
    }
    function rn() {
      const {
        insetInput: bn,
        dateFnsLocale: Ln,
        density: Kn,
        type: Bn,
        format: Fn,
        rangeSeparator: Gn,
        defaultPickerValue: Wn
      } = s, {
        insetInputValue: Mn,
        value: Tn
      } = u;
      return bn ? createVNode(dateInput, mergeProps$1({
        dateFnsLocale: Ln,
        format: Fn,
        insetInputValue: Mn,
        rangeSeparator: Gn,
        type: Bn,
        value: Tn,
        handleInsetDateFocus: On,
        handleInsetTimeFocus: _n,
        onInsetInputChange: Gt,
        rangeInputStartRef: b,
        rangeInputEndRef: S,
        density: Kn,
        defaultPickerValue: Wn
      }, {
        insetInput: bn
      }), null) : null;
    }
    const an = (...bn) => Q.handleInputChange(...bn), Gt = (bn) => Q.handleInsetInputChange(bn), nn = (bn) => Q.handleInputComplete(bn), vt = (bn) => Q.handleInputBlur(lodashExports.get(bn, "target.value"), bn), Et = (...bn) => {
      Q.handleInputFocus(...bn);
    }, Qt = (bn) => Q.handleInputClear(bn), un = (bn) => {
      Q.handleTriggerWrapperClick(bn);
    }, gn = (bn) => Q.handleSetRangeFocus(bn), dn = (bn, Ln) => Q.handleRangeInputBlur(bn, Ln), yn = (bn) => Q.handleRangeInputClear(bn), vn = (bn) => Q.handleRangeEndTabPress(bn), Pn = (bn) => bn === "rangeStart" ? E.value.rangeEnd : E.value.rangeStart, On = (bn, Ln) => {
      const Kn = lodashExports.get(this, "monthGrid.current.foundation");
      Kn && (Kn.showDatePanel(strings$f.PANEL_TYPE_LEFT), Kn.showDatePanel(strings$f.PANEL_TYPE_RIGHT)), Et(bn, Ln);
    }, _n = () => {
      const bn = lodashExports.get(this, "monthGrid.current.foundation");
      bn && (bn.showTimePicker(strings$f.PANEL_TYPE_LEFT), bn.showTimePicker(strings$f.PANEL_TYPE_RIGHT));
    }, Nn = (bn) => {
      Q.handlePanelVisibleChange(bn);
    };
    function Un(bn) {
      const {
        clearIcon: Ln,
        type: Kn,
        format: Bn,
        multiple: Fn,
        disabled: Gn,
        showClear: Wn,
        insetLabel: Mn,
        insetLabelId: Tn,
        placeholder: Rn,
        validateStatus: hn,
        inputStyle: Qn,
        prefix: rr,
        locale: tr,
        dateFnsLocale: Cr,
        triggerRender: Fr,
        size: An,
        inputReadOnly: Hn,
        rangeSeparator: ir,
        insetInput: dr,
        defaultPickerValue: ar,
        borderless: Or
      } = s, {
        value: Sr,
        inputValue: kr,
        rangeInputFocus: Nr,
        triggerDisabled: Ur
      } = u, _r = W(Kn, Fr), Zr = Gn || dr && Ur, Jr = cls(`${cssClasses$I.PREFIX}-input`, {
        [`${cssClasses$I.PREFIX}-range-input`]: _r,
        [`${cssClasses$I.PREFIX}-range-input-${An}`]: _r && An,
        [`${cssClasses$I.PREFIX}-range-input-active`]: _r && Nr && !Zr,
        [`${cssClasses$I.PREFIX}-range-input-disabled`]: _r && Zr,
        [`${cssClasses$I.PREFIX}-range-input-${hn}`]: _r && hn,
        [`${cssClasses$I.PREFIX}-borderless`]: Or
      }), ii = Rn || tr.placeholder[Kn], Ti = {
        ...bn,
        showClearIgnoreDisabled: !!dr,
        placeholder: ii,
        clearIcon: Ln,
        disabled: Zr,
        inputValue: kr,
        value: Sr,
        defaultPickerValue: ar,
        onChange: an,
        onEnterPress: nn,
        // TODO: remove in next major version
        block: !0,
        inputStyle: Qn,
        showClear: Wn,
        insetLabel: Mn,
        insetLabelId: Tn,
        type: Kn,
        format: Bn,
        multiple: Fn,
        validateStatus: hn,
        inputReadOnly: Hn || !!dr,
        // onClick: handleOpenPanel,
        onBlur: vt,
        onFocus: Et,
        onClear: Qt,
        prefix: rr,
        size: An,
        autofocus: u.autofocus,
        dateFnsLocale: Cr,
        rangeInputFocus: Nr,
        rangeSeparator: ir,
        onRangeBlur: dn,
        onRangeClear: yn,
        onRangeEndTabPress: vn,
        rangeInputStartRef: dr ? null : b,
        rangeInputEndRef: dr ? null : S
      };
      return createVNode("div", {
        role: "combobox",
        "aria-label": Array.isArray(Sr) && Sr.length ? "Change date" : "Choose date",
        "aria-disabled": Gn,
        onClick: un,
        class: Jr
      }, [typeof Fr == "function" ? createVNode(Index$6, mergeProps$1(lodashExports.pick(Ti, ...triggerPropsKeys), {
        triggerRender: Fr,
        componentName: "DatePicker",
        componentProps: {
          ...z.getProps()
        }
      }), null) : createVNode(dateInput, Ti, null)]);
    }
    const Xn = (bn) => Q.handleConfirm(), zn = (bn) => Q.handleCancel(), jn = (bn, Ln) => z.needConfirm() ? createVNode(Footer$2, {
      prefixCls: s.prefixCls,
      locale: bn,
      localeCode: Ln,
      onConfirmClick: Xn,
      onCancelClick: zn
    }, null) : null, kn = (bn, Ln, Kn) => {
      const {
        dropdownClassName: Bn,
        dropdownStyle: Fn,
        density: Gn,
        topSlot: Wn,
        bottomSlot: Mn,
        presetPosition: Tn,
        type: Rn
      } = s, hn = cls(cssClasses$I.PREFIX, {
        [cssClasses$I.PANEL_YAM]: z.typeIsYearOrMonth(),
        [`${cssClasses$I.PREFIX}-compact`]: Gn === "compact"
      }, Bn);
      return createVNode("div", {
        ref: m,
        class: hn,
        style: Fn,
        "x-type": Rn
      }, [Wn && createVNode("div", {
        class: `${cssClasses$I.PREFIX}-topSlot`,
        "x-semi-prop": "topSlot"
      }, [typeof Wn == "function" ? Wn() : Wn]), Tn === "top" && Rn !== "monthRange" && ln(), z.typeIsYearOrMonth() ? Yn(bn, Ln) : tn(bn, Ln, Kn), Tn === "bottom" && Rn !== "monthRange" && ln(), Mn && createVNode("div", {
        class: `${cssClasses$I.PREFIX}-bottomSlot`,
        "x-semi-prop": "bottomSlot"
      }, [typeof Mn == "function" ? Mn() : Mn]), jn(bn, Ln)]);
    }, Yn = (bn, Ln) => {
      const {
        density: Kn,
        presetPosition: Bn,
        yearAndMonthOpts: Fn,
        type: Gn,
        startYear: Wn,
        endYear: Mn
      } = s, Tn = u.value[0], Rn = {
        left: 0,
        right: 0
      }, hn = {
        left: 0,
        right: 0
      };
      if (lodashExports.isDate(Tn) && (Rn.left = Tn.getFullYear(), hn.left = Tn.getMonth() + 1), Gn === "monthRange") {
        const Qn = u.value[1];
        lodashExports.isDate(Qn) && (Rn.right = Qn.getFullYear(), hn.right = Qn.getMonth() + 1);
      }
      return createVNode(yearAndMonth, {
        locale: bn,
        localeCode: Ln,
        disabledDate: xt,
        noBackBtn: !0,
        monthCycled: !0,
        onSelect: yt,
        currentYear: Rn,
        currentMonth: hn,
        density: Kn,
        presetPosition: Bn,
        renderQuickControls: ln(),
        renderDateInput: rn(),
        type: Gn,
        yearAndMonthOpts: Fn,
        startYear: Wn,
        endYear: Mn
      }, null);
    }, {
      context: Zn
    } = useConfigContext(), er = (bn) => {
      const {
        panelShow: Ln
      } = u, Bn = Zn.value.direction === "rtl" ? "bottomRight" : "bottomLeft", {
        motion: Fn,
        zIndex: Gn,
        position: Wn = Bn,
        getPopupContainer: Mn,
        locale: Tn,
        localeCode: Rn,
        dateFnsLocale: hn,
        stopPropagation: Qn,
        autoAdjustOverflow: rr,
        spacing: tr,
        dropdownMargin: Cr
      } = s;
      return createVNode(Popover$1, {
        getPopupContainer: Mn,
        autoAdjustOverflow: rr,
        zIndex: Gn,
        motion: Fn,
        margin: Cr,
        content: kn(Tn, Rn, hn),
        trigger: "custom",
        position: Wn,
        visible: Ln,
        stopPropagation: Qn,
        spacing: tr,
        onVisibleChange: Nn
      }, _isSlot$D(bn) ? bn : {
        default: () => [bn]
      });
    };
    return () => {
      const {
        style: bn,
        className: Ln,
        prefixCls: Kn,
        type: Bn,
        ...Fn
      } = s, Gn = {
        style: bn,
        class: cls(Ln, {
          [Kn]: !0
        }),
        ref: Re,
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-required": s["aria-required"],
        ...N()
      }, Wn = [];
      Bn.toLowerCase().includes("range") || Wn.push("borderless");
      const Mn = Un(lodashExports.pick(s, Wn)), Tn = er(Mn);
      return createVNode("div", Gn, [Tn]);
    };
  }
}), DatePicker$2 = DatePicker$1, vuePropsType$2g = {
  ...vuePropsTypeDatePickerProps
  // forwardRef: [Object, Function],
}, index$9 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2g
  },
  name: "DatePickerIndex",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const {
      getProps: l
    } = useHasInProps(), u = ref$1();
    return o({
      open: () => {
        var c;
        return (c = u.value) == null ? void 0 : c.open();
      },
      close: () => {
        var c;
        return (c = u.value) == null ? void 0 : c.close();
      },
      focus: () => {
        var c;
        return (c = u.value) == null ? void 0 : c.focus();
      },
      blur: () => {
        var c;
        return (c = u.value) == null ? void 0 : c.blur();
      }
    }), () => {
      const c = l(s), {
        type: m,
        format: g,
        rangeSeparator: v
      } = c;
      return typeof g == "string" && g && (/[Hhms]+/.test(g) || (m === "dateTime" ? c.type = "date" : m === "dateTimeRange" && (c.type = "dateRange"))), v && typeof v == "string" && (c.rangeSeparator = ` ${v.trim()} `), c.insetInput && (c.position || (c.position = strings$f.POSITION_INLINE_INPUT), c.position.includes("Over") && !c.spacing && (c.spacing = numbers$d.SPACING_INSET_INPUT)), createVNode(ConfigContext.Consumer, null, {
        default: ({
          timeZone: b
        }) => createVNode(LocaleConsumer$6, {
          componentName: "DatePicker"
        }, {
          default: (S, E, P) => createVNode(DatePicker$2, mergeProps$1({
            ...c,
            timeZone: b,
            localeCode: E,
            locale: S,
            dateFnsLocale: P
          }, {
            ref: u
          }), null)
        })
      });
    };
  }
}), DatePicker = index$9, cssClasses$F = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-empty`
};
function _isSlot$C(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$A = cssClasses$F.PREFIX, vuePropsType$2f = {
  layout: {
    type: String,
    default: "vertical"
  },
  imageStyle: [Object, String],
  title: [Object, String],
  description: [Object, String],
  image: [Object, String],
  darkModeImage: [Object, String],
  style: [Object, String],
  className: [String]
}, Empty = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2f
  },
  name: "Empty",
  setup(s) {
    const {
      getProps: o
    } = useHasInProps(), l = useAttrs();
    let u, c;
    const m = reactive({
      mode: null
    });
    onMounted(() => {
      if (s.darkModeImage) {
        u = window.document.body, v();
        const S = {
          attributes: !0,
          childList: !1,
          subtree: !1
        };
        c = new MutationObserver(g), c.observe(u, S);
      }
    }), onUnmounted(() => {
      c && c.disconnect();
    });
    const g = (S) => {
      for (const E of S)
        E.type === "attributes" && E.attributeName === "theme-mode" && v();
    }, v = () => {
      const S = u.getAttribute("theme-mode");
      S !== m.mode && (m.mode = S);
    }, b = useSlots();
    return () => {
      const S = b.default ? b.default() : null, {
        className: E,
        image: P,
        description: T,
        style: N,
        title: O,
        imageStyle: z,
        layout: Q,
        darkModeImage: W,
        ...ue
      } = o(s), te = typeof T == "string" ? T : "empty", K = m.mode && W ? W : P;
      let ve = null;
      typeof K == "string" ? ve = createVNode("img", {
        alt: te,
        src: K
      }, null) : K && "id" in K ? ve = createVNode("svg", {
        "aria-hidden": "true"
      }, [createVNode("use", {
        "xlink:href": `#${K.id}`
      }, null)]) : ve = K;
      const ee = cls(E, prefixCls$A, {
        [`${prefixCls$A}-${Q}`]: Q
      }), Re = ve ? {
        heading: 4
      } : {
        heading: 6,
        style: {
          fontWeight: 400
        }
      };
      return createVNode("div", mergeProps$1({
        class: ee,
        style: N
      }, getDataAttr({
        ...ue,
        ...l
      })), [createVNode("div", {
        class: `${prefixCls$A}-image`,
        style: z
      }, [ve]), createVNode("div", {
        class: `${prefixCls$A}-content`
      }, [O ? createVNode(TypographyTitle, mergeProps$1(Re, {
        className: `${prefixCls$A}-title`
      }), _isSlot$C(O) ? O : {
        default: () => [O]
      }) : null, T ? createVNode("div", {
        class: `${prefixCls$A}-description`
      }, [T]) : null, S ? createVNode("div", {
        class: `${prefixCls$A}-footer`
      }, [S]) : null])]);
    };
  }
}), Empty$1 = Empty, cssClasses$E = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-select`,
  PREFIX_OPTION: `${BASE_CLASS_PREFIX$1}-select-option`,
  PREFIX_GROUP: `${BASE_CLASS_PREFIX$1}-select-group`
}, strings$d = {
  SIZE_SET: ["small", "large", "default"],
  POSITION_SET: strings$q.POSITION_SET,
  MODE_SELECT: "select",
  MODE_AUTOCOMPLETE: "autoComplete",
  // MODE_TAGS: 'tags',
  STATUS: VALIDATE_STATUS,
  SEARCH_POSITION_TRIGGER: "trigger",
  SEARCH_POSITION_DROPDOWN: "dropdown"
}, numbers$b = { LIST_HEIGHT: 270 };
class SelectFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this._keydownHandler = null;
  }
  init() {
    this._setDropdownWidth();
    const o = this.getProp("defaultOpen"), l = this.getProp("open"), u = this._collectOptions();
    this._setDefaultSelection(u), (o || l) && this.open(void 0, u), this.getProp("autoFocus") && this.focus();
  }
  focus() {
    const o = this._isFilterable(), l = this._isMultiple();
    this._adapter.updateFocusState(!0), this._adapter.setIsFocusInContainer(!1), o && l ? this.focusInput() : o && !l ? this.toggle2SearchInput(!0) : this._focusTrigger();
  }
  _focusTrigger() {
    this._adapter.focusTrigger();
  }
  destroy() {
    this._adapter.unregisterClickOutsideHandler();
  }
  _setDropdownWidth() {
    const { style: o, dropdownMatchSelectWidth: l } = this.getProps();
    let u;
    l && (o && lodashExports.isNumber(o.width) || o && lodashExports.isString(o.width) && !o.width.includes("%") ? u = o.width : u = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(u));
  }
  _collectOptions() {
    const o = this._adapter.getOptionsFromChildren();
    return this._adapter.updateOptions(o), this._adapter.rePositionDropdown(), o;
  }
  _setDefaultSelection(o) {
    let { value: l } = this.getProps();
    const { defaultValue: u } = this.getProps();
    this._isControlledComponent() || (l = u), this._update(l, o);
  }
  // call when props.optionList change
  handleOptionListChange() {
    const o = this._collectOptions(), { selections: l } = this.getStates();
    this.updateOptionsActiveStatus(l, o);
    const { defaultActiveFirstOption: u } = this.getProps();
    u && this._adapter.updateFocusIndex(0);
  }
  // In uncontrolled mode, when props.optionList change,
  // but already had defaultValue or choose some option
  handleOptionListChangeHadDefaultValue() {
    const o = this.getState("selections");
    let l;
    const { onChangeWithObject: u } = this.getProps(), c = this._isMultiple();
    switch (!0) {
      case (c && !!o.size):
        try {
          l = [...o].map(
            (g) => (
              // At this point item1 is directly the object
              u ? g[1] : g[1].value
            )
          );
        } catch {
          l = [];
        }
        break;
      case (c && !o.size):
        l = [];
        break;
      case (!c && !!o.size):
        try {
          l = u ? [...o][0][1] : [...o][0][1].value;
        } catch {
        }
        break;
      case (!c && !o.size):
        break;
    }
    const m = this._adapter.getOptionsFromChildren();
    this._update(l, m);
  }
  // call when props.value change
  handleValueChange(o) {
    const { allowCreate: l, autoClearSearchValue: u, remote: c } = this.getProps(), { inputValue: m } = this.getStates();
    let g;
    l && this._isControlledComponent() ? (g = this.getState("options"), g.forEach((v) => v._show = !0)) : g = this._adapter.getOptionsFromChildren(), this._adapter.rePositionDropdown(), this._isFilterable() && !u && m && !c && (g = this._filterOption(g, m)), this._update(o, g);
  }
  // Update the selected item in the selection box
  _update(o, l) {
    let u;
    this._isMultiple() ? (u = this._updateMultiple(o, l), this.updateOverflowItemCount(u.size)) : u = this._updateSingle(o, l), this._adapter.updateSelection(u), this.updateOptionsActiveStatus(u, l);
  }
  // Optionally selected updates (when components are mounted, or after value changes)
  _updateSingle(o, l) {
    const u = /* @__PURE__ */ new Map(), { onChangeWithObject: c } = this.getProps(), m = c && typeof o < "u" ? o.value : o, g = l.filter((b) => b.value === m), v = !g.length && typeof m < "u" && m !== null;
    if (g.length) {
      const S = { ...g[0] };
      u.set(S.label, S);
    } else if (v) {
      let b = { value: o, label: o, _notExist: !0, _scrollIndex: -1 };
      c && (b = { ...o, _notExist: !0, _scrollIndex: -1 }), u.set(b.label, b);
    }
    return u;
  }
  // Multi-selected option update (when the component is mounted, or after the value changes)
  _updateMultiple(o, l) {
    const u = this.getState("selections");
    let c = [];
    const m = Array.isArray(o);
    this.checkMultipleProps(), u.size && (c = [...u].map((S) => S[1]));
    const g = /* @__PURE__ */ new Map();
    let v = o;
    const { onChangeWithObject: b } = this.getProps();
    return b && m && (v = o.map((S) => S.value)), m && v.length && v.forEach((S, E) => {
      const P = l.findIndex((T) => T.value === S);
      if (P !== -1)
        g.set(l[P].label, l[P]);
      else {
        const T = c.findIndex((N) => N.value === S);
        if (T !== -1) {
          const N = c[T];
          if (b) {
            const O = { ...o[E] };
            lodashExports.isEqual(O, N) ? g.set(N.label, N) : g.set(O.label, O);
          } else
            g.set(N.label, N);
        } else {
          let N = { value: S, label: S, _notExist: !0 };
          b && (N = { ...o[E], _notExist: !0 }), g.set(N.label, { ...N, _scrollIndex: -1 });
        }
      }
    }), g;
  }
  _isMultiple() {
    return this.getProp("multiple");
  }
  _isDisabled() {
    return this.getProp("disabled");
  }
  _isFilterable() {
    return !!this.getProp("filter");
  }
  handleClick(o) {
    const { clickToHide: l } = this.getProps(), { isOpen: u } = this.getStates();
    this._isDisabled() || (u ? u && l ? this.close({ event: o }) : u && !l && this.focusInput() : (this.open(), this._notifyFocus(o)));
  }
  open(o, l) {
    const u = this._isFilterable(), c = l || this.getState("options");
    if (u) {
      const g = this._filterOption(c, "").filter((v) => !v._inputCreateOnly);
      this._adapter.updateOptions(g), this.toggle2SearchInput(!0);
    } else
      this._adapter.updateFocusState(!0);
    this._adapter.openMenu(() => {
      const { searchPosition: m, autoFocus: g } = this.getProps();
      g && m === strings$d.SEARCH_POSITION_DROPDOWN && this._adapter.focusDropdownInput();
    }), this._setDropdownWidth(), this._adapter.notifyDropdownVisibleChange(!0), this.bindKeyBoardEvent(), this._adapter.registerClickOutsideHandler((m) => {
      this.close({ event: m }), this._notifyBlur(m), this._adapter.updateFocusState(!1);
    });
  }
  toggle2SearchInput(o) {
    o ? this._adapter.toggleInputShow(o, () => this.focusInput()) : this._adapter.toggleInputShow(o, () => {
    });
  }
  close(o) {
    const { event: l, closeCb: u, notToggleInput: c } = o || {};
    this._adapter.closeMenu(), this._adapter.notifyDropdownVisibleChange(!1), this._adapter.setIsFocusInContainer(!1), this._adapter.unregisterClickOutsideHandler();
    const m = this._isFilterable();
    m && !c && this.toggle2SearchInput(!1), this._adapter.once("popoverClose", () => {
      m && this.clearInput(l), u && u();
    });
  }
  onSelect(o, l, u) {
    if (this._isDisabled())
      return;
    o._inputCreateOnly && this._adapter.notifyCreate(o), this._isMultiple() ? this._handleMultipleSelect(o, u) : (this._handleSingleSelect(o, u), this._focusTrigger()), this._adapter.updateFocusIndex(l);
  }
  _handleSingleSelect({ value: o, label: l, ...u }, c) {
    const m = (/* @__PURE__ */ new Map()).set(l, { value: o, label: l, ...u });
    this._notifySelect(o, { value: o, label: l, ...u });
    const g = this._isFilterable();
    this._isControlledComponent() ? this.close({
      event: c,
      notToggleInput: !0,
      closeCb: () => {
        this._notifyChange(m), g && this.toggle2SearchInput(!1);
      }
    }) : (this._adapter.updateSelection(m), this._notifyChange(m), this.close({
      event: c,
      closeCb: () => {
        this.updateOptionsActiveStatus(m);
      }
    }));
  }
  _handleMultipleSelect({ value: o, label: l, ...u }, c) {
    const m = this._adapter.getMaxLimit(), g = this._adapter.getSelections(), { autoClearSearchValue: v } = this.getProps();
    if (g.has(l))
      this._notifyDeselect(o, { value: o, label: l, ...u }), g.delete(l);
    else if (m && g.size === m) {
      this._adapter.notifyMaxLimit({ value: o, label: l, ...lodashExports.omit(u, "_scrollIndex") });
      return;
    } else
      this._notifySelect(o, { value: o, label: l, ...u }), g.set(l, { value: o, label: l, ...u });
    if (this._isControlledComponent())
      this._notifyChange(g), this._isFilterable() && (v && this.clearInput(c), this.focusInput());
    else {
      this._adapter.updateSelection(g), this.updateOverflowItemCount(g.size), this._adapter.rePositionDropdown();
      let { options: b } = this.getStates();
      this._isFilterable() && (v && (this.clearInput(c), b = this._filterOption(b, "")), this.focusInput()), this.updateOptionsActiveStatus(g, b), this._notifyChange(g);
    }
  }
  clearSelected() {
    const o = /* @__PURE__ */ new Map();
    this._isControlledComponent() ? (this._notifyChange(o), this._adapter.notifyClear()) : (this._adapter.updateSelection(o), this.updateOptionsActiveStatus(o), this._notifyChange(o), this._adapter.notifyClear());
    const { isOpen: l } = this.getStates();
    l && this._adapter.rePositionDropdown();
  }
  // Update the selected item in the drop-down box
  updateOptionsActiveStatus(o, l = this.getState("options")) {
    const { allowCreate: u } = this.getProps(), c = l.map((m) => (o.has(m.label) ? (m._selected = !0, u && delete m._inputCreateOnly) : (m._inputCreateOnly && (m._show = !1), m._selected = !1), m));
    this._adapter.updateOptions(c);
  }
  removeTag(o) {
    const l = this._adapter.getSelections();
    l.delete(o.label), this._isControlledComponent() ? (this._notifyDeselect(o.value, o), this._notifyChange(l)) : (this._notifyDeselect(o.value, o), this._adapter.updateSelection(l), this.updateOverflowItemCount(l.size), this.updateOptionsActiveStatus(l), this._adapter.rePositionDropdown(), this._notifyChange(l));
  }
  // The reason why event input is optional is that clearInput may be manually called by the user through ref
  clearInput(o) {
    const { inputValue: l } = this.getStates();
    if (l !== "") {
      this._adapter.updateInputValue(""), this._adapter.notifySearch("", o);
      const { options: u } = this.getStates(), { remote: c } = this.getProps();
      let m = u;
      c || (m = this._filterOption(u, "")), this._adapter.updateOptions(m);
    }
  }
  focusInput() {
    this._adapter.focusInput(), this._adapter.updateFocusState(!0), this._adapter.setIsFocusInContainer(!1);
  }
  handleInputChange(o, l) {
    this._adapter.updateInputValue(o);
    const { options: u, isOpen: c } = this.getStates(), { allowCreate: m, remote: g } = this.getProps();
    let v = u;
    g || (v = this._filterOption(u, o)), v = this._createOptionByInput(m, v, o), this._adapter.updateOptions(v), this._adapter.notifySearch(o, l), this._isMultiple() && this._adapter.rePositionDropdown();
  }
  _filterOption(o, l) {
    const u = this.getProp("filter");
    if (u) {
      if (typeof u == "boolean" && u) {
        const c = l.toLowerCase();
        return o.map((m) => {
          const g = m.label.toString().toLowerCase(), v = m._parentGroup && m._parentGroup.label, b = g.includes(c), S = lodashExports.isString(v) && v.toLowerCase().includes(c);
          return b || S ? m._show = !0 : m._show = !1, m;
        });
      } else if (typeof u == "function")
        return o.map((c) => (u(l, c) ? c._show = !0 : c._show = !1, c));
    } else return o;
  }
  _createOptionByInput(o, l, u) {
    if (o)
      if (u) {
        const c = {
          _show: !0,
          _selected: !1,
          value: u,
          label: u,
          // True indicates that the option was dynamically created during user filtering
          _inputCreateOnly: !0
        };
        let m = -1, g = -1;
        l.forEach((v, b) => {
          !v._show && !v._inputCreateOnly || (v.label === u && (g = b), v._inputCreateOnly && (m = b, v.value = u, v.label = u, v._show = !0));
        }), m === -1 && g === -1 && l.push(c), g !== -1 && (l = l.filter((v) => !v._inputCreateOnly));
      } else
        l = l.filter((c) => !c._inputCreateOnly);
    return l;
  }
  bindKeyBoardEvent() {
    this._keydownHandler = (o) => {
      this._handleKeyDown(o);
    }, this._adapter.registerKeyDown(this._keydownHandler);
  }
  unBindKeyBoardEvent() {
    this._keydownHandler && this._adapter.unregisterKeyDown();
  }
  // When searchPosition is trigger, the keyboard events bind to the outer trigger div
  // When searchPosition is dropdown, the popup and the outer trigger div are not parent- child relationships, keyboard events bind to the dorpdown input
  _handleKeyDown(o) {
    const l = o.keyCode, { loading: u, filter: c, multiple: m, disabled: g } = this.getProps(), { isOpen: v } = this.getStates();
    if (!(u || g))
      switch (l) {
        case KeyCode.UP:
          o.preventDefault(), this._handleArrowKeyDown(-1);
          break;
        case KeyCode.DOWN:
          o.preventDefault(), this._handleArrowKeyDown(1);
          break;
        case KeyCode.BACKSPACE:
          this._handleBackspaceKeyDown();
          break;
        case KeyCode.ENTER:
          handlePrevent(o), this._handleEnterKeyDown(o);
          break;
        case KeyCode.ESC:
          v && this.close({ event: o }), c && !m && this._focusTrigger();
          break;
        case KeyCode.TAB:
          this._handleTabKeyDown(o);
          break;
      }
  }
  handleContainerKeyDown(o) {
    const l = o.keyCode, { isOpen: u } = this.getStates();
    switch (l) {
      case KeyCode.TAB:
        u && this._handleTabKeyDown(o);
        break;
    }
  }
  _getEnableFocusIndex(o) {
    const { focusIndex: l, options: u } = this.getStates(), c = u.filter((v) => v._show), m = c.length;
    let g = l + o;
    if (g < 0 && (g = m - 1), g >= m && (g = 0), o > 0) {
      let v = -1;
      for (let b = 0; b < c.length && (!c[b].disabled && (v = b), !(v >= g)); b++)
        ;
      g = v;
    } else {
      let v = c.length;
      for (let b = m - 1; b >= 0 && (!c[b].disabled && (v = b), !(v <= g)); b--)
        ;
      g = v;
    }
    this._adapter.updateFocusIndex(g), this._adapter.updateScrollTop(g);
  }
  _handleArrowKeyDown(o) {
    const { isOpen: l } = this.getStates();
    l ? this._getEnableFocusIndex(o) : this.open();
  }
  _handleTabKeyDown(o) {
    const { isOpen: l } = this.getStates();
    if (this._adapter.updateFocusState(!1), l) {
      const u = this._adapter.getContainer(), c = this._adapter.getFocusableElements(u);
      c.length > 0 ? o.shiftKey ? this._handlePanelOpenShiftTabKeyDown(c, o) : this._handlePanelOpenTabKeyDown(c, o) : (this.close({ event: o }), this._notifyBlur(o));
    } else
      this._notifyBlur(o);
  }
  _handlePanelOpenTabKeyDown(o, l) {
    const u = this._adapter.getActiveElement();
    this._adapter.getIsFocusInContainer() ? u === o[o.length - 1] && (this._focusTrigger(), this.close({ event: l }), handlePrevent(l)) : (o[0].focus(), this._adapter.setIsFocusInContainer(!0), handlePrevent(l));
  }
  _handlePanelOpenShiftTabKeyDown(o, l) {
    const u = this._adapter.getActiveElement();
    this._adapter.getIsFocusInContainer() ? u === o[0] && (this._focusTrigger(), this._adapter.setIsFocusInContainer(!1), handlePrevent(l)) : (this.close({ event: l }), this._notifyBlur(l));
  }
  _handleEnterKeyDown(o) {
    const { isOpen: l, options: u, focusIndex: c } = this.getStates();
    if (!l)
      this.open();
    else if (c !== -1) {
      const m = u.filter((v) => v._show), { length: g } = m;
      if (g <= c)
        return;
      if (m && g) {
        const v = m[c];
        if (v.disabled)
          return;
        this.onSelect(v, c, o);
      }
    } else
      this.close({ event: o });
  }
  _handleBackspaceKeyDown() {
    if (this._isMultiple()) {
      const o = this._adapter.getSelections(), { inputValue: l } = this.getStates(), u = o.size;
      if (u && !l) {
        const c = [...o.keys()];
        let m = u - 1, g = c[m], v = o.get(g), b = !1;
        if (v.disabled && m === 0)
          return;
        for (; v.disabled && m !== 0; )
          m = m - 1, g = c[m], v = o.get(g), m == 0 && v.disabled && (b = !0);
        b || this.removeTag(v);
      }
    }
  }
  _notifyChange(o) {
    const { onChangeWithObject: l } = this.getProps(), u = this.getState("selections");
    let c;
    const m = [...o.values()], g = this._isMultiple();
    if (this._diffSelections(o, u, g))
      switch (!0) {
        case l:
          this._notifyChangeWithObject(o);
          break;
        case (!l && !g):
          c = m.length ? m[0].value : void 0, this._adapter.notifyChange(c);
          break;
        case (!l && g):
          c = m.length ? m.map((b) => b.value) : [], this._adapter.notifyChange(c);
          break;
      }
  }
  _removeInternalKey(o) {
    let l = { ...o };
    return delete l._parentGroup, delete l._show, delete l._selected, delete l._scrollIndex, delete l._keyInJsx, "_keyInOptionList" in l && (l.key = l._keyInOptionList, delete l._keyInOptionList), l;
  }
  _notifySelect(o, l) {
    const u = this._removeInternalKey(l);
    this._adapter.notifySelect(o, u);
  }
  _notifyDeselect(o, l) {
    const u = this._removeInternalKey(l);
    this._adapter.notifyDeselect(o, u);
  }
  _diffSelections(o, l, u) {
    let c = !0, m = !0;
    if (!u) {
      const g = [...o.values()], v = [...l.values()], b = g[0] ? g[0].value : g[0], S = v[0] ? v[0].value : v[0];
      m = !lodashExports.isEqual(b, S);
      const E = g[0] ? g[0].label : g[0], P = v[0] ? v[0].label : v[0];
      c = !lodashExports.isEqual(E, P);
    }
    return m || c;
  }
  // When onChangeWithObject is true, the onChange input parameter is not only value, but also label and other parameters
  _notifyChangeWithObject(o) {
    this.getState("selections");
    const l = [];
    for (const u of o.entries()) {
      let c = { label: u[0], ...u[1] };
      c = this._removeInternalKey(c), l.push(c);
    }
    this._isMultiple() ? this._adapter.notifyChange(l) : this._adapter.notifyChange(l[0]);
  }
  // Scenes that may trigger blur：
  // 1、clickOutSide
  // 2、 tab to next element/ shift tab to previous element
  // 3、[remove when add a11y] click option / press enter, and then select complete（when multiple is false 
  // 4、[remove when add a11y] press esc when dropdown list open 
  _notifyBlur(o) {
    this._adapter.notifyBlur(o);
  }
  // Scenes that may trigger focus:
  // 1、click selection
  _notifyFocus(o) {
    this._adapter.notifyFocus(o);
  }
  handleMouseEnter(o) {
    this._adapter.updateHovering(!0), this._adapter.notifyMouseEnter(o);
  }
  handleMouseLeave(o) {
    this._adapter.updateHovering(!1), this._adapter.notifyMouseLeave(o);
  }
  handleClearClick(o) {
    const { filter: l, searchPosition: u } = this.getProps();
    l && u === strings$d.SEARCH_POSITION_TRIGGER && this.clearInput(o), this.focus(), this.clearSelected(), o.stopPropagation();
  }
  handleKeyPress(o) {
    o && o.key === ENTER_KEY && this.handleClick(o);
  }
  /* istanbul ignore next */
  handleClearBtnEnterPress(o) {
    isEnterPress(o) && this.handleClearClick(o);
  }
  handleOptionMouseEnter(o) {
    this._adapter.updateFocusIndex(o);
  }
  handleListScroll(o) {
    this._adapter.notifyListScroll(o);
  }
  handleTriggerFocus(o) {
    this.bindKeyBoardEvent(), this._adapter.setIsFocusInContainer(!1);
  }
  handleTriggerBlur(o) {
    this.getProps();
    const { isOpen: l, isFocus: u } = this.getStates();
    u && !l && (this._notifyBlur(o), this._adapter.updateFocusState(!1));
  }
  handleInputBlur(o) {
    const { filter: l, autoFocus: u } = this.getProps(), c = this._isMultiple();
    u && l && !c && this.toggle2SearchInput(!1);
  }
  selectAll() {
    const { options: o } = this.getStates(), { onChangeWithObject: l } = this.getProps();
    let u = [];
    if (!this._isMultiple()) {
      console.warn(
        `[Semi Select]: It seems that you have called the selectAll method in the single-selection Select.
                Please note that this is not a legal way to use it`
      );
      return;
    }
    l ? u = o : u = o.map((m) => m.value), this.handleValueChange(u), this._adapter.notifyChange(u);
  }
  /**
   * Check whether the props
   *  -defaultValue/value in multiple selection mode is array
   * @param {Object} props
   */
  checkMultipleProps(o) {
    if (this._isMultiple()) {
      const l = o || this.getProps(), { defaultValue: u, value: c } = l, m = c || u;
      !isNullOrUndefined(m) && !Array.isArray(m) && warning$1(!0, "[Semi Select] defaultValue/value should be array type in multiple mode");
    }
  }
  updateScrollTop() {
    this._adapter.updateScrollTop();
  }
  updateOverflowItemCount(o, l) {
    const { maxTagCount: u, ellipsisTrigger: c } = this.getProps();
    c && (l ? this._adapter.updateOverflowItemCount(l) : typeof u == "number" && (o - u > 0 ? this._adapter.updateOverflowItemCount(o - u) : this._adapter.updateOverflowItemCount(0)));
  }
  updateIsFullTags() {
    const { isFullTags: o } = this.getStates();
    o || this._adapter.setState({
      isFullTags: !0
    });
  }
  handlePopoverClose() {
    this._adapter.emit("popoverClose");
  }
  // need to remove focus style of option when user hover slot
  handleSlotMouseEnter() {
    this._adapter.updateFocusIndex(-1);
  }
}
function _isSlot$B(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$z = cssClasses$K.PREFIX, tagSize = strings$g.TAG_SIZE, vuePropsType$2e = {
  maxTagCount: Number,
  restCount: Number,
  tagList: Array,
  showPopover: Boolean,
  popoverProps: Object,
  mode: String,
  // TODO: This API is not in the check file
  style: {
    type: [Object, String],
    default: {}
  },
  className: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: tagSize[0]
  },
  avatarShape: {
    type: String,
    default: "square"
  },
  onTagClose: Function,
  onPlusNMouseEnter: Function
}, Group = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2e
  },
  name: "TagGroup",
  setup(s, {
    slots: o
  }) {
    function l(m, g) {
      const {
        size: v,
        showPopover: b,
        popoverProps: S
      } = s;
      let E = createVNode(Tag, {
        closable: !1,
        size: v,
        color: "grey",
        style: {
          backgroundColor: "transparent"
        },
        key: "_+n"
      }, {
        default: () => [createTextVNode("+"), m]
      });
      if (b) {
        const P = /* @__PURE__ */ function() {
          return E;
        }();
        E = createVNode(Popover$1, mergeProps$1({
          showArrow: !0,
          content: g,
          trigger: "hover",
          position: "top",
          autoAdjustOverflow: !0,
          className: `${prefixCls$z}-rest-group-popover`
        }, S, {
          key: "_+n_Popover"
        }), _isSlot$B(E) ? E : {
          default: () => [P]
        });
      }
      return E;
    }
    function u(m) {
      const {
        maxTagCount: g,
        tagList: v,
        restCount: b
      } = s, S = b || v.length - g;
      let E = m;
      const P = m.slice(0, g), T = m.slice(g);
      let N = null;
      return S > 0 && (N = l(S, T), P.push(N), E = P), E;
    }
    function c() {
      const {
        tagList: m,
        size: g,
        mode: v,
        avatarShape: b
      } = s;
      return m.map((E, P) => v === "custom" ? E : (E.size || (E.size = g), E.avatarShape || (E.avatarShape = b), createVNode(Tag, mergeProps$1({
        key: `${P}-tag`
      }, lodashExports.omit(E, "children")), {
        default: () => E.children
      })));
    }
    return () => {
      const {
        style: m,
        className: g,
        maxTagCount: v,
        size: b
      } = s, S = cls({
        [`${prefixCls$z}-group`]: !0,
        [`${prefixCls$z}-group-max`]: v,
        [`${prefixCls$z}-group-small`]: b === "small",
        [`${prefixCls$z}-group-large`]: b === "large"
      }, g), E = c(), P = typeof v > "u" ? E : u(E);
      return createVNode("div", {
        style: m,
        class: S
      }, [P]);
    };
  }
}), TagGroup = Group, cssClasses$D = {
  PREFIX: BASE_CLASS_PREFIX$1 + "-overflow-list"
}, MODE_MAP = {
  COLLAPSE: "collapse",
  SCROLL: "scroll"
}, BOUNDARY_MAP = {
  START: "start",
  END: "end"
}, OVERFLOW_DIR = {
  NONE: 0,
  GROW: 1,
  SHRINK: 2
}, strings$c = {
  BOUNDARY_SET: Object.values(BOUNDARY_MAP),
  POSITION_SET: ["vertical", "horizontal"],
  MODE_SET: Object.values(MODE_MAP),
  MODE_MAP,
  BOUNDARY_MAP,
  OVERFLOW_DIR
}, numbers$a = {
  MINIMUM_HTML_ELEMENT_WIDTH: 4
}, propTypes$1o = {
  onIntersect: func,
  option: object$1,
  root: any$1,
  threshold: number$2,
  rootMargin: string$3,
  items: object$1
}, defaultProps$1i = {
  onIntersect: () => {
  },
  threshold: 0.75,
  rootMargin: "0px",
  option: {},
  items: {}
}, vuePropsType$2d = vuePropsMake(propTypes$1o, defaultProps$1i), ReactIntersectionObserver = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2d
  },
  name: "ReactIntersectionObserver",
  setup(s, {}) {
    const o = useSlots();
    let l, u;
    onMounted(() => {
      const {
        items: m
      } = s;
      u = Object.keys(m);
      const {
        root: g,
        threshold: v,
        rootMargin: b,
        option: S,
        onIntersect: E
      } = s;
      l = new IntersectionObserver(E, {
        root: g,
        threshold: v,
        rootMargin: b,
        ...S
      }), c();
    }), watch(() => Object.keys(s.items), () => {
      const {
        items: m
      } = s, g = Object.keys(m);
      lodashExports.isEqual(u, g) || (c(!0), u = g);
    }), onBeforeUnmount(() => {
      l && (l.disconnect(), l = null);
    });
    function c(m = !1) {
      const {
        items: g
      } = s;
      if (lodashExports.isEmpty(g)) {
        l == null || l.disconnect();
        return;
      }
      m && (l == null || l.disconnect()), Object.keys(g).forEach((v) => {
        const b = g[v];
        if (!b)
          return;
        const S = isElement$1(b) ? b : b.$el;
        l == null || l.observe(S);
      });
    }
    return () => {
      var m;
      return (m = o.default) == null ? void 0 : m.call(o);
    };
  }
}), Boundary$1 = strings$c.BOUNDARY_MAP;
class OverflowListFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.previousY = void 0, this.isScrollMode = () => {
      const { renderMode: l } = this.getProps();
      return l === "scroll";
    }, this.getReversedItems = () => {
      const { items: l } = this.getProps();
      return index$b(l).reverse();
    };
  }
  getOverflowItem() {
    const { items: o } = this.getProps(), { visibleState: l, overflow: u } = this.getStates();
    if (!this.isScrollMode())
      return u;
    const c = o.map(({ key: b }) => !!l.get(b)), m = c.indexOf(!0), g = c.lastIndexOf(!0), v = [];
    return v[0] = m >= 0 ? o.slice(0, m) : [], v[1] = g >= 0 ? o.slice(g + 1, o.length) : o, v;
  }
  handleIntersect(o) {
    const l = index$b(this.getState("visibleState")), u = {};
    o.forEach((b) => {
      const S = lodashExports.get(b, "target.dataset.scrollkey"), E = b.isIntersecting;
      u[S] = b, l.set(S, E);
    });
    let c = !1;
    for (const b of l.values())
      if (b) {
        c = !0;
        break;
      }
    const m = c, [g] = o, v = g.boundingClientRect.y;
    if (!m && this.previousY !== void 0 && v !== this.previousY) {
      this.previousY = v;
      return;
    }
    this.previousY = v, this._adapter.updateVisibleState(l), this._adapter.notifyIntersect(u);
  }
  handleCollapseOverflow() {
    const { minVisibleItems: o, collapseFrom: l } = this.getProps(), { overflowWidth: u, containerWidth: c, pivot: m, overflowStatus: g } = this.getStates(), { items: v, onOverflow: b } = this.getProps();
    let S = u, E = 0, P = !1;
    for (const T of this._adapter.getItemSizeMap().values()) {
      if (S += T, S > c) {
        P = !0;
        break;
      }
      if (E === v.length - 1) {
        this._adapter.updateStates({
          overflowStatus: "normal",
          pivot: v.length - 1,
          visible: v,
          overflow: []
        });
        break;
      }
      E++;
    }
    if (P) {
      const T = Math.max(o, E), N = l === Boundary$1.START, O = N ? this.getReversedItems().slice(0, T).reverse() : v.slice(0, T), z = N ? this.getReversedItems().slice(T).reverse() : v.slice(T);
      this._adapter.updateStates({
        overflowStatus: "overflowed",
        pivot: T,
        visible: O,
        overflow: z
      }), m !== T && b(z);
      return;
    }
  }
}
function _isSlot$A(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$y = cssClasses$D.PREFIX, Boundary = strings$c.BOUNDARY_MAP, OverflowDirection = strings$c.OVERFLOW_DIR, RenderMode = strings$c.MODE_MAP, defaultProps$1h = {
  collapseFrom: "end",
  minVisibleItems: 0,
  overflowRenderer: () => null,
  renderMode: "collapse",
  threshold: 0.75,
  visibleItemRenderer: () => null,
  onOverflow: () => null,
  overflowRenderDirection: "both"
}, propTypes$1n = {
  // if render in scroll mode, key is required in items
  className: string$3,
  collapseFrom: string$3,
  // direction: PropTypes.string as PropType<OverflowListProps['direction']>,
  items: array$1,
  minVisibleItems: number$2,
  onIntersect: func,
  onOverflow: func,
  overflowRenderer: func,
  renderMode: string$3,
  style: object$1,
  threshold: number$2,
  visibleItemRenderer: func,
  wrapperClassName: string$3,
  wrapperStyle: object$1,
  collapseMask: object$1,
  overflowRenderDirection: string$3,
  onVisibleStateChange: func,
  itemKey: [string$3, bool, func]
}, vuePropsType$2c = vuePropsMake(propTypes$1n, defaultProps$1h), OverflowList = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2c
  },
  name: "OverflowList",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    const l = reactive({
      direction: OverflowDirection.GROW,
      lastOverflowCount: 0,
      overflow: [],
      visible: [],
      containerWidth: 0,
      visibleState: /* @__PURE__ */ new Map(),
      itemSizeMap: /* @__PURE__ */ new Map(),
      overflowStatus: "calculating",
      pivot: 0,
      overflowWidth: 0,
      maxCount: 0
    });
    function u(ve) {
      const {
        prevProps: ee
      } = l, Re = {};
      Re.prevProps = ve;
      const wt = (yt) => !ee && yt in o(ve) || ee && !lodashExports.isEqual(ee[yt], ve[yt]);
      return (wt("items") || wt("style")) && (Re.direction = OverflowDirection.GROW, Re.lastOverflowCount = 0, ve.renderMode === RenderMode.SCROLL ? (Re.visible = ve.items, Re.overflow = []) : (Re.visible = [], Re.overflow = []), Re.pivot = 0, Re.maxCount = 0, Re.overflowStatus = "calculating"), Re;
    }
    watch(() => s, (ve) => {
      const ee = u({
        ...s
      });
      ee && Object.keys(ee).forEach((Re) => {
        l[Re] = ee[Re];
      });
    }, {
      deep: !0,
      immediate: !0
    });
    const {
      adapter: c
    } = useBaseComponent(s, l);
    function m() {
      return {
        ...c(),
        updateVisibleState: (ve) => {
          var ee;
          l.visibleState = ve, (ee = s.onVisibleStateChange) == null || ee.call(s, ve);
        },
        updateStates: (ve) => {
          ve && Object.keys(ve).forEach((ee) => {
            l[ee] = ve[ee];
          });
        },
        notifyIntersect: (ve) => {
          s.onIntersect && s.onIntersect(ve);
        },
        getItemSizeMap: () => E
      };
    }
    const g = m(), v = new OverflowListFoundation(g);
    let b = ref$1({}), S = null, E = /* @__PURE__ */ new Map();
    const P = () => {
      const {
        renderMode: ve
      } = s;
      return ve === RenderMode.SCROLL;
    }, T = shallowRef(0);
    watch([() => s.items, () => s.collapseFrom, () => l.overflow, () => l.containerWidth, () => l.visible, () => l.overflowStatus, () => T.value], (ve, ee) => {
      const Re = ve[0].map((yt) => yt.key), wt = s.items.map((yt) => yt.key);
      if (lodashExports.isEqual(Re, wt) || (b.value = {}, l.visibleState = /* @__PURE__ */ new Map()), !(P() || l.overflowStatus !== "calculating"))
        if (l.visible.length === 0 && l.overflow.length === 0 && s.items.length !== 0) {
          const yt = Math.min(s.items.length, Math.floor(l.containerWidth / numbers$a.MINIMUM_HTML_ELEMENT_WIDTH)), xt = s.collapseFrom === Boundary.START, Kt = xt ? v.getReversedItems().slice(0, yt) : s.items.slice(0, yt), tn = xt ? v.getReversedItems().slice(yt) : s.items.slice(yt);
          l.overflowStatus = "calculating", l.visible = Kt, l.overflow = tn, l.maxCount = yt, E.clear();
        } else
          v.handleCollapseOverflow();
    });
    const N = (ve = []) => {
      var Re;
      const ee = (Re = ve[0]) == null ? void 0 : Re.target.clientWidth;
      l.containerWidth = ee, l.overflowStatus = "calculating";
    }, O = (ve) => {
      v.handleIntersect(ve);
    }, z = (ve, ee, Re) => {
      b.value[Re] = ee, typeof ve == "function" ? ve(ee) : typeof ve == "object" && ve && "value" in ve && (ve.value = ee);
    }, Q = () => {
      const ve = v.getOverflowItem();
      return s.overflowRenderer(ve);
    }, W = (ve, ee) => {
      const {
        itemKey: Re
      } = s;
      return lodashExports.isFunction(Re) ? Re(ve) : lodashExports.get(ve, Re || "key", ee);
    }, ue = () => {
      const {
        className: ve,
        wrapperClassName: ee,
        wrapperStyle: Re,
        style: wt,
        visibleItemRenderer: yt,
        renderMode: xt,
        collapseFrom: Kt
      } = s, {
        visible: tn,
        overflowStatus: ln
      } = l;
      let rn = Q();
      if (!P() && (Array.isArray(rn) && (rn = createVNode(Fragment, null, [rn])), isVNode(rn))) {
        const nn = cloneVNode(rn);
        rn = createVNode(ReactResizeObserver, {
          onResize: ([vt]) => {
            l.overflowWidth = vt.target.clientWidth, l.overflowStatus = "calculating";
          }
        }, {
          default: () => [createVNode("div", {
            class: `${prefixCls$y}-overflow`
          }, [nn])]
        });
      }
      const an = xt === RenderMode.SCROLL ? (() => {
        const nn = [createVNode("div", {
          class: cls(ee, `${prefixCls$y}-scroll-wrapper`),
          ref: (vt) => {
            S = vt;
          },
          style: {
            ...Re
          },
          key: `${prefixCls$y}-scroll-wrapper`
        }, [tn.map(yt).map((vt) => {
          const {
            forwardRef: Et,
            key: Qt
          } = vt;
          return cloneVNode(vt, {
            ref: (un) => z(Et, un, Qt),
            "data-scrollkey": `${Qt}`,
            key: Qt
          });
        })])];
        return s.overflowRenderDirection === "both" ? (nn.unshift(rn[0]), nn.push(rn[1])) : s.overflowRenderDirection === "start" ? (nn.unshift(rn[1]), nn.unshift(rn[0])) : (nn.push(rn[0]), nn.push(rn[1])), nn;
      })() : [Kt === Boundary.START ? rn : null, tn.map((nn, vt) => {
        const {
          key: Et
        } = nn, Qt = yt(nn, vt), un = cloneVNode(Qt);
        return createVNode(ReactResizeObserver, {
          key: Et ?? vt,
          onResize: ([gn]) => K(gn, nn, vt)
        }, {
          default: () => [createVNode("div", {
            key: Et ?? vt,
            class: `${prefixCls$y}-item`
          }, [un])]
        });
      }), Kt === Boundary.END ? rn : null];
      return createVNode("div", {
        class: cls(`${prefixCls$y}`, ve),
        style: {
          ...wt,
          ...xt === RenderMode.COLLAPSE ? {
            maxWidth: "100%",
            visibility: ln === "calculating" ? "hidden" : "visible"
          } : null
        }
      }, [...an]);
    }, te = lodashExports.debounce(() => {
      T.value++;
    }, 10), K = (ve, ee, Re) => {
      const wt = W(ee, Re), yt = E.get(wt);
      yt ? yt !== ve.target.clientWidth && (E.set(wt, ve.target.clientWidth), l.overflowStatus = "calculating") : E.set(wt, ve.target.clientWidth);
      const {
        maxCount: xt
      } = l;
      E.size === xt - 1 && (l.overflowStatus = "calculating"), te();
    };
    return () => {
      const ve = ue(), {
        renderMode: ee
      } = s;
      return ee === RenderMode.SCROLL ? createVNode(ReactIntersectionObserver, {
        onIntersect: O,
        root: S,
        threshold: s.threshold,
        items: b.value
      }, _isSlot$A(ve) ? ve : {
        default: () => [ve]
      }) : createVNode(ReactResizeObserver, {
        onResize: N
      }, _isSlot$A(ve) ? ve : {
        default: () => [ve]
      });
    };
  }
}), OverflowList$1 = OverflowList, generateOption = (s, o, l, u) => {
  const c = s.props;
  if (!s || !c)
    return null;
  const m = {
    value: c.value,
    // Drop-down menu rendering priority label value, children, value in turn downgrade
    label: c.label || // @ts-ignore
    (typeof s.children == "object" && s.children.default ? s.children.default() : null) || c.value,
    _show: !0,
    _selected: !1,
    _scrollIndex: l,
    ...c,
    _parentGroup: o
  };
  return m._keyInJsx = u || s.key, m;
}, getOptionsFromGroup = (s) => {
  let o = [], l = [];
  const u = {
    label: "",
    children: [],
    _show: !1
  };
  let c = s.filter((v) => v && v.props), m = "", g = -1;
  return c.forEach((v) => {
    var b, S;
    if (((b = v.type) == null ? void 0 : b.name) === "isSelectOption") {
      m = "option", g++;
      const E = generateOption(v, void 0, g);
      u.children.push(E), l.push(E);
    } else if (((S = v.type) == null ? void 0 : S.name) === "isSelectOptionGroup") {
      m = "group";
      let {
        ...E
      } = v.props, P = getFragmentChildren(v.children), T = [];
      Array.isArray(P) ? T = P.map((z) => z.key) : T.push(P.key), Array.isArray(P[0]) && (P = P[0]);
      const N = P.map((z, Q) => {
        let W = z.key;
        return T[Q] === null && (W = v.key + "" + z.key), g++, generateOption(z, E, g, W);
      }), O = {
        ...v.props,
        children: N,
        // @ts-ignore
        key: v.key
      };
      o.push(O), l = l.concat(N);
    } else
      warning$1(!0, "[Semi Select] The children of `Select` should be `Select.Option` or `Select.OptionGroup`");
  }), m === "option" && (o = [u]), {
    optionGroups: o,
    options: l
  };
}, VirtualRow = ({
  index: s,
  data: o,
  style: l
}) => {
  const {
    visibleOptions: u,
    renderOption: c
  } = o, m = u[s];
  return c(m, s, l);
}, LocaleConsumer$3 = LocaleConsumerFunc(), vuePropsType$2b = {
  value: [String, Number],
  label: [String, Number, Object, Array],
  children: [String, Number, Object, Array],
  disabled: Boolean,
  selected: Boolean,
  empty: Boolean,
  emptyContent: [Object, String, Number, Function],
  inputValue: String,
  renderOptionItem: Function,
  onMouseEnter: Function,
  focused: Boolean,
  showTick: Boolean,
  className: String,
  style: [String, Object],
  onSelect: Function,
  prefixCls: {
    type: String,
    default: cssClasses$E.PREFIX_OPTION
  },
  _scrollIndex: Number,
  _selected: Boolean,
  _show: Boolean,
  semiOptionId: String,
  key_: [Object, String, Number],
  _parentGroup: Object,
  _keyInOptionList: String,
  _keyInJsx: String,
  _inputCreateOnly: Boolean
}, Option = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2b
  },
  name: "isSelectOption",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    function u({
      value: m,
      label: g,
      children: v,
      ...b
    }, S) {
      s.disabled || s.onSelect({
        ...b,
        value: m,
        label: toRaw(g || v)
      }, S);
    }
    function c({
      config: m,
      children: g,
      inputValue: v,
      prefixCls: b
    }) {
      return lodashExports.isString(g) && v ? getHighLightTextHTML(m) : g;
    }
    return () => {
      const m = o.default ? o.default() : null, {
        disabled: g,
        value: v,
        selected: b,
        label: S,
        empty: E,
        emptyContent: P,
        onSelect: T,
        focused: N,
        showTick: O,
        className: z,
        style: Q,
        onMouseEnter: W,
        prefixCls: ue,
        renderOptionItem: te,
        inputValue: K,
        semiOptionId: ve,
        ...ee
      } = s, Re = cls(ue, {
        [`${ue}-disabled`]: g,
        [`${ue}-selected`]: b,
        [`${ue}-focused`]: N,
        [`${ue}-empty`]: E,
        [z]: z
      }), wt = cls([`${ue}-icon`]);
      if (E)
        return P === null ? null : createVNode(LocaleConsumer$3, {
          componentName: "Select"
        }, {
          default: (xt) => createVNode("div", {
            class: Re
          }, [P || xt.emptyText])
        });
      if (typeof te == "function")
        return te({
          disabled: g,
          focused: N,
          selected: b,
          style: Q,
          label: S,
          value: v,
          inputValue: K,
          onMouseEnter: (xt) => W(xt),
          onClick: (xt) => u({
            value: v,
            label: S,
            children: m,
            ...ee
          }, xt),
          className: z,
          ...ee
        });
      const yt = {
        searchWords: K,
        sourceString: m,
        option: {
          highlightClassName: `${ue}-keyword`
        }
      };
      return (
        // eslint-disable-next-line jsx-a11y/interactive-supports-focus,jsx-a11y/click-events-have-key-events
        createVNode("div", mergeProps$1({
          class: Re,
          onClick: (xt) => {
            u({
              value: v,
              label: S,
              children: m,
              ...ee
            }, xt);
          },
          onMouseenter: (xt) => W && W(xt),
          role: "option",
          id: ve,
          "aria-selected": b ? "true" : "false",
          "aria-disabled": g ? "true" : "false",
          style: Q
        }, getDataAttr(l)), [O ? createVNode("div", {
          class: wt
        }, [createVNode(IconComponent$6, null, null)]) : null, lodashExports.isString(m) ? createVNode("div", {
          class: `${ue}-text`
        }, [c({
          children: m,
          config: yt,
          inputValue: K,
          prefixCls: ue
        })]) : [m]])
      );
    };
  }
}), Option$1 = Option, prefixCls$x = cssClasses$E.PREFIX_GROUP, vuePropsType$2a = {
  label: [String, Number, Object, Array],
  children: [String, Number, Object, Array],
  className: String,
  style: [String, Object]
}, OptionGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2a
  },
  name: "isSelectOptionGroup",
  setup(s, {
    slots: o,
    attrs: l
  }) {
    return () => {
      const {
        label: u,
        className: c,
        style: m,
        ...g
      } = s, v = cls(c, {
        [prefixCls$x]: !0
      });
      return !u && typeof u != "number" ? null : createVNode("div", mergeProps$1({
        class: v,
        style: m
      }, getDataAttr(l)), [u]);
    };
  }
});
function _isSlot$z(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$6 = cssClasses$E.PREFIX, LocaleConsumer$2 = LocaleConsumerFunc(), key$1 = 0, propTypes$1m = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": bool,
  "aria-labelledby": string$3,
  "aria-label": string$3,
  "aria-required": bool,
  autoFocus: bool,
  autoClearSearchValue: bool,
  borderless: bool,
  defaultValue: oneOfType([string$3, number$2, array$1, object$1]),
  value: oneOfType([string$3, number$2, array$1, object$1]),
  placeholder: node$1,
  onChange: func,
  multiple: bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filter: [func, bool],
  // How many tags can you choose?
  max: number$2,
  // How many tabs are displayed at most, and the rest are displayed in + N
  maxTagCount: number$2,
  maxHeight: oneOfType([string$3, number$2]),
  style: object$1,
  className: string$3,
  size: String,
  disabled: bool,
  emptyContent: node$1,
  onDropdownVisibleChange: func,
  zIndex: number$2,
  position: String,
  onSearch: func,
  getPopupContainer: func,
  dropdownClassName: string$3,
  dropdownStyle: object$1,
  outerTopSlot: node$1,
  innerTopSlot: node$1,
  inputProps: object$1,
  outerBottomSlot: node$1,
  innerBottomSlot: node$1,
  // Options slot
  optionList: array$1,
  // O
  dropdownMatchSelectWidth: bool,
  loading: bool,
  defaultOpen: bool,
  validateStatus: String,
  defaultActiveFirstOption: bool,
  triggerRender: func,
  stopPropagation: bool,
  // motion doesn't need to be exposed
  motion: oneOfType([func, bool, object$1]),
  onChangeWithObject: bool,
  suffix: node$1,
  prefix: node$1,
  insetLabel: node$1,
  insetLabelId: string$3,
  showClear: bool,
  showArrow: bool,
  renderSelectedItem: func,
  allowCreate: bool,
  renderCreateItem: func,
  onMouseEnter: func,
  onMouseLeave: func,
  clickToHide: bool,
  onExceed: func,
  onCreate: func,
  remote: bool,
  onDeselect: func,
  // The main difference between onSelect and onChange is that when multiple selections are selected, onChange contains all options, while onSelect only contains items for the current operation
  onSelect: func,
  autoAdjustOverflow: bool,
  mouseEnterDelay: number$2,
  mouseLeaveDelay: number$2,
  spacing: oneOfType([number$2, object$1]),
  onBlur: func,
  onFocus: func,
  onClear: func,
  virtualize: object$1,
  renderOptionItem: func,
  onListScroll: func,
  arrowIcon: node$1,
  preventScroll: bool,
  // open: PropTypes.bool,
  // tagClosable: PropTypes.bool,
  showRestTagsPopover: bool,
  restTagsPopoverProps: object$1,
  id: String,
  expandRestTagsOnClick: bool,
  ellipsisTrigger: bool,
  searchPosition: String,
  searchPlaceholder: String,
  clearIcon: node$1,
  dropdownMargin: [number$2, object$1]
}, defaultProps$1g = {
  stopPropagation: !0,
  motion: !0,
  borderless: !1,
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  // position: 'bottomLeft',
  filter: !1,
  multiple: !1,
  disabled: !1,
  defaultOpen: !1,
  allowCreate: !1,
  placeholder: "",
  onDropdownVisibleChange: lodashExports.noop,
  onChangeWithObject: !1,
  onChange: lodashExports.noop,
  onSearch: lodashExports.noop,
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop,
  onDeselect: lodashExports.noop,
  onSelect: lodashExports.noop,
  onCreate: lodashExports.noop,
  onExceed: lodashExports.noop,
  onFocus: lodashExports.noop,
  onBlur: lodashExports.noop,
  onClear: lodashExports.noop,
  onListScroll: lodashExports.noop,
  maxHeight: numbers$b.LIST_HEIGHT,
  dropdownMatchSelectWidth: !0,
  defaultActiveFirstOption: !0,
  // In order to meet the needs of A11y, change to true
  showArrow: !0,
  showClear: !1,
  searchPosition: strings$d.SEARCH_POSITION_TRIGGER,
  remote: !1,
  autoAdjustOverflow: !0,
  autoClearSearchValue: !0,
  arrowIcon: createVNode(IconComponent$A, {
    "aria-label": ""
  }, null),
  // Radio selection is different from the default renderSelectedItem for multiple selection, so it is not declared here
  // renderSelectedItem: (optionNode) => optionNode.label,
  // The default creator rendering is related to i18, so it is not declared here
  // renderCreateItem: (input) => input
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  expandRestTagsOnClick: !1,
  ellipsisTrigger: !1
}, vuePropsType$29 = vuePropsMake(propTypes$1m, defaultProps$1g), Index$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$29
  },
  name: "Select",
  setup(s, {
    expose: o
  }) {
    const l = useSlots(), u = reactive({
      isOpen: !1,
      isFocus: !1,
      options: [],
      // All options
      selections: /* @__PURE__ */ new Map(),
      // A collection of all currently selected items, k: label, v: {value,... otherProps}
      dropdownMinWidth: null,
      optionKey: key$1,
      inputValue: "",
      showInput: !1,
      focusIndex: s.defaultActiveFirstOption ? 0 : -1,
      keyboardEventSet: {},
      optionGroups: [],
      isHovering: !1,
      isFocusInContainer: !1,
      isFullTags: !1,
      overflowItemCount: 0
    });
    let c = "", m = "", g = ref$1(), v = ref$1(), b = ref$1(), S = ref$1(), E = ref$1();
    const P = ref$1();
    let T, N;
    T = null, warning$1("optionLabelProp" in s, "[Semi Select] 'optionLabelProp' has already been deprecated, please use 'renderSelectedItem' instead."), warning$1("labelInValue" in s, "[Semi Select] 'labelInValue' has already been deprecated, please use 'onChangeWithObject' instead.");
    const {
      hasInProps: O
    } = useHasInProps(), z = new Event$1(), {
      adapter: Q,
      context: W,
      getDataAttr: ue
    } = useBaseComponent(s, u), te = (Fn) => P.value = Fn;
    let K = shallowRef([]);
    function ve() {
      const Fn = {
        registerKeyDown: (Mn) => {
          const Tn = {
            onKeyDown: Mn
          };
          u.keyboardEventSet = Tn;
        },
        unregisterKeyDown: () => {
          u.keyboardEventSet = {};
        },
        updateFocusIndex: (Mn) => {
          u.focusIndex = Mn;
        },
        // eslint-disable-next-line @typescript-eslint/no-empty-function
        scrollToFocusOption: () => {
        }
      }, Gn = {
        updateInputValue: (Mn) => {
          u.inputValue = Mn;
        },
        toggleInputShow: (Mn, Tn) => {
          u.showInput = Mn, nextTick(() => {
            Tn == null || Tn();
          });
        },
        focusInput: () => {
          const {
            preventScroll: Mn
          } = s;
          v.value && v.value.$el && v.value.$el.children[0].focus({
            preventScroll: Mn
          });
        },
        focusDropdownInput: () => {
          const {
            preventScroll: Mn
          } = s;
          b.value && b.value.focus({
            preventScroll: Mn
          });
        }
      }, Wn = {
        notifyMaxLimit: (Mn) => s.onExceed(Mn),
        getMaxLimit: () => s.max,
        registerClickOutsideHandler: (Mn) => {
          const Tn = (Rn) => {
            var Fr, An;
            const hn = E.value && ((An = (Fr = E.value).getRef) == null ? void 0 : An.call(Fr).vnode.el), Qn = S.value, rr = hn, tr = Rn.target, Cr = Rn.composedPath && Rn.composedPath() || [tr];
            !(rr && rr.contains(tr)) && !(Qn && Qn.contains(tr)) && !(Cr.includes(Qn) || Cr.includes(rr)) && Mn(Rn);
          };
          T = Tn, document.addEventListener("mousedown", Tn, !1);
        },
        unregisterClickOutsideHandler: () => {
          T && (document.removeEventListener("mousedown", T, !1), T = null);
        },
        rePositionDropdown: () => {
          let {
            optionKey: Mn
          } = u;
          Mn = Mn + 1, u.optionKey = Mn;
        },
        notifyDeselect: (Mn, Tn) => {
          delete Tn._parentGroup, s.onDeselect(Mn, Tn);
        }
      };
      return {
        ...Q(),
        ...Fn,
        ...Gn,
        ...Wn,
        on: (Mn, Tn) => z.on(Mn, Tn),
        off: (Mn) => z.off(Mn),
        once: (Mn, Tn) => z.once(Mn, Tn),
        emit: (Mn) => z.emit(Mn),
        // Collect all subitems, each item is visible by default when collected, and is not selected
        //slots.default?slots.default():null
        getOptionsFromChildren: () => {
          let Mn = [], Tn = [];
          const {
            optionList: Rn
          } = s;
          if (Rn && Rn.length)
            Tn = Rn.map((hn, Qn) => ({
              _show: !0,
              _selected: !1,
              _scrollIndex: Qn,
              ...hn
            })), Mn[0] = {
              children: Tn,
              label: ""
            };
          else {
            const hn = getOptionsFromGroup(K.value);
            Mn = hn.optionGroups, Tn = hn.options;
          }
          return u.optionGroups = Mn, Tn;
        },
        updateOptions: (Mn) => {
          u.options = Mn;
        },
        openMenu: (Mn) => {
          u.isOpen = !0, nextTick(() => {
            Mn == null || Mn();
          });
        },
        closeMenu: () => {
          u.isOpen = !1;
        },
        getTriggerWidth: () => {
          const Mn = S.value;
          return Mn && Mn.getBoundingClientRect().width;
        },
        setOptionWrapperWidth: (Mn) => {
          u.dropdownMinWidth = Mn;
        },
        updateSelection: (Mn) => {
          u.selections = Mn;
        },
        // clone Map, important!!!, prevent unexpected modify on state
        getSelections: () => new Map(u.selections),
        notifyChange: (Mn) => {
          s.onChange(Mn);
        },
        notifySelect: (Mn, Tn) => {
          delete Tn._parentGroup, s.onSelect(Mn, Tn);
        },
        notifyDropdownVisibleChange: (Mn) => {
          s.onDropdownVisibleChange(Mn);
        },
        notifySearch: (Mn, Tn) => {
          s.onSearch(Mn, Tn);
        },
        notifyCreate: (Mn) => {
          s.onCreate(Mn);
        },
        notifyMouseEnter: (Mn) => {
          s.onMouseEnter(Mn);
        },
        notifyMouseLeave: (Mn) => {
          s.onMouseLeave(Mn);
        },
        notifyFocus: (Mn) => {
          s.onFocus(Mn);
        },
        notifyBlur: (Mn) => {
          s.onBlur(Mn);
        },
        notifyClear: () => {
          s.onClear();
        },
        notifyListScroll: (Mn) => {
          s.onListScroll(Mn);
        },
        updateHovering: (Mn) => {
          u.isHovering = Mn;
        },
        updateFocusState: (Mn) => {
          u.isFocus = Mn;
        },
        updateOverflowItemCount: (Mn) => {
          u.overflowItemCount = Mn;
        },
        focusTrigger: () => {
          try {
            const {
              preventScroll: Mn
            } = s;
            S.value.focus({
              preventScroll: Mn
            });
          } catch {
          }
        },
        getContainer: () => P.value,
        getFocusableElements: (Mn) => getFocusableElements(Mn),
        getActiveElement: () => getActiveElement(),
        setIsFocusInContainer: (Mn) => {
          u.isFocusInContainer = Mn;
        },
        getIsFocusInContainer: () => u.isFocusInContainer,
        updateScrollTop: (Mn) => {
          var hn;
          let Tn = `.${prefixcls$6}-option-selected`;
          Mn !== void 0 && (Tn = `.${prefixcls$6}-option:nth-child(${Mn})`);
          let Rn = (hn = P.value) == null ? void 0 : hn.querySelector(`#${prefixcls$6}-${c} ${Tn}`);
          if (Array.isArray(Rn) && (Rn = Rn[0]), Rn) {
            const Qn = Rn.parentNode;
            Qn.scrollTop = Rn.offsetTop - Qn.offsetTop - Qn.clientHeight / 2 + Rn.clientHeight / 2;
          }
        }
      };
    }
    const ee = ve();
    N = new SelectFoundation(ee), onMounted(() => {
      N.init(), c = getUuidShort(), m = s.id || getUuidShort();
    }), onUnmounted(() => {
      N.destroy();
    }), watch([() => s.value, () => s.optionList, K], (Fn, [Gn, Wn, Mn]) => {
      const Tn = Mn.map((Qn) => Qn.key), Rn = K.value.map((Qn) => Qn.key);
      let hn = !1;
      (!lodashExports.isEqual(Tn, Rn) || !lodashExports.isEqual(Wn, s.optionList)) && (hn = !0, N.handleOptionListChange()), (Gn !== s.value || hn) && (O("value") ? N.handleValueChange(s.value) : N.handleOptionListChangeHadDefaultValue());
    });
    const Re = (Fn, Gn) => {
      N.handleInputChange(Fn, Gn);
    };
    function wt() {
      const {
        size: Fn,
        multiple: Gn,
        disabled: Wn,
        inputProps: Mn,
        filter: Tn
      } = s, Rn = lodashExports.get(Mn, "className"), hn = cls(`${prefixcls$6}-input`, {
        [`${prefixcls$6}-input-single`]: !Gn,
        [`${prefixcls$6}-input-multiple`]: Gn
      }, Rn), {
        inputValue: Qn,
        focusIndex: rr
      } = u, tr = {
        value: Qn,
        disabled: Wn,
        className: hn,
        onChange: Re,
        ...Mn
      };
      let Cr = {};
      return Gn && (Cr = {
        width: Qn ? `${Qn.length * 16}px` : "2px"
      }, tr.style = Cr), createVNode(Input$1, mergeProps$1({
        ref: v,
        size: Fn,
        "aria-activedescendant": rr !== -1 ? `${m}-option-${rr}` : "",
        onFocus: (Fr) => {
          Gn && Tn && (u.isFocus = !0), Fr.stopPropagation();
        }
      }, tr), null);
    }
    function yt() {
      const {
        size: Fn,
        multiple: Gn,
        disabled: Wn,
        inputProps: Mn,
        filter: Tn,
        searchPosition: Rn,
        searchPlaceholder: hn
      } = s, {
        inputValue: Qn,
        focusIndex: rr
      } = u, tr = cls(`${prefixcls$6}-dropdown-search-wrapper`, {}), Cr = lodashExports.get(Mn, "className"), Fr = cls(`${prefixcls$6}-dropdown-input`, {
        [`${prefixcls$6}-dropdown-input-single`]: !Gn,
        [`${prefixcls$6}-dropdown-input-multiple`]: Gn
      }, Cr), An = {
        value: Qn,
        disabled: Wn,
        className: Fr,
        onChange: Re,
        placeholder: hn,
        showClear: !0,
        ...Mn,
        /**
         * When searchPosition is trigger, the keyboard events are bound to the outer trigger div, so there is no need to listen in input.
         * When searchPosition is dropdown, the popup and the outer trigger div are not parent- child relationships,
         * and bubbles cannot occur, so onKeydown needs to be listened in input.
         *  */
        onKeyDown: (Hn) => N._handleKeyDown(Hn)
      };
      return createVNode("div", {
        class: tr
      }, [createVNode(Input$1, mergeProps$1({
        ref: b,
        prefix: createVNode(IconComponent$9, null, null),
        "aria-activedescendant": rr !== -1 ? `${m}-option-${rr}` : ""
      }, An), null)]);
    }
    function xt() {
      N.close();
    }
    function Kt() {
      N.open();
    }
    function tn() {
      N.clearInput();
    }
    function ln() {
      N.selectAll();
    }
    function rn() {
      N.clearSelected();
    }
    function an() {
      N.focus();
    }
    o({
      close: xt,
      open: Kt,
      clearInput: tn,
      selectAll: ln,
      deselectAll: rn,
      focus: an
    });
    function Gt(Fn, Gn, Wn) {
      N.onSelect(toRaw(Fn), Gn, Wn);
    }
    function nn(Fn) {
      Fn.stopImmediatePropagation(), N.handleClearClick(Fn);
    }
    function vt() {
      return createVNode(Option$1, {
        empty: !0,
        emptyContent: s.emptyContent
      }, null);
    }
    function Et() {
      const Fn = `${prefixcls$6}-loading-wrapper`;
      return createVNode("div", {
        class: Fn
      }, [createVNode(Spin, null, null)]);
    }
    function Qt(Fn, Gn, Wn) {
      const {
        focusIndex: Mn,
        inputValue: Tn
      } = u, {
        renderOptionItem: Rn
      } = s;
      let hn;
      const Qn = Gn === Mn;
      let rr = Wn || {};
      return Fn.style && (rr = {
        ...rr,
        ...Fn.style
      }), Fn._inputCreateOnly ? hn = un(Fn, Qn, Gn, Wn) : ("key_" in Fn && (Fn._keyInOptionList = Fn.key_), hn = createVNode(Option$1, mergeProps$1({
        showTick: !0
      }, Fn, {
        selected: Fn._selected,
        onSelect: (tr, Cr) => Gt(tr, Gn, Cr),
        focused: Qn,
        onMouseEnter: () => gn(Gn),
        style: rr,
        key: Fn._keyInOptionList || Fn._keyInJsx || Fn.label + Fn.value + Gn,
        renderOptionItem: Rn,
        inputValue: Tn,
        semiOptionId: `${m}-option-${Gn}`
      }), {
        default: () => [Fn.label]
      })), hn;
    }
    function un(Fn, Gn, Wn, Mn) {
      const {
        renderCreateItem: Tn
      } = s;
      if (typeof Tn > "u")
        return createVNode(Option$1, mergeProps$1({
          key: Fn.key_ || Fn.label + Fn.value,
          onSelect: (Qn, rr) => Gt(Qn, Wn, rr),
          onMouseEnter: () => gn(Wn),
          showTick: !0
        }, Fn, {
          focused: Gn,
          style: Mn
        }), {
          default: () => [createVNode(LocaleConsumer$2, {
            componentName: "Select"
          }, {
            default: (Qn) => createVNode(Fragment, null, [createVNode("span", {
              class: `${prefixcls$6}-create-tips`
            }, [Qn.createText]), Fn.value])
          })]
        });
      const Rn = Tn(Fn.value, Gn, Mn);
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/interactive-supports-focus
        createVNode("div", {
          role: "button",
          "aria-label": "Use the input box to create an optional item",
          onClick: (hn) => Gt(Fn, Wn, hn),
          key: Fn.key_ || Fn.label
        }, [Rn])
      );
    }
    function gn(Fn) {
      N.handleOptionMouseEnter(Fn);
    }
    function dn(Fn) {
      const Gn = [], Wn = /* @__PURE__ */ new Map();
      return Fn.forEach((Mn, Tn) => {
        const Rn = Mn._parentGroup, hn = Qt(Mn, Tn);
        if (Rn && !Wn.has(Rn.label)) {
          const Qn = createVNode(OptionGroup, mergeProps$1(Rn, {
            key: Rn.label
          }), null);
          Wn.set(Rn.label, !0), Gn.push(Qn);
        }
        Gn.push(hn);
      }), Gn;
    }
    function yn(Fn) {
      const {
        virtualize: Gn
      } = s, {
        direction: Wn
      } = W.value, {
        height: Mn,
        width: Tn,
        itemSize: Rn
      } = Gn;
      return createVNode(Jt$1, {
        ref: g,
        height: Mn || numbers$b.LIST_HEIGHT,
        itemCount: Fn.length,
        itemSize: Rn,
        itemData: {
          visibleOptions: Fn,
          renderOption: Qt
        },
        width: Tn,
        style: {
          direction: Wn
        }
      }, _isSlot$z(VirtualRow) ? VirtualRow : {
        default: () => [VirtualRow]
      });
    }
    function vn(Fn) {
      const {
        dropdownMinWidth: Gn,
        options: Wn,
        selections: Mn
      } = u, {
        maxHeight: Tn,
        dropdownClassName: Rn,
        dropdownStyle: hn,
        outerTopSlot: Qn,
        innerTopSlot: rr,
        outerBottomSlot: tr,
        innerBottomSlot: Cr,
        loading: Fr,
        virtualize: An,
        multiple: Hn,
        emptyContent: ir,
        searchPosition: dr,
        filter: ar
      } = s, Or = Wn.filter((_r) => _r._show);
      let Sr = dn(Or);
      An && (Sr = yn(Or));
      const kr = {
        minWidth: typeof Gn == "string" ? Gn : Gn + "px",
        ...hn
      }, Nr = cls({
        [`${prefixcls$6}-option-list`]: !0,
        [`${prefixcls$6}-option-list-chosen`]: Mn.size
      }), Ur = !Wn.length || !Wn.some((_r) => _r._show);
      return createVNode("div", {
        id: `${prefixcls$6}-${c}`,
        class: Rn,
        style: kr,
        ref: te,
        onKeydown: (_r) => N.handleContainerKeyDown(_r)
      }, [Qn ? createVNode("div", {
        class: `${prefixcls$6}-option-list-outer-top-slot`,
        onMouseenter: () => N.handleSlotMouseEnter()
      }, [Qn]) : null, dr === strings$d.SEARCH_POSITION_DROPDOWN && ar ? yt() : null, createVNode("div", {
        style: {
          maxHeight: `${Tn}px`
        },
        class: Nr,
        role: "listbox",
        "aria-multiselectable": Hn,
        onScroll: (_r) => N.handleListScroll(_r)
      }, [rr ? createVNode("div", {
        class: `${prefixcls$6}-option-list-inner-top-slot`,
        onMouseenter: () => N.handleSlotMouseEnter()
      }, [rr]) : null, Fr ? Et() : Ur ? vt() : Sr, Cr ? createVNode("div", {
        class: `${prefixcls$6}-option-list-inner-bottom-slot`,
        onMouseenter: () => N.handleSlotMouseEnter()
      }, [Cr]) : null]), tr ? createVNode("div", {
        class: `${prefixcls$6}-option-list-outer-bottom-slot`,
        onMouseenter: () => N.handleSlotMouseEnter()
      }, [tr]) : null]);
    }
    function Pn(Fn, Gn) {
      let {
        renderSelectedItem: Wn,
        searchPosition: Mn
      } = s;
      const {
        placeholder: Tn
      } = s, {
        showInput: Rn,
        inputValue: hn
      } = u;
      let Qn = "";
      const rr = [...Fn];
      if (typeof Wn > "u" && (Wn = (An) => An.label), rr.length) {
        const An = rr[0][1];
        Qn = Wn(An);
      }
      const tr = Mn === strings$d.SEARCH_POSITION_TRIGGER, Cr = cls({
        [`${prefixcls$6}-selection-text`]: !0,
        [`${prefixcls$6}-selection-placeholder`]: !Qn && Qn !== 0,
        [`${prefixcls$6}-selection-text-hide`]: hn && Rn && tr,
        // show Input
        [`${prefixcls$6}-selection-text-inactive`]: !hn && Rn && tr
        // Stack Input & RenderText(opacity 0.4)
      }), Fr = `${prefixcls$6}-content-wrapper`;
      return createVNode("div", {
        class: Fr
      }, [createVNode("span", {
        class: Cr,
        "x-semi-prop": "placeholder",
        key: Qn
      }, [Qn || Qn === 0 ? Qn : Tn]), Gn && Rn && tr ? wt() : null]);
    }
    const On = (Fn, Gn, Wn) => {
      const {
        size: Mn,
        disabled: Tn
      } = s, Rn = Fn[0], {
        value: hn
      } = Fn[1], Qn = Fn[1].disabled || Tn, rr = (An, Hn) => {
        Hn && typeof Hn.preventDefault == "function" && Hn.preventDefault(), N.removeTag({
          label: Rn,
          value: hn
        });
      }, {
        content: tr,
        isRenderInTag: Cr
      } = Wn(Fn[1], {
        index: Gn,
        disabled: Qn,
        onClose: rr
      }), Fr = {
        disabled: Qn,
        closable: !Qn,
        onClose: rr
      };
      return Cr ? createVNode(Tag, mergeProps$1(Fr, {
        color: "white",
        size: Mn || "large",
        key: hn,
        tabIndex: -1
      }), _isSlot$z(tr) ? tr : {
        default: () => [tr]
      }) : createVNode(Fragment, {
        key: hn
      }, [tr]);
    };
    function _n(Fn, Gn, Wn) {
      const {
        size: Mn,
        disabled: Tn
      } = s;
      let {
        renderSelectedItem: Rn
      } = s;
      const hn = Fn[0], {
        value: Qn
      } = Fn[1], rr = Fn[1].disabled || Tn, tr = (ir, dr) => {
        dr && typeof dr.preventDefault == "function" && dr.preventDefault(), N.removeTag({
          label: hn,
          value: Qn
        });
      };
      typeof Rn > "u" && (Rn = (ir) => ({
        isRenderInTag: !0,
        content: ir.label
      }));
      const {
        content: Cr,
        isRenderInTag: Fr
      } = Rn(Fn[1], {
        index: Gn,
        disabled: rr,
        onClose: tr
      }), An = {
        disabled: rr,
        closable: !rr,
        onClose: tr
      }, Hn = Wn && !lodashExports.isFunction(s.renderSelectedItem) ? createVNode(TypographyText, {
        size: "small",
        ellipsis: {
          rows: 1,
          showTooltip: {
            type: "popover",
            opts: {
              style: {
                width: "auto",
                fontSize: 12
              }
            }
          }
        }
      }, _isSlot$z(Cr) ? Cr : {
        default: () => [Cr]
      }) : Cr;
      return Fr ? createVNode(Tag, mergeProps$1(An, {
        color: "white",
        size: Mn || "large",
        key: Qn,
        style: {
          maxWidth: "100%"
        }
      }), _isSlot$z(Hn) ? Hn : {
        default: () => [Hn]
      }) : createVNode(Fragment, {
        key: Qn
      }, [Hn]);
    }
    function Nn(Fn, Gn) {
      const {
        size: Wn,
        showRestTagsPopover: Mn,
        restTagsPopoverProps: Tn
      } = s;
      let Rn = createVNode(Tag, {
        closable: !1,
        size: Wn || "large",
        color: "grey",
        className: `${prefixcls$6}-content-wrapper-collapse-tag`,
        key: `_+${Fn}`,
        style: {
          marginRight: 0,
          flexShrink: 0
        }
      }, {
        default: () => [createTextVNode("+"), Fn]
      });
      if (Mn) {
        let hn;
        const Qn = /* @__PURE__ */ function() {
          return Rn;
        }();
        Rn = createVNode(Popover$1, mergeProps$1({
          showArrow: !0,
          content: createVNode(Space, {
            spacing: 2,
            wrap: !0,
            style: {
              maxWidth: "400px"
            }
          }, _isSlot$z(hn = Gn.map((rr, tr) => _n(rr, tr))) ? hn : {
            default: () => [hn]
          }),
          trigger: "hover",
          position: "top",
          autoAdjustOverflow: !0
        }, Tn, {
          key: `_+${Fn}_Popover`
        }), _isSlot$z(Rn) ? Rn : {
          default: () => [Qn]
        });
      }
      return Rn;
    }
    function Un(Fn, Gn) {
      return Fn.length && Fn[0] ? _n(Fn[0], Gn, !0) : null;
    }
    function Xn(Fn) {
      const {
        overflowItemCount: Gn,
        selections: Wn
      } = u, {
        maxTagCount: Mn
      } = s, Tn = Wn.size - Mn > 0 ? Wn.size - Mn + Fn.length - 1 : Fn.length - 1;
      Gn !== Tn && N.updateOverflowItemCount(Wn.size, Tn);
    }
    function zn(Fn, Gn) {
      const {
        overflowItemCount: Wn
      } = u, Mn = typeof Gn == "number" ? Fn.slice(0, Gn) : Fn;
      return createVNode("div", {
        class: `${prefixcls$6}-content-wrapper-collapse`
      }, [createVNode(OverflowList$1, {
        items: Mn,
        key: String(Fn.length),
        overflowRenderer: (Tn) => Un(Tn, Gn - 1),
        onOverflow: (Tn) => Xn(Tn),
        visibleItemRenderer: (Tn, Rn) => _n(Tn, Rn)
      }, null), Wn > 0 && Nn(Wn, Fn.slice(Fn.length - Wn))]);
    }
    function jn(Fn, Gn) {
      let {
        renderSelectedItem: Wn
      } = s;
      const {
        showRestTagsPopover: Mn,
        restTagsPopoverProps: Tn,
        maxTagCount: Rn
      } = s, {
        isFullTags: hn
      } = u;
      let Qn;
      if (typeof Wn > "u" && (Wn = (rr) => ({
        isRenderInTag: !0,
        content: rr.label
      })), Mn) {
        const tr = (hn ? Fn : Fn.slice(0, Rn)).map((Cr, Fr) => On(Cr, Fr, Wn));
        Qn = createVNode(TagGroup, {
          tagList: tr,
          maxTagCount: Gn,
          restCount: hn ? void 0 : Fn.length - Rn,
          size: "large",
          mode: "custom",
          showPopover: Mn,
          popoverProps: Tn,
          onPlusNMouseEnter: () => {
            N.updateIsFullTags();
          }
        }, null);
      } else {
        const tr = Fn.slice(0, Rn).map((Cr, Fr) => On(Cr, Fr, Wn));
        Qn = createVNode(TagGroup, {
          tagList: tr,
          maxTagCount: Gn,
          restCount: Fn.length - Rn,
          size: "large",
          mode: "custom"
        }, null);
      }
      return Qn;
    }
    function kn(Fn, Gn) {
      const {
        placeholder: Wn,
        maxTagCount: Mn,
        expandRestTagsOnClick: Tn,
        ellipsisTrigger: Rn
      } = s, {
        inputValue: hn,
        isOpen: Qn
      } = u, rr = [...Fn], tr = cls({
        [`${prefixcls$6}-content-wrapper`]: !0,
        [`${prefixcls$6}-content-wrapper-one-line`]: Mn && !Qn,
        [`${prefixcls$6}-content-wrapper-empty`]: !rr.length
      }), Cr = cls({
        [`${prefixcls$6}-selection-text`]: !0,
        [`${prefixcls$6}-selection-placeholder`]: !rr.length,
        [`${prefixcls$6}-selection-text-hide`]: rr && rr.length
      }), Fr = Wn && !hn ? createVNode("span", {
        class: Cr
      }, [Wn]) : null, An = rr.length > Mn ? Mn : void 0, Hn = !Mn, ir = Rn ? zn(rr, An) : jn(rr, An), dr = Hn || Tn && Qn ? rr.map((ar, Or) => _n(ar, Or)) : ir;
      return createVNode(Fragment, null, [createVNode("div", {
        class: tr
      }, [rr && rr.length ? dr : Fr, Gn ? wt() : null])]);
    }
    function Yn(Fn) {
      N.handleMouseEnter(Fn);
    }
    function Zn(Fn) {
      N.handleMouseLeave(Fn);
    }
    function er(Fn) {
      N.handleKeyPress(Fn);
    }
    function bn(Fn) {
      const {
        virtualize: Gn
      } = s, {
        selections: Wn
      } = u;
      if (Fn)
        if (Gn) {
          let Mn = -1;
          if (Wn.forEach((Tn) => {
            const Rn = lodashExports.get(Tn, "_scrollIndex");
            lodashExports.isNumber(Rn) && Rn >= 0 && (Mn = Mn !== -1 && Mn < Rn ? Mn : Rn);
          }), Mn !== -1)
            try {
              g.value.scrollToItem(Mn, "center");
            } catch (Tn) {
              console.error(Tn);
            }
        } else
          N.updateScrollTop();
    }
    function Ln() {
      const {
        suffix: Fn
      } = s, Gn = cls({
        [`${prefixcls$6}-suffix`]: !0,
        [`${prefixcls$6}-suffix-text`]: Fn && lodashExports.isString(Fn),
        [`${prefixcls$6}-suffix-icon`]: isSemiIcon(Fn)
      });
      return createVNode("div", {
        class: Gn,
        "x-semi-prop": "suffix"
      }, [Fn]);
    }
    function Kn() {
      const {
        prefix: Fn,
        insetLabel: Gn,
        insetLabelId: Wn
      } = s, Mn = Fn || Gn, Tn = cls({
        [`${prefixcls$6}-prefix`]: !0,
        [`${prefixcls$6}-inset-label`]: Gn,
        [`${prefixcls$6}-prefix-text`]: Mn && lodashExports.isString(Mn),
        [`${prefixcls$6}-prefix-icon`]: isSemiIcon(Mn)
      });
      return createVNode("div", {
        class: Tn,
        id: Wn,
        "x-semi-prop": "prefix,insetLabel"
      }, [Mn]);
    }
    function Bn() {
      const {
        disabled: Fn,
        multiple: Gn,
        filter: Wn,
        style: Mn,
        id: Tn,
        size: Rn,
        className: hn,
        validateStatus: Qn,
        showArrow: rr,
        suffix: tr,
        prefix: Cr,
        insetLabel: Fr,
        placeholder: An,
        triggerRender: Hn,
        arrowIcon: ir,
        clearIcon: dr,
        borderless: ar,
        ...Or
      } = s, {
        selections: Sr,
        isOpen: kr,
        keyboardEventSet: Nr,
        inputValue: Ur,
        isHovering: _r,
        isFocus: Zr,
        showInput: Jr,
        focusIndex: ii
      } = u, Ti = typeof Hn == "function", Mi = !!Wn, ui = Ti ? cls(hn) : cls(prefixcls$6, hn, {
        [`${prefixcls$6}-borderless`]: ar,
        [`${prefixcls$6}-open`]: kr,
        [`${prefixcls$6}-focus`]: Zr,
        [`${prefixcls$6}-disabled`]: Fn,
        [`${prefixcls$6}-single`]: !Gn,
        [`${prefixcls$6}-multiple`]: Gn,
        [`${prefixcls$6}-filterable`]: Mi,
        [`${prefixcls$6}-small`]: Rn === "small",
        [`${prefixcls$6}-large`]: Rn === "large",
        [`${prefixcls$6}-error`]: Qn === "error",
        [`${prefixcls$6}-warning`]: Qn === "warning",
        [`${prefixcls$6}-no-arrow`]: !rr,
        [`${prefixcls$6}-with-prefix`]: Cr || Fr,
        [`${prefixcls$6}-with-suffix`]: tr
      }), Ii = s.showClear && (Sr.size || Ur) && !Fn && (_r || kr), bs = rr ? createVNode("div", {
        class: `${prefixcls$6}-arrow`,
        "x-semi-prop": "arrowIcon"
      }, [ir]) : createVNode("div", {
        class: `${prefixcls$6}-arrow-empty`
      }, null), Oi = dr || createVNode(IconComponent$w, null, null), Vs = Ti ? createVNode(Index$6, {
        value: Array.from(Sr.values()),
        inputValue: Ur,
        onChange: Re,
        onSearch: Re,
        onRemove: (Is) => N.removeTag(Is),
        onClear: nn,
        disabled: Fn,
        triggerRender: Hn,
        placeholder: An,
        componentName: "Select",
        componentProps: {
          ...s
        }
      }, null) : [createVNode(Fragment, {
        key: "prefix"
      }, [Cr || Fr ? Kn() : null]), createVNode(Fragment, {
        key: "selection"
      }, [createVNode("div", {
        class: cls(`${prefixcls$6}-selection`)
      }, [Gn ? kn(Sr, Mi) : Pn(Sr, Mi)])]), createVNode(Fragment, {
        key: "clearicon"
      }, [Ii ? createVNode("div", {
        class: cls(`${prefixcls$6}-clear`),
        onClick: nn
      }, [Oi]) : bs]), createVNode(Fragment, {
        key: "suffix"
      }, [tr ? Ln() : null])], _s = Fn || Mi && Jr || Mi && Gn ? -1 : 0;
      return createVNode("div", mergeProps$1({
        role: "combobox",
        "aria-disabled": Fn,
        "aria-expanded": kr,
        "aria-controls": `${prefixcls$6}-${c}`,
        "aria-haspopup": "listbox",
        "aria-label": "select value",
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-required": s["aria-required"],
        class: ui,
        ref: (Is) => S.value = Is,
        onClick: (Is) => N.handleClick(Is),
        style: Mn,
        id: Tn,
        tabindex: _s,
        "aria-activedescendant": ii !== -1 ? `${m}-option-${ii}` : "",
        onMouseenter: Yn,
        onMouseleave: Zn,
        onFocus: (Is) => N.handleTriggerFocus(Is),
        onBlur: (Is) => N.handleTriggerBlur(Is),
        onKeypress: er
      }, Nr, ue()), [Vs]);
    }
    return () => {
      const Fn = getFragmentChildren(l);
      !s.optionList && Fn && ((Fn == null ? void 0 : Fn.length) !== K.value.length || !lodashExports.isEqual(Fn.map((Or) => Or.props), K.value.map((Or) => Or.props))) && (K.value = Fn || []);
      const {
        direction: Gn
      } = W.value, Wn = Gn === "rtl" ? "bottomRight" : "bottomLeft", {
        position: Mn = Wn,
        zIndex: Tn,
        getPopupContainer: Rn,
        motion: hn,
        autoAdjustOverflow: Qn,
        mouseLeaveDelay: rr,
        mouseEnterDelay: tr,
        spacing: Cr,
        stopPropagation: Fr,
        dropdownMargin: An
      } = s, {
        isOpen: Hn,
        optionKey: ir
      } = u, dr = vn(l.default ? l.default() : null), ar = Bn();
      return createVNode(Popover$1, {
        getPopupContainer: Rn,
        motion: hn,
        autoAdjustOverflow: Qn,
        mouseLeaveDelay: rr,
        mouseEnterDelay: tr,
        zIndex: Tn,
        ref: E,
        content: dr,
        visible: Hn,
        trigger: "custom",
        rePosKey: ir,
        position: Mn,
        spacing: Cr,
        stopPropagation: Fr,
        disableArrowKeyDown: !0,
        onVisibleChange: (Or) => bn(Or),
        afterClose: () => N.handlePopoverClose()
      }, _isSlot$z(ar) ? ar : {
        default: () => [ar]
      });
    };
  }
}), Select = Index$1, parseToDate = (s, o = strings$e.DEFAULT_FORMAT, l = locale) => {
  if (s instanceof Date)
    return s;
  if (typeof s == "number")
    return new Date(lodashExports.toNumber(s));
  if (typeof s == "string") {
    let u = /* @__PURE__ */ new Date();
    return u = parse$2(s, o, u, { locale: l }), u;
  } else if (typeof s > "u")
    return;
  return /* @__PURE__ */ new Date();
}, formatToString = (s, o = strings$e.DEFAULT_FORMAT, l = locale) => format$3(s, o, { locale: l }), hourIsDisabled = (s, o) => {
  if (typeof s == "function") {
    const l = s();
    if (Array.isArray(l) && !isNullOrUndefined(o) && l.some((u) => lodashExports.toNumber(u) === lodashExports.toNumber(o)))
      return !0;
  }
  return !1;
}, minuteIsDisabled = (s, o, l) => {
  if (typeof s == "function") {
    const u = s(o);
    if (Array.isArray(u) && !isNullOrUndefined(o) && !isNullOrUndefined(l) && u.some((c) => lodashExports.toNumber(c) === lodashExports.toNumber(l)))
      return !0;
  }
  return !1;
}, secondIsDisabled = (s, o, l, u) => {
  if (typeof s == "function") {
    const c = s(o, l);
    if (Array.isArray(c) && !isNullOrUndefined(o) && !isNullOrUndefined(l) && !isNullOrUndefined(u) && c.some((m) => lodashExports.toNumber(m) === lodashExports.toNumber(u)))
      return !0;
  }
  return !1;
}, transformToArray = (s) => Array.isArray(s) ? [...s] : [], isTimeFormatLike = (s, o) => {
  let l = !0;
  const u = "BDEGHKLMOPQRSTXYabcehimopqstuwxyz", c = new RegExp(`[${u}]`, "g"), m = new RegExp(`[^${u}]`, "g"), g = /[H|m|s]{1,2}/, v = o.split(m), b = o.replace(c, ""), S = new RegExp(`[${b}]`, "g"), E = s.split(S);
  if (v.length !== E.length)
    l = !1;
  else
    for (let P = 0, T = E.length; P < T; P++) {
      const N = v[P], O = E[P];
      if (g.test(N) && O.length < N.length) {
        l = !1;
        break;
      }
    }
  return l;
};
let TimePickerFoundation$1 = class extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    this.initDataFromDefaultValue(), (this._isControlledComponent("open") ? this.getProp("open") : this.getProp("defaultOpen")) && !this._isControlledComponent("open") && this._adapter.registerClickOutSide();
  }
  getPosition() {
    const o = this.getProp("position"), l = this.getProp("type") || strings$e.DEFAULT_TYPE, c = this.getContext("direction") === "rtl" ? "bottomRight" : "";
    return o || c || strings$e.DEFAULT_POSITION[l];
  }
  isDisabledHMS({ hours: o, minutes: l, seconds: u }) {
    const { disabledHours: c, disabledMinutes: m, disabledSeconds: g } = this.getProps(), v = !isNullOrUndefined(o) && hourIsDisabled(c, o), b = !isNullOrUndefined(o) && !isNullOrUndefined(l) && minuteIsDisabled(m, o, l), S = !isNullOrUndefined(o) && !isNullOrUndefined(l) && !isNullOrUndefined(u) && secondIsDisabled(g, o, l, u);
    return v || b || S;
  }
  isValidTimeZone(o) {
    return ["string", "number"].includes(typeof o) && o !== "";
  }
  getDefaultFormatIfNeed() {
    return this._isInProps("format") ? this.getProp("format") : this.getProp("use12Hours") ? strings$e.DEFAULT_FORMAT_A : strings$e.DEFAULT_FORMAT;
  }
  /**
   * User input value => save timestamp
   */
  initDataFromDefaultValue() {
    const o = this.getProp("defaultValue");
    let l = this.getProp("value");
    const u = this.getProp("timeZone"), c = this.getValidFormat(), { rangeSeparator: m, dateFnsLocale: g } = this.getProps();
    l = l || o, Array.isArray(l) || (l = l ? [l] : []);
    const v = [];
    let b = !1;
    l.forEach((P) => {
      const T = parseToDate(P, c, g);
      isNaN(T.getTime()) || v.push(this.isValidTimeZone(u) ? utcToZonedTime(T, u) : T);
    });
    const S = [!0, !1];
    v.map((P, T) => {
      S[T] = getHours(P) < 12;
    }), v.length === l.length ? l = v : (l = [], l.length && (b = !0));
    let E = "";
    b || (E = l.map((P) => formatToString(P, c, g)).join(m)), this.setState({
      isAM: S,
      value: l,
      inputValue: E,
      invalid: b
    });
  }
  getValidFormat(o) {
    let l = o;
    return isNullOrUndefined(l) && (l = this.getDefaultFormatIfNeed()), typeof l != "string" && (l = strings$e.DEFAULT_FORMAT), l;
  }
  handlePanelChange(o, l = 0) {
    const u = this.getValidFormat(), c = this.getProp("dateFnsLocale"), m = this.getState("value");
    let g = this.getState("isAM");
    const v = transformToArray(m);
    if (g = transformToArray(g), o) {
      const b = !!o.isAM, S = parseToDate(o.timeStampValue, u, c);
      v[l] = S, g[l] = b;
      const E = this.formatValue(v);
      if (this.getState("isAM")[l] !== o.isAM && this.setState({ isAM: g }), !this._isControlledComponent("value")) {
        const P = this.validateDates(v);
        this.setState({
          isAM: g,
          value: v,
          inputValue: E,
          invalid: P
        });
      }
      this._hasChanged(v, m) && this._notifyChange(v, E);
    }
  }
  refreshProps(o = {}) {
    const { value: l, timeZone: u, __prevTimeZone: c } = o;
    let m = this.parseValue(l), g = m.some((b) => isNaN(Number(b)));
    g || (this.isValidTimeZone(u) && (m = m.map(
      (b) => utcToZonedTime(
        this.isValidTimeZone(c) ? zonedTimeToUtc(b, c) : b,
        u
      )
    )), g = m.some(
      (b) => this.isDisabledHMS({ hours: b.getHours(), minutes: b.getMinutes(), seconds: b.getSeconds() })
    ));
    const v = this.formatValue(m);
    this.setState({
      value: m,
      invalid: g,
      inputValue: v
    });
  }
  handleFocus(o) {
    this.getState("open") || this.handlePanelOpen(), this._adapter.notifyFocus(o);
  }
  setPanel(o) {
    this._adapter.togglePanel(o);
  }
  destroy() {
    this._adapter.unregisterClickOutSide();
  }
  handlePanelOpen() {
    this._isControlledComponent("open") || (this._adapter.registerClickOutSide(), this.setPanel(!0)), this._adapter.notifyOpenChange(!0);
  }
  handlePanelClose(o, l) {
    this._isControlledComponent("open") || (this._adapter.unregisterClickOutSide(), this.setPanel(!1)), this._adapter.notifyOpenChange(!1), this._adapter.notifyBlur(l);
  }
  /* istanbul ignore next */
  handleVisibleChange(o) {
    this._isControlledComponent("open") || this._adapter.togglePanel(o), this._adapter.notifyOpenChange(o);
  }
  handleInputChange(o) {
    this._adapter.setInputValue(o);
    const l = this.getProp("rangeSeparator"), u = lodashExports.split(o, l), c = this.getValidFormat();
    if (o !== "" && u.some((E) => !isTimeFormatLike(E, c)))
      return;
    const m = this.parseInput(o), g = this.validateDates(m), v = { invalid: g }, b = this.getState("value");
    let S = transformToArray(b);
    g || (v.value = m, S = [...m]), this._isControlledComponent("value") || this.setState(v), this._hasChanged(S, b) && this._notifyChange(S, o);
  }
  /* istanbul ignore next */
  doValidate(o) {
    if (typeof o == "string")
      return this.validateStr(o);
    if (Array.isArray(o))
      return this.validateDates(o);
  }
  validateStr(o = "") {
    const l = this.parseInput(o);
    return this.validateDates(l);
  }
  validateDates(o = []) {
    let l = o.some((u) => isNaN(Number(u)));
    return l || (l = o.some(
      (u) => this.isDisabledHMS({ hours: u.getHours(), minutes: u.getMinutes(), seconds: u.getSeconds() })
    )), l;
  }
  handleInputBlur(o) {
    const l = this.getState("invalid"), u = this.getState("inputValue"), c = this.getState("value");
    u ? l ? this.setState({
      inputValue: this.formatValue(c),
      invalid: !1
    }) : this.setState({
      inputValue: this.formatValue(c)
    }) : this.setState({
      inputValue: "",
      value: [],
      invalid: !1
    });
  }
  formatValue(o) {
    const l = this.getValidFormat(), u = this.getProp("rangeSeparator"), c = this.getProp("dateFnsLocale");
    let m = o;
    if (m && !Array.isArray(m) && (m = m[m]), m && Array.isArray(m))
      return m.map((v) => {
        let b;
        return lodashExports.isUndefined(v) ? b = "" : b = formatToString(v, l, c), b;
      }).join(u);
  }
  parseInput(o) {
    const l = this.getValidFormat(), u = this.getProp("rangeSeparator"), c = this.getProp("dateFnsLocale");
    return o && typeof o == "string" ? lodashExports.split(o, u).map((m) => parseToDate(m, l, c)) : [];
  }
  parseValue(o = []) {
    const l = this.getValidFormat(), u = this.getProp("dateFnsLocale");
    let c = o;
    return Array.isArray(c) || (c = c ? [c] : []), Array.isArray(c) ? c.map((m) => parseToDate(m, l, u)) : [];
  }
  _notifyChange(o, l) {
    let u = l, c = o;
    const m = this.getProp("timeZone");
    if (this._adapter.isRangePicker()) {
      const v = this.getProp("rangeSeparator");
      u = lodashExports.split(l, v);
    } else
      c = Array.isArray(c) ? c[0] : c;
    if (this.isValidTimeZone(m) && c) {
      const v = this.getValidFormat();
      Array.isArray(c) ? (c = c.map((b) => zonedTimeToUtc(b, m)), u = c.map((b) => format$3(b, v))) : (c = zonedTimeToUtc(c, m), u = format$3(c, v));
    }
    this.getProp("onChangeWithDateFirst") ? this._adapter.notifyChange(c, u) : this._adapter.notifyChange(u, c);
  }
  _hasChanged(o = [], l = []) {
    const u = this.getValidFormat(), c = this.getProp("dateFnsLocale");
    return o.length !== l.length || o.some((m, g) => {
      const v = l[g];
      return !(isValid$5(m) && isValid$5(v) && formatToString(m, u, c) === formatToString(v, u, c));
    });
  }
};
class TimePickerFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
  }
  destroy() {
  }
  handleFocus(o) {
    this.storeCursor(), this._adapter.notifyFocus(o);
  }
  handleChange(o) {
    this.storeCursor(), this._adapter.notifyChange(o);
  }
  handleBlur(o) {
    this.clearCursor(), this._adapter.notifyBlur(o);
  }
  storeCursor() {
    const o = this.getCache("inputNode");
    if (o) {
      const { selectionStart: l } = o;
      this.setCache("cursorIndex", l);
    }
  }
  restoreCursor() {
    const o = this.getCache("inputNode"), l = this.getCache("cursorIndex");
    o && !isNullOrUndefined(l) && (o.selectionStart = l, o.selectionEnd = l);
  }
  clearCursor() {
    this.setCache("cursorIndex", null), this.setCache("beforeStr", null), this.setCache("afterStr", null);
  }
}
const propTypes$1l = {
  value: String,
  borderless: bool,
  format: {
    type: string$3,
    default: strings$e.DEFAULT_FORMAT
  },
  prefixCls: string$3,
  placeholder: string$3,
  clearText: string$3,
  inputReadOnly: {
    type: bool,
    default: !1
  },
  hourOptions: array$1,
  minuteOptions: array$1,
  secondOptions: array$1,
  disabledHours: {
    type: func,
    default: lodashExports.noop
  },
  disabledMinutes: {
    type: func,
    default: lodashExports.noop
  },
  disabledSeconds: {
    type: func,
    default: lodashExports.noop
  },
  onChange: {
    type: func,
    default: lodashExports.noop
  },
  onFocus: {
    type: func,
    default: lodashExports.noop
  },
  onBlur: {
    type: func,
    default: lodashExports.noop
  },
  onEsc: func,
  onClick: {
    type: func,
    default: lodashExports.noop
  },
  defaultOpenValue: object$1,
  currentSelectPanel: string$3,
  focusOnOpen: bool,
  timeStampValue: any$1,
  locale: object$1,
  localeCode: string$3,
  insetLabel: node$1,
  validateStatus: string$3,
  preventScroll: bool,
  disabled: bool,
  type: string$3,
  timeZone: [string$3, number$2],
  defaultOpen: bool,
  dateFnsLocale: object$1,
  style: object$1,
  className: string$3,
  invalid: bool
}, defaultProps$1f = {
  borderless: !1,
  inputReadOnly: !1,
  onChange: lodashExports.noop,
  onBlur: lodashExports.noop,
  onFocus: lodashExports.noop,
  onClick: lodashExports.noop,
  disabledHours: lodashExports.noop,
  disabledMinutes: lodashExports.noop,
  disabledSeconds: lodashExports.noop,
  format: strings$e.DEFAULT_FORMAT
}, vuePropsType$28 = vuePropsMake(propTypes$1l, defaultProps$1f), TimeInput = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$28
  },
  name: "TimeInput",
  setup(s, {
    slots: o
  }) {
    const l = reactive({
      // focusing: props.focusOnOpen,
    }), {
      adapter: u,
      isControlled: c
    } = useBaseComponent(s, l);
    function m() {
      return {
        ...u(),
        notifyChange: (...O) => s.onChange(...O),
        notifyFocus: (...O) => s.onFocus(...O),
        notifyBlur: (...O) => s.onBlur(...O)
      };
    }
    const g = m(), v = new TimePickerFoundation(g);
    onMounted(() => {
      const {
        focusOnOpen: O,
        preventScroll: z
      } = s;
      O && (window.requestAnimationFrame || window.setTimeout)(() => {
        const W = g.getCache("inputNode");
        W && (W.focus({
          preventScroll: z
        }), W.select());
      });
    }), watch([() => s.timeStampValue, () => l.timeStampValue, () => s.value], (O, [z, Q, W]) => {
      const {
        timeStampValue: ue
      } = s;
      c("timeStampValue") && ue !== l.timeStampValue && v.restoreCursor(), s.value !== W && v.restoreCursor();
    }, {
      immediate: !0
    });
    const b = (O) => g.setCache("inputNode", O), S = (O) => s.onClick(O), E = (O) => v.handleFocus(O), P = (O) => v.handleBlur(O), T = (O) => v.handleChange(O);
    function N() {
      const {
        prefixCls: O,
        placeholder: z,
        inputReadOnly: Q,
        onFocus: W,
        disabled: ue,
        type: te,
        locale: K,
        localeCode: ve,
        insetLabel: ee,
        validateStatus: Re,
        value: wt,
        onChange: yt,
        invalid: xt,
        format: Kt,
        clearText: tn,
        disabledHours: ln,
        disabledMinutes: rn,
        disabledSeconds: an,
        onEsc: Gt,
        defaultOpenValue: nn,
        currentSelectPanel: vt,
        focusOnOpen: Et,
        timeStampValue: Qt,
        timeZone: un,
        defaultOpen: gn,
        dateFnsLocale: dn,
        onBlur: yn,
        ...vn
      } = s, Pn = cls(`${O}-input`, {
        [`${O}-input-invalid`]: xt,
        [`${O}-input-readonly`]: Q
      }), On = xt ? "error" : Re;
      return createVNode(Input$1, mergeProps$1(vn, {
        hideSuffix: !0,
        className: Pn,
        ref: b,
        value: wt,
        placeholder: z || K.placeholder[te],
        readonly: !!Q,
        onChange: T,
        onFocus: E,
        onBlur: P,
        suffix: createVNode(IconComponent$v, {
          onClick: S
        }, null),
        validateStatus: On,
        disabled: ue,
        insetLabel: ee
      }), null);
    }
    return () => {
      const {
        prefixCls: O
      } = s;
      return createVNode("div", {
        class: `${O}-input-wrap`
      }, [N()]);
    };
  }
}), propTypes$1k = timePickerPropTypes, defaultProps$1e = {
  autoAdjustOverflow: !0,
  getPopupContainer: () => document.body,
  showClear: !0,
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  rangeSeparator: strings$e.DEFAULT_RANGE_SEPARATOR,
  onOpenChange: lodashExports.noop,
  clearText: "clear",
  prefixCls: cssClasses$H.PREFIX,
  borderless: !1,
  inputReadOnly: !1,
  style: {},
  stopPropagation: !0,
  className: "",
  popupClassName: "",
  popupStyle: {
    left: "0px",
    top: "0px"
  },
  disabledHours: () => [],
  disabledMinutes: () => [],
  disabledSeconds: () => [],
  hideDisabledOptions: !1,
  // position: 'bottomLeft',
  onFocus: lodashExports.noop,
  onBlur: lodashExports.noop,
  onChange: lodashExports.noop,
  onChangeWithDateFirst: !0,
  use12Hours: !1,
  focusOnOpen: !1,
  onKeyDown: lodashExports.noop,
  size: "default",
  type: strings$e.DEFAULT_TYPE,
  motion: !0,
  ...PanelShapeDefaults
  // format: strings.DEFAULT_FORMAT,
  // open and value controlled
}, vuePropsType$27 = vuePropsMake(propTypes$1k, defaultProps$1e), TimePicker$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$27
  },
  name: "TimePicker",
  setup(s, {
    slots: o
  }) {
    const {
      getProps: l
    } = useHasInProps(), {
      format: u = strings$e.DEFAULT_FORMAT
    } = s, c = reactive({
      open: s.open || s.defaultOpen || !1,
      value: [],
      // Date[]
      inputValue: "",
      // time string
      currentSelectPanel: 0,
      isAM: [!0, !1],
      showHour: !!u.match(/HH|hh|H|h/g),
      showMinute: !!u.match(/mm/g),
      showSecond: !!u.match(/ss/g),
      invalid: void 0
    }), m = ref$1(), g = ref$1();
    let v = typeof s.triggerRender == "function", b;
    const {
      adapter: S,
      isControlled: E
    } = useBaseComponent(s, c), P = new TimePickerFoundation$1(T());
    function T() {
      return {
        ...S(),
        togglePanel: (wt) => {
          c.open = wt;
        },
        registerClickOutSide: () => {
          b && T().unregisterClickOutSide(), b = (wt) => {
            const yt = g.value, xt = m.value, Kt = wt.target, tn = wt.composedPath && wt.composedPath() || [Kt];
            !(yt && yt.contains(Kt)) && !(xt && xt.contains(Kt)) && !(tn.includes(xt) || tn.includes(yt)) && P.handlePanelClose(!0, wt);
          }, document.addEventListener("mousedown", b);
        },
        setInputValue: (wt, yt) => {
          c.inputValue = wt, nextTick(() => {
            yt();
          });
        },
        unregisterClickOutSide: () => {
          b && (document.removeEventListener("mousedown", b), b = null);
        },
        notifyOpenChange: (...wt) => s.onOpenChange(...wt),
        notifyChange: (wt, yt) => s.onChange && s.onChange(wt, yt),
        notifyFocus: (...wt) => s.onFocus && s.onFocus(...wt),
        notifyBlur: (...wt) => s.onBlur && s.onBlur(...wt),
        isRangePicker: () => s.type === strings$e.TYPE_TIME_RANGE_PICKER
      };
    }
    function N(wt, yt) {
      return "open" in l(wt) && wt.open !== yt.open ? {
        open: wt.open
      } : null;
    }
    watch([() => s.open, () => c.open], (wt) => {
      const yt = N({
        ...s
      }, {
        ...c
      });
      yt && Object.keys(yt).forEach((xt) => {
        c[xt] = yt[xt];
      });
    }, {
      immediate: !0
    }), watch([() => s.value, () => s.timeZone, () => c.value], (wt, yt) => {
      E("value") && wt[0] !== yt[0] ? P.refreshProps({
        ...s
      }) : wt[1] !== yt[1] && P.refreshProps({
        timeZone: s.timeZone,
        __prevTimeZone: yt[1],
        value: c.value
      });
    }, {
      immediate: !0
    });
    const O = (wt) => {
      c.currentSelectPanel = wt;
    }, z = (wt, yt) => {
      P.handlePanelChange(wt, yt);
    }, Q = (wt) => {
      P.handleInputChange(wt);
    }, W = (wt = 0) => {
      const {
        panels: yt,
        panelFooter: xt,
        panelHeader: Kt,
        locale: tn
      } = s, ln = {
        panelHeader: Kt,
        panelFooter: xt
      };
      if (T().isRangePicker()) {
        const rn = {
          0: tn.begin,
          1: tn.end
        };
        ln.panelHeader = lodashExports.get(yt, wt, isNullOrUndefined(Kt) ? lodashExports.get(rn, wt, null) : Kt), ln.panelFooter = lodashExports.get(yt, wt, xt);
      }
      return ln;
    };
    function ue() {
      const {
        prefixCls: wt,
        type: yt
      } = s, {
        isAM: xt,
        value: Kt
      } = c, tn = P.getDefaultFormatIfNeed(), ln = [createVNode(Combobox, {
        ...s,
        key: 0,
        format: tn,
        isAM: xt[0],
        timeStampValue: Kt[0],
        prefixCls: `${wt}-panel`,
        onChange: (an) => z(an, 0),
        onCurrentSelectPanelChange: O,
        ...W(0)
      }, null)];
      yt === strings$e.TYPE_TIME_RANGE_PICKER && ln.push(createVNode(Combobox, {
        ...s,
        key: 1,
        format: tn,
        isAM: xt[1],
        timeStampValue: Kt[1],
        prefixCls: `${wt}-panel`,
        onChange: (an) => z(an, 1),
        onCurrentSelectPanelChange: O,
        ...W(1)
      }, null));
      const rn = cls({
        [cssClasses$H.RANGE_PANEL_LISTS]: T().isRangePicker()
      });
      return createVNode("div", {
        ref: g,
        class: rn
      }, [ln.map((an) => an)]);
    }
    function te() {
      const {
        use12Hours: wt,
        prefixCls: yt,
        popupClassName: xt
      } = s, {
        showHour: Kt,
        showMinute: tn,
        showSecond: ln
      } = c;
      let rn = 0;
      return Kt && (rn += 1), tn && (rn += 1), ln && (rn += 1), wt && (rn += 1), cls(`${yt}-panel`, xt, {
        [`${yt}-panel-narrow`]: (!Kt || !tn || !ln) && !wt,
        [cssClasses$H.RANGE_PICKER]: T().isRangePicker()
      }, `${yt}-panel-column-${rn}`);
    }
    const K = () => {
      P.handlePanelOpen();
    }, ve = (wt) => {
      P.handleFocus(wt);
    }, ee = (wt) => P.handleInputBlur(wt), Re = (wt) => m.value = wt;
    return () => {
      const {
        prefixCls: wt,
        placeholder: yt,
        disabled: xt,
        defaultValue: Kt,
        dropdownMargin: tn,
        className: ln,
        popupStyle: rn,
        size: an,
        style: Gt,
        locale: nn,
        localeCode: vt,
        zIndex: Et,
        getPopupContainer: Qt,
        insetLabel: un,
        insetLabelId: gn,
        inputStyle: dn,
        showClear: yn,
        panelHeader: vn,
        panelFooter: Pn,
        rangeSeparator: On,
        onOpenChange: _n,
        onChangeWithDateFirst: Nn,
        popupClassName: Un,
        hideDisabledOptions: Xn,
        use12Hours: zn,
        minuteStep: jn,
        hourStep: kn,
        secondStep: Yn,
        scrollItemProps: Zn,
        triggerRender: er,
        motion: bn,
        autoAdjustOverflow: Ln,
        stopPropagation: Kn,
        ...Bn
      } = s, Fn = P.getDefaultFormatIfNeed(), Gn = P.getPosition(), {
        open: Wn,
        inputValue: Mn,
        invalid: Tn,
        value: Rn
      } = c, hn = te(), Qn = cls({
        [`${wt}-header`]: !0
      }), rr = cls({
        [`${wt}-panel`]: !0,
        [`${wt}-panel-${an}`]: an
      }), tr = {
        ...Bn,
        disabled: xt,
        prefixCls: wt,
        size: an,
        showClear: xt ? !1 : yn,
        style: dn,
        value: Mn,
        onFocus: ve,
        insetLabel: un,
        insetLabelId: gn,
        format: Fn,
        locale: nn,
        localeCode: vt,
        invalid: Tn,
        placeholder: yt,
        onChange: Q,
        onBlur: ee
      }, Cr = {};
      return v && (Cr.onClick = K), createVNode("div", mergeProps$1({
        ref: Re,
        class: cls({
          [wt]: !0
        }, ln),
        style: Gt
      }, Cr), [createVNode(Popover$1, {
        getPopupContainer: Qt,
        zIndex: Et,
        prefixCls: rr,
        contentClassName: hn,
        style: rn,
        content: ue(),
        trigger: "custom",
        position: Gn,
        visible: xt ? !1 : !!Wn,
        motion: bn,
        margin: tn,
        autoAdjustOverflow: Ln,
        stopPropagation: Kn
      }, {
        default: () => [v ? createVNode(Index$6, {
          triggerRender: er,
          disabled: xt,
          value: Rn,
          inputValue: Mn,
          onChange: Q,
          placeholder: yt,
          componentName: "TimePicker",
          componentProps: {
            ...s
          }
        }, null) : createVNode("span", {
          class: Qn
        }, [createVNode(TimeInput, tr, null)])]
      })]);
    };
  }
}), vuePropsType$26 = vuePropsMake(propTypes$1k, defaultProps$1e), index$8 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$26
  },
  name: "TimePickerIndex",
  setup(s, {}) {
    useSlots();
    const {
      getProps: o,
      hasInProps: l
    } = useHasInProps();
    return () => {
      const {
        type: u
      } = s;
      return createVNode(ConfigContext.Consumer, null, {
        default: ({
          timeZone: c
        }) => createVNode(LocaleConsumer$6, {
          componentName: "TimePicker"
        }, {
          default: (m, g, v) => createVNode(TimePicker$1, mergeProps$1({
            timeZone: c,
            placeholder: lodashExports.get(m, ["placeholder", u])
          }, o(s), {
            locale: m,
            localeCode: g,
            dateFnsLocale: v
          }), null)
        })
      });
    };
  }
}), TimePicker = index$8, isBothNaN = (s, o) => {
  const { isNaN: l } = Number;
  return l(s) && l(o);
}, cssClasses$C = {
  ...cssClasses$O
}, numbers$9 = {
  ...numbers$e,
  DEFAULT_STEP: 1,
  DEFAULT_SHIFT_STEP: 10,
  DEFAULT_PRESS_TIMEOUT: 250,
  DEFAULT_PRESS_INTERVAL: 0,
  MOUSE_BUTTON_LEFT: 0
  // left mouse button
}, strings$b = {
  ...strings$l
};
function plus(s, o) {
  const l = (s.toString().split(".")[1] || "").length, u = (o.toString().split(".")[1] || "").length, c = Math.pow(10, Math.max(l, u));
  return (s * c + o * c) / c;
}
function minus(s, o) {
  return plus(s, -o);
}
class InputNumberFoundation extends BaseFoundation$1 {
  init() {
    this._setInitValue();
  }
  destroy() {
    this._unregisterInterval(), this._unregisterTimer(), this._adapter.unregisterGlobalEvent("mouseup");
  }
  isControlled() {
    return this._isControlledComponent("value");
  }
  _doInput(o = "", l = null, u = null) {
    let c = o, m = o, g = !0;
    const v = this.isControlled();
    typeof o != "number" && (m = this.doParse(o, !1), g = !isNaN(m)), g && (c = m, v || this._adapter.setNumber(m)), v || this._adapter.setValue(o, u), this.getProp("keepFocus") && this._adapter.setFocusing(!0, () => {
      this._adapter.setClickUpOrDown(!0);
    }), this.notifyChange(c, l);
  }
  _registerInterval(o) {
    const l = this.getProp("pressInterval") || numbers$9.DEFAULT_PRESS_INTERVAL;
    this._intervalHasRegistered = !0, this._interval = setInterval(() => {
      typeof o == "function" && this._intervalHasRegistered && o();
    }, l);
  }
  _unregisterInterval() {
    this._interval && (this._intervalHasRegistered = !1, clearInterval(this._interval), this._interval = null);
  }
  _registerTimer(o) {
    const l = this.getProp("pressTimeout") || numbers$9.DEFAULT_PRESS_TIMEOUT;
    this._timerHasRegistered = !0, this._timer = setTimeout(() => {
      this._timerHasRegistered && typeof o == "function" && o();
    }, l);
  }
  _unregisterTimer() {
    this._timer && (this._timerHasRegistered = !1, clearTimeout(this._timer), this._timer = null);
  }
  handleInputFocus(o) {
    this.getState("value"), this._adapter.recordCursorPosition(), this._adapter.setFocusing(!0, null), this._adapter.setClickUpOrDown(!1), this._adapter.notifyFocus(o);
  }
  /**
   * Input box content update processing
   * @param {String} value
   * @param {*} event
   */
  handleInputChange(o, l) {
    const u = this.doParse(o, !0, !0, !0), c = this.doParse(o, !1, !1, !1), m = this.afterParser(o);
    this._adapter.recordCursorPosition();
    let g, v = c, b = o;
    if (o === "")
      this.isControlled() || (v = null);
    else if (this.isValidNumber(c) && this.isValidNumber(u))
      g = c, b = this.doFormat(c, !1);
    else {
      if (typeof c == "number" && !isNaN(c)) {
        b = this.doFormat(c, !1);
        const S = m.lastIndexOf("."), E = m.length - 1 - S, P = this._getPrecLen(c);
        if (P) {
          if (P < E)
            for (let T = 0; T < E - P; T++)
              b += "0";
        } else {
          const T = S > -1 ? m.slice(S) : "";
          b += T;
        }
        v = c;
      } else
        b = this.doFormat(m, !1);
      g = m;
    }
    !this.isControlled() && (v === null || typeof v == "number" && !isNaN(v)) && this._adapter.setNumber(v), this._adapter.setValue(this.isControlled() ? b : this.doFormat(m, !1), () => {
      this._adapter.restoreCursor();
    }), this.notifyChange(g, l);
  }
  handleInputKeyDown(o) {
    const l = o.keyCode;
    if (l === KeyCode.UP || l === KeyCode.DOWN) {
      this._adapter.setClickUpOrDown(!0), this._adapter.recordCursorPosition();
      const u = l === KeyCode.UP ? this.add(null, o) : this.minus(null, o);
      this._doInput(u, o, () => {
        this._adapter.restoreCursor();
      }), o.preventDefault();
    }
    this._adapter.notifyKeyDown(o);
  }
  handleInputBlur(o) {
    const l = lodashExports.toString(this.getState("value"));
    let u = this.getState("number");
    if (u != null || l != null && l !== "") {
      const c = this.doParse(l, !1, !0, !0);
      let m = !1, g = !1, v, b;
      this.isValidNumber(c) && u !== c && (v = c, this.isControlled() || (u = v), m = !0);
      const S = this.doFormat(u, !0);
      if (S !== l && (b = S, g = !0), g || m) {
        const E = b ?? v;
        b != null && this._adapter.setValue(b), v != null && (this._isControlledComponent("value") || this._adapter.setNumber(v)), this.notifyChange(E, o);
      }
    }
    this._adapter.setFocusing(!1), this._adapter.notifyBlur(o);
  }
  handleInputMouseEnter(o) {
    this._adapter.setHovering(!0);
  }
  handleInputMouseLeave(o) {
    this._adapter.setHovering(!1);
  }
  handleInputMouseMove(o) {
    this._adapter.setHovering(!0);
  }
  handleMouseUp(o) {
    this._unregisterInterval(), this._unregisterTimer(), this._adapter.unregisterGlobalEvent("mouseup");
  }
  handleUpClick(o) {
    const { readonly: l } = this.getProps();
    !this._isMouseButtonLeft(o) || l || (this._adapter.setClickUpOrDown(!0), o && (this._persistEvent(o), o.stopPropagation(), this._preventDefault(o)), this.upClick(o), this._registerTimer(() => {
      this._registerInterval(() => {
        this.upClick(o);
      });
    }));
  }
  handleDownClick(o) {
    const { readonly: l } = this.getProps();
    !this._isMouseButtonLeft(o) || l || (this._adapter.setClickUpOrDown(!0), o && (this._persistEvent(o), o.stopPropagation(), this._preventDefault(o)), this.downClick(o), this._registerTimer(() => {
      this._registerInterval(() => {
        this.downClick(o);
      });
    }));
  }
  /**
   * Whether it is a left mouse button click
   * @see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
   */
  _isMouseButtonLeft(o) {
    return lodashExports.get(o, "button") === numbers$9.MOUSE_BUTTON_LEFT;
  }
  _preventDefault(o) {
    const l = this._adapter.getProp("keepFocus"), u = this._adapter.getProp("innerButtons");
    (l || u) && o.preventDefault();
  }
  handleMouseLeave(o) {
    this._adapter.registerGlobalEvent("mouseup", () => {
      this.handleMouseUp(o);
    });
  }
  upClick(o) {
    const l = this.add(null, o);
    this._doInput(l, o), this._adapter.notifyUpClick(l, o);
  }
  downClick(o) {
    const l = this.minus(null, o);
    this._doInput(l, o), this._adapter.notifyDownClick(l, o);
  }
  _setInitValue() {
    const { defaultValue: o, value: l } = this.getProps(), u = this._isControlledComponent("value") ? l : o, c = this.doParse(lodashExports.toString(u), !1, !0, !0);
    let m = null;
    typeof c == "number" && !isNaN(c) && (m = c);
    const g = typeof m == "number" ? this.doFormat(m, !0) : "";
    this._adapter.setNumber(m), this._adapter.setValue(g), lodashExports.isString(g) && g !== String(u ?? "") && this.notifyChange(g, null);
  }
  add(o, l) {
    const c = l && l.shiftKey ? this.getProp("shiftStep") : this.getProp("step");
    o = o == null ? c : Number(o);
    const m = Math.abs(lodashExports.toNumber(o)), g = this.getState("number");
    let v = this.toNumber(g) || 0;
    const b = this.getProp("min"), S = this.getProp("max"), E = this._getPrecLen(b), P = this._getPrecLen(S), T = this._getPrecLen(v), N = this._getPrecLen(o), O = Math.pow(10, Math.max(E, P, T, N));
    return o < 0 ? Math.abs(minus(b, v)) >= m && (v = (v * O + o * O) / O) : o > 0 && Math.abs(minus(S, v)) >= m && (v = (v * O + o * O) / O), typeof b == "number" && b > v && (v = b), typeof S == "number" && S < v && (v = S), this.doFormat(v, !0);
  }
  minus(o, l) {
    const c = l && l.shiftKey ? this.getProp("shiftStep") : this.getProp("step");
    return o = o == null ? c : Number(o), this.add(-o, l);
  }
  /**
   * get decimal length
   * @param {number} num
   * @returns {number}
   */
  _getPrecLen(o) {
    typeof o != "string" && (o = String(Math.abs(Number(o || ""))));
    const l = o.indexOf(".") + 1;
    return l ? o.length - l : 0;
  }
  _adjustPrec(o) {
    const l = this.getProp("precision");
    return typeof l == "number" && o !== "" && o !== null && !Number.isNaN(Number(o)) && (o = Number(o).toFixed(l)), lodashExports.toString(o);
  }
  /**
   * format number to string
   * @param {string|number} value
   * @param {boolean} needAdjustPrec
   * @returns {string}
   */
  doFormat(o = 0, l = !0) {
    let u;
    const c = this.getProp("formatter");
    return l ? u = this._adjustPrec(o) : u = lodashExports.toString(o), typeof c == "function" && (u = c(u)), u;
  }
  /**
   *
   * @param {number} current
   * @returns {number}
   */
  fetchMinOrMax(o) {
    const { min: l, max: u } = this.getProps();
    return o < l ? l : o > u ? u : o;
  }
  /**
   * parse to number
   * @param {string|number} value
   * @param {boolean} needCheckPrec
   * @param {boolean} needAdjustPrec
   * @param {boolean} needAdjustMaxMin
   * @returns {number}
   */
  doParse(o, l = !0, u = !1, c = !1) {
    if (typeof o == "number")
      return c && (o = this.fetchMinOrMax(o)), u && (o = this._adjustPrec(o)), lodashExports.toNumber(o);
    const m = this.getProp("parser");
    if (typeof m == "function" && (o = m(o)), l && typeof o == "string") {
      const g = o.indexOf(".") === -1 || o.indexOf(".") > -1 && (o === "0" || o.lastIndexOf("0") < o.length - 1), v = o.lastIndexOf(".") < o.length - 1 && o.split("").filter((b) => b === ".").length < 2;
      if (!g || !v)
        return NaN;
    }
    return u && (o = this._adjustPrec(o)), typeof o == "string" && o.length ? c ? this.fetchMinOrMax(lodashExports.toNumber(o)) : lodashExports.toNumber(o) : NaN;
  }
  /**
   * Parsing the input value
   * @param {string} value
   * @returns {string}
   */
  afterParser(o) {
    const l = this.getProp("parser");
    return typeof o == "string" && typeof l == "function" ? lodashExports.toString(l(o)) : lodashExports.toString(o);
  }
  toNumber(o, l = !0) {
    if (typeof o == "number")
      return o;
    if (typeof o == "string") {
      const u = this.getProp("parser");
      typeof u == "function" && (o = u(o)), l && (o = this._adjustPrec(o));
    }
    return lodashExports.toNumber(o);
  }
  /**
   * Returning true requires both:
   * 1.type is number and not equal to NaN
   * 2.min < = value < = max
   * 3.length after decimal point requires < = precision | | No precision
   * @param {*} um
   * @param {*} needCheckPrec
   * @returns
   */
  isValidNumber(o, l = !0) {
    if (typeof o == "number" && !isNaN(o)) {
      const { min: u, max: c, precision: m } = this.getProps(), g = this._getPrecLen(o), v = l ? typeof m == "number" && g <= m || typeof m != "number" : !0;
      if (o >= u && o <= c && v)
        return !0;
    }
    return !1;
  }
  isValidString(o) {
    if (typeof o == "string" && o.length) {
      const l = this.doParse(o);
      return this.isValidNumber(l);
    }
    return !1;
  }
  notifyChange(o, l) {
    if (o == null || o === "")
      this._adapter.notifyChange("", l);
    else {
      const u = this.toNumber(o, !0);
      typeof u == "number" && !isNaN(u) ? (this._adapter.notifyChange(u, l), this.notifyNumberChange(u, l)) : this._adapter.notifyChange(this.afterParser(o), l);
    }
  }
  notifyNumberChange(o, l) {
    const { number: u } = this.getStates();
    this.isValidNumber(o) && o !== u && this._adapter.notifyNumberChange(o, l);
  }
  updateStates(o, l) {
    this._adapter.updateStates(o, l);
  }
}
const propTypes$1j = {
  ...propTypes$1C,
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-invalid": [bool, string$3],
  "aria-errormessage": string$3,
  "aria-describedby": string$3,
  "aria-required": bool,
  autofocus: bool,
  className: string$3,
  defaultValue: [number$2, string$3],
  disabled: bool,
  formatter: func,
  forwardedRef: any$1,
  hideButtons: bool,
  innerButtons: bool,
  insetLabel: node$1,
  insetLabelId: string$3,
  keepFocus: bool,
  max: number$2,
  min: number$2,
  parser: func,
  precision: number$2,
  prefixCls: string$3,
  pressInterval: number$2,
  pressTimeout: number$2,
  preventScroll: bool,
  shiftStep: number$2,
  size: string$3,
  step: number$2,
  style: object$1,
  suffix: {
    type: any$1,
    default: void 0
  },
  value: [number$2, string$3],
  onBlur: func,
  onChange: func,
  onDownClick: func,
  onFocus: func,
  onKeyDown: func,
  onNumberChange: func,
  onUpClick: func
}, defaultProps$1d = {
  forwardedRef: lodashExports.noop,
  innerButtons: !1,
  keepFocus: !1,
  max: 1 / 0,
  min: -1 / 0,
  prefixCls: cssClasses$C.PREFIX,
  pressInterval: numbers$9.DEFAULT_PRESS_TIMEOUT,
  pressTimeout: numbers$9.DEFAULT_PRESS_TIMEOUT,
  shiftStep: numbers$9.DEFAULT_SHIFT_STEP,
  size: strings$b.DEFAULT_SIZE,
  step: numbers$9.DEFAULT_STEP,
  onBlur: lodashExports.noop,
  onChange: lodashExports.noop,
  onDownClick: lodashExports.noop,
  onFocus: lodashExports.noop,
  onKeyDown: lodashExports.noop,
  onNumberChange: lodashExports.noop,
  onUpClick: lodashExports.noop
}, vuePropsType$25 = vuePropsMake(propTypes$1j, defaultProps$1d), InputNumber = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$25
  },
  name: "InputNumber",
  setup(s, {}) {
    let o, l, u, c, m;
    const g = reactive({
      value: "",
      number: null,
      // Current parsed numbers
      focusing: !!s.autofocus || !1,
      hovering: !1
    });
    let v = null, b = !1;
    const {
      adapter: S
    } = useBaseComponent(s, g);
    function E() {
      return {
        ...S(),
        setValue: (Kt, tn) => {
          g.value = Kt, nextTick(() => {
            tn == null || tn();
          });
        },
        setNumber: (Kt, tn) => {
          g.number = Kt, nextTick(() => {
            tn == null || tn();
          });
        },
        setFocusing: (Kt, tn) => {
          g.focusing = Kt, nextTick(() => {
            tn == null || tn();
          });
        },
        setHovering: (Kt) => g.hovering = Kt,
        notifyChange: (...Kt) => s.onChange(...Kt),
        notifyNumberChange: (...Kt) => s.onNumberChange(...Kt),
        notifyBlur: (Kt) => s.onBlur(Kt),
        notifyFocus: (Kt) => s.onFocus(Kt),
        notifyUpClick: (Kt, tn) => s.onUpClick(Kt, tn),
        notifyDownClick: (Kt, tn) => s.onDownClick(Kt, tn),
        notifyKeyDown: (Kt) => s.onKeyDown(Kt),
        registerGlobalEvent: (Kt, tn) => {
          Kt && typeof tn == "function" && (P.unregisterGlobalEvent(Kt), P.setCache(Kt, tn), document.addEventListener(Kt, tn));
        },
        unregisterGlobalEvent: (Kt) => {
          if (Kt) {
            const tn = P.getCache(Kt);
            document.removeEventListener(Kt, tn), P.setCache(Kt, null);
          }
        },
        recordCursorPosition: () => {
          try {
            v && (o = v.selectionStart, l = v.selectionEnd, u = v.value, c = v.value.substring(0, o), m = v.value.substring(l));
          } catch (Kt) {
            console.warn(Kt);
          }
        },
        restoreByAfter: (Kt) => {
          if (isNullOrUndefined(Kt))
            return !1;
          const tn = v.value, ln = tn.lastIndexOf(Kt);
          return ln === -1 ? !1 : ln + Kt.length === tn.length ? (P.fixCaret(ln, ln), !0) : !1;
        },
        restoreCursor: (Kt = m) => isNullOrUndefined(Kt) ? !1 : Array.prototype.some.call(Kt, (tn, ln) => {
          const rn = Kt.substring(ln);
          return P.restoreByAfter(rn);
        }),
        fixCaret: (Kt, tn) => {
          if (!(Kt === void 0 || tn === void 0 || !v || !v.value))
            try {
              const ln = v.selectionStart, rn = v.selectionEnd;
              (Kt !== ln || tn !== rn) && v.setSelectionRange(Kt, tn);
            } catch {
            }
        },
        setClickUpOrDown: (Kt) => {
          b = Kt;
        },
        updateStates: (Kt, tn) => {
          Object.keys(Kt).forEach((ln) => {
            g[ln] = Kt[ln];
          }), nextTick(() => {
            tn == null || tn();
          });
        }
      };
    }
    const P = E();
    let T = new InputNumberFoundation(P);
    watch([() => s.value, () => s.preventScroll, () => g.focusing], (Kt, [tn, ln, rn]) => {
      const {
        value: an,
        preventScroll: Gt
      } = s, {
        focusing: nn
      } = g;
      let vt;
      if (an !== tn && !isBothNaN(an, tn)) {
        if (isNullOrUndefined(an) || an === "")
          vt = "", T.updateStates({
            value: vt,
            number: null
          });
        else {
          let Et = an;
          typeof an == "number" && (Et = T.doFormat(an));
          const Qt = T.doParse(Et, !1, !0, !0), un = typeof an == "number" ? an : T.doParse(Et, !1, !1, !1);
          if (nn)
            if (T.isValidNumber(Qt) && Qt !== g.number) {
              const gn = {
                number: Qt
              };
              b && (gn.value = T.doFormat(gn.number, !0), vt = gn.value), T.updateStates(gn, () => P.restoreCursor());
            } else lodashExports.isNaN(un) ? (vt = T.doFormat(Et, !1), T.updateStates({
              value: Et
            })) : (vt = T.doFormat(un, !1), T.updateStates({
              value: vt
            }));
          else T.isValidNumber(Qt) ? (vt = T.doFormat(Qt), T.updateStates({
            number: Qt,
            value: vt
          })) : (vt = "", T.updateStates({
            number: null,
            value: vt
          }));
        }
        vt && lodashExports.isString(vt) && vt !== String(s.value) && T.notifyChange(vt, null);
      }
      b && s.keepFocus && g.focusing && document.activeElement !== v && v.focus({
        preventScroll: Gt
      });
    }, {
      immediate: !0
    });
    const N = (Kt) => {
      const {
        forwardedRef: tn
      } = s;
      v = Kt, tn && typeof tn == "object" ? tn.current = Kt : typeof tn == "function" && tn(Kt);
    }, O = (Kt) => T.handleInputFocus(Kt), z = (Kt, tn) => T.handleInputChange(Kt, tn), Q = (Kt) => T.handleInputBlur(Kt), W = (Kt) => T.handleInputKeyDown(Kt), ue = (Kt) => T.handleInputMouseEnter(Kt), te = (Kt) => T.handleInputMouseLeave(Kt), K = (Kt) => T.handleInputMouseMove(Kt), ve = (Kt) => {
      T.handleUpClick(Kt);
    }, ee = (Kt) => {
      T.handleDownClick(Kt);
    }, Re = (Kt) => {
      T.handleMouseUp(Kt);
    }, wt = (Kt) => {
      T.handleMouseLeave(Kt);
    }, yt = () => {
      const {
        prefixCls: Kt,
        disabled: tn,
        innerButtons: ln,
        max: rn,
        min: an
      } = s, {
        hovering: Gt,
        focusing: nn,
        number: vt
      } = g, Et = tn || vt === rn, Qt = tn || vt === an, un = cls(`${Kt}-number-suffix-btns`, {
        [`${Kt}-number-suffix-btns-inner`]: ln,
        [`${Kt}-number-suffix-btns-inner-hover`]: ln && Gt && !nn
      }), gn = cls(`${Kt}-number-button`, `${Kt}-number-button-up`, {
        [`${Kt}-number-button-up-disabled`]: tn,
        [`${Kt}-number-button-up-not-allowed`]: Et
      }), dn = cls(`${Kt}-number-button`, `${Kt}-number-button-down`, {
        [`${Kt}-number-button-down-disabled`]: tn,
        [`${Kt}-number-button-down-not-allowed`]: Qt
      });
      return createVNode("div", {
        class: un
      }, [createVNode("span", {
        class: gn,
        onMousedown: Et ? lodashExports.noop : ve,
        onMouseup: Re,
        onMouseleave: wt
      }, [createVNode(IconComponent$x, {
        size: "extra-small"
      }, null)]), createVNode("span", {
        class: dn,
        onMousedown: Qt ? lodashExports.noop : ee,
        onMouseup: Re,
        onMouseleave: wt
      }, [createVNode(IconComponent$A, {
        size: "extra-small"
      }, null)])]);
    }, xt = () => {
      const {
        innerButtons: Kt,
        suffix: tn
      } = s, {
        hovering: ln,
        focusing: rn
      } = g;
      return Kt && (ln || rn) ? yt() : tn;
    };
    return () => {
      const {
        disabled: Kt,
        className: tn,
        prefixCls: ln,
        min: rn,
        max: an,
        step: Gt,
        shiftStep: nn,
        precision: vt,
        formatter: Et,
        parser: Qt,
        forwardedRef: un,
        onUpClick: gn,
        onDownClick: dn,
        pressInterval: yn,
        pressTimeout: vn,
        suffix: Pn,
        size: On,
        hideButtons: _n,
        innerButtons: Nn,
        style: Un,
        onNumberChange: Xn,
        keepFocus: zn,
        defaultValue: jn,
        ...kn
      } = s, {
        value: Yn,
        number: Zn
      } = g, er = cls(tn, `${ln}-number`, {
        [`${ln}-number-size-${On}`]: On
      }), bn = yt(), Ln = {
        "aria-disabled": Kt,
        step: Gt
      };
      return Zn && (Ln["aria-valuenow"] = Zn), an !== 1 / 0 && (Ln["aria-valuemax"] = an), rn !== -1 / 0 && (Ln["aria-valuemin"] = rn), createVNode("div", {
        class: er,
        style: Un,
        onMousemove: (Bn) => K(Bn),
        onMouseenter: (Bn) => ue(Bn),
        onMouseleave: (Bn) => te(Bn)
      }, [createVNode(Input$1, mergeProps$1({
        role: "spinbutton"
      }, {
        ...Ln,
        ...kn,
        size: On,
        disabled: Kt,
        ref: N,
        value: Yn,
        onFocus: O,
        onChange: z,
        onBlur: Q,
        onKeyDown: W,
        suffix: xt()
      }), null), _n || Nn ? null : bn]);
    };
  }
}), InputNumber$1 = InputNumber, cssClasses$B = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-progress`
}, strings$a = {
  types: ["line", "circle"],
  DEFAULT_TYPE: "line",
  STROKE_DEFAULT: "var(--semi-color-success)",
  strokeLineCap: ["square", "round"],
  DEFAULT_LINECAP: "round",
  sizes: ["default", "small", "large"],
  DEFAULT_SIZE: "default",
  directions: ["vertical", "horizontal"],
  DEFAULT_DIRECTION: "horizontal"
};
function generateColor(s, o, l) {
  try {
    const u = generate$1(s, o, l);
    if (u.length !== 0) return u;
  } catch {
    return;
  }
}
function generate$1(s, o, l) {
  if (s.sort((c, m) => c.percent - m.percent), s[0].percent > o)
    return strings$a.STROKE_DEFAULT;
  const u = s[s.length - 1];
  if (u.percent < o)
    return formatToHex(u.color);
  for (const [c, m] of s.entries()) {
    if (m.percent === o)
      return formatToHex(m.color);
    if (o > m.percent) continue;
    const g = s[c - 1];
    return l ? generateGradients(
      {
        startColor: formatToHex(g.color),
        endColor: formatToHex(m.color),
        size: m.percent - g.percent - 1
      },
      o - g.percent - 1
    ) : formatToHex(g.color);
  }
}
function generateGradients(s, o) {
  const { startColor: l, endColor: u, size: c } = s, m = l.split(""), g = u.split(""), v = [parseInt(`${m[1]}${m[2]}`, 16), parseInt(`${g[1]}${g[2]}`, 16)], b = [parseInt(`${m[3]}${m[4]}`, 16), parseInt(`${g[3]}${g[4]}`, 16)], S = [parseInt(`${m[5]}${m[6]}`, 16), parseInt(`${g[5]}${g[6]}`, 16)], E = [parseInt(`${m[7]}${m[8]}`, 16), parseInt(`${g[7]}${g[8]}`, 16)], P = (v[0] - v[1]) / (c + 1), T = (b[0] - b[1]) / (c + 1), N = (S[0] - S[1]) / (c + 1), O = (E[0] - E[1]) / (c + 1);
  function z(W) {
    const ue = Math.round(v[0] - P * (W + 1)).toString(16), te = Math.round(b[0] - T * (W + 1)).toString(16), K = Math.round(S[0] - N * (W + 1)).toString(16), ve = `${Q(ue)}${Q(te)}${Q(K)}`, ee = Math.floor(O * (W + 1) + E[1]).toString(16);
    return toHex.Hex(`#${ve}`, ee);
  }
  function Q(W) {
    return W.length === 1 ? `0${W}` : W.length === 0 ? "00" : W;
  }
  if (typeof o > "u") {
    const W = [l];
    for (let ue = 0; ue < c; ue += 1)
      W.push(z(ue));
    return W;
  }
  return z(o);
}
function formatToHex(s) {
  if (s = s.trim().toLowerCase(), REG_S.hex.test(s))
    return toHex.Hex(s, void 0);
  if (REG_S.hslA.test(s))
    return toHex.Hex(toHex.HslA(s), void 0);
  if (REG_S.rgbA.test(s))
    return toHex.Hex(toHex.RgbA(s), void 0);
  if (REG_S.semiDesignTokens.test(s))
    return SEMI_DESIGN_TOKENS.ALONG.indexOf(s) !== -1 ? toHex.SemiDesignToken(s) : SEMI_DESIGN_TOKENS.SEQUENCE.indexOf(s) !== -1 ? toHex.SemiDesignToken(`${s}-5`) : toHex.SemiDesignToken(`${s}`);
}
const toHex = {
  Hex(s, o) {
    return s = s.replace("#", ""), s.length === 8 ? `#${s}` : s.length === 6 ? `#${s}${o || "ff"}` : (s.length === 3 && (s = s.split("").map((l) => l + l).join("")), `#${s}${o || "ff"}`);
  },
  SemiDesignToken(s) {
    if (typeof window > "u")
      return;
    const o = getComputedStyle(document.body).getPropertyValue(`--semi-${s}`);
    if (o === "") return;
    const l = `rgba(${o}, 1)`;
    return toHex.RgbA(l);
  },
  HslA(s) {
    const o = REG_S.hslA.exec(s), l = parseInt(o[2]), u = parseInt(o[3]) / 100, c = parseInt(o[4]) / 100, m = o[5], g = (1 - Math.abs(2 * c - 1)) * u, v = g * (1 - Math.abs(l / 60 % 2 - 1)), b = c - g / 2;
    let S = 0, E = 0, P = 0;
    return 0 <= l && l < 60 ? (S = g, E = v, P = 0) : 60 <= l && l < 120 ? (S = v, E = g, P = 0) : 120 <= l && l < 180 ? (S = 0, E = g, P = v) : 180 <= l && l < 240 ? (S = 0, E = v, P = g) : 240 <= l && l < 300 ? (S = v, E = 0, P = g) : 300 <= l && l < 360 && (S = g, E = 0, P = v), S = Math.round((S + b) * 255).toString(16), E = Math.round((E + b) * 255).toString(16), P = Math.round((P + b) * 255).toString(16), toHex.utils.pAL(S, E, P, m);
  },
  RgbA(s) {
    const o = REG_S.rgbA.exec(s), l = parseInt(o[2], 10).toString(16), u = parseInt(o[3], 10).toString(16), c = parseInt(o[4], 10).toString(16), m = o[5];
    return toHex.utils.pAL(l, u, c, m);
  },
  utils: {
    pAL(s, o, l, u) {
      return s.length == 1 && (s = "0" + s), o.length == 1 && (o = "0" + o), l.length == 1 && (l = "0" + l), typeof u < "u" ? (u = Math.round(parseInt(u) * 255).toString(16), u.length == 1 && (u = "0" + u), "#" + s + o + l + u) : "#" + s + o + l;
    }
  }
}, REG_S = {
  hex: /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6}|[0-9a-fA-F]{8})$/,
  hslA: /(hsl)a?\(\s*?(\d+),?\s*?(\d+)%,?\s*?(\d+)%,?\s*?\/?(\s*?[\d.]+)?\s*?\)/,
  rgbA: /(rgb)a?\(\s*?(\d+),?\s*?(\d+),?\s*?(\d+),?\s*?\/?(\s*?[\d.]+)?\s*?\)/,
  semiDesignTokens: /(\w+)?-?(\w+)-?(\d)?/
}, SEMI_DESIGN_TOKENS = {
  // No sequence
  ALONG: ["black", "white"],
  // Sequence: 0-9
  SEQUENCE: [
    "amber",
    "blue",
    "cyan",
    "green",
    "grey",
    "indigo",
    "light-blue",
    "light-green",
    "lime",
    "orange",
    "pink",
    "purple",
    "red",
    "teal",
    "violet",
    "yellow"
  ]
}, prefixCls$w = cssClasses$B.PREFIX, propTypes$1i = {
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-valuetext": string$3,
  className: string$3,
  direction: String,
  format: [Function, ...node$1],
  id: string$3,
  motion: oneOfType([bool, func, object$1]),
  orbitStroke: string$3,
  percent: number$2,
  // scale: PropTypes.number as PropType<ProgressProps['scale']>,
  showInfo: bool,
  size: String,
  stroke: [string$3, array$1],
  strokeGradient: bool,
  strokeLinecap: String,
  strokeWidth: number$2,
  style: object$1,
  type: String,
  width: number$2
}, defaultProps$1c = {
  className: "",
  direction: strings$a.DEFAULT_DIRECTION,
  format: () => (s) => `${s}%`,
  motion: !0,
  orbitStroke: "var(--semi-color-fill-0)",
  percent: 0,
  showInfo: !1,
  size: strings$a.DEFAULT_SIZE,
  stroke: strings$a.STROKE_DEFAULT,
  strokeGradient: !1,
  strokeLinecap: strings$a.DEFAULT_LINECAP,
  strokeWidth: 4,
  style: {},
  type: strings$a.DEFAULT_TYPE
}, vuePropsType$24 = vuePropsMake(propTypes$1i, defaultProps$1c), Progress = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$24
  },
  name: "Progress",
  setup(s, {}) {
    const o = useAttrs();
    useSlots();
    let l = !0, u;
    const c = reactive({
      percentNumber: s.percent
      // Specially used for animation of numbers
    });
    watch(() => s.percent, (S, E) => {
      if (isNaN(S) || isNaN(E))
        throw new Error("[Semi Progress]:percent can not be NaN");
    }), watch(() => s.percent, (S, E) => {
      if (!s.motion) {
        c.percentNumber = s.percent;
        return;
      }
      u && u.destroy && u.destroy(), u = new Animation({
        from: {
          value: E
        },
        to: {
          value: s.percent
        }
      }, {
        // easing: 'cubic-bezier(0, .68, .3, 1)'
        easing: "linear",
        duration: 300
      }), u.on("frame", (P) => {
        if (l === !1)
          return;
        const T = parseInt(P.value);
        c.percentNumber = T;
      }), u.on("rest", () => {
        l !== !1 && (c.percentNumber = s.percent);
      }), u.start();
    }), onUnmounted(() => {
      u && u.destroy(), l = !1;
    });
    function m() {
      const {
        strokeLinecap: S,
        style: E,
        className: P,
        strokeWidth: T,
        format: N,
        size: O,
        stroke: z,
        strokeGradient: Q,
        showInfo: W,
        percent: ue,
        orbitStroke: te,
        id: K,
        ...ve
      } = s, ee = s["aria-label"], Re = s["aria-labelledby"], wt = s["aria-valuetext"], {
        percentNumber: yt
      } = c, xt = {
        wrapper: cls(`${prefixCls$w}-circle`, P),
        svg: cls(`${prefixCls$w}-circle-ring`),
        circle: cls(`${prefixCls$w}-circle-ring-inner`)
      }, Kt = g(ue), tn = g(yt);
      let ln;
      s.width ? ln = s.width : O === strings$a.DEFAULT_SIZE ? ln = 72 : ln = 24;
      const rn = v(z, ue, Q), an = ln / 2, Gt = ln / 2, nn = (ln - T) / 2, vt = nn * 2 * Math.PI, Et = (1 - Kt / 100) * vt, Qt = `${vt} ${vt}`, un = N(tn);
      return createVNode("div", mergeProps$1({
        id: K,
        class: xt.wrapper,
        style: E,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": tn,
        "aria-labelledby": Re,
        "aria-label": ee,
        "aria-valuetext": wt
      }, getDataAttr({
        ...ve,
        ...o
      })), [createVNode("svg", {
        key: O,
        class: xt.svg,
        height: ln,
        width: ln,
        "aria-hidden": !0
      }, [createVNode("circle", {
        "stroke-dashoffset": 0,
        "stroke-width": T,
        "stroke-dasharray": Qt,
        "stroke-linecap": S,
        fill: "transparent",
        stroke: te,
        r: nn,
        cx: Gt,
        cy: an,
        "aria-hidden": !0
      }, null), createVNode("circle", {
        class: xt.circle,
        "stroke-dashoffset": Et,
        "stroke-width": T,
        "stroke-dasharray": Qt,
        "stroke-linecap": S,
        fill: "transparent",
        stroke: rn,
        r: nn,
        cx: Gt,
        cy: an,
        "aria-hidden": !0
      }, null)]), W && O !== "small" ? createVNode("span", {
        class: `${prefixCls$w}-circle-text`
      }, [un]) : null]);
    }
    function g(S) {
      let E;
      return S > 100 ? E = 100 : S < 0 ? E = 0 : E = S, E;
    }
    function v(S, E, P) {
      if (typeof S == "string")
        return S;
      const T = generateColor(S, E, P);
      return typeof T < "u" ? T : strings$a.STROKE_DEFAULT;
    }
    function b() {
      const {
        className: S,
        style: E,
        stroke: P,
        strokeGradient: T,
        direction: N,
        format: O,
        showInfo: z,
        size: Q,
        percent: W,
        orbitStroke: ue,
        id: te,
        ...K
      } = s, ve = s["aria-label"], ee = s["aria-labelledby"], Re = s["aria-valuetext"], {
        percentNumber: wt
      } = c, yt = cls(prefixCls$w, S, {
        [`${prefixCls$w}-horizontal`]: N === strings$a.DEFAULT_DIRECTION,
        [`${prefixCls$w}-vertical`]: N !== strings$a.DEFAULT_DIRECTION,
        [`${prefixCls$w}-large`]: Q === "large"
      }), xt = cls({
        [`${prefixCls$w}-track`]: !0
      }), Kt = cls(`${prefixCls$w}-track-inner`), tn = g(W), ln = g(wt), an = {
        background: v(P, W, T)
      };
      N === strings$a.DEFAULT_DIRECTION ? an.width = `${tn}%` : an.height = `${tn}%`;
      const Gt = O(ln);
      return createVNode("div", mergeProps$1({
        id: te,
        class: yt,
        style: E,
        role: "progressbar",
        "aria-valuemin": 0,
        "aria-valuemax": 100,
        "aria-valuenow": tn,
        "aria-labelledby": ee,
        "aria-label": ve,
        "aria-valuetext": Re
      }, getDataAttr({
        ...K,
        ...o
      })), [createVNode("div", {
        class: xt,
        style: ue ? {
          backgroundColor: ue
        } : {},
        "aria-hidden": !0
      }, [createVNode("div", {
        class: Kt,
        style: an,
        "aria-hidden": !0
      }, null)]), z ? createVNode("div", {
        class: `${prefixCls$w}-line-text`
      }, [Gt]) : null]);
    }
    return () => {
      const {
        type: S
      } = s;
      return S === "line" ? b() : m();
    };
  }
}), Progress$1 = Progress;
function isObject(s) {
  return s !== null && typeof s == "object";
}
function isPromise(s) {
  return isObject(s) && typeof s.then == "function";
}
const PREFIX$1 = `${BASE_CLASS_PREFIX$1}-upload`, FILE_LIST_PIC = "picture", FILE_LIST_DEFAULT = "list", PROGRESS_COEFFICIENT = 0.95, cssClasses$A = {
  PREFIX: PREFIX$1,
  // WRAPPER: `${PREFIX}-wrapper`,
  LIST: `${PREFIX$1}-list`
}, TRIGGER_AUTO$1 = "auto", TRIGGER_CUSTOM = "custom", strings$9 = {
  FILE_STATUS_UPLOADING: "uploading",
  FILE_STATUS_SUCCESS: "success",
  FILE_STATUS_UPLOAD_FAIL: "uploadFail",
  FILE_STATUS_VALIDATING: "validating",
  FILE_STATUS_VALID_FAIL: "validateFail",
  FILE_STATUS_WAIT_UPLOAD: "wait",
  FILE_LIST_PIC,
  FILE_LIST_DEFAULT,
  LIST_TYPE: [FILE_LIST_PIC, FILE_LIST_DEFAULT],
  imageTypes: ["image", "webp", "png", "svg", "gif", "jpg", "jpeg", "bmp", "dpg"],
  DRAG_AREA_DEFAULT: "default",
  DRAG_AREA_LEGAL: "legal",
  DRAG_AREA_ILLEGAL: "illegal",
  TRIGGER_AUTO: TRIGGER_AUTO$1,
  TRIGGER_CUSTOM,
  UPLOAD_TRIGGER: [TRIGGER_AUTO$1, TRIGGER_CUSTOM],
  VALIDATE_STATUS,
  PROMPT_POSITION: ["left", "right", "bottom"]
}, numbers$8 = {
  PROGRESS_COEFFICIENT
}, byteKB = 1024, byteMB = 1048576;
function getFileSize(s) {
  if (s < byteKB)
    return `${(s / byteKB).toFixed(2)}KB`;
  if (s >= byteKB && s < byteMB)
    return `${(s / byteKB).toFixed(1)}KB`;
  if (s >= byteMB)
    return `${(s / byteMB).toFixed(1)}MB`;
}
function endsWith(s, o) {
  return s.indexOf(o, s.length - o.length) !== -1;
}
async function loopFiles(s) {
  return new Promise((o, l) => {
    const u = s.createReader();
    let c = [];
    function m() {
      u.readEntries((g) => {
        const v = Array.prototype.slice.apply(g);
        c = c.concat(v), !v.length ? o(c) : m();
      }, l);
    }
    m();
  });
}
async function mapFileTree(s) {
  const o = [], l = async (u, c) => {
    if (c = c || "", u.path = c, u.isFile)
      o.push(new Promise((m, g) => {
        u.file((v) => {
          u.fullPath && !v.webkitRelativePath && (Object.defineProperties(v, {
            webkitRelativePath: {
              writable: !0
            }
          }), v.webkitRelativePath = u.fullPath.replace(/^\//, ""), Object.defineProperties(v, {
            webkitRelativePath: {
              writable: !1
            }
          })), m(v);
        }, g);
      }));
    else if (u.isDirectory) {
      const m = await loopFiles(u);
      for (let g = 0; g < m.length; g++) {
        const v = m[g];
        await l(v, `${c}${u.name}/`);
      }
    }
  };
  try {
    const u = s.map((m) => l(m.webkitGetAsEntry()));
    return await Promise.all(u), await Promise.all(o);
  } catch (u) {
    return console.warn("Captured error while loop directory."), console.error(u), [];
  }
}
const {
  FILE_STATUS_UPLOADING,
  FILE_STATUS_SUCCESS,
  FILE_STATUS_UPLOAD_FAIL,
  FILE_STATUS_VALID_FAIL,
  FILE_STATUS_WAIT_UPLOAD,
  DRAG_AREA_DEFAULT,
  DRAG_AREA_LEGAL,
  TRIGGER_AUTO
} = strings$9;
class UploadFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    const { disabled: o, addOnPasting: l } = this.getProps();
    l && !o && this.bindPastingHandler();
  }
  destroy() {
    const { disabled: o, addOnPasting: l } = this.getProps();
    this.releaseMemory(), o || this.unbindPastingHandler();
  }
  getError({ action: o, xhr: l, message: u, fileName: c }) {
    const m = l ? l.status : 0, g = u || `cannot post ${c} to ${o}, xhr status: ${m}'`, v = new Error(g);
    return v.status = m, v.method = "post", v.url = o, v;
  }
  getBody(o) {
    if (!o)
      return;
    const l = o.responseText || o.response;
    if (!l)
      return l;
    try {
      return JSON.parse(l);
    } catch {
      return l;
    }
  }
  checkFileSize(o) {
    const { size: l } = o, { maxSize: u, minSize: c } = this.getProps();
    let m = !1;
    return (l > u * byteKB || l < c * byteKB) && (m = !0), m;
  }
  /**
   * 1. 选择文件
   * 2. transform转换. 添加uid
   * 3. 检查文件个数是否超出
   *   若超出，不添加到list中，触发onExceed，中止流程
   *   若未超出，执行以下流程
   * 4. 检查文件尺寸，添加尺寸是否合法的标识
   * 5. 检查uploadTrigger是否为'auto'，若是执行步骤6-8
   * 6. 遍历文件列表触发上传
   *    - 对尺寸不合适的不需要触发上传
   * 7. beforeUpload
   *    - 对beforeUpload中设为不合法的不需要触发上传
   * 8. TODO: check
   * 9. afterUpload
   * 
   * 1. Select file
   * 2. transform, add uid
   * 3. Check whether the number of files exceeds
   *   If it exceeds, it is not added to the list, trigger onExceed, and abort the process
   *   If it is not exceeded, execute the following process
   * 4. check the file size, add the size is legal logo
   * 5. Check whether the uploadTrigger is'auto ', if so, perform steps 6-8
   * 6. Traversing the file list triggers upload
   *    - No need to trigger uploads for inappropriate sizes
   * 7. beforeUpload
   *    - no need to trigger upload if beforeUpload is not set to be valid
   * 8. TODO: check
   * 9. afterUpload
   */
  handleChange(o) {
    const l = [], { limit: u, transformFile: c, accept: m } = this.getProps(), { fileList: g } = this.getStates();
    let v = Array.from(o);
    if (typeof m < "u" && (v = v.filter((S) => {
      const E = this.checkFileFormat(m, S);
      return E || l.push(S), E;
    }), l.length !== 0 && this._adapter.notifyAcceptInvalid(l), v.length === 0))
      return;
    v = v.map((S) => (c && (S = c(S)), S.uid || (S.uid = getUuidv4()), this.checkFileSize(S) && (S._sizeInvalid = !0, S.status = FILE_STATUS_VALID_FAIL, this._adapter.notifySizeError(S, g)), S));
    const b = g.length + v.length;
    if (typeof u < "u" && b > u) {
      if (this._adapter.notifyExceed(v), u === 1) {
        v = v.slice(-1), this._adapter.notifyFileSelect(v), this._adapter.resetInput(), this.replaceFileList(v);
        return;
      }
      const S = u - g.length;
      v = v.slice(0, S);
    }
    this._adapter.notifyFileSelect(v), this._adapter.resetInput(), this.addFilesToList(v);
  }
  // Triggered when replacing a single file
  handleReplaceChange(o) {
    if (o.length === 0)
      return;
    const { transformFile: l, uploadTrigger: u, accept: c } = this.getProps(), { replaceIdx: m, fileList: g } = this.getStates();
    let v = Array.from(o).pop();
    if (typeof c < "u" && !this.checkFileFormat(c, v)) {
      this._adapter.notifyAcceptInvalid([v]);
      return;
    }
    l && (v = l(v)), v.uid || (v.uid = getUuidv4()), this.checkFileSize(v) && (v._sizeInvalid = !0, v.status = FILE_STATUS_VALID_FAIL, this._adapter.notifySizeError(v, g)), this._adapter.notifyFileSelect([v]);
    const b = this.buildFileItem(v, u), S = [...g];
    S.splice(m, 1, b), this._adapter.notifyChange({ currentFile: b, fileList: S }), this._adapter.updateFileList(S, () => {
      this._adapter.resetReplaceInput(), b._sizeInvalid || this.upload(b);
    });
  }
  buildFileItem(o, l) {
    const { _sizeInvalid: u, status: c } = o;
    try {
      delete o._sizeInvalid, delete o.status;
    } catch {
    }
    const m = {
      status: c || (l === TRIGGER_AUTO ? FILE_STATUS_UPLOADING : FILE_STATUS_WAIT_UPLOAD),
      name: o.name,
      size: getFileSize(o.size),
      uid: o.uid,
      percent: 0,
      fileInstance: o,
      url: this._createURL(o)
    };
    return u && (m._sizeInvalid = !0), this.isImage(o) && (m.preview = !0), m;
  }
  replaceFileList(o) {
    const { uploadTrigger: l } = this.getProps(), u = o.map((c) => this.buildFileItem(c, l));
    this._adapter.notifyChange({ fileList: u, currentFile: u[0] }), this._adapter.updateFileList(u, () => {
      l === TRIGGER_AUTO && this.startUpload(u);
    });
  }
  addFilesToList(o) {
    const l = this.getState("fileList").slice(), { uploadTrigger: u } = this.getProps(), c = o.map((m) => this.buildFileItem(m, u));
    c.forEach((m) => {
      const g = l.findIndex((v) => v.uid === m.uid);
      g !== -1 ? l[g] = m : (l.push(m), this._adapter.notifyChange({ fileList: l, currentFile: m }));
    }), this._adapter.updateFileList(l, () => {
      u === TRIGGER_AUTO && this.startUpload(c);
    });
  }
  // 插入多个文件到指定位置
  // Insert files to the specified location
  insertFileToList(o, l) {
    const { limit: u, transformFile: c, accept: m, uploadTrigger: g } = this.getProps(), { fileList: v } = this.getStates(), b = [];
    let S = Array.from(o);
    if (typeof m < "u" && (S = S.filter((N) => {
      const O = this.checkFileFormat(m, N);
      return O || b.push(N), O;
    }), b.length !== 0 && this._adapter.notifyAcceptInvalid(b), S.length === 0))
      return;
    S = S.map((N) => (N.uid || (N.uid = getUuidv4()), this.checkFileSize(N) && (N._sizeInvalid = !0, N.status = FILE_STATUS_VALID_FAIL, this._adapter.notifySizeError(N, v)), c && (N = c(N)), N));
    const E = v.length + S.length;
    if (typeof u < "u" && E > u) {
      if (u === 1) {
        S = S.slice(-1), this._adapter.notifyFileSelect(S), this._adapter.resetInput(), this.replaceFileList(S);
        return;
      }
      const N = u - v.length;
      S = S.slice(0, N), this._adapter.notifyExceed(S);
    }
    const P = S.map((N) => this.buildFileItem(N, g)), T = v.slice();
    typeof l < "u" ? T.splice(l, 0, ...P) : T.push(...P), this._adapter.notifyFileSelect(S), this._adapter.notifyChange({ fileList: T, currentFile: null }), this._adapter.updateFileList(T, () => {
      g === TRIGGER_AUTO && this.startUpload(P);
    });
  }
  /* istanbul ignore next */
  manualUpload() {
    const o = this.getState("fileList").filter((l) => l.status === FILE_STATUS_WAIT_UPLOAD);
    this.startUpload(o);
  }
  startUpload(o) {
    o.forEach((l) => {
      l._sizeInvalid || this.upload(l);
    });
  }
  upload(o) {
    const { beforeUpload: l } = this.getProps();
    if (typeof l > "u") {
      this.post(o);
      return;
    }
    if (typeof l == "function") {
      const { fileList: u } = this.getStates(), c = this._adapter.notifyBeforeUpload({ file: o, fileList: u });
      switch (!0) {
        case c === !0: {
          this.post(o);
          break;
        }
        case c === !1: {
          const m = { shouldUpload: !1, status: strings$9.FILE_STATUS_VALID_FAIL };
          this.handleBeforeUploadResultInObject(m, o);
          break;
        }
        case (c && isPromise(c)): {
          Promise.resolve(c).then(
            (m) => {
              let g = { shouldUpload: !0 };
              Object.prototype.toString.call(m).slice(8, -1) === "Object" && (g = { ...g, ...m }), this.handleBeforeUploadResultInObject(g, o);
            },
            (m) => {
              let g = { shouldUpload: !1, status: strings$9.FILE_STATUS_VALID_FAIL };
              Object.prototype.toString.call(m).slice(8, -1) === "Object" && (g = { ...g, ...m }), this.handleBeforeUploadResultInObject(g, o);
            }
          );
          break;
        }
        case typeof c == "object":
          this.handleBeforeUploadResultInObject(c, o);
          break;
      }
    }
  }
  // handle beforeUpload result when it's an object
  handleBeforeUploadResultInObject(o, l) {
    const { shouldUpload: u, status: c, autoRemove: m, validateMessage: g, fileInstance: v } = o;
    let b = this.getState("fileList").slice();
    if (m)
      b = b.filter((S) => S.uid !== l.uid);
    else {
      const S = this._getFileIndex(l, b);
      if (S < 0)
        return;
      c && (b[S].status = c), g && (b[S].validateMessage = g), v && (v.uid = l.uid, b[S].fileInstance = v, b[S].size = getFileSize(v.size), b[S].name = v.name, b[S].url = this._createURL(v)), b[S].shouldUpload = u;
    }
    this._adapter.updateFileList(b), this._adapter.notifyChange({ fileList: b, currentFile: l }), u && this.post(l);
  }
  post(o) {
    const { fileInstance: l } = o, u = this.getProps();
    if (typeof XMLHttpRequest > "u")
      return;
    const c = new XMLHttpRequest(), m = new FormData(), { action: g } = u;
    let { data: v } = u;
    v && (typeof v == "function" && (v = v(l)), Object.keys(v).forEach((E) => {
      m.append(E, v[E]);
    }));
    const b = u.name || u.fileName || l.name;
    if (u.customRequest)
      return u.customRequest({
        fileName: b,
        data: v,
        file: o,
        fileInstance: l,
        onProgress: (E) => this.handleProgress({ e: E, fileInstance: l }),
        onError: (E, P) => this.handleError({ e: P, xhr: E, fileInstance: l }),
        onSuccess: (E, P) => this.handleSuccess({ response: E, fileInstance: l, e: P, isCustomRequest: !0 }),
        withCredentials: u.withCredentials,
        action: u.action
      });
    m.append(b, l), c.open("post", g, !0), u.withCredentials && "withCredentials" in c && (c.withCredentials = !0), c.upload && (c.upload.onprogress = (E) => this.handleProgress({ e: E, fileInstance: l })), c.onload = (E) => this.handleOnLoad({ e: E, xhr: c, fileInstance: l }), c.onerror = (E) => this.handleError({ e: E, xhr: c, fileInstance: l });
    let S = u.headers || {};
    typeof S == "function" && (S = S(l));
    for (const E in S)
      Object.prototype.hasOwnProperty.call(S, E) && S[E] !== null && c.setRequestHeader(E, S[E]);
    c.send(m);
  }
  handleProgress({ e: o, fileInstance: l }) {
    const { fileList: u } = this.getStates(), c = u.slice();
    let m = 0;
    o.total > 0 && (m = Number((o.loaded / o.total * 100 * numbers$8.PROGRESS_COEFFICIENT).toFixed(0)) || 0);
    const g = this._getFileIndex(l, c);
    g < 0 || (c[g].percent = m, c[g].status = FILE_STATUS_UPLOADING, this._adapter.notifyProgress(m, l, c), this._adapter.updateFileList(c), this._adapter.notifyChange({ fileList: c, currentFile: c[g] }));
  }
  handleOnLoad({ e: o, xhr: l, fileInstance: u }) {
    const { fileList: c } = this.getStates(), m = this._getFileIndex(u, c);
    m < 0 || (l.status < 200 || l.status >= 300 ? this.handleError({ e: o, xhr: l, fileInstance: u }) : this.handleSuccess({ e: o, xhr: l, fileInstance: u, index: m }));
  }
  handleSuccess({ e: o, fileInstance: l, isCustomRequest: u = !1, xhr: c, response: m }) {
    const { fileList: g } = this.getStates();
    let v = null;
    const b = this._getFileIndex(l, g);
    if (b < 0)
      return;
    u ? v = m : v = this.getBody(c);
    const S = g.slice(), { afterUpload: E } = this.getProps();
    if (S[b].status = FILE_STATUS_SUCCESS, S[b].percent = 100, this._adapter.notifyProgress(100, l, S), S[b].response = v, o && (S[b].event = o), E && typeof E == "function") {
      const { autoRemove: P, status: T, validateMessage: N, name: O } = this._adapter.notifyAfterUpload({
        response: v,
        file: S[b],
        fileList: S
      }) || {};
      T && (S[b].status = T), N && (S[b].validateMessage = N), O && (S[b].name = O), P && S.splice(b, 1);
    }
    this._adapter.notifySuccess(v, l, S), this._adapter.notifyChange({ fileList: S, currentFile: S[b] }), this._adapter.updateFileList(S);
  }
  _getFileIndex(o, l) {
    return l.findIndex((u) => u.uid === o.uid);
  }
  handleRemove(o) {
    const { disabled: l } = this.getProps();
    if (l)
      return;
    const { fileList: u } = this.getStates();
    Promise.resolve(this._adapter.notifyBeforeRemove(o, u)).then((c) => {
      if (c === !1)
        return;
      const m = u.slice(), g = this._getFileIndex(o, u);
      g < 0 || (m.splice(g, 1), this._adapter.notifyRemove(o.fileInstance, m, o), this._adapter.updateFileList(m), this._adapter.notifyChange({ fileList: m, currentFile: o }));
    });
  }
  handleError({ e: o, xhr: l, fileInstance: u }) {
    const { fileList: c } = this.getStates(), m = this._getFileIndex(u, c);
    if (m < 0)
      return;
    const { action: g } = this.getProps(), v = c.slice(), b = this.getError({ action: g, xhr: l, fileName: u.name });
    v[m].status = FILE_STATUS_UPLOAD_FAIL, v[m].response = b, v[m].event = o, this._adapter.notifyError(b, u, v, l), this._adapter.updateFileList(v), this._adapter.notifyChange({ currentFile: v[m], fileList: v });
  }
  handleClear() {
    const { disabled: o } = this.getProps(), { fileList: l } = this.getStates();
    o || Promise.resolve(this._adapter.notifyBeforeClear(l)).then((u) => {
      u !== !1 && (this._adapter.updateFileList([]), this._adapter.notifyClear(), this._adapter.notifyChange({ fileList: [] }));
    }).catch((u) => {
    });
  }
  _createURL(o) {
    const l = URL.createObjectURL(o), { localUrls: u } = this.getStates(), c = u.slice();
    return c.push(l), this._adapter.updateLocalUrls(c), l;
  }
  // 释放预览文件所占用的内存
  // Release memory used by preview files
  releaseMemory() {
    const { localUrls: o } = this.getStates();
    o.forEach((l) => {
      this._releaseBlob(l);
    });
  }
  _releaseBlob(o) {
    try {
      URL.revokeObjectURL(o);
    } catch (l) {
      console.log(l);
    }
  }
  isImage(o) {
    return /(webp|svg|png|gif|jpg|jpeg|bmp|dpg)$/i.test(o.type);
  }
  /* istanbul ignore next */
  isMultiple() {
    return !!this.getProp("multiple");
  }
  handleDragEnter(o) {
    o.preventDefault(), o.stopPropagation(), this._dragEnterTarget = o.currentTarget;
    const { disabled: l } = this.getProps();
    l || this._adapter.updateDragAreaStatus(DRAG_AREA_LEGAL);
  }
  async handleDirectoryDrop(o) {
    const l = this.getState("fileList").slice(), u = [].slice.call(o.dataTransfer.items), c = await mapFileTree(u);
    this.handleChange(c), this._adapter.updateDragAreaStatus(DRAG_AREA_DEFAULT), this._adapter.notifyDrop(o, c, l);
  }
  handleDrop(o) {
    o.preventDefault(), o.stopPropagation();
    const { disabled: l, directory: u } = this.getProps(), c = this.getState("fileList").slice();
    if (!l) {
      if (u) {
        this.handleDirectoryDrop(o);
        return;
      }
      const m = Array.from(o.dataTransfer.files);
      this.handleChange(m), this._adapter.updateDragAreaStatus(DRAG_AREA_DEFAULT), this._adapter.notifyDrop(o, m, c);
    }
  }
  handleDragOver(o) {
    o.preventDefault(), o.stopPropagation();
  }
  handleDragLeave(o) {
    o.preventDefault(), o.stopPropagation(), this._dragEnterTarget === o.target && this._adapter.updateDragAreaStatus(DRAG_AREA_DEFAULT);
  }
  // 拖拽上传时，需要对文件的格式进行校验
  // When dragging and uploading, you need to verify the file format
  checkFileFormat(o, l) {
    const u = o.split(",").map((g) => g.trim()).filter((g) => g), c = l.type || "", m = c.replace(/\/.*$/, "");
    return u.some((g) => {
      if (g.charAt(0) === ".") {
        const v = l.name || "", b = g.split(".").pop().toLowerCase();
        return endsWith(v.toLowerCase(), b);
      }
      if (/\/\*$/.test(g)) {
        const v = g.replace(/\/.*$/, "");
        return m === v;
      }
      return /^[^\/]+\/[^\/]+$/.test(g) ? c === g : !1;
    });
  }
  retry(o) {
    const { onRetry: l } = this.getProps();
    l && typeof l == "function" && l(o), this.post(o);
  }
  handlePreviewClick(o) {
    this._adapter.notifyPreviewClick(o);
  }
  readFileFromClipboard(o) {
    for (const l of o)
      for (const u of l.types)
        u.startsWith("image") && l.getType(u).then((c) => c.arrayBuffer()).then((c) => {
          const m = u.split("/")[1], g = new File([c], `upload.${m}`, { type: u });
          this.handleChange([g]);
        });
  }
  handlePasting(o) {
    const u = this._adapter.isMac() ? o.metaKey : o.ctrlKey, { addOnPasting: c } = this.getProps();
    c && u && o.code === "KeyV" && o.target === document.body && navigator.permissions.query({ name: "clipboard-read" }).then((g) => {
      g.state === "granted" || g.state === "prompt" ? navigator.clipboard.read().then((v) => {
        this.readFileFromClipboard(v);
      }) : this._adapter.notifyPastingError(g);
    }).catch((g) => {
      this._adapter.notifyPastingError(g);
    });
  }
  bindPastingHandler() {
    this._adapter.registerPastingHandler((o) => this.handlePasting(o));
  }
  unbindPastingHandler() {
    this._adapter.unRegisterPastingHandler();
  }
}
class FileCardFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  handleImageError(o) {
    this._adapter.updateFallbackPreview(!0);
  }
}
function _isSlot$y(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$v = cssClasses$A.PREFIX, ErrorSvg = (s = {}) => (
  // @ts-ignore
  createVNode("svg", mergeProps$1({
    focusable: !1,
    "aria-hidden": !0,
    width: "16",
    height: "16",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s), [createVNode("circle", {
    cx: "7.99992",
    cy: "7.99992",
    r: "6.66667",
    fill: "white"
  }, null), createVNode("path", {
    "fill-rule": "evenodd",
    "clip-rule": "evenodd",
    d: "M15.3332 8.00008C15.3332 12.0502 12.0499 15.3334 7.99984 15.3334C3.94975 15.3334 0.666504 12.0502 0.666504 8.00008C0.666504 3.94999 3.94975 0.666748 7.99984 0.666748C12.0499 0.666748 15.3332 3.94999 15.3332 8.00008ZM8.99984 11.6667C8.99984 11.1145 8.55212 10.6667 7.99984 10.6667C7.44755 10.6667 6.99984 11.1145 6.99984 11.6667C6.99984 12.219 7.44755 12.6667 7.99984 12.6667C8.55212 12.6667 8.99984 12.219 8.99984 11.6667ZM7.99984 3.33341C7.27573 3.33341 6.7003 3.94171 6.74046 4.66469L6.94437 8.33495C6.97549 8.89513 7.4388 9.33341 7.99984 9.33341C8.56087 9.33341 9.02419 8.89513 9.05531 8.33495L9.25921 4.66469C9.29938 3.94171 8.72394 3.33341 7.99984 3.33341Z",
    fill: "#F93920"
  }, null)])
), ReplaceSvg = (s = {}) => (
  // @ts-ignore
  createVNode("svg", mergeProps$1({
    focusable: !1,
    "aria-hidden": !0,
    width: "28",
    height: "28",
    viewBox: "0 0 28 28",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s), [createVNode("circle", {
    cx: "14",
    cy: "14",
    r: "14",
    fill: "#16161A",
    "fill-opacity": "0.6"
  }, null), createVNode("path", {
    d: "M9 10.25V18.25L10.25 13.25H17.875V11.75C17.875 11.4739 17.6511 11.25 17.375 11.25H14L12.75 9.75H9.5C9.22386 9.75 9 9.97386 9 10.25Z",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null), createVNode("path", {
    d: "M18 18.25L19 13.25H10.2031L9 18.25H18Z",
    stroke: "currentColor",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])
), DirectorySvg = (s = {}) => (
  // @ts-ignore
  createVNode("svg", mergeProps$1({
    focusable: !1,
    "aria-hidden": !0,
    width: "24",
    height: "24",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, s), [createVNode("path", {
    d: "M6 17V7.58824C6 7.26336 6.26863 7 6.6 7H10.5L12 8.76471H16.05C16.3814 8.76471 16.65 9.02806 16.65 9.35294V11.1176H7.5L6 17ZM6 17L7.44375 11.1176H18L16.8 17L6 17Z",
    stroke: "currentColor",
    "stroke-width": "1.5",
    "stroke-linecap": "round",
    "stroke-linejoin": "round"
  }, null)])
), propTypes$1h = {
  className: string$3,
  disabled: {
    type: bool,
    required: !0
  },
  listType: {
    type: string$3,
    required: !0
  },
  name: {
    type: string$3,
    required: !0
  },
  onPreviewClick: {
    type: func,
    required: !0
  },
  onRemove: {
    type: func,
    required: !0
  },
  onReplace: {
    type: func,
    required: !0
  },
  onRetry: {
    type: func,
    required: !0
  },
  percent: number$2,
  preview: bool,
  previewFile: func,
  picWidth: oneOfType([number$2, string$3]),
  picHeight: oneOfType([number$2, string$3]),
  showReplace: bool,
  showRetry: bool,
  size: {
    type: oneOfType([number$2, string$3]),
    required: !0
  },
  status: {
    type: string$3,
    required: !0
  },
  style: object$1,
  url: string$3,
  validateMessage: node$1,
  index: number$2,
  // key: String,
  showPicInfo: Boolean,
  renderPicInfo: Function,
  renderPicPreviewIcon: Function,
  renderFileOperation: Function,
  uid: {
    type: String,
    required: !0
  },
  fileInstance: Object,
  renderThumbnail: Function,
  response: Object,
  event: Object,
  shouldUpload: Boolean,
  _sizeInvalid: Boolean
}, defaultProps$1b = {
  listType: strings$9.FILE_LIST_DEFAULT,
  name: "",
  onRemove: () => {
  },
  onRetry: () => {
  },
  preview: !1,
  size: ""
}, vuePropsType$23 = vuePropsMake(propTypes$1h, defaultProps$1b), FileCard = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$23
  },
  name: "FileCard",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      fallbackPreview: !1
    }), {
      adapter: l
    } = useBaseComponent(s, o);
    function u() {
      return {
        ...l(),
        updateFallbackPreview: (O) => {
          o.fallbackPreview = O;
        }
      };
    }
    const c = u(), m = new FileCardFoundation(c);
    function g(O) {
      return typeof O == "number" ? getFileSize(O) : O;
    }
    function v() {
      const {
        status: O,
        validateMessage: z
      } = s;
      let Q = null;
      switch (!0) {
        case (typeof z == "string" && O === strings$9.FILE_STATUS_VALIDATING):
          Q = createVNode(Fragment, null, [createVNode(Spin, {
            size: "small",
            wrapperClassName: `${prefixCls$v}-file-card-icon-loading`
          }, null), z]);
          break;
        case typeof z == "string":
          Q = createVNode(Fragment, null, [createVNode(IconComponent$K, {
            class: `${prefixCls$v}-file-card-icon-error`
          }, null), z]);
          break;
        case isElement(z):
          Q = z;
          break;
      }
      return Q;
    }
    function b() {
      const {
        status: O,
        validateMessage: z
      } = s;
      let Q = null;
      switch (!0) {
        case (z && O === strings$9.FILE_STATUS_VALIDATING):
          Q = createVNode(Spin, {
            size: "small",
            wrapperClassName: `${prefixCls$v}-picture-file-card-icon-loading`
          }, null);
          break;
        case (z && (O === strings$9.FILE_STATUS_VALID_FAIL || O === strings$9.FILE_STATUS_UPLOAD_FAIL)):
          Q = createVNode("div", {
            class: `${prefixCls$v}-picture-file-card-icon-error`
          }, [createVNode(ErrorSvg, null, null)]);
          break;
      }
      return Q ? createVNode(Tooltip$1, {
        content: z,
        trigger: "hover",
        position: "bottom"
      }, _isSlot$y(Q) ? Q : {
        default: () => [Q]
      }) : null;
    }
    function S(O) {
      const {
        fallbackPreview: z
      } = o, {
        url: Q,
        percent: W,
        status: ue,
        disabled: te,
        style: K,
        onPreviewClick: ve,
        showPicInfo: ee,
        renderPicInfo: Re,
        renderPicPreviewIcon: wt,
        renderThumbnail: yt,
        name: xt,
        index: Kt,
        picHeight: tn,
        picWidth: ln
      } = s, rn = ue === strings$9.FILE_STATUS_UPLOADING && W !== 100, an = ue === strings$9.FILE_STATUS_UPLOAD_FAIL && s.showRetry, Gt = ue === strings$9.FILE_STATUS_SUCCESS && s.showReplace, nn = ue === strings$9.FILE_STATUS_SUCCESS && !s.showReplace, vt = typeof yt == "function", Et = cls({
        [`${prefixCls$v}-picture-file-card`]: !0,
        [`${prefixCls$v}-picture-file-card-preview-fallback`]: z,
        [`${prefixCls$v}-picture-file-card-disabled`]: te,
        [`${prefixCls$v}-picture-file-card-show-pointer`]: typeof ve < "u",
        [`${prefixCls$v}-picture-file-card-error`]: ue === strings$9.FILE_STATUS_UPLOAD_FAIL,
        [`${prefixCls$v}-picture-file-card-uploading`]: rn,
        [`${prefixCls$v}-picture-file-card-custom-thumbnail`]: vt && tn && ln
      }), Qt = createVNode("div", {
        role: "button",
        "tab-index": 0,
        class: `${prefixCls$v}-picture-file-card-retry`,
        onClick: (Nn) => N(Nn)
      }, [createVNode(IconComponent$b, {
        class: `${prefixCls$v}-picture-file-card-icon-retry`
      }, null)]), un = createVNode(Tooltip$1, {
        trigger: "hover",
        position: "top",
        content: O.replace,
        showArrow: !1,
        spacing: 4
      }, {
        default: () => [createVNode("div", {
          role: "button",
          "tab-index": 0,
          class: `${prefixCls$v}-picture-file-card-replace`,
          onClick: (Nn) => T(Nn)
        }, [createVNode(ReplaceSvg, {
          class: `${prefixCls$v}-picture-file-card-icon-replace`
        }, null)])]
      }), gn = createVNode("div", {
        class: `${prefixCls$v}-picture-file-card-preview`
      }, [typeof wt == "function" ? wt(s) : null]), dn = createVNode("div", {
        role: "button",
        "tab-index": 0,
        class: `${prefixCls$v}-picture-file-card-close`,
        onClick: (Nn) => P(Nn)
      }, [createVNode(IconComponent$w, {
        class: `${prefixCls$v}-picture-file-card-icon-close`
      }, null)]), yn = typeof Re == "function" ? Re(s) : createVNode("div", {
        class: `${prefixCls$v}-picture-file-card-pic-info`
      }, [Kt + 1]);
      let vn = {}, Pn = K ? {
        ...K
      } : {};
      tn && (Pn.height = styleNum(tn), vn.height = styleNum(tn)), ln && (Pn.width = styleNum(ln), vn.width = styleNum(ln));
      const On = z ? createVNode(IconComponent$n, {
        size: "large"
      }, null) : createVNode("img", {
        src: Q,
        alt: xt,
        onError: (Nn) => m.handleImageError(Nn),
        style: vn
      }, null), _n = vt ? yt(s) : On;
      return createVNode("div", {
        role: "listitem",
        class: Et,
        style: Pn,
        onClick: ve
      }, [_n, rn ? createVNode(Progress$1, {
        percent: W,
        type: "circle",
        size: "small",
        orbitStroke: "#FFF",
        "aria-label": "uploading file progress"
      }, null) : null, an ? Qt : null, Gt && un, nn && gn, ee && yn, !te && dn, b()]);
    }
    function E(O) {
      const {
        name: z,
        size: Q,
        percent: W,
        url: ue,
        showRetry: te,
        showReplace: K,
        preview: ve,
        previewFile: ee,
        status: Re,
        style: wt,
        onPreviewClick: yt,
        renderFileOperation: xt
      } = s, {
        fallbackPreview: Kt
      } = o, tn = cls({
        [`${prefixCls$v}-file-card`]: !0,
        [`${prefixCls$v}-file-card-fail`]: Re === strings$9.FILE_STATUS_VALID_FAIL || Re === strings$9.FILE_STATUS_UPLOAD_FAIL,
        [`${prefixCls$v}-file-card-show-pointer`]: typeof yt < "u"
      }), ln = cls({
        [`${prefixCls$v}-file-card-preview`]: !0,
        [`${prefixCls$v}-file-card-preview-placeholder`]: !ve || ee || Kt
      }), rn = `${prefixCls$v}-file-card-info`, an = `${prefixCls$v}-file-card-close`, Gt = `${prefixCls$v}-file-card-replace`, nn = !(W === 100 || typeof W > "u") && Re === strings$9.FILE_STATUS_UPLOADING, vt = Re === strings$9.FILE_STATUS_UPLOAD_FAIL && te, Et = Re === strings$9.FILE_STATUS_SUCCESS && K, Qt = g(Q);
      let un = ve && !Kt ? createVNode("img", {
        src: ue,
        alt: z,
        onError: (dn) => m.handleImageError(dn)
      }, null) : createVNode(IconComponent$n, {
        size: "large"
      }, null);
      ee && (un = ee(s));
      const gn = typeof xt == "function" ? xt(s) : createVNode(Button$2, {
        onClick: (dn) => P(dn),
        type: "tertiary",
        icon: createVNode(IconComponent$u, null, null),
        theme: "borderless",
        size: "small",
        class: an
      }, null);
      return createVNode("div", {
        role: "listitem",
        class: tn,
        style: wt,
        onClick: yt
      }, [createVNode("div", {
        class: ln
      }, [un]), createVNode("div", {
        class: `${rn}-main`
      }, [createVNode("div", {
        class: `${rn}-main-text`
      }, [createVNode("span", {
        class: `${rn}-name`
      }, [z]), createVNode("span", null, [createVNode("span", {
        class: `${rn}-size`
      }, [Qt]), Et && createVNode(Tooltip$1, {
        trigger: "hover",
        position: "top",
        showArrow: !1,
        content: O.replace
      }, {
        default: () => [createVNode(Button$2, {
          onClick: (dn) => T(dn),
          type: "tertiary",
          theme: "borderless",
          size: "small",
          icon: createVNode(DirectorySvg, null, null),
          className: Gt
        }, null)]
      })])]), nn ? createVNode(Progress$1, {
        percent: W,
        style: {
          width: "100%"
        },
        "aria-label": "uploading file progress"
      }, null) : null, createVNode("div", {
        class: `${rn}-main-control`
      }, [createVNode("span", {
        class: `${rn}-validate-message`
      }, [v()]), vt ? createVNode("span", {
        role: "button",
        "tab-index": 0,
        class: `${rn}-retry`,
        onClick: (dn) => N(dn)
      }, [O.retry]) : null])]), gn]);
    }
    function P(O) {
      O.stopPropagation(), s.onRemove();
    }
    function T(O) {
      O.stopPropagation(), s.onReplace();
    }
    function N(O) {
      O.stopPropagation(), s.onRetry();
    }
    return () => {
      const {
        listType: O
      } = s;
      return O === strings$9.FILE_LIST_PIC ? createVNode(LocaleConsumer$6, {
        componentName: "Upload"
      }, {
        default: (z) => S(z)
      }) : O === strings$9.FILE_LIST_DEFAULT ? createVNode(LocaleConsumer$6, {
        componentName: "Upload"
      }, {
        default: (z) => E(z)
      }) : null;
    };
  }
}), FileCard$1 = FileCard, prefixCls$u = cssClasses$A.PREFIX, propTypes$1g = {
  accept: string$3,
  // Limit allowed file types
  action: {
    type: String,
    required: !0
  },
  addOnPasting: bool,
  afterUpload: func,
  beforeClear: func,
  beforeRemove: func,
  beforeUpload: func,
  // children: PropTypes.node as PropType<any>,
  className: string$3,
  customRequest: func,
  data: oneOfType([object$1, func]),
  // Extra parameters attached when uploading
  defaultFileList: array$1,
  directory: bool,
  // Support folder upload
  disabled: bool,
  dragIcon: node$1,
  dragMainText: node$1,
  dragSubText: node$1,
  draggable: bool,
  fileList: array$1,
  // files had been uploaded
  fileName: string$3,
  // same as name, to avoid props conflict in Form.Upload
  headers: oneOfType([object$1, func]),
  hotSpotLocation: String,
  itemStyle: object$1,
  limit: number$2,
  // 最大允许上传文件个数
  listType: String,
  maxSize: number$2,
  // 文件大小限制，单位kb
  minSize: number$2,
  // 文件大小限制，单位kb
  multiple: bool,
  name: string$3,
  // file name
  onAcceptInvalid: func,
  onChange: func,
  onClear: func,
  onDrop: func,
  onError: func,
  onExceed: func,
  onFileChange: func,
  onOpenFileDialog: func,
  onPreviewClick: func,
  onProgress: func,
  onRemove: func,
  onRetry: func,
  onSizeError: func,
  onSuccess: func,
  onPastingError: func,
  previewFile: func,
  prompt: node$1,
  promptPosition: String,
  picWidth: oneOfType([number$2, string$3]),
  picHeight: oneOfType([number$2, string$3]),
  renderFileItem: func,
  renderPicPreviewIcon: func,
  renderFileOperation: func,
  renderPicInfo: func,
  renderThumbnail: func,
  showClear: bool,
  showPicInfo: bool,
  showReplace: bool,
  showRetry: bool,
  showUploadList: bool,
  // whether to show fileList
  style: object$1,
  timeout: number$2,
  transformFile: func,
  uploadTrigger: String,
  // auto、custom
  validateMessage: node$1,
  validateStatus: String,
  withCredentials: bool,
  capture: [bool, string$3]
}, defaultProps$1a = {
  defaultFileList: [],
  disabled: !1,
  listType: "list",
  hotSpotLocation: "end",
  multiple: !1,
  onAcceptInvalid: lodashExports.noop,
  onChange: lodashExports.noop,
  beforeRemove: () => !0,
  beforeClear: () => !0,
  onClear: lodashExports.noop,
  onDrop: lodashExports.noop,
  onError: lodashExports.noop,
  onExceed: lodashExports.noop,
  onFileChange: lodashExports.noop,
  onOpenFileDialog: lodashExports.noop,
  onProgress: lodashExports.noop,
  onRemove: lodashExports.noop,
  onRetry: lodashExports.noop,
  onSizeError: lodashExports.noop,
  onSuccess: lodashExports.noop,
  onPastingError: lodashExports.noop,
  promptPosition: "right",
  showClear: !0,
  showPicInfo: !1,
  showReplace: !1,
  showRetry: !0,
  showUploadList: !0,
  uploadTrigger: "auto",
  withCredentials: !1
}, vuePropsType$22 = vuePropsMake(propTypes$1g, defaultProps$1a), Upload = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$22
  },
  name: "Upload",
  setup(s, {
    expose: o
  }) {
    const l = useSlots(), u = reactive({
      fileList: s.defaultFileList || [],
      replaceIdx: -1,
      inputKey: Math.random(),
      replaceInputKey: Math.random(),
      // Status of the drag zone
      dragAreaStatus: "default",
      localUrls: []
    }), c = ref$1(), m = ref$1();
    let g;
    const {
      adapter: v,
      getDataAttr: b
    } = useBaseComponent(s, u);
    function S() {
      return {
        ...v(),
        notifyFileSelect: (rn) => s.onFileChange(rn),
        notifyError: (rn, an, Gt, nn) => s.onError(rn, an, Gt, nn),
        notifySuccess: (rn, an, Gt) => s.onSuccess(rn, an, Gt),
        notifyProgress: (rn, an, Gt) => s.onProgress(rn, an, Gt),
        notifyRemove: (rn, an, Gt) => s.onRemove(rn, an, Gt),
        notifySizeError: (rn, an) => s.onSizeError(rn, an),
        notifyExceed: (rn) => s.onExceed(rn),
        updateFileList: (rn, an) => {
          typeof an == "function" ? (u.fileList = rn, nextTick(() => {
            an == null || an();
          })) : u.fileList = rn;
        },
        notifyBeforeUpload: ({
          file: rn,
          fileList: an
        }) => s.beforeUpload({
          file: rn,
          fileList: an
        }),
        notifyAfterUpload: ({
          response: rn,
          file: an,
          fileList: Gt
        }) => s.afterUpload({
          response: rn,
          file: an,
          fileList: Gt
        }),
        resetInput: () => {
          u.inputKey = Math.random();
        },
        resetReplaceInput: () => {
          u.replaceInputKey = Math.random();
        },
        isMac: () => navigator.platform.toUpperCase().indexOf("MAC") >= 0,
        registerPastingHandler: (rn) => {
          document.body.addEventListener("keydown", rn), g = rn;
        },
        unRegisterPastingHandler: () => {
          g && document.body.removeEventListener("keydown", g);
        },
        notifyPastingError: (rn) => s.onPastingError(rn),
        updateDragAreaStatus: (rn) => u.dragAreaStatus = rn,
        notifyChange: ({
          currentFile: rn,
          fileList: an
        }) => s.onChange({
          currentFile: rn,
          fileList: an
        }),
        updateLocalUrls: (rn) => {
          u.localUrls = rn;
        },
        notifyClear: () => s.onClear(),
        notifyPreviewClick: (rn) => s.onPreviewClick(rn),
        notifyDrop: (rn, an, Gt) => s.onDrop(rn, an, Gt),
        notifyAcceptInvalid: (rn) => s.onAcceptInvalid(rn),
        notifyBeforeRemove: (rn, an) => s.beforeRemove(rn, an),
        notifyBeforeClear: (rn) => s.beforeClear(rn)
      };
    }
    const E = S(), P = new UploadFoundation(E);
    watch(() => s.fileList, (rn) => {
      "fileList" in s && (u.fileList = rn || []);
    }, {
      immediate: !0
    }), onMounted(() => {
      P.init();
    }), onUnmounted(() => {
      P.destroy();
    });
    const T = () => {
      const {
        onOpenFileDialog: rn
      } = s;
      s.disabled || !c || !c.value || (c.value.click(), rn && rn());
    }, N = (rn) => {
      const {
        files: an
      } = rn.target;
      P.handleChange(an);
    }, O = (rn) => {
      u.replaceIdx = rn, nextTick(() => {
        m.value.click();
      });
    }, z = (rn) => {
      const {
        files: an
      } = rn.target;
      P.handleReplaceChange(an);
    }, Q = () => {
      P.handleClear();
    }, W = (rn) => {
      P.handleRemove(rn);
    };
    o({
      insert: (rn, an) => P.insertFileToList(rn, an),
      upload: () => {
        P.manualUpload();
      }
    });
    const K = (rn, an, Gt) => {
      const {
        name: nn,
        status: vt,
        validateMessage: Et,
        _sizeInvalid: Qt,
        uid: un
      } = rn, {
        previewFile: gn,
        listType: dn,
        itemStyle: yn,
        showPicInfo: vn,
        renderPicInfo: Pn,
        renderPicPreviewIcon: On,
        renderFileOperation: _n,
        renderFileItem: Nn,
        renderThumbnail: Un,
        disabled: Xn,
        onPreviewClick: zn,
        picWidth: jn,
        picHeight: kn
      } = s, Yn = () => W(rn), Zn = () => {
        P.retry(rn);
      }, er = () => {
        O(an);
      }, bn = {
        ...lodashExports.pick(s, ["showRetry", "showReplace", ""]),
        ...lodashExports.pick(rn, [...Object.keys(vuePropsType$23)]),
        previewFile: gn,
        listType: dn,
        onRemove: Yn,
        onRetry: Zn,
        index: an,
        //@ts-ignore
        key: un || `${nn}${an}`,
        style: yn,
        disabled: Xn,
        showPicInfo: vn,
        renderPicInfo: Pn,
        renderPicPreviewIcon: On,
        renderFileOperation: _n,
        renderThumbnail: Un,
        onReplace: er,
        onPreviewClick: typeof zn < "u" ? () => P.handlePreviewClick(rn) : void 0,
        picWidth: jn,
        picHeight: kn
      };
      return vt === strings$9.FILE_STATUS_UPLOAD_FAIL && !Et && (bn.validateMessage = Gt.fail), Qt && !Et && (bn.validateMessage = Gt.illegalSize), typeof Nn > "u" ? createVNode(FileCard$1, bn, null) : Nn(bn);
    }, ve = () => {
      const {
        listType: rn
      } = s;
      return rn === strings$9.FILE_LIST_PIC ? ee() : rn === strings$9.FILE_LIST_DEFAULT ? Re() : null;
    }, ee = () => {
      var Yn;
      const rn = (Yn = l.default) == null ? void 0 : Yn.call(l), {
        showUploadList: an,
        limit: Gt,
        disabled: nn,
        draggable: vt,
        hotSpotLocation: Et,
        picHeight: Qt,
        picWidth: un
      } = s, {
        fileList: gn,
        dragAreaStatus: dn
      } = u, yn = s.fileList || gn, vn = Gt ? Gt > yn.length : !0, Pn = `${prefixCls$u}-drag-area`, On = cls(`${prefixCls$u}-add`, {
        [`${prefixCls$u}-picture-add`]: !0,
        [`${prefixCls$u}-picture-add-disabled`]: nn
      }), _n = cls(`${prefixCls$u}-file-list`, {
        [`${prefixCls$u}-picture-file-list`]: !0
      }), Nn = cls({
        [`${Pn}-legal`]: dn === strings$9.DRAG_AREA_LEGAL,
        [`${Pn}-illegal`]: dn === strings$9.DRAG_AREA_ILLEGAL
      }), Un = `${prefixCls$u}-file-list-main`, Xn = {
        role: "button",
        className: On,
        onClick: T,
        style: {
          height: styleNum(Qt),
          width: styleNum(un)
        }
      }, zn = {
        class: _n
      };
      vt && Object.assign(Xn, {
        onDrop: wt,
        onDragover: yt,
        onDragleave: xt,
        onDragenter: Kt
      }, {
        className: cls(On, Nn)
      });
      const kn = createVNode("div", mergeProps$1(Xn, {
        "x-semi-prop": "children"
      }), [rn]);
      return !an || !yn.length ? vn ? kn : null : createVNode(LocaleConsumer$6, {
        componentName: "Upload"
      }, {
        default: (Zn) => createVNode("div", zn, [createVNode("div", {
          class: Un,
          role: "list",
          "aria-label": "picture list"
        }, [vn && Et === "start" ? kn : null, yn.map((er, bn) => K(er, bn, Zn)), vn && Et === "end" ? kn : null])])
      });
    }, Re = () => {
      const {
        showUploadList: rn,
        limit: an,
        disabled: Gt
      } = s, {
        fileList: nn
      } = u, vt = s.fileList || nn, Et = cls(`${prefixCls$u}-file-list`), Qt = `${prefixCls$u}-file-list-title`, un = `${prefixCls$u}-file-list-main`, gn = an !== 1 && vt.length, dn = s.showClear && !Gt, yn = {
        class: Et
      };
      return !rn || !vt.length ? null : createVNode(LocaleConsumer$6, {
        componentName: "Upload"
      }, {
        default: (vn) => createVNode("div", yn, [gn ? createVNode("div", {
          class: Qt
        }, [createVNode("span", {
          class: `${Qt}-choosen`
        }, [vn.selectedFiles]), dn ? createVNode("span", {
          role: "button",
          tabindex: 0,
          onClick: Q,
          class: `${Qt}-clear`
        }, [vn.clear]) : null]) : null, createVNode("div", {
          class: un,
          role: "list",
          "aria-label": "file list"
        }, [vt.map((Pn, On) => K(Pn, On, vn))])])
      });
    }, wt = (rn) => {
      P.handleDrop(rn);
    }, yt = (rn) => {
      P.handleDragOver(rn);
    }, xt = (rn) => {
      P.handleDragLeave(rn);
    }, Kt = (rn) => {
      P.handleDragEnter(rn);
    }, tn = () => {
      var Et;
      const rn = (Et = l.default) == null ? void 0 : Et.call(l), {
        draggable: an,
        listType: Gt,
        disabled: nn
      } = s, vt = cls(`${prefixCls$u}-add`);
      return Gt === strings$9.FILE_LIST_PIC ? null : an ? ln() : createVNode("div", {
        role: "button",
        tabindex: 0,
        "aria-disabled": nn,
        class: vt,
        onClick: T
      }, [rn]);
    }, ln = () => {
      var gn;
      const {
        dragAreaStatus: rn
      } = u, an = (gn = l.default) == null ? void 0 : gn.call(l), {
        dragIcon: Gt,
        dragMainText: nn,
        dragSubText: vt,
        disabled: Et
      } = s, Qt = `${prefixCls$u}-drag-area`, un = cls(Qt, {
        [`${Qt}-legal`]: rn === strings$9.DRAG_AREA_LEGAL,
        [`${Qt}-illegal`]: rn === strings$9.DRAG_AREA_ILLEGAL,
        [`${Qt}-custom`]: an
      });
      return createVNode(LocaleConsumer$6, {
        componentName: "Upload"
      }, {
        default: (dn) => createVNode("div", {
          role: "button",
          tabindex: 0,
          "aria-disabled": Et,
          class: un,
          onDrop: wt,
          onDragover: yt,
          onDragleave: xt,
          onDragenter: Kt,
          onClick: T
        }, [an || createVNode(Fragment, null, [createVNode("div", {
          class: `${Qt}-icon`,
          "x-semi-prop": "dragIcon"
        }, [Gt || createVNode(IconComponent$2, {
          size: "extra-large"
        }, null)]), createVNode("div", {
          class: `${Qt}-text`
        }, [createVNode("div", {
          class: `${Qt}-main-text`,
          "x-semi-prop": "dragMainText"
        }, [nn || dn.mainText]), createVNode("div", {
          class: `${Qt}-sub-text`,
          "x-semi-prop": "dragSubText"
        }, [vt]), createVNode("div", {
          class: `${Qt}-tips`
        }, [rn === strings$9.DRAG_AREA_LEGAL && createVNode("span", {
          class: `${Qt}-tips-legal`
        }, [dn.legalTips]), rn === strings$9.DRAG_AREA_ILLEGAL && createVNode("span", {
          class: `${Qt}-tips-illegal`
        }, [dn.illegalTips])])])])])
      });
    };
    return () => {
      const {
        style: rn,
        className: an,
        multiple: Gt,
        accept: nn,
        disabled: vt,
        capture: Et,
        listType: Qt,
        prompt: un,
        promptPosition: gn,
        draggable: dn,
        validateMessage: yn,
        validateStatus: vn,
        directory: Pn
      } = s, On = cls(prefixCls$u, {
        [`${prefixCls$u}-picture`]: Qt === strings$9.FILE_LIST_PIC,
        [`${prefixCls$u}-disabled`]: vt,
        [`${prefixCls$u}-default`]: vn === "default",
        [`${prefixCls$u}-error`]: vn === "error",
        [`${prefixCls$u}-warning`]: vn === "warning",
        [`${prefixCls$u}-success`]: vn === "success"
      }, an), _n = cls(`${prefixCls$u}-hidden-input`), Nn = cls(`${prefixCls$u}-hidden-input-replace`), Un = cls(`${prefixCls$u}-prompt`), Xn = cls(`${prefixCls$u}-validate-message`), zn = Pn ? {
        directory: "directory",
        webkitdirectory: "webkitdirectory"
      } : {};
      return createVNode("div", mergeProps$1({
        class: On,
        style: rn,
        "x-prompt-pos": gn
      }, b()), [createVNode("input", mergeProps$1({
        key: u.inputKey,
        capture: Et,
        multiple: Gt,
        accept: nn,
        onChange: N,
        type: "file",
        "data-testid": "upload-bt",
        autocomplete: "off",
        tabindex: -1,
        class: _n,
        ref: c
      }, zn), null), createVNode("input", {
        key: u.replaceInputKey,
        multiple: !1,
        accept: nn,
        onChange: z,
        type: "file",
        autocomplete: "off",
        tabindex: -1,
        class: Nn,
        ref: m
      }, null), tn(), un ? createVNode("div", {
        class: Un,
        "x-semi-prop": "prompt"
      }, [un]) : null, yn ? createVNode("div", {
        class: Xn,
        "x-semi-prop": "validateMessage"
      }, [yn]) : null, ve()]);
    };
  }
}), Upload$1 = Upload, cssClasses$z = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-slider`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-slider-disabled`,
  VERTICAL: `${BASE_CLASS_PREFIX$1}-slider-vertical`,
  TRACK: `${BASE_CLASS_PREFIX$1}-slider-track`,
  DOTS: `${BASE_CLASS_PREFIX$1}-slider-dots`,
  MARKS: `${BASE_CLASS_PREFIX$1}-slider-marks`,
  HANDLE: `${BASE_CLASS_PREFIX$1}-slider-handle`,
  HANDLE_DOT: `${BASE_CLASS_PREFIX$1}-slider-handle-dot`
}, touchEventPolyfill = (s, o) => (!globalThis.Touch || !(s instanceof Touch) || ["stopPropagation", "preventDefault"].forEach((u) => {
  let c = o[u];
  c && (typeof c == "function" && (c = (...m) => o[u](...m)), s[u] ? warning$1(!0, `"The key ${u}" exist in Touch.`) : s[u] = c);
}), s);
class SliderFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...SliderFoundation.defaultAdapter, ...o }), this.getMinAndMaxPercent = (l) => {
      const { range: u, min: c, max: m } = this._adapter.getProps(), g = u ? (l[0] - c) / (m - c) : (l - c) / (m - c), v = u ? (l[1] - c) / (m - c) : 1;
      return { min: this._checkValidity(g), max: this._checkValidity(v) };
    }, this._checkValidity = (l, u = 0, c = 1) => l > c ? c : l < u ? u : l, this.computeHandleVisibleVal = (l, u, c) => {
      const { focusPos: m, currentValue: g } = this._adapter.getStates(), v = { min: !1, max: !1 };
      let b;
      return u ? b = {
        min: u(c ? this.outPutValue(g[0]) : this.outPutValue(g)),
        max: c ? u(this.outPutValue(g[1])) : null
      } : b = {
        min: c ? this.outPutValue(g[0]) : this.outPutValue(g),
        max: c ? this.outPutValue(g[1]) : null
      }, l ? (v.min = !0, v.max = !0) : typeof l > "u" && u && (m === "min" ? v.min = !0 : m === "max" && (v.max = !0)), {
        tipVisible: v,
        tipChildren: b
      };
    }, this.valueFormatIsCorrect = (l) => Array.isArray(l) ? typeof l[0] == "number" && typeof l[0] == "number" : typeof l == "number", this.handleMousePos = (l, u) => {
      const c = this._adapter.getParentRect(), m = this._adapter.getScrollParentVal(), g = c ? c.left : 0, v = c ? c.top : 0;
      return { x: l - g + m.scrollLeft, y: u - v + m.scrollTop };
    }, this.getScrollParent = (l) => {
      const u = l, c = /(auto|scroll)/, m = (b, S) => window.getComputedStyle(b, null).getPropertyValue(S), g = (b) => c.test(m(b, "overflow") + m(b, "overflow-y") + m(b, "overflow-x")), v = (b) => !b || b === document.body || !(b instanceof Element) ? document.body : g(b) ? b : v(b.parentNode);
      return v(u);
    }, this.checkMeetMinMax = (l) => {
      const { vertical: u, verticalReverse: c, range: m } = this._adapter.getProps(), g = this._adapter.getState("currentValue");
      this.transValueToPos(g);
      const { sliderX: v, sliderY: b, sliderWidth: S, sliderHeight: E } = this._adapter.getSliderLengths();
      this._adapter.getStates();
      const P = u ? E : S;
      let T;
      u && c ? T = b + P : T = u ? b : v;
      let N;
      return u && c ? N = b : N = u ? b + E : v + S, u && c ? l >= T ? l = T : l <= N && (l = N) : l <= T ? l = T : l >= N && (l = N), l;
    }, this.transPosToValue = (l, u) => {
      const c = this.checkMeetMinMax(l), { min: m, max: g, currentValue: v } = this._adapter.getStates(), { range: b, vertical: S, step: E, verticalReverse: P } = this._adapter.getProps(), { sliderX: T, sliderY: N, sliderWidth: O, sliderHeight: z } = this._adapter.getSliderLengths(), Q = S ? N : T, W = S ? z : O;
      let ue;
      S && P ? ue = (Q + W - c) / W * (g - m) + m : ue = (c - Q) / W * (g - m) + m;
      let te;
      return b ? te = u ? v[0] : v[1] : te = v, E !== 1 && (ue = Math.round(ue / E) * E), b && ue !== te ? u ? [ue, v[1]] : [v[0], ue] : !b && ue !== te ? ue : !1;
    }, this.transValueToPos = (l) => {
      const { min: u, max: c } = this._adapter.getStates(), { vertical: m, range: g, verticalReverse: v } = this._adapter.getProps(), { sliderX: b, sliderY: S, sliderWidth: E, sliderHeight: P } = this._adapter.getSliderLengths(), T = m ? S : b, N = m ? P : E;
      return g ? [(l[0] - u) * N / (c - u) + T, (l[1] - u) * N / (c - u) + T] : (l - u) * N / (c - u) + T;
    }, this.isMarkActive = (l) => {
      const { min: u, max: c, range: m, included: g } = this._adapter.getProps(), v = this._adapter.getState("currentValue");
      return typeof (l / 1) == "number" && l >= u && l <= c ? m ? (l > v[1] || l < v[0]) && g ? "unActive" : "active" : l <= v && g ? "active" : "unActive" : !1;
    }, this.outPutValue = (l) => {
      const u = (g) => {
        var b;
        return /^\d+(\.\d+)?$/.test(String(g)) ? ((b = g.toString().split(".")[1]) == null ? void 0 : b.length) ?? 0 : 0;
      }, c = this._adapter.getProp("step"), m = (() => {
        const g = u(c), v = Math.pow(10, g);
        return (b) => Math.round(b * v) / v;
      })();
      return Array.isArray(l) ? [m(l[0]), m(l[1])] : m(l);
    }, this.handleDisabledChange = (l) => {
      this._adapter.updateDisabled(l);
    }, this.checkAndUpdateIsInRenderTreeState = () => this._adapter.checkAndUpdateIsInRenderTreeState(), this.calculateOutputValue = (l, u) => {
      const c = this.transPosToValue(l, u);
      if (c !== !1)
        return this.outPutValue(c);
    }, this.handleValueChange = (l, u) => {
      const { min: c, max: m } = this._adapter.getStates();
      let g = null;
      const v = {};
      this.valueFormatIsCorrect(u) ? (Array.isArray(l) && Array.isArray(u) && (u = [
        u[0] < c ? c : u[0],
        // Math.round(nextValue[0]),
        u[1] > m ? m : u[1]
        // Math.round(nextValue[1])
      ], g = Object.assign(v, {
        currentValue: u
      })), typeof l == "number" && typeof u == "number" && (u > m ? u = m : u = u < c ? c : u, g = Object.assign(v, {
        currentValue: u
      }))) : g = v, g && this._adapter.transNewPropsToState(g);
    }, this.onHandleDown = (l, u) => {
      this._adapter.onHandleDown(l);
      const c = this._adapter.getState("disabled"), { vertical: m } = this._adapter.getProps(), { dragging: g } = this._adapter.getOverallVars();
      if (c)
        return !1;
      this._adapter.setStateVal("isDrag", !0), this._adapter.setStateVal("chooseMovePos", u), u === "min" ? this._adapter.setDragging([!0, g[1]]) : this._adapter.setDragging([g[0], !0]);
      const v = this.handleMousePos(l.clientX, l.clientY);
      let b = m ? v.y : v.x;
      if (!this._adapter.isEventFromHandle(l))
        this._dragOffset = 0;
      else {
        const S = this._getHandleCenterPosition(m, l.target);
        this._dragOffset = b - S, b = S;
      }
      return !0;
    }, this.onHandleMove = (l) => {
      this._adapter.setEventDefault(l);
      const { disabled: u, chooseMovePos: c } = this._adapter.getStates(), { vertical: m } = this._adapter.getProps(), { dragging: g } = this._adapter.getOverallVars();
      if (u)
        return !1;
      this.onHandleEnter(c);
      const v = this.handleMousePos(l.clientX, l.clientY);
      let b = m ? v.y : v.x;
      if (b = b - this._dragOffset, c === "min" && g[0] || c === "max" && g[1]) {
        const S = this.calculateOutputValue(b, c === "min");
        if (S === void 0)
          return !1;
        this._adapter.notifyChange(S), this._adapter.onHandleMove(b, c === "min", void 0, !1, S);
      }
      return !0;
    }, this.onHandleTouchStart = (l, u) => {
      const c = this._adapter.getMinHandleEl(), m = this._adapter.getMaxHandleEl();
      if (l.target === c || l.target === m) {
        handlePrevent(l);
        const g = touchEventPolyfill(l.touches[0], l);
        this.onHandleDown(g, u);
      }
    }, this.onHandleTouchMove = (l) => {
      const u = this._adapter.getMinHandleEl(), c = this._adapter.getMaxHandleEl();
      if (l.target === u || l.target === c) {
        const m = touchEventPolyfill(l.touches[0], l);
        this.onHandleMove(m);
      }
    }, this.onHandleEnter = (l) => {
      const { disabled: u, focusPos: c } = this._adapter.getStates();
      u || !c && l !== c && this._adapter.onHandleEnter(l);
    }, this.onHandleLeave = () => {
      const l = this._adapter.getState("disabled"), u = this._adapter.getState("isDrag");
      !l && !u && this._adapter.onHandleLeave();
    }, this.onHandleUp = (l) => {
      this._adapter.onHandleUpBefore(l);
      const { disabled: u, chooseMovePos: c } = this._adapter.getStates(), { dragging: m } = this._adapter.getOverallVars();
      return u ? !1 : (c === "min" ? this._adapter.setDragging([!1, m[1]]) : this._adapter.setDragging([m[0], !1]), this._adapter.setStateVal("isDrag", !1), this._adapter.onHandleLeave(), this._adapter.onHandleUpAfter(), !0);
    }, this._handleValueDecreaseWithKeyBoard = (l, u) => {
      const { min: c, currentValue: m } = this.getStates(), { range: g } = this.getProps();
      if (u === "min")
        if (g) {
          let v = m[0] - l;
          return v = v < c ? c : v, [v, m[1]];
        } else {
          let v = m - l;
          return v = v < c ? c : v, v;
        }
      else {
        let v = m[1] - l;
        return v = v < m[0] ? m[0] : v, [m[0], v];
      }
    }, this._handleValueIncreaseWithKeyBoard = (l, u) => {
      const { max: c, currentValue: m } = this.getStates(), { range: g } = this.getProps();
      if (u === "min")
        if (g) {
          let v = m[0] + l;
          return v = v > m[1] ? m[1] : v, [v, m[1]];
        } else {
          let v = m + l;
          return v = v > c ? c : v, v;
        }
      else {
        let v = m[1] + l;
        return v = v > c ? c : v, [m[0], v];
      }
    }, this._handleHomeKey = (l) => {
      const { min: u, currentValue: c } = this.getStates(), { range: m } = this.getProps();
      return l === "min" ? m ? [u, c[1]] : u : [c[0], c[0]];
    }, this._handleEndKey = (l) => {
      const { max: u, currentValue: c } = this.getStates(), { range: m } = this.getProps();
      return l === "min" ? m ? [c[1], c[1]] : u : [c[0], u];
    }, this.handleKeyDown = (l, u) => {
      const { min: c, max: m, currentValue: g } = this.getStates(), { step: v, range: b } = this.getProps();
      let S;
      switch (l.key) {
        case "ArrowLeft":
        case "ArrowDown":
          S = this._handleValueDecreaseWithKeyBoard(v, u);
          break;
        case "ArrowRight":
        case "ArrowUp":
          S = this._handleValueIncreaseWithKeyBoard(v, u);
          break;
        case "PageUp":
          S = this._handleValueIncreaseWithKeyBoard(10 * v, u);
          break;
        case "PageDown":
          S = this._handleValueDecreaseWithKeyBoard(10 * v, u);
          break;
        case "Home":
          S = this._handleHomeKey(u);
          break;
        case "End":
          S = this._handleEndKey(u);
          break;
      }
      if (["ArrowLeft", "ArrowDown", "ArrowRight", "ArrowUp", "PageUp", "PageDown", "Home", "End"].includes(l.key)) {
        let E = !0;
        Array.isArray(g) ? E = !(g[0] === S[0] && g[1] === S[1]) : E = g !== S, E && (this._adapter.updateCurrentValue(S), this._adapter.notifyChange(S)), handlePrevent(l);
      }
    }, this.onFocus = (l, u) => {
      handlePrevent(l);
      const { target: c } = l;
      try {
        c.matches(":focus-visible") && (u === "min" ? this._adapter.setStateVal("firstDotFocusVisible", !0) : this._adapter.setStateVal("secondDotFocusVisible", !0));
      } catch {
        warning$1(!0, "Warning: [Semi Slider] The current browser does not support the focus-visible");
      }
    }, this.onBlur = (l, u) => {
      const { firstDotFocusVisible: c, secondDotFocusVisible: m } = this.getStates();
      u === "min" ? c && this._adapter.setStateVal("firstDotFocusVisible", !1) : m && this._adapter.setStateVal("secondDotFocusVisible", !1);
    }, this.handleWrapClick = (l) => {
      const { disabled: u, isDrag: c } = this._adapter.getStates();
      if (c || u || this._adapter.isEventFromHandle(l))
        return;
      const { vertical: m } = this.getProps(), g = this.handleMousePos(l.clientX, l.clientY), v = m ? g.y : g.x, b = this.checkWhichHandle(v), S = this.calculateOutputValue(v, b);
      S !== void 0 && (this._adapter.notifyChange(S), !this._isControlledComponent() && this.setHandlePos(v, b, !0, S));
    }, this.setHandlePos = (l, u, c = !1, m) => {
      this._adapter.onHandleMove(l, u, () => this._adapter.onHandleUpAfter(), c, m);
    }, this.checkWhichHandle = (l) => {
      const { vertical: u, verticalReverse: c } = this.getProps(), { currentValue: m } = this._adapter.getStates(), g = this.transValueToPos(m);
      let v = !0;
      return Array.isArray(g) && (l > g[1] || Math.abs(l - g[0]) > Math.abs(l - g[1])) && (v = !1), u && c && (v = !v), v;
    }, this.handleWrapperEnter = () => {
      this._adapter.setStateVal("showBoundary", !0);
    }, this.handleWrapperLeave = () => {
      this._adapter.setStateVal("showBoundary", !1);
    };
  }
  init() {
    this._checkCurrentValue(), this._dragOffset = 0;
  }
  _checkCurrentValue() {
    const { currentValue: o, min: l, max: u } = this.getStates();
    let c;
    Array.isArray(o) ? (c = [], c[0] = this._checkValidity(o[0], l, u), c[1] = this._checkValidity(o[1], l, u)) : c = this._checkValidity(o, l, u), this._adapter.updateCurrentValue(c);
  }
  /**
   * Untie event
   * @memberof SliderFoundation
   */
  destroy() {
    this._adapter.unSubscribeEventListener();
  }
  _getHandleCenterPosition(o, l) {
    const u = l.getBoundingClientRect(), { x: c, y: m } = this.handleMousePos(u.left + u.width * 0.5, u.top + u.height * 0.5);
    return o ? m : c;
  }
}
function _isSlot$x(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$t = cssClasses$z.PREFIX;
function domIsInRenderTree(s) {
  return s ? !!(s.offsetWidth || s.offsetHeight || s.getClientRects().length) : !1;
}
const propTypes$1f = {
  // allowClear: PropTypes.bool,
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-valuetext": string$3,
  defaultValue: [number$2, array$1],
  disabled: {
    type: bool,
    default: void 0
  },
  showMarkLabel: bool,
  included: {
    type: bool,
    default: void 0
  },
  // Whether to juxtapose. Allow dragging
  marks: object$1,
  // Scale
  max: number$2,
  min: number$2,
  range: {
    type: bool,
    default: void 0
  },
  // Whether both sides
  step: number$2,
  tipFormatter: func,
  value: [number$2, array$1],
  vertical: {
    type: bool,
    default: void 0
  },
  onAfterChange: func,
  // OnmouseUp and triggered when clicked
  onChange: func,
  onMouseUp: func,
  tooltipOnMark: bool,
  tooltipVisible: {
    type: bool,
    default: void 0
  },
  showArrow: bool,
  style: object$1,
  className: string$3,
  showBoundary: {
    type: bool,
    default: void 0
  },
  railStyle: object$1,
  verticalReverse: {
    type: bool,
    default: void 0
  },
  getAriaValueText: func,
  handleDot: oneOfType([object$1, array$1])
}, defaultProps$19 = {
  // allowClear: false,
  disabled: !1,
  showMarkLabel: !0,
  tooltipOnMark: !1,
  included: !0,
  // No is juxtaposition. Allow dragging
  max: 100,
  min: 0,
  range: !1,
  // Whether both sides
  showArrow: !0,
  step: 1,
  tipFormatter: (s) => s,
  vertical: !1,
  showBoundary: !1,
  onAfterChange: (s) => {
  },
  onChange: (s) => {
  },
  verticalReverse: !1
}, vuePropsType$21 = vuePropsMake(propTypes$1f, defaultProps$19), Slider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$21
  },
  name: "Slider",
  setup(s, {}) {
    useSlots();
    let {
      value: o
    } = s;
    o || (o = s.defaultValue);
    const l = reactive({
      // eslint-disable-next-line no-nested-ternary
      currentValue: o || (s.range ? [0, 0] : 0),
      min: s.min || 0,
      max: s.max || 0,
      focusPos: "",
      onChange: s.onChange,
      disabled: s.disabled || !1,
      chooseMovePos: "",
      isDrag: !1,
      clickValue: 0,
      showBoundary: !1,
      isInRenderTree: !0,
      firstDotFocusVisible: !1,
      secondDotFocusVisible: !1
    }), u = ref$1(), c = ref$1(), m = ref$1();
    let g = [!1, !1];
    const v = /* @__PURE__ */ new Set(), b = /* @__PURE__ */ new Set(), {
      adapter: S,
      getDataAttr: E
    } = useBaseComponent(s, l), P = T();
    function T() {
      return {
        ...S(),
        getSliderLengths: () => {
          var K;
          if (u && u.value) {
            const ve = u.value.getBoundingClientRect(), ee = (K = u.value.offsetParent) == null ? void 0 : K.getBoundingClientRect(), Re = {
              x: ee ? ve.left - ee.left : u.value.offsetLeft,
              y: ee ? ve.top - ee.top : u.value.current.offsetTop
            };
            return {
              sliderX: Re.x,
              sliderY: Re.y,
              sliderWidth: ve.width,
              sliderHeight: ve.height
            };
          }
          return {
            sliderX: 0,
            sliderY: 0,
            sliderWidth: 0,
            sliderHeight: 0
          };
        },
        getParentRect: () => {
          const K = u && u.value && u.value.offsetParent;
          if (K)
            return K.getBoundingClientRect();
        },
        getScrollParentVal: () => {
          const K = N.getScrollParent(u.value);
          return {
            scrollTop: K.scrollTop,
            scrollLeft: K.scrollLeft
          };
        },
        isEventFromHandle: (K) => {
          const ve = [c, m];
          let ee = !1;
          return ve.forEach((Re) => {
            Re.value && Re.value.contains(K.target) && (ee = !0);
          }), ee;
        },
        getOverallVars: () => ({
          dragging: g
        }),
        updateDisabled: (K) => {
          l.disabled = K;
        },
        transNewPropsToState(K, ve = lodashExports.noop) {
          Object.keys(K).forEach((ee) => {
            l[ee] = K[ee];
          }), nextTick(() => {
            ve == null || ve();
          });
        },
        notifyChange: (K) => {
          s.onChange(Array.isArray(K) ? [...K].sort() : K);
        },
        setDragging: (K) => {
          g = K;
        },
        updateCurrentValue: (K) => {
        },
        setOverallVars: (K, ve) => {
          console.error("smw: 用途 未知");
        },
        getMinHandleEl: () => c.value,
        getMaxHandleEl: () => m.value,
        onHandleDown: (K) => {
          b.add(te(document.body, "mousemove", N.onHandleMove, !1)), b.add(te(window, "mouseup", N.onHandleUp, !1)), b.add(te(document.body, "touchmove", N.onHandleTouchMove, !1));
        },
        onHandleMove: (K, ve, ee = lodashExports.noop, Re = !1, wt) => {
          if (!N.checkAndUpdateIsInRenderTreeState())
            return;
          const {
            value: xt
          } = s;
          let Kt = wt;
          if (Kt === void 0) {
            const ln = N.transPosToValue(K, ve);
            if (ln === !1)
              return;
            Kt = N.outPutValue(ln);
          }
          const {
            currentValue: tn
          } = l;
          if (!lodashExports.isEqual(N.outPutValue(tn), Kt)) {
            if (!Re && N.valueFormatIsCorrect(xt))
              return !1;
            l.currentValue = Kt, nextTick(() => {
              ee == null || ee();
            });
          }
        },
        setEventDefault: (K) => {
          K.stopPropagation(), K.preventDefault();
        },
        setStateVal: (K, ve) => {
          l[K] = ve;
        },
        checkAndUpdateIsInRenderTreeState: () => {
          const K = domIsInRenderTree(u.value);
          return K !== l.isInRenderTree && (l.isInRenderTree = K), K;
        },
        onHandleEnter: (K) => {
          l.focusPos = K;
        },
        onHandleLeave: () => {
          l.focusPos = "";
        },
        onHandleUpBefore: (K) => {
          var ve;
          (ve = s.onMouseUp) == null || ve.call(s, K), K.stopPropagation(), K.preventDefault(), Array.from(b).forEach((ee) => ee()), b.clear();
        },
        onHandleUpAfter: () => {
          const {
            currentValue: K
          } = l, ve = N.outPutValue(K);
          s.onAfterChange(ve);
        },
        unSubscribeEventListener: () => {
          Array.from(v).forEach((K) => K == null ? void 0 : K());
        }
      };
    }
    const N = new SliderFoundation(P);
    watch([() => s.value, () => s.disabled, () => l.currentValue], (K, [ve, ee]) => {
      const Re = !lodashExports.isEqual(s.value, ve);
      if (s.disabled !== ee && N.handleDisabledChange(s.disabled), Re) {
        const yt = s.value, xt = l.currentValue;
        N.handleValueChange(xt, yt);
      }
    }), onMounted(() => {
      N.init();
    }), onUnmounted(() => {
      N.init();
    });
    const O = () => {
      const {
        vertical: K,
        range: ve,
        tooltipVisible: ee,
        tipFormatter: Re,
        "aria-label": wt,
        "aria-labelledby": yt,
        "aria-valuetext": xt,
        getAriaValueText: Kt,
        disabled: tn
      } = s, {
        chooseMovePos: ln,
        isDrag: rn,
        isInRenderTree: an,
        firstDotFocusVisible: Gt,
        secondDotFocusVisible: nn
      } = l, vt = K ? "top" : "left", Et = N.getMinAndMaxPercent(l.currentValue), Qt = Et.min, un = Et.max, {
        tipVisible: gn,
        tipChildren: dn
      } = N.computeHandleVisibleVal(ee && an, Re, ve), yn = cls(cssClasses$z.HANDLE, {
        [`${cssClasses$z.HANDLE}-clicked`]: ln === "min" && rn
      }), vn = cls(cssClasses$z.HANDLE, {
        [`${cssClasses$z.HANDLE}-clicked`]: ln === "max" && rn
      }), {
        min: Pn,
        max: On,
        currentValue: _n
      } = l, Nn = {
        "aria-label": wt ?? (tn ? "Disabled Slider" : void 0),
        "aria-labelledby": yt,
        "aria-disabled": tn
      };
      K && Object.assign(Nn, {
        "aria-orientation": "vertical"
      });
      const Un = s.handleDot;
      return ve ? createVNode(Fragment, null, [createVNode(Tooltip$1, {
        content: dn.min,
        position: "top",
        trigger: "custom",
        rePosKey: Qt,
        visible: an && (gn.min || Gt),
        className: `${cssClasses$z.HANDLE}-tooltip`
      }, {
        default: () => {
          var zn, jn;
          return [createVNode("span", mergeProps$1({
            ref: c,
            class: yn,
            style: {
              [vt]: `${Qt * 100}%`,
              zIndex: ln === "min" ? 2 : 1
            },
            onMousedown: (kn) => {
              N.onHandleDown(kn, "min");
            },
            onMouseenter: () => {
              N.onHandleEnter("min");
            },
            onTouchstart: (kn) => {
              N.onHandleTouchStart(kn, "min");
            },
            onMouseleave: () => {
              N.onHandleLeave();
            },
            onKeyup: (kn) => {
              N.onHandleUp(kn);
            },
            onTouchend: (kn) => {
              N.onHandleUp(kn);
            },
            onKeydown: (kn) => {
              N.handleKeyDown(kn, "min");
            },
            onFocus: (kn) => {
              N.onFocus(kn, "min");
            },
            onBlur: (kn) => {
              N.onBlur(kn, "min");
            },
            role: "slider",
            tabindex: tn ? -1 : 0
          }, Nn, {
            "aria-valuetext": Kt ? Kt(_n[0], 0) : xt,
            "aria-valuenow": _n[0],
            "aria-valuemax": _n[1],
            "aria-valuemin": Pn
          }), [(Un == null ? void 0 : Un[0]) && createVNode("div", {
            class: cssClasses$z.HANDLE_DOT,
            style: {
              ...(zn = Un[0]) != null && zn.size ? {
                width: Un[0].size,
                height: Un[0].size
              } : {},
              ...(jn = Un[0]) != null && jn.color ? {
                backgroundColor: Un[0].color
              } : {}
            }
          }, null)])];
        }
      }), createVNode(Tooltip$1, {
        content: dn.max,
        position: "top",
        trigger: "custom",
        rePosKey: un,
        visible: an && (gn.max || nn),
        className: `${cssClasses$z.HANDLE}-tooltip`
      }, {
        default: () => {
          var zn, jn, kn;
          return [createVNode("span", mergeProps$1({
            ref: m,
            class: vn,
            style: {
              [vt]: `${un * 100}%`,
              zIndex: ln === "max" ? 2 : 1
            },
            onMousedown: (Yn) => {
              N.onHandleDown(Yn, "max");
            },
            onMouseenter: () => {
              N.onHandleEnter("max");
            },
            onMouseleave: () => {
              N.onHandleLeave();
            },
            onKeyup: (Yn) => {
              N.onHandleUp(Yn);
            },
            onTouchstart: (Yn) => {
              N.onHandleTouchStart(Yn, "max");
            },
            onTouchend: (Yn) => {
              N.onHandleUp(Yn);
            },
            onKeydown: (Yn) => {
              N.handleKeyDown(Yn, "max");
            },
            onFocus: (Yn) => {
              N.onFocus(Yn, "max");
            },
            onBlur: (Yn) => {
              N.onBlur(Yn, "max");
            },
            role: "slider",
            tabindex: tn ? -1 : 0
          }, Nn, {
            "aria-valuetext": Kt ? Kt(_n[1], 1) : xt,
            "aria-valuenow": _n[1],
            "aria-valuemax": On,
            "aria-valuemin": _n[0]
          }), [((zn = s.handleDot) == null ? void 0 : zn[1]) && createVNode("div", {
            class: cssClasses$z.HANDLE_DOT,
            style: {
              ...(jn = s.handleDot[1]) != null && jn.size ? {
                width: s.handleDot[1].size,
                height: s.handleDot[1].size
              } : {},
              ...(kn = s.handleDot[1]) != null && kn.color ? {
                backgroundColor: s.handleDot[1].color
              } : {}
            }
          }, null)])];
        }
      })]) : createVNode(Tooltip$1, {
        content: dn.min,
        showArrow: s.showArrow,
        position: "top",
        trigger: "custom",
        rePosKey: Qt,
        visible: an && (gn.min || Gt),
        className: `${cssClasses$z.HANDLE}-tooltip`
      }, {
        default: () => [createVNode("span", mergeProps$1({
          onMouseover: N.checkAndUpdateIsInRenderTreeState,
          ref: c,
          class: yn,
          style: {
            [vt]: `${Qt * 100}%`,
            zIndex: ln === "min" && rn ? 2 : 1
          },
          onMousedown: (zn) => {
            N.onHandleDown(zn, "min");
          },
          onMouseenter: () => {
            N.onHandleEnter("min");
          },
          onTouchstart: (zn) => {
            N.onHandleTouchStart(zn, "min");
          },
          onMouseleave: () => {
            N.onHandleLeave();
          },
          onKeyup: (zn) => {
            N.onHandleUp(zn);
          },
          onTouchend: (zn) => {
            N.onHandleUp(zn);
          },
          onKeydown: (zn) => {
            N.handleKeyDown(zn, "min");
          },
          onFocus: (zn) => {
            N.onFocus(zn, "min");
          },
          onBlur: (zn) => {
            N.onBlur(zn, "min");
          },
          role: "slider",
          "aria-valuetext": Kt ? Kt(_n, 0) : xt,
          tabindex: tn ? -1 : 0
        }, Nn, {
          "aria-valuenow": _n,
          "aria-valuemax": On,
          "aria-valuemin": Pn
        }), [Un && createVNode("div", {
          class: cssClasses$z.HANDLE_DOT,
          style: {
            ...Un != null && Un.size ? {
              width: Un.size,
              height: Un.size
            } : {},
            ...Un != null && Un.color ? {
              backgroundColor: Un.color
            } : {}
          }
        }, null)])]
      });
    }, z = () => {
      const {
        range: K,
        included: ve,
        vertical: ee
      } = s, Re = N.getMinAndMaxPercent(l.currentValue), wt = Re.min, yt = Re.max;
      let xt = ee ? {
        height: K ? `${Math.abs(yt - wt) * 100}%` : `${wt * 100}%`,
        top: K ? `${Math.min(wt, yt) * 100}%` : 0
      } : {
        width: K ? `${Math.abs(yt - wt) * 100}%` : `${wt * 100}%`,
        left: K ? `${Math.min(wt, yt) * 100}%` : 0
      };
      return xt = ve ? xt : {}, // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
      createVNode("div", {
        class: cssClasses$z.TRACK,
        style: xt,
        onClick: N.handleWrapClick
      }, null);
    }, Q = () => {
      const {
        min: K,
        max: ve,
        vertical: ee,
        marks: Re
      } = s, wt = ee ? "top" : "left";
      return Re && Object.keys(Re).length > 0 ? createVNode("div", {
        class: cssClasses$z.DOTS
      }, [Object.keys(Re).map((xt) => {
        const Kt = N.isMarkActive(Number(xt)), tn = cls(`${prefixCls$t}-dot`, {
          [`${prefixCls$t}-dot-active`]: N.isMarkActive(Number(xt)) === "active"
        }), ln = (Number(xt) - K) / (ve - K), rn = (
          // eslint-disable-next-line jsx-a11y/no-static-element-interactions
          createVNode("span", {
            key: xt,
            onClick: N.handleWrapClick,
            class: tn,
            style: {
              [wt]: `calc(${ln * 100}% - 2px)`
            }
          }, null)
        );
        return Kt ? s.tooltipOnMark ? createVNode(Tooltip$1, {
          content: Re[xt]
        }, _isSlot$x(rn) ? rn : {
          default: () => [rn]
        }) : rn : null;
      })]) : null;
    }, W = () => {
      if (!s.showMarkLabel)
        return null;
      const {
        min: K,
        max: ve,
        vertical: ee,
        marks: Re,
        verticalReverse: wt
      } = s, yt = ee ? "top" : "left";
      return Re && Object.keys(Re).length > 0 ? createVNode("div", {
        class: cssClasses$z.MARKS + (ee && wt ? "-reverse" : "")
      }, [Object.keys(Re).map((Kt) => {
        const tn = N.isMarkActive(Number(Kt)), ln = (Number(Kt) - K) / (ve - K);
        return tn ? (
          // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
          createVNode("span", {
            key: Kt,
            class: cls(`${prefixCls$t}-mark${ee && wt ? "-reverse" : ""}`),
            style: {
              [yt]: `${ln * 100}%`
            },
            onClick: N.handleWrapClick
          }, [Re[Kt]])
        ) : null;
      })]) : null;
    }, ue = (K, ve) => {
      const {
        getAriaValueText: ee
      } = s;
      return ee ? ee(K, ve) : K;
    };
    function te(K, ve, ee, ...Re) {
      if (K.addEventListener) {
        K.addEventListener(ve, ee, ...Re);
        const wt = () => {
          K == null || K.removeEventListener(ve, ee), Promise.resolve().then(() => {
            v.delete(wt);
          });
        };
        return v.add(wt), wt;
      } else
        return lodashExports.noop;
    }
    return () => {
      const {
        disabled: K,
        currentValue: ve,
        min: ee,
        max: Re
      } = l, {
        vertical: wt,
        verticalReverse: yt,
        style: xt,
        railStyle: Kt,
        range: tn,
        className: ln,
        ...rn
      } = s, an = cls(`${prefixCls$t}-wrapper`, {
        [`${prefixCls$t}-disabled`]: K,
        [`${cssClasses$z.VERTICAL}-wrapper`]: wt,
        [`${prefixCls$t}-reverse`]: wt && yt
      }, ln), Gt = cls(`${prefixCls$t}-boundary`, {
        [`${prefixCls$t}-boundary-show`]: s.showBoundary && l.showBoundary
      }), nn = cls({
        [`${prefixCls$t}`]: !wt,
        [cssClasses$z.VERTICAL]: wt
      }), vt = Array.isArray(ve) ? [...ve].sort() : ve, Et = tn ? `Range: ${ue(vt[0], 0)} to ${ue(vt[1], 1)}` : void 0, Qt = createVNode("div", mergeProps$1({
        class: an,
        style: xt,
        ref: u,
        "aria-label": Et,
        onMouseenter: () => N.handleWrapperEnter(),
        onMouseleave: () => N.handleWrapperLeave()
      }, E()), [
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        createVNode("div", {
          class: `${prefixCls$t}-rail`,
          onClick: N.handleWrapClick,
          style: Kt
        }, null),
        z(),
        Q(),
        createVNode("div", null, [O()]),
        W(),
        createVNode("div", {
          class: Gt
        }, [createVNode("span", {
          class: `${prefixCls$t}-boundary-min`
        }, [ee]), createVNode("span", {
          class: `${prefixCls$t}-boundary-max`
        }, [Re])])
      ]);
      return wt ? Qt : createVNode("div", {
        class: nn
      }, [Qt]);
    };
  }
}), Slider$1 = Slider, cssClasses$y = {
  PREFIX: `${BASE_CLASS_PREFIX$1}`
}, prefixCls$s = cssClasses$y.PREFIX, Divider = (s, {
  slots: o
}) => {
  var T;
  const {
    layout: l = "horizontal",
    dashed: u,
    align: c = "center",
    className: m,
    margin: g,
    style: v,
    ...b
  } = s, S = (T = o.default) == null ? void 0 : T.call(o), E = cls(`${prefixCls$s}-divider`, m, {
    [`${prefixCls$s}-divider-horizontal`]: l === "horizontal",
    [`${prefixCls$s}-divider-vertical`]: l === "vertical",
    [`${prefixCls$s}-divider-dashed`]: !!u,
    [`${prefixCls$s}-divider-with-text`]: S && l === "horizontal",
    [`${prefixCls$s}-divider-with-text-${c}`]: S && l === "horizontal"
  });
  let P = {};
  return g !== void 0 && (l === "vertical" ? P = {
    marginLeft: g,
    marginRight: g
  } : l === "horizontal" && (P = {
    marginTop: g,
    marginBottom: g
  })), createVNode("div", mergeProps$1(b, {
    class: E,
    style: {
      ...P,
      ...v
    }
  }), [S && l === "horizontal" ? typeof S == "string" ? createVNode("span", {
    class: `${prefixCls$s}-divider_inner-text`,
    "x-semi-prop": "children"
  }, [S]) : S : null]);
}, Divider$1 = Divider, cssClasses$x = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-rating`
};
class RatingFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...RatingFoundation.defaultAdapter, ...o }), this.handleStarFocusVisible = (l) => {
      const { target: u } = l;
      this.getProps();
      try {
        u.matches(":focus-visible") && this._adapter.setEmptyStarFocusVisible(!0);
      } catch {
        warning$1(!0, "Warning: [Semi Rating] The current browser does not support the focus-visible");
      }
    }, this.handleStarBlur = (l) => {
      const { emptyStarFocusVisible: u } = this.getStates();
      u && this._adapter.setEmptyStarFocusVisible(!1);
    };
  }
  init() {
    const { autoFocus: o, disabled: l } = this.getProps();
    o && !l && this._adapter.focus();
  }
  _getScroll(o, l) {
    let u = l ? o.pageYOffset : o.pageXOffset;
    const c = l ? "scrollTop" : "scrollLeft";
    if (typeof u != "number") {
      const m = o.document;
      u = m.documentElement[c], typeof u != "number" && (u = m.body[c]);
    }
    return u;
  }
  _getClientPosition(o) {
    let l, u;
    const c = o.ownerDocument, { body: m } = c, g = c && c.documentElement, v = o.getBoundingClientRect();
    return l = v.left, u = v.top, l -= g.clientLeft || m.clientLeft || 0, u -= g.clientTop || m.clientTop || 0, {
      left: l,
      top: u
    };
  }
  _getOffsetLeft(o) {
    const l = this._getClientPosition(o), u = o.ownerDocument, c = u.defaultView || u.parentWindow;
    return l.left += this._getScroll(c), l.left;
  }
  getStarValue(o, l) {
    const { allowHalf: u } = this.getProps(), m = this._adapter.getContext("direction") === "rtl";
    let g = o + 1;
    if (u) {
      const v = this._adapter.getStarDOM(o), b = this._getOffsetLeft(v), S = v.clientWidth;
      (m && l - b > S / 2 || !m && l - b < S / 2) && (g -= 0.5);
    }
    return g;
  }
  handleHover(o, l) {
    const u = this.getStarValue(l, o.pageX), { clearedValue: c, hoverValue: m } = this.getStates();
    u !== m && u !== c && this._adapter.notifyHoverChange(u, null);
  }
  handleMouseLeave() {
    this._adapter.notifyHoverChange(void 0, null);
  }
  handleClick(o, l) {
    const { allowClear: u } = this.getProps(), { value: c } = this.getStates(), m = this.getStarValue(l, o.pageX), g = u ? m === c : !1;
    this._adapter.updateValue(g ? 0 : m), g ? this._adapter.notifyHoverChange(void 0, m) : this._adapter.clearValue(null);
  }
  handleFocus(o) {
    this._adapter.notifyFocus(o);
  }
  handleBlur(o) {
    this._adapter.notifyBlur(o);
  }
  handleKeyDown(o, l) {
    const { key: u } = o, { count: c, allowHalf: m } = this.getProps(), v = this._adapter.getContext("direction") === "rtl", b = m ? 0.5 : 1;
    let S, E;
    u === "ArrowRight" || u === "ArrowUp" ? S = l + (v ? -b : b) : (u === "ArrowLeft" || u === "ArrowDown") && (S = l + (v ? b : -b)), S > c ? E = 0 : S < 0 ? E = c : E = S, ["ArrowRight", "ArrowUp", "ArrowLeft", "ArrowDown"].includes(u) && (this._adapter.notifyKeyDown(o), this._adapter.updateValue(E), this.changeFocusStar(E, o), o.preventDefault(), this._adapter.notifyHoverChange(void 0, null));
  }
  changeFocusStar(o, l) {
    const { count: u, allowHalf: c, preventScroll: m } = this.getProps(), g = Math.ceil(o) - 1, v = [...l.currentTarget.childNodes].map((b) => b.childNodes[0].childNodes);
    g < 0 ? v[u][0].focus({ preventScroll: m }) : v[g][c ? o * 10 % 10 === 5 ? 0 : 1 : 0].focus({ preventScroll: m });
  }
}
class RatingItemFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...RatingItemFoundation.defaultAdapter, ...o }), this.handleFocusVisible = (l, u) => {
      const { target: c } = l;
      try {
        c.matches(":focus-visible") && (u === "first" ? this._adapter.setFirstStarFocus(!0) : this._adapter.setSecondStarFocus(!0));
      } catch {
        warning$1(!0, "Warning: [Semi Rating] The current browser does not support the focus-visible");
      }
    }, this.handleBlur = (l, u) => {
      const { firstStarFocus: c, secondStarFocus: m } = this.getStates();
      u === "first" ? c && this._adapter.setFirstStarFocus(!1) : m && this._adapter.setSecondStarFocus(!1);
    };
  }
}
const propTypes$1e = {
  value: {
    type: number$2,
    required: !0
  },
  index: {
    type: number$2,
    required: !0
  },
  prefixCls: {
    type: string$3,
    required: !0
  },
  allowHalf: {
    type: bool,
    required: !0
  },
  onHover: {
    type: func,
    required: !0
  },
  onClick: {
    type: func,
    required: !0
  },
  character: {
    type: node$1,
    required: !0
  },
  focused: {
    type: bool,
    required: !0
  },
  disabled: {
    type: bool,
    required: !0
  },
  count: {
    type: number$2,
    required: !0
  },
  ariaLabelPrefix: {
    type: string$3,
    required: !0
  },
  size: {
    type: oneOfType([string$3, number$2]),
    required: !0
  },
  "aria-describedby": string$3,
  onFocus: func,
  onBlur: func,
  preventScroll: bool,
  style: object$1,
  className: string$3
}, vuePropsType$20 = vuePropsMake(propTypes$1e, {}), Item$3 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$20
  },
  name: "Item",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const l = reactive({
      firstStarFocus: !1,
      secondStarFocus: !1
    }), {
      adapter: u
    } = useBaseComponent(s, l);
    function c() {
      return {
        ...u(),
        setFirstStarFocus: (z) => {
          l.firstStarFocus = z;
        },
        setSecondStarFocus: (z) => {
          l.secondStarFocus = z;
        }
      };
    }
    const m = c(), g = new RatingItemFoundation(m), v = ref$1(), b = ref$1(), S = (z) => {
      const {
        onHover: Q,
        index: W
      } = s;
      Q(z, W);
    }, E = (z) => {
      const {
        onClick: Q,
        index: W
      } = s;
      Q(z, W);
    }, P = (z, Q) => {
      const {
        onFocus: W
      } = s;
      W && W(z), g.handleFocusVisible(z, Q);
    }, T = (z, Q) => {
      const {
        onBlur: W
      } = s;
      W && W(z), g.handleBlur(z, Q);
    }, N = (z) => {
      const {
        onClick: Q,
        index: W
      } = s;
      z.keyCode === 13 && Q(z, W);
    };
    return o({
      starFocus: () => {
        const {
          value: z,
          index: Q,
          preventScroll: W
        } = s;
        z - Q === 0.5 ? v.value.focus({
          preventScroll: W
        }) : b.value.focus({
          preventScroll: W
        });
      }
    }), () => {
      const {
        index: z,
        prefixCls: Q,
        character: W,
        count: ue,
        value: te,
        disabled: K,
        allowHalf: ve,
        focused: ee,
        size: Re,
        ariaLabelPrefix: wt
      } = s, {
        firstStarFocus: yt,
        secondStarFocus: xt
      } = l, Kt = z + 1, tn = Kt - te, ln = ve && tn < 1 && tn > 0, rn = 1 - tn, an = Kt <= te, Gt = typeof Re == "number", nn = cls(Q, {
        [`${Q}-half`]: ln,
        [`${Q}-full`]: an,
        [`${Q}-${Re}`]: !Gt
      }), vt = Gt ? {
        width: Re,
        height: Re,
        fontSize: Re
      } : {}, Qt = W || createVNode(IconComponent$7, {
        size: Gt ? "inherit" : Re === "small" ? "default" : "extra-large",
        style: {
          display: "block"
        }
      }, null), un = z === ue, gn = cls(`${Q}-wrapper`, {
        [`${Q}-disabled`]: K,
        [`${cssClasses$x.PREFIX}-focus`]: (yt || xt) && te !== 0
      }), dn = {
        onClick: K ? null : E,
        onKeydown: K ? null : N,
        onMousemove: K ? null : S,
        class: gn
      }, yn = ve ? ue * 2 + 1 : ue + 1, vn = {
        ref: v,
        role: "radio",
        "aria-checked": te === z + 0.5,
        "aria-posinset": 2 * z + 1,
        "aria-setsize": yn,
        "aria-disabled": K,
        "aria-label": `${z + 0.5} ${wt}s`,
        "aria-labelledby": s["aria-describedby"],
        "aria-describedby": s["aria-describedby"],
        class: cls(`${Q}-first`, `${cssClasses$x.PREFIX}-no-focus`),
        tabindex: !K && te === z + 0.5 ? 0 : -1,
        onFocus: (_n) => {
          P(_n, "first");
        },
        onBlur: (_n) => {
          T(_n, "first");
        }
      }, Pn = !K && (te === z + 1 || un && te === 0) ? 0 : -1, On = {
        ref: b,
        role: "radio",
        "aria-checked": un ? te === 0 : te === z + 1,
        "aria-posinset": ve ? 2 * (z + 1) : z + 1,
        "aria-setsize": yn,
        "aria-disabled": K,
        "aria-label": `${un ? 0 : z + 1} ${wt}${z === 0 ? "" : "s"}`,
        "aria-labelledby": s["aria-describedby"],
        "aria-describedby": s["aria-describedby"],
        className: cls(`${Q}-second`, `${cssClasses$x.PREFIX}-no-focus`),
        tabIndex: Pn,
        onFocus: (_n) => {
          P(_n, "second");
        },
        onBlur: (_n) => {
          T(_n, "second");
        }
      };
      return createVNode("li", {
        class: nn,
        style: {
          ...vt
        },
        key: z
      }, [createVNode("div", dn, [ve && !un && createVNode("div", mergeProps$1(vn, {
        style: {
          width: `${rn * 100}%`
        }
      }), [Qt]), createVNode("div", mergeProps$1(On, {
        "x-semi-prop": "character"
      }), [Qt])])]);
    };
  }
});
function _isSlot$w(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$1d = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": [bool, string$3],
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-required": bool,
  disabled: bool,
  value: number$2,
  defaultValue: number$2,
  count: number$2,
  allowHalf: bool,
  allowClear: bool,
  style: object$1,
  prefixCls: string$3,
  onChange: func,
  onHoverChange: func,
  className: string$3,
  character: node$1,
  tabIndex: number$2,
  onFocus: func,
  onBlur: func,
  onKeyDown: func,
  autoFocus: bool,
  size: oneOfType([string$3, number$2]),
  tooltips: Array,
  id: string$3,
  preventScroll: bool,
  onClick: func
}, defaultProps$18 = {
  defaultValue: 0,
  count: 5,
  allowHalf: !1,
  allowClear: !0,
  style: {},
  prefixCls: cssClasses$x.PREFIX,
  onChange: noop$1,
  onHoverChange: noop$1,
  tabIndex: -1,
  size: "default"
}, vuePropsType$1$ = vuePropsMake(propTypes$1d, defaultProps$18), Rating = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1$
  },
  name: "Rating",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    const l = ref$1(), u = {}, c = reactive({
      value: s.value === void 0 ? s.defaultValue : s.value,
      focused: !1,
      hoverValue: void 0,
      clearedValue: null,
      emptyStarFocusVisible: !1
    }), {
      adapter: m,
      getDataAttr: g
    } = useBaseComponent(s, c);
    function v() {
      return {
        ...m(),
        focus: () => {
          const {
            disabled: ee,
            count: Re
          } = s, {
            value: wt
          } = c;
          if (!ee) {
            const yt = Math.ceil(wt) - 1;
            u[yt < 0 ? Re : yt].starFocus();
          }
        },
        getStarDOM: (ee) => (u && u[ee]).$el,
        notifyHoverChange: (ee, Re) => {
          const {
            onHoverChange: wt
          } = s;
          c.hoverValue = ee, c.clearedValue = Re, wt(ee);
        },
        updateValue: (ee) => {
          const {
            onChange: Re
          } = s;
          "value" in o(s) || (c.value = ee), Re(ee);
        },
        clearValue: (ee) => {
          c.clearedValue = ee;
        },
        notifyFocus: (ee) => {
          const {
            onFocus: Re
          } = s;
          c.focused = !0, Re && Re(ee);
        },
        notifyBlur: (ee) => {
          const {
            onBlur: Re
          } = s;
          c.focused = !1, Re && Re(ee);
        },
        notifyKeyDown: (ee) => {
          const {
            onKeyDown: Re
          } = s;
          c.focused = !1, Re && Re(ee);
        },
        setEmptyStarFocusVisible: (ee) => {
          c.emptyStarFocusVisible = ee;
        }
      };
    }
    const b = v(), S = new RatingFoundation(b);
    function E(ee, Re) {
      return "value" in ee && ee.value !== void 0 ? {
        ...Re,
        value: ee.value
      } : Re;
    }
    watch(() => s.value, () => {
      const ee = E({
        ...o(s)
      }, {
        ...c
      });
      ee && Object.keys(ee).forEach((Re) => {
        c[Re] = ee[Re];
      });
    }), onMounted(() => {
      S.init();
    }), onUnmounted(() => {
      S.destroy();
    });
    const P = (ee, Re) => {
      S.handleHover(ee, Re);
    }, T = () => {
      S.handleMouseLeave();
    }, N = (ee, Re) => {
      S.handleClick(ee, Re);
    }, O = (ee) => {
      S.handleFocus(ee);
    }, z = (ee) => {
      S.handleBlur(ee);
    }, Q = (ee) => {
      const {
        value: Re
      } = c;
      S.handleKeyDown(ee, Re);
    }, W = (ee) => (Re) => {
      u[ee] = Re;
    }, ue = (ee) => {
      S.handleStarFocusVisible(ee);
    }, te = (ee) => {
      S.handleStarBlur(ee);
    }, K = () => {
      if (s["aria-label"])
        return s["aria-label"];
      let ee = "star";
      const {
        character: Re
      } = s;
      return typeof Re == "string" && (ee = Re), ee;
    }, ve = (ee) => {
      const {
        count: Re,
        allowHalf: wt,
        prefixCls: yt,
        disabled: xt,
        character: Kt,
        size: tn,
        tooltips: ln
      } = s, {
        value: rn,
        hoverValue: an,
        focused: Gt
      } = c;
      return [...Array(Re + 1).keys()].map((vt) => {
        const Et = createVNode(Item$3, {
          ref: (Qt) => {
            W(vt)(Qt);
          },
          index: vt,
          count: Re,
          prefixCls: `${yt}-star`,
          allowHalf: wt,
          value: an === void 0 ? rn : an,
          onClick: xt ? noop$1 : N,
          onHover: xt ? noop$1 : P,
          key: vt,
          disabled: xt,
          character: Kt,
          focused: Gt,
          size: vt === Re ? 0 : tn,
          ariaLabelPrefix: ee,
          onFocus: xt || Re !== vt ? noop$1 : ue,
          onBlur: xt || Re !== vt ? noop$1 : te
        }, null);
        if (ln) {
          const Qt = ln[vt] ? ln[vt] : "", un = an - 1 === vt;
          return createVNode(Tooltip$1, {
            visible: un,
            trigger: "custom",
            content: Qt,
            key: `${vt}-${un}`
          }, _isSlot$w(Et) ? Et : {
            default: () => [Et]
          });
        }
        return Et;
      });
    };
    return () => {
      const {
        style: ee,
        prefixCls: Re,
        disabled: wt,
        className: yt,
        id: xt,
        count: Kt,
        tabIndex: tn,
        ...ln
      } = s, {
        value: rn,
        emptyStarFocusVisible: an
      } = c, Gt = K(), nn = `Rating: ${rn} of ${Kt} ${Gt}${rn === 1 ? "" : "s"},`, vt = ve(Gt), Et = cls(Re, {
        [`${Re}-disabled`]: wt,
        [`${Re}-focus`]: an
      }, yt);
      return (
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
        createVNode("ul", mergeProps$1({
          "aria-label": nn,
          "aria-labelledby": s["aria-labelledby"],
          "aria-describedby": s["aria-describedby"],
          class: Et,
          style: ee,
          onMouseleave: wt ? noop$1 : T,
          tabindex: wt ? -1 : tn,
          onFocus: wt ? noop$1 : O,
          onBlur: wt ? noop$1 : z,
          onKeydown: wt ? noop$1 : Q,
          ref: l,
          id: xt
        }, g()), [vt])
      );
    };
  }
}), Rating$1 = Rating;
class TreeFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({
      ...o
    }), this.clearDragState = () => {
      this._adapter.updateState({
        dragOverNodeKey: "",
        dragging: !1
      });
    };
  }
  _isMultiple() {
    return this.getProp("multiple");
  }
  _isAnimated() {
    return this.getProp("motion");
  }
  _isDisabled(o = {}) {
    return this.getProp("disabled") || o.disabled;
  }
  _isExpandControlled() {
    return !lodashExports.isUndefined(this.getProp("expandedKeys"));
  }
  _isLoadControlled() {
    return !lodashExports.isUndefined(this.getProp("loadedKeys"));
  }
  _isFilterable() {
    return !!this.getProp("filterTreeNode");
  }
  _showFilteredOnly() {
    const { inputValue: o } = this.getStates(), { showFilteredOnly: l } = this.getProps();
    return !!o && l;
  }
  getTreeNodeProps(o) {
    const {
      expandedKeys: l = /* @__PURE__ */ new Set([]),
      selectedKeys: u = [],
      checkedKeys: c = /* @__PURE__ */ new Set([]),
      halfCheckedKeys: m = /* @__PURE__ */ new Set([]),
      realCheckedKeys: g = /* @__PURE__ */ new Set([]),
      keyEntities: v = {},
      filteredKeys: b = /* @__PURE__ */ new Set([]),
      inputValue: S = "",
      loadedKeys: E = /* @__PURE__ */ new Set([]),
      loadingKeys: P = /* @__PURE__ */ new Set([]),
      filteredExpandedKeys: T = /* @__PURE__ */ new Set([]),
      disabledKeys: N = /* @__PURE__ */ new Set([])
    } = this.getStates(), { treeNodeFilterProp: O, checkRelation: z } = this.getProps(), Q = v[o];
    if (!Q)
      return null;
    let ue = !1, te = !1;
    z === "related" ? (ue = c.has(o), te = m.has(o)) : z === "unRelated" && (ue = g.has(o), te = !1);
    const ve = {
      eventKey: o,
      expanded: !!S ? T.has(o) : l.has(o),
      selected: u.includes(o),
      checked: ue,
      halfChecked: te,
      pos: String(Q ? Q.pos : ""),
      level: Q.level,
      filtered: b.has(o),
      loading: P.has(o) && !E.has(o),
      loaded: E.has(o),
      keyword: S,
      treeNodeFilterProp: O
    };
    return this.getProp("disableStrictly") && N.has(o) && (ve.disabled = !0), ve;
  }
  notifyJsonChange(o, l) {
    const u = this.getProp("treeDataSimpleJson"), c = normalizedArr$1(o).map((g) => g.replace("-", ".")), m = lodashExports.pick(u, c);
    this._adapter.notifyChange(m);
  }
  constructDataForValue(o) {
    const { keyMaps: l } = this.getProps(), u = lodashExports.get(l, "key", "key"), c = lodashExports.get(l, "label", "label");
    return {
      [u]: o,
      [c]: o
    };
  }
  findDataForValue(o) {
    const { value: l, defaultValue: u, keyMaps: c } = this.getProps(), m = lodashExports.get(c, "value", "value"), g = lodashExports.get(c, "key", "key");
    let v = [];
    return l ? v = Array.isArray(l) ? l : [l] : u && (v = Array.isArray(u) ? u : [u]), v.find((b) => b[m] === o || b[g] === o);
  }
  getDataForKeyNotInKeyEntities(o) {
    const { onChangeWithObject: l } = this.getProps();
    return l ? this.findDataForValue(o) : this.constructDataForValue(o);
  }
  notifyMultipleChange(o, l) {
    const { keyEntities: u } = this.getStates(), { leafOnly: c, checkRelation: m, keyMaps: g, autoMergeValue: v } = this.getProps();
    let b, S = [];
    m === "related" ? S = v ? normalizeKeyList(o, u, c, !0) : o : m === "unRelated" && (S = o);
    const E = S.map((P) => u[P] ? u[P].data : this.getDataForKeyNotInKeyEntities(P));
    this.getProp("onChangeWithObject") ? b = E : b = getValueOrKey(E, g), this._adapter.notifyChange(b);
  }
  notifyChange(o, l) {
    const u = this._isMultiple(), { keyMaps: c } = this.getProps(), { keyEntities: m } = this.getStates();
    if (this.getProp("treeDataSimpleJson"))
      this.notifyJsonChange(o, l);
    else if (u)
      this.notifyMultipleChange(o, l);
    else {
      let g;
      if (this.getProp("onChangeWithObject"))
        g = lodashExports.get(m, o).data;
      else {
        const { data: v } = lodashExports.get(m, o);
        g = getValueOrKey(v, c);
      }
      this._adapter.notifyChange(g);
    }
  }
  handleInputChange(o) {
    this._adapter.updateInputValue(o);
    const { expandedKeys: l, selectedKeys: u, keyEntities: c, treeData: m } = this.getStates(), { showFilteredOnly: g, filterTreeNode: v, treeNodeFilterProp: b, keyMaps: S } = this.getProps(), E = b !== "label" ? b : lodashExports.get(S, "label", "label");
    let P = [], T = [], N = [], O = /* @__PURE__ */ new Set([]);
    if (!o)
      T = findAncestorKeys(u, c), T.forEach((Q) => l.add(Q)), N = flattenTreeData(m, l, S);
    else {
      P = Object.values(c).filter((W) => filter$1(o, W.data, v, E)).map((W) => W.key), T = findAncestorKeys(P, c, !1);
      const Q = findDescendantKeys(P, c, !0);
      O = /* @__PURE__ */ new Set([...Q, ...T]), N = flattenTreeData(
        m,
        new Set(T),
        S,
        g && O
      );
    }
    const z = new Set(T);
    this._adapter.notifySearch(o, Array.from(z)), this._adapter.updateState({
      expandedKeys: l,
      flattenNodes: N,
      motionKeys: /* @__PURE__ */ new Set([]),
      filteredKeys: new Set(P),
      filteredExpandedKeys: z,
      filteredShownKeys: O
    });
  }
  handleNodeSelect(o, l) {
    this._isDisabled(l) || (this._isMultiple() ? this.handleMultipleSelect(o, l) : this.handleSingleSelect(o, l));
  }
  handleNodeRightClick(o, l) {
    this._adapter.notifyRightClick(o, l.data);
  }
  handleNodeDoubleClick(o, l) {
    this._adapter.notifyDoubleClick(o, l.data);
  }
  handleSingleSelect(o, l) {
    let u = [...this.getState("selectedKeys")];
    const { selected: c, eventKey: m, data: g } = l, v = !c;
    this._adapter.notifySelect(m, !0, g), v && (u.includes(m) || (u = [m], this.notifyChange(m, o), this._isControlledComponent() || this._adapter.updateState({ selectedKeys: u })));
  }
  calcCheckedKeys(o, l) {
    const { keyEntities: u } = this.getStates(), c = new Set(this.getState("checkedKeys")), m = new Set(this.getState("halfCheckedKeys"));
    return l ? calcCheckedKeysForChecked(o, u, c, m) : calcCheckedKeysForUnchecked(o, u, c, m);
  }
  /*
  * Compute the checked state of the node
  */
  calcCheckedStatus(o, l) {
    if (!o)
      return o;
    const { checkedKeys: u, keyEntities: c, disabledKeys: m } = this.getStates(), g = normalizeKeyList(findDescendantKeys([l], c, !1), c, !0);
    return g.some((E) => m.has(E)) ? !g.filter((E) => !m.has(E)).every((E) => u.has(E)) : o;
  }
  /*
  * In strict disable mode, calculate the nodes of checked and halfCheckedKeys and return their corresponding keys
  */
  calcNonDisabledCheckedKeys(o, l) {
    const { keyEntities: u, disabledKeys: c } = this.getStates(), m = new Set(this.getState("checkedKeys")), g = normalizeKeyList(findDescendantKeys([o], u, !1), u, !0);
    if (!g.some((E) => c.has(E)))
      return this.calcCheckedKeys(o, l);
    const b = g.filter((E) => !c.has(E)), S = l ? [...b, ...m] : lodashExports.difference(normalizeKeyList([...m], u, !0, !0), b);
    return calcCheckedKeys(S, u);
  }
  /*
  * Handle the selection event in the case of multiple selection
  */
  handleMultipleSelect(o, l) {
    const { disableStrictly: u, checkRelation: c } = this.getProps(), { realCheckedKeys: m } = this.getStates(), { checked: g, eventKey: v, data: b } = l;
    if (c === "related") {
      const S = u ? this.calcCheckedStatus(!g, v) : !g, { checkedKeys: E, halfCheckedKeys: P } = u ? this.calcNonDisabledCheckedKeys(v, S) : this.calcCheckedKeys(v, S);
      this._adapter.notifySelect(v, S, b), this.notifyChange([...E], o), this._isControlledComponent() || this._adapter.updateState({ checkedKeys: E, halfCheckedKeys: P });
    } else if (c === "unRelated") {
      const S = new Set(m);
      let E;
      m.has(v) ? (S.delete(v), E = !1) : (S.add(v), E = !0), this._adapter.notifySelect(v, E, b), this.notifyChange([...S], o), this._isControlledComponent() || this._adapter.updateState({ realCheckedKeys: S });
    }
  }
  setExpandedStatus(o) {
    const { inputValue: l, treeData: u, filteredShownKeys: c, keyEntities: m } = this.getStates(), { keyMaps: g } = this.getProps(), v = !!l, b = this._showFilteredOnly(), S = v ? "filteredExpandedKeys" : "expandedKeys", E = new Set(this.getState(S));
    let P = "show";
    const { eventKey: T, expanded: N, data: O } = o;
    if (N ? E.has(T) && (E.delete(T), P = "hide") : E.add(T), this._adapter.cacheFlattenNodes(P === "hide" && this._isAnimated()), !this._isExpandControlled()) {
      const z = flattenTreeData(
        u,
        E,
        g,
        v && b && c
      ), Q = this._isAnimated() ? getMotionKeys(T, E, m) : [], W = {
        [S]: E,
        flattenNodes: z,
        motionKeys: new Set(Q),
        motionType: P
      };
      this._adapter.updateState(W);
    }
    return {
      expandedKeys: E,
      expanded: !N,
      data: O
    };
  }
  handleNodeExpand(o, l) {
    const { loadData: u } = this.getProps();
    if (!u && (!l.children || !l.children.length))
      return;
    const { expandedKeys: c, data: m, expanded: g } = this.setExpandedStatus(l);
    this._adapter.notifyExpand(c, {
      expanded: g,
      node: m
    });
  }
  handleNodeLoad(o, l, u, c) {
    const { loadData: m, onLoad: g } = this.getProps(), { key: v } = u;
    return !m || o.has(v) || l.has(v) ? {} : (m(u).then(() => {
      const b = new Set(this.getState("loadedKeys")), S = new Set(this.getState("loadingKeys")), E = b.add(v), P = /* @__PURE__ */ new Set([...S]);
      P.delete(v), g && g(E, u), this._isLoadControlled() || this._adapter.updateState({
        loadedKeys: E
      }), this._adapter.setState({
        loadingKeys: P
      }), c();
    }), {
      loadingKeys: l.add(v)
    });
  }
  // Drag and drop related processing logic
  getDragEventNodeData(o) {
    return {
      ...o.data,
      ...lodashExports.pick(o, ["expanded", "pos", "children"])
    };
  }
  triggerDragEvent(o, l, u, c = {}) {
    const m = this.getProp(o);
    m && m({
      event: l,
      node: this.getDragEventNodeData(u),
      ...c
    });
  }
  handleNodeDragStart(o, l) {
    const { keyEntities: u } = this.getStates(), { hideDraggingNode: c, renderDraggingNode: m } = this.getProps(), { eventKey: g, nodeInstance: v, data: b } = l;
    if (c || m) {
      let S;
      typeof m == "function" ? S = m(v, b) : c && (S = v.cloneNode(!0), S.style.opacity = 0), document.body.appendChild(S), o.dataTransfer.setDragImage(S, 0, 0);
    }
    this._adapter.setDragNode(l), this._adapter.updateState({
      dragging: !0,
      dragNodesKeys: new Set(getDragNodesKeys(g, u))
    }), this.triggerDragEvent("onDragStart", o, l);
  }
  handleNodeDragEnter(o, l, u) {
    const { dragging: c, dragNodesKeys: m } = this.getStates(), { autoExpandWhenDragEnter: g } = this.getProps(), { pos: v, eventKey: b, expanded: S } = l;
    if (!u || m.has(b))
      return;
    const E = calcDropRelativePosition(o, l);
    if (u.eventKey === b && E === 0) {
      this._adapter.updateState({
        dragOverNodeKey: "",
        dropPosition: null
      });
      return;
    }
    setTimeout(() => {
      if (this._adapter.updateState({
        dragOverNodeKey: b,
        dropPosition: E
      }), !g || S) {
        this.triggerDragEvent("onDragEnter", o, l);
        return;
      }
      this.delayedDragEnterLogic || (this.delayedDragEnterLogic = {}), Object.keys(this.delayedDragEnterLogic).forEach((P) => {
        clearTimeout(this.delayedDragEnterLogic[P]);
      }), this.delayedDragEnterLogic[v] = window.setTimeout(() => {
        if (!c)
          return;
        const { expandedKeys: P } = this.setExpandedStatus(l);
        this.triggerDragEvent("onDragEnter", o, l, { expandedKeys: [...P] });
      }, 400);
    }, 0);
  }
  handleNodeDragOver(o, l, u) {
    const { dropPosition: c, dragNodesKeys: m, dragOverNodeKey: g } = this.getStates(), { eventKey: v } = l;
    if (!m.has(v)) {
      if (u && v === g) {
        const b = calcDropRelativePosition(o, l);
        if (c === b)
          return;
        this._adapter.updateState({
          dropPosition: b
        });
      }
      this.triggerDragEvent("onDragOver", o, l);
    }
  }
  handleNodeDragLeave(o, l) {
    this._adapter.updateState({
      dragOverNodeKey: ""
    }), this.triggerDragEvent("onDragLeave", o, l);
  }
  handleNodeDragEnd(o, l) {
    this.clearDragState(), this.triggerDragEvent("onDragEnd", o, l), this._adapter.setDragNode(null);
  }
  handleNodeDrop(o, l, u) {
    const { dropPosition: c, dragNodesKeys: m } = this.getStates(), { eventKey: g, pos: v } = l;
    if (this.clearDragState(), m.has(g))
      return;
    const b = {
      dragNode: u ? this.getDragEventNodeData(u) : null,
      dragNodesKeys: [...m],
      dropPosition: calcDropActualPosition(v, c),
      dropToGap: c !== 0
    };
    this.triggerDragEvent("onDrop", o, l, b), this._adapter.setDragNode(null);
  }
}
const cssClasses$w = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-tree`,
  PREFIX_OPTION: `${BASE_CLASS_PREFIX$1}-tree-option`
};
function cloneDeep(s) {
  return lodashExports.cloneDeepWith(s, (o) => {
    if (lodashExports.isPlainObject(o) && !o._innerDataTag || isVNode(o))
      return o;
  });
}
const prefixcls$5 = cssClasses$w.PREFIX, propTypes$1c = {
  defaultHeight: oneOfType([number$2, string$3]),
  defaultWidth: oneOfType([number$2, string$3]),
  children: func
}, defaultProps$17 = {
  defaultHeight: "100%",
  defaultWidth: "100%"
}, vuePropsType$1_ = vuePropsMake(propTypes$1c, defaultProps$17), AutoSizer = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1_
  },
  name: "AutoSizer",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      height: s.defaultHeight || 0
    });
    onMounted(() => {
      const {
        height: u
      } = o;
    });
    const l = (u) => {
      const c = u && u[1] && u[1].target;
      if (c) {
        const m = lodashExports.get(c, "offsetHeight") || 0, g = window.getComputedStyle(c) || {}, v = parseInt(lodashExports.get(g, "paddingTop"), 10) || 0, b = parseInt(lodashExports.get(g, "paddingBottom"), 10) || 0, S = m - v - b;
        o.height !== S && (o.height = m - v - b);
      }
    };
    return () => {
      const {
        defaultWidth: u,
        defaultHeight: c
      } = s, {
        height: m
      } = o;
      let g = !1;
      return (m === 0 || typeof m != "number") && (g = !0), createVNode(ReactResizeObserver, {
        observeParent: !0,
        onResize: l
      }, {
        default: () => {
          var v;
          return [createVNode("div", {
            style: {
              height: typeof c == "number" ? c + "px" : c,
              overflow: "visible"
            },
            class: `${prefixcls$5}-auto-wrapper`
          }, [!g && ((v = s.children) == null ? void 0 : v.call(s, {
            height: m,
            width: u
          }))])];
        }
      });
    };
  }
}), vuePropsType$1Z = {
  value: Object
}, Provider$e = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    immediate: !0
  }), provide("TreeContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$1Z
  },
  name: "TreeContextProvider"
});
function useTreeContext() {
  return {
    context: inject("TreeContext", ref$1({}))
  };
}
const vuePropsType$1Y = {
  name: String
}, Consumer$f = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useTreeContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$1Y
  },
  name: "TreeContextConsumer"
}), TreeContext = {
  Provider: Provider$e,
  Consumer: Consumer$f
}, Indent = ({
  prefixcls: s,
  level: o,
  isEnd: l,
  showLine: u
}) => {
  const c = `${s}-indent-unit`, m = [];
  for (let g = 0; g < o; g += 1)
    m.push(createVNode("span", {
      key: g,
      class: cls(c, {
        [`${c}-end`]: l[g]
      })
    }, null));
  return createVNode("span", {
    "aria-hidden": "true",
    class: cls(`${s}-indent`, {
      [`${s}-indent-show-line`]: u
    })
  }, [m]);
}, prefixcls$4 = cssClasses$w.PREFIX_OPTION, propTypes$1b = {
  expanded: {
    type: bool,
    default: void 0
  },
  selected: {
    type: bool,
    default: void 0
  },
  checked: {
    type: bool,
    default: void 0
  },
  halfChecked: {
    type: bool,
    default: void 0
  },
  active: {
    type: bool,
    default: void 0
  },
  disabled: {
    type: bool,
    default: void 0
  },
  loaded: {
    type: bool,
    default: void 0
  },
  loading: {
    type: bool,
    default: void 0
  },
  isLeaf: {
    type: bool,
    default: void 0
  },
  pos: string$3,
  icon: node$1,
  directory: {
    type: bool,
    default: void 0
  },
  keyword: string$3,
  treeNodeFilterProp: string$3,
  selectedKey: string$3,
  motionKey: oneOfType([string$3, array$1]),
  isEnd: array$1,
  showLine: bool,
  eventKey: String,
  label: node$1,
  data: Object,
  children: Object,
  nodeInstance: node$1,
  emptyContent: node$1,
  filtered: [String, Boolean],
  level: Number,
  empty: Boolean,
  style: [Object, String],
  display: any$1
}, defaultProps$16 = {
  selectedKey: "",
  motionKey: ""
}, vuePropsType$1X = vuePropsMake(propTypes$1b, defaultProps$16), TreeNode = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1X
  },
  name: "TreeNode",
  setup(s, {}) {
    useSlots();
    const o = ref$1(), {
      context: l
    } = useTreeContext();
    reactive({});
    const u = (Kt) => {
      const {
        onNodeSelect: tn
      } = l.value;
      tn(Kt, s);
    }, c = lodashExports.debounce(u, 500, {
      leading: !0,
      trailing: !1
    }), m = (Kt) => {
      const {
        onNodeExpand: tn
      } = l.value;
      Kt && Kt.stopPropagation(), Kt.stopImmediatePropagation(), tn(Kt, s);
    }, g = (Kt) => {
      var ln;
      if (K())
        return;
      const {
        onNodeCheck: tn
      } = l.value;
      Kt.stopPropagation(), (ln = Kt.stopImmediatePropagation) == null || ln.call(Kt), tn(Kt, s);
    }, v = (Kt) => {
      isEnterPress(Kt) && g(Kt);
    }, b = (Kt) => {
      const {
        onNodeRightClick: tn
      } = l.value;
      tn(Kt, s);
    }, S = (Kt) => {
      const {
        expandAction: tn
      } = l.value;
      if (tn === "doubleClick") {
        c(Kt);
        return;
      }
      u(Kt), tn === "click" && m(Kt);
    }, E = (Kt) => {
      isEnterPress(Kt) && S(Kt);
    }, P = (Kt) => {
      const {
        expandAction: tn,
        onNodeDoubleClick: ln
      } = l.value;
      Kt.stopPropagation(), Kt.stopImmediatePropagation(), lodashExports.isFunction(ln) && ln(Kt, s), tn === "doubleClick" && m(Kt);
    }, T = (Kt) => {
      const {
        onNodeDragStart: tn
      } = l.value;
      Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
      try {
        Kt.dataTransfer.setData("text/plain", "");
      } catch {
      }
    }, N = (Kt) => {
      const {
        onNodeDragEnter: tn
      } = l.value;
      Kt.preventDefault(), Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
    }, O = (Kt) => {
      const {
        onNodeDragOver: tn
      } = l.value;
      Kt.preventDefault(), Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
    }, z = (Kt) => {
      const {
        onNodeDragLeave: tn
      } = l.value;
      Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
    }, Q = (Kt) => {
      const {
        onNodeDragEnd: tn
      } = l.value;
      Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
    }, W = (Kt) => {
      const {
        onNodeDrop: tn
      } = l.value;
      Kt.preventDefault(), Kt.stopPropagation(), tn(Kt, {
        ...s,
        nodeInstance: o.value
      });
    }, ue = () => {
      const {
        children: Kt
      } = s;
      return Kt || [];
    }, te = () => {
      const {
        isLeaf: Kt,
        loaded: tn
      } = s, {
        loadData: ln
      } = l.value, rn = ue().length !== 0;
      return Kt === !1 ? !1 : Kt || !ln && !rn || ln && tn && !rn;
    }, K = () => {
      const {
        disabled: Kt
      } = s, {
        treeDisabled: tn
      } = l.value;
      return Kt === !1 ? !1 : !!(tn || Kt);
    };
    function ve() {
      const Kt = !te(), {
        loading: tn,
        expanded: ln,
        showLine: rn
      } = s;
      return tn ? createVNode(Spin, {
        wrapperClassName: `${prefixcls$4}-spin-icon`
      }, null) : Kt ? createVNode(IconComponent$4, {
        role: "button",
        "aria-label": `${ln ? "Expand" : "Collapse"} the tree item`,
        className: `${prefixcls$4}-expand-icon`,
        size: "small",
        onClick: m
      }, null) : rn ? Re() : createVNode("span", {
        class: `${prefixcls$4}-empty-icon`
      }, null);
    }
    function ee() {
      const {
        checked: Kt,
        halfChecked: tn,
        eventKey: ln
      } = s, rn = K();
      return createVNode("div", {
        role: "none",
        onClick: g,
        onKeypress: v
      }, [createVNode(Checkbox$1, {
        "aria-label": "Toggle the checked state of checkbox",
        value: ln,
        indeterminate: tn,
        checked: Kt,
        disabled: !!rn
      }, null)]);
    }
    const Re = () => te() ? createVNode("span", {
      class: cls(`${prefixcls$4}-switcher`)
    }, [createVNode("span", {
      class: `${prefixcls$4}-switcher-leaf-line`
    }, null)]) : null;
    function wt() {
      const {
        directory: Kt,
        treeIcon: tn
      } = l.value, {
        expanded: ln,
        icon: rn,
        data: an
      } = s;
      return rn || (tn ? typeof tn == "function" ? tn(s) : tn : Kt ? te() ? createVNode(IconComponent$n, {
        className: `${prefixcls$4}-item-icon`
      }, null) : ln ? createVNode(IconComponent$k, {
        className: `${prefixcls$4}-item-icon`
      }, null) : createVNode(IconComponent$l, {
        className: `${prefixcls$4}-item-icon`
      }, null) : null);
    }
    function yt() {
      const {
        emptyContent: Kt
      } = s, tn = cls(prefixcls$4, {
        [`${prefixcls$4}-empty`]: !0
      });
      return createVNode("ul", {
        class: tn
      }, [createVNode("li", {
        class: `${prefixcls$4}-label ${prefixcls$4}-label-empty`,
        "x-semi-prop": "emptyContent"
      }, [Kt])]);
    }
    const xt = () => {
      const {
        renderLabel: Kt
      } = l.value, {
        label: tn,
        keyword: ln,
        data: rn,
        filtered: an,
        treeNodeFilterProp: Gt
      } = s;
      return lodashExports.isFunction(Kt) ? Kt(tn, rn) : lodashExports.isString(tn) && an && ln ? getHighLightTextHTML({
        sourceString: tn,
        searchWords: [ln],
        option: {
          highlightTag: "span",
          highlightClassName: `${prefixcls$4}-highlight`
        }
      }) : tn;
    };
    return () => {
      const {
        eventKey: Kt,
        expanded: tn,
        selected: ln,
        checked: rn,
        halfChecked: an,
        loading: Gt,
        active: nn,
        level: vt,
        empty: Et,
        filtered: Qt,
        treeNodeFilterProp: un,
        // eslint-disable-next-line no-unused-vars
        display: gn,
        style: dn,
        isEnd: yn,
        showLine: vn,
        ...Pn
      } = s;
      if (Et)
        return yt();
      const {
        multiple: On,
        draggable: _n,
        renderFullLabel: Nn,
        dragOverNodeKey: Un,
        dropPosition: Xn,
        labelEllipsis: zn
      } = l.value, jn = yn[yn.length - 1], kn = K(), Yn = Un === Kt && Xn === 0, Zn = Un === Kt && Xn === -1, er = Un === Kt && Xn === 1, bn = cls(prefixcls$4, {
        [`${prefixcls$4}-level-${vt + 1}`]: !0,
        [`${prefixcls$4}-fullLabel-level-${vt + 1}`]: Nn,
        [`${prefixcls$4}-collapsed`]: !tn,
        [`${prefixcls$4}-disabled`]: !!kn,
        [`${prefixcls$4}-selected`]: ln,
        [`${prefixcls$4}-active`]: !On && nn,
        [`${prefixcls$4}-ellipsis`]: zn,
        [`${prefixcls$4}-drag-over`]: !kn && Yn,
        [`${prefixcls$4}-draggable`]: !kn && _n && !Nn,
        // When draggable + renderFullLabel is enabled, the default style
        [`${prefixcls$4}-fullLabel-draggable`]: !kn && _n && Nn,
        // When draggable + renderFullLabel is turned on, the style of dragover
        [`${prefixcls$4}-fullLabel-drag-over-gap-top`]: !kn && Zn && Nn,
        [`${prefixcls$4}-fullLabel-drag-over-gap-bottom`]: !kn && er && Nn,
        [`${prefixcls$4}-tree-node-last-leaf`]: jn
      }), Ln = {
        onClick: S,
        onContextMenu: b,
        onDoubleClick: P,
        className: bn,
        onExpand: m,
        data: Pn.data,
        level: vt,
        onCheck: g,
        style: dn,
        expandIcon: ve(),
        checkStatus: {
          checked: rn,
          halfChecked: an
        },
        expandStatus: {
          expanded: tn,
          loading: Gt
        },
        filtered: Qt,
        searchWord: Pn.keyword
      }, Kn = {
        onDblclick: P,
        onDragstart: _n ? T : void 0,
        onDragenter: _n ? N : void 0,
        onDragover: _n ? O : void 0,
        onDragleave: _n ? z : void 0,
        onDrop: _n ? W : void 0,
        onDragend: _n ? Q : void 0,
        draggable: !kn && _n || void 0
      };
      if (Nn) {
        const Wn = Nn({
          ...Ln
        });
        return _n ? cloneElement(Wn, {
          ref: o,
          ...Kn
        }) : lodashExports.isEmpty(dn) ? Wn : cloneElement(Wn, {
          style: {
            ...lodashExports.get(Wn, ["props", "style"]),
            ...dn
          }
        });
      }
      const Bn = cls(`${prefixcls$4}-label`, {
        [`${prefixcls$4}-drag-over-gap-top`]: !kn && Zn,
        [`${prefixcls$4}-drag-over-gap-bottom`]: !kn && er
      }), Fn = lodashExports.get(Pn, ["data", "length"]), Gn = lodashExports.isString(Pn.pos) ? Number(Pn.pos.split("-")[vt + 1]) + 1 : 1;
      return createVNode("li", mergeProps$1({
        class: bn,
        role: "treeitem",
        "aria-disabled": kn,
        "aria-checked": rn,
        "aria-selected": ln,
        "aria-setsize": Fn,
        "aria-posinset": Gn,
        "aria-expanded": tn,
        "aria-level": vt + 1,
        "data-key": Kt,
        ref: o,
        style: dn
      }, {
        onClick: S,
        onKeypress: E,
        onContextmenu: b,
        onDblclick: P,
        ...Kn
      }), [createVNode(Indent, {
        showLine: vn,
        prefixcls: prefixcls$4,
        level: vt,
        isEnd: yn
      }, null), ve(), createVNode("span", {
        class: Bn
      }, [On ? ee() : null, wt(), createVNode("span", {
        class: `${prefixcls$4}-label-text`
      }, [xt()])])]);
    };
  }
}), TreeNode$1 = TreeNode;
function noop() {
}
const vuePropsType$1W = {
  onStart: {
    type: Function,
    default: noop
  },
  onFrame: {
    type: Function,
    default: noop
  },
  onPause: {
    type: Function,
    default: noop
  },
  onResume: {
    type: Function,
    default: noop
  },
  onStop: {
    type: Function,
    default: noop
  },
  onRest: {
    type: Function,
    default: noop
  },
  from: Object,
  to: Object,
  reverse: Boolean,
  reset: Boolean,
  force: {
    type: Boolean,
    default: !1
  },
  config: Object,
  autoStart: {
    type: Boolean,
    default: !0
  },
  forwardInstance: Function,
  immediate: Boolean,
  enter: Object,
  leave: Object,
  state: [String, Boolean],
  willEnter: {
    type: Function,
    default: noop
  },
  didEnter: {
    type: Function,
    default: noop
  },
  willLeave: {
    type: Function,
    default: noop
  },
  didLeave: {
    type: Function,
    default: noop
  }
}, Index = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  let l = !1, u = !1;
  const c = shallowRef(null);
  let m, g, v;
  const b = reactive({
    currentStyle: {}
  });
  let S = function() {
    throw new Error("Method not implemented.");
  };
  E(), P(), onMounted(() => {
    l = !0;
    const {
      forwardInstance: T
    } = s;
    c.value === null && (E(), P()), typeof T == "function" && T(c.value), S();
  }), onBeforeUnmount(() => {
    l = !1, c.value && (c.value.destroy(), c.value = null);
  }), watch([() => s.from, () => s.to, () => s.reset, () => s.force], (T, [N, O]) => {
    s.reset && (s.from !== N || s.to !== O) && (m(), E(), S()), s.force && s.to !== O && (E({
      ...s,
      from: O
    }), S());
  });
  function E(T) {
    T = T ?? s;
    let {
      from: N,
      to: O,
      config: z,
      reverse: Q
    } = T;
    Q && ([N, O] = [O, N]), c.value = new Animation({
      from: {
        ...N
      },
      to: {
        ...O
      }
    }, {
      ...z
    }), events.forEach((W) => {
      const ue = `on${W[0].toUpperCase() + W.slice(1)}`;
      c.value.on(W, (te) => {
        l && !u && (b.currentStyle = {
          ...te
        }, s[ue](te));
      });
    }), u = !1;
  }
  function P() {
    S = () => {
      const {
        immediate: T,
        autoStart: N
      } = s;
      T ? g() : N && v();
    }, v = () => {
      c.value && c.value.start();
    }, g = () => {
      c.value && c.value.end();
    }, m = () => {
      u = !0, c.value && c.value.destroy();
    };
  }
  return () => {
    const T = o.default, N = {};
    return Object.keys(b.currentStyle).forEach((O) => {
      ["height", "width", "left", "right", "top", "bottom", "maxHeight", "minHeight", "maxWidth", "minWidth"].includes(O) ? typeof b.currentStyle[O] == "number" && (N[O] = b.currentStyle[O] + "px") : N[O] = b.currentStyle[O];
    }), typeof T == "function" && c.value ? T(N) : isVNode(T) ? T : null;
  };
}, {
  props: vuePropsType$1W,
  name: "Animation"
}), vuePropsType$1V = {
  children: [Object, Function],
  from: Object,
  enter: Object,
  leave: Object,
  state: {
    type: [String, Boolean],
    // @ts-ignore
    default: void 0
  },
  willEnter: {
    type: Function,
    default: noop
  },
  didEnter: {
    type: Function,
    default: noop
  },
  willLeave: {
    type: Function,
    default: noop
  },
  didLeave: {
    type: Function,
    default: noop
  },
  onRest: {
    type: Function,
    default: noop
  },
  onStart: {
    type: Function,
    default: noop
  }
}, Transition = /* @__PURE__ */ defineComponent((s, {}) => {
  const o = useSlots();
  onActivated(() => {
  });
  const l = reactive({
    state: "",
    lastChildren: null,
    currentChildren: null
  });
  function u(b, S) {
    const E = {}, P = b.children || o.default;
    return P !== S.currentChildren && (E.lastChildren = S.currentChildren, E.currentChildren = P, P == null ? E.state = "leave" : E.state = "enter"), b.state != null && (E.state = b.state), E;
  }
  function c() {
    const b = u({
      ...s
    }, {
      ...l
    });
    Object.keys(b).forEach((S) => {
      l[S] = b[S];
    });
  }
  watch(() => s.children, () => {
    c();
  }, {
    immediate: !0
  }), watch(() => s.state, () => {
    c();
  }, {
    immediate: !0
  }), onBeforeUnmount(() => {
  });
  const m = () => [!0, !1, "enter", "leave"].includes(s.state), g = (b) => {
    l.state === "enter" ? s.didEnter(b) : l.state === "leave" && (l.currentChildren = null, l.lastChildren = null, s.didLeave(b)), s.onRest(b);
  }, v = (b) => {
    l.state === "enter" ? s.willEnter(b) : l.state === "leave" && s.willLeave(b), s.onStart(b);
  };
  return () => {
    const {
      from: b,
      enter: S,
      leave: E,
      children: P,
      ...T
    } = s;
    let N = {}, O = {};
    const z = m();
    let Q;
    if (z)
      Q = s.children || o.default, l.state = s.state;
    else if (l.currentChildren == null && l.lastChildren == null)
      return console.log("transition: no children"), null;
    l.state === "enter" ? (N = b, O = S, z || (Q = l.currentChildren)) : l.state === "leave" && (N = S, O = E, z || (Q = l.lastChildren));
    const W = {
      ...T,
      onRest: g,
      onStart: v,
      from: N,
      to: O
    };
    return createVNode(Index, mergeProps$1(W, {
      force: !0
    }), {
      default: (ue) => typeof Q == "function" ? Q(ue) : isVNode(Q) ? Q : null
    });
  };
}, {
  props: vuePropsType$1V,
  name: "Transition"
}), cssClasses$v = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-collapsible`
};
function getMotionObjFromProps(s) {
  if (typeof s != "object" || s === null)
    throw new TypeError(`props should be object type, got ${typeof s}`);
  const o = ["willEnter", "didEnter", "willLeave", "didLeave", "onStart", "onRest", "state"], { motion: l = {} } = s;
  let u = {};
  if (lodashExports.isObject(l)) {
    u = index$b(l);
    for (const c of Object.keys(l)) {
      const m = l[c];
      typeof m == "function" ? c in s && (u[c] = () => {
        s[c](), m();
      }) : warning$1(!0, `[Semi] duplicate motion key '${c}' from motion prop and props`);
    }
  } else if (typeof l == "function") {
    const c = l(s);
    u = lodashExports.isObject(c) ? c : {};
  }
  if (lodashExports.isObject(u))
    for (const c of o)
      c in s && !(c in u) && (u[c] = s[c]);
  return u;
}
const ease = "cubicBezier(.25,.1,.25,1)", propsType = {
  motion: oneOfType([bool, func, object$1]),
  duration: number$2,
  onMotionEnd: func,
  motionType: String
}, vuePropsType$1U = vuePropsMake(propsType, {
  duration: 250,
  motion: !0,
  onMotionEnd: lodashExports.noop
}), Collapse$2 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1U
  },
  name: "Collapse",
  setup(s, {}) {
    const o = useSlots(), l = ref$1(), u = ref$1(0);
    function c(K) {
      u.value = K;
    }
    const m = ref$1(!0);
    function g(K) {
      m.value = K;
    }
    const v = ref$1(!1);
    function b(K) {
      v.value = K;
    }
    const S = ref$1(!1);
    function E(K) {
      S.value = K;
    }
    watch(() => s.motionType, () => {
      P();
    });
    function P() {
      s.motionType === "enter" ? (!m.value && g(!0), v.value && b(!1)) : s.motionType === "leave" && (!m.value && g(!0), !S.value && E(!0), v.value && b(!1));
    }
    let T = "";
    const N = (K) => {
      s.motionType !== T && (P(), T = s.motionType), nextTick(() => {
        const ve = K && K.scrollHeight;
        ve && u.value !== ve && c(ve);
      });
    }, O = () => {
      l.value.style.maxHeight = "none";
    }, z = (K) => {
      const {
        maxHeight: ve
      } = K;
      return {
        maxHeight: ve
      };
    }, Q = (K) => {
      var wt;
      const ve = K && typeof K == "object" ? z(K) : {}, ee = {
        overflow: "hidden",
        maxHeight: m.value ? "none" : 0,
        ...ve
      }, Re = (wt = o.default) == null ? void 0 : wt.call(o);
      return createVNode("div", {
        style: ee,
        class: `${cssClasses$v.PREFIX}-wrapper`,
        ref: l
      }, [createVNode("div", {
        ref: N
      }, [Re])]);
    }, W = () => {
      b(!0), c(0), s.motionType === "leave" && s.onMotionEnd();
    }, ue = () => {
      m.value && g(!1), E(!1);
    }, te = () => {
      O(), S.value && ue(), s.motionType === "enter" && s.onMotionEnd();
    };
    return () => {
      if (v.value)
        return null;
      const K = getMotionObjFromProps({
        didEnter: te,
        didLeave: W,
        motion: s.motion
      });
      return s.motion ? createVNode(Transition, mergeProps$1({
        state: m.value ? "enter" : "leave",
        immediate: S.value,
        from: {
          maxHeight: 0
        },
        enter: {
          maxHeight: {
            val: u.value,
            easing: ease,
            duration: s.duration
          }
        },
        leave: {
          maxHeight: {
            val: 0,
            easing: ease,
            duration: s.duration
          }
        }
      }, K), {
        default: (ve) => Q(ve)
      }) : Q(null);
    };
  }
});
function _isSlot$v(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const getTreeNodeKey = (s) => s.key, vuePropsType$1T = {
  flattenNodes: {
    type: Array,
    required: !0
  },
  motionKeys: {
    type: Object,
    required: !0
  },
  motionType: {
    type: String,
    required: !1
  },
  flattenList: {
    type: Array,
    required: !1
  },
  searchTargetIsDeep: Boolean,
  renderTreeNode: {
    type: Function,
    required: !0
  },
  onMotionEnd: {
    type: Function,
    required: !1
  },
  role: String
}, NodeList = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1T
  },
  name: "NodeList",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      transitionNodes: []
    });
    function l(c) {
      const {
        flattenNodes: m = [],
        motionKeys: g,
        motionType: v,
        flattenList: b = []
      } = c, S = !lodashExports.isEqual(o.cachedMotionKeys, g) || !lodashExports.isEqual(o.cachedData.map((Q) => Q.key), m.map((Q) => Q.key)), E = [...g];
      if (!S || !E.length)
        return null;
      const P = [], T = [];
      let N = 0, O = {};
      return (v === "hide" && b ? b : m).forEach((Q, W) => {
        const ue = getTreeNodeKey(Q);
        g.has(ue) ? (T.push(Q), ue === E[0] && (N = W)) : P.push(Q);
      }), P.splice(N, 0, T), O = {
        transitionNodes: P,
        cachedData: m,
        cachedMotionKeys: g,
        cachedMotionType: v
      }, O;
    }
    watch([() => s.flattenNodes, () => s.motionKeys, () => s.motionType, () => s.flattenList], () => {
      const c = l({
        ...s
      });
      c && Object.keys(c).forEach((m) => {
        o[m] = c[m];
      });
    }, {
      immediate: !0
    });
    const u = () => {
      typeof s.onMotionEnd == "function" && s.onMotionEnd(), o.transitionNodes = [];
    };
    return () => {
      const {
        flattenNodes: c,
        motionType: m,
        searchTargetIsDeep: g,
        renderTreeNode: v
      } = s, {
        transitionNodes: b
      } = o;
      return /*@ts-ignore*/ (b.length && !g ? b : c).map((P) => {
        const T = Array.isArray(P);
        if (T && !P.length)
          return null;
        if (T && P.length) {
          let N;
          const O = getTreeNodeKey(P[0]);
          return createVNode(Collapse$2, {
            motionType: m === "show" ? "enter" : "leave",
            key: `motion-${O}`,
            onMotionEnd: u,
            motion: !!m
          }, _isSlot$v(N = P.map((z) => v(z))) ? N : {
            default: () => [N]
          });
        }
        return v(P);
      });
    };
  }
});
function _isSlot$u(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$3 = cssClasses$w.PREFIX, propTypes$1a = {
  autoMergeValue: bool,
  blockNode: bool,
  className: string$3,
  showClear: bool,
  defaultExpandAll: bool,
  defaultExpandedKeys: array$1,
  defaultValue: oneOfType([string$3, array$1]),
  directory: bool,
  disabled: bool,
  emptyContent: node$1,
  expandAll: bool,
  expandedKeys: array$1,
  filterTreeNode: oneOfType([func, bool]),
  icon: [object$1, func],
  onChangeWithObject: bool,
  motion: bool,
  multiple: bool,
  onChange: func,
  onExpand: func,
  onSearch: func,
  onSelect: func,
  onContextMenu: func,
  onDoubleClick: func,
  searchClassName: string$3,
  searchPlaceholder: string$3,
  searchStyle: object$1,
  selectedKey: string$3,
  showFilteredOnly: bool,
  showLine: bool,
  style: object$1,
  treeData: array$1,
  keyMaps: object$1,
  treeDataSimpleJson: object$1,
  treeNodeFilterProp: string$3,
  value: oneOfType([string$3, number$2, array$1, object$1]),
  virtualize: object$1,
  autoExpandParent: bool,
  expandAction: [String, Boolean],
  searchRender: oneOfType([func, bool]),
  renderLabel: func,
  renderFullLabel: func,
  leafOnly: bool,
  loadedKeys: array$1,
  loadData: func,
  onLoad: func,
  disableStrictly: bool,
  draggable: bool,
  autoExpandWhenDragEnter: bool,
  hideDraggingNode: bool,
  renderDraggingNode: func,
  onDragEnd: func,
  onDragEnter: func,
  onDragLeave: func,
  onDragOver: func,
  onDragStart: func,
  onDrop: func,
  labelEllipsis: bool,
  checkRelation: string$3,
  "aria-label": string$3,
  preventScroll: bool,
  role: string$3
}, defaultProps$15 = {
  showClear: !0,
  disabled: !1,
  blockNode: !0,
  multiple: !1,
  filterTreeNode: !1,
  autoExpandParent: !1,
  treeNodeFilterProp: "label",
  defaultExpandAll: !1,
  expandAll: !1,
  onChangeWithObject: !1,
  motion: !0,
  leafOnly: !1,
  showFilteredOnly: !1,
  showLine: !1,
  expandAction: !1,
  disableStrictly: !1,
  draggable: !1,
  autoExpandWhenDragEnter: !0,
  checkRelation: "related",
  autoMergeValue: !0
}, vuePropsType$1S = vuePropsMake(propTypes$1a, defaultProps$15), Tree = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1S
  },
  name: "Tree",
  setup(s, {}) {
    useSlots();
    let o, l;
    const {
      context: u
    } = useConfigContext(), c = reactive({
      inputValue: "",
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      selectedKeys: [],
      checkedKeys: /* @__PURE__ */ new Set(),
      halfCheckedKeys: /* @__PURE__ */ new Set(),
      realCheckedKeys: /* @__PURE__ */ new Set([]),
      motionKeys: /* @__PURE__ */ new Set([]),
      motionType: "hide",
      expandedKeys: new Set(s.expandedKeys),
      filteredKeys: /* @__PURE__ */ new Set(),
      filteredExpandedKeys: /* @__PURE__ */ new Set(),
      filteredShownKeys: /* @__PURE__ */ new Set(),
      prevProps: null,
      loadedKeys: /* @__PURE__ */ new Set(),
      loadingKeys: /* @__PURE__ */ new Set(),
      cachedFlattenNodes: void 0,
      cachedKeyValuePairs: {},
      disabledKeys: /* @__PURE__ */ new Set(),
      dragging: !1,
      dragNodesKeys: /* @__PURE__ */ new Set(),
      dragOverNodeKey: null,
      dropPosition: null
    }), m = ref$1();
    ref$1();
    const g = ref$1(), v = ref$1(), {
      adapter: b,
      getDataAttr: S
    } = useBaseComponent(s, c);
    function E() {
      const nn = {
        updateInputValue: (vt) => {
          c.inputValue = vt;
        },
        focusInput: () => {
          const {
            preventScroll: vt
          } = s;
          m.value && m.value.focus({
            preventScroll: vt
          });
        }
      };
      return {
        ...b(),
        ...nn,
        updateState: (vt) => {
          Object.keys(vt).forEach((Et) => {
            c[Et] = vt[Et];
          });
        },
        notifyExpand: (vt, {
          expanded: Et,
          node: Qt
        }) => {
          s.onExpand && s.onExpand([...vt], {
            expanded: Et,
            node: Qt
          }), Et && s.loadData && ue(Qt);
        },
        notifySelect: (vt, Et, Qt) => {
          s.onSelect && s.onSelect(vt, Et, Qt);
        },
        notifyChange: (vt) => {
          s.onChange && s.onChange(vt);
        },
        notifySearch: (vt, Et) => {
          s.onSearch && s.onSearch(vt, Et);
        },
        notifyRightClick: (vt, Et) => {
          s.onContextMenu && s.onContextMenu(vt, Et);
        },
        notifyDoubleClick: (vt, Et) => {
          s.onDoubleClick && s.onDoubleClick(vt, Et);
        },
        cacheFlattenNodes: (vt) => {
          c.cachedFlattenNodes = vt ? cloneDeep(c.flattenNodes) : void 0;
        },
        setDragNode: (vt) => {
          g.value = vt;
        }
      };
    }
    const P = E(), T = new TreeFoundation(P);
    function N(nn, vt) {
      var Yn;
      const {
        prevProps: Et
      } = vt, {
        keyMaps: Qt
      } = nn;
      let un, gn = vt.keyEntities || {}, dn = vt.cachedKeyValuePairs || {};
      const yn = !!(nn.filterTreeNode && vt.inputValue && vt.inputValue.length), vn = {
        prevProps: nn
      }, Pn = "expandedKeys" in nn, On = (Zn) => {
        const er = !Et && Zn in nn, bn = Et && !lodashExports.isEqual(Et[Zn], nn[Zn]);
        return er || bn;
      }, _n = () => {
        const Zn = !Et && "treeData" in nn, er = Et && Et.treeData !== nn.treeData;
        return Zn || er;
      }, Nn = On("treeData"), Un = On("treeDataSimpleJson");
      if (Nn || nn.draggable && _n()) {
        un = nn.treeData, vn.treeData = un;
        const Zn = convertDataToEntities$1(un, Qt);
        vn.keyEntities = {
          ...Zn.keyEntities
        }, gn = vn.keyEntities, vn.cachedKeyValuePairs = {
          ...Zn.valueEntities
        }, dn = vn.cachedKeyValuePairs;
      } else if (Un) {
        un = convertJsonToData(nn.treeDataSimpleJson), vn.treeData = un;
        const Zn = convertDataToEntities$1(un, Qt);
        vn.keyEntities = {
          ...Zn.keyEntities
        }, gn = vn.keyEntities, vn.cachedKeyValuePairs = {
          ...Zn.valueEntities
        }, dn = vn.cachedKeyValuePairs;
      }
      un && nn.motion && Et && nn.motion && (vn.motionKeys = /* @__PURE__ */ new Set([]), vn.motionType = null);
      const Xn = Un || Nn, zn = Xn && nn.expandAll;
      if (yn) {
        let Zn;
        if (un && (Zn = filterTreeData({
          treeData: un,
          inputValue: vt.inputValue,
          filterTreeNode: nn.filterTreeNode,
          filterProps: nn.treeNodeFilterProp,
          showFilteredOnly: nn.showFilteredOnly,
          keyEntities: vn.keyEntities,
          prevExpandedKeys: [...vt.filteredExpandedKeys],
          keyMaps: Qt
        }), vn.flattenNodes = Zn.flattenNodes, vn.motionKeys = /* @__PURE__ */ new Set([]), vn.filteredKeys = Zn.filteredKeys, vn.filteredShownKeys = Zn.filteredShownKeys, vn.filteredExpandedKeys = Zn.filteredExpandedKeys), nn.expandedKeys) {
          if (vn.filteredExpandedKeys = calcExpandedKeys(nn.expandedKeys, gn, nn.autoExpandParent || !Et), Et && nn.motion) {
            const er = vt ? vt.filteredExpandedKeys : /* @__PURE__ */ new Set([]);
            if (!un) {
              const bn = calcMotionKeys(er, vn.filteredExpandedKeys, gn);
              let {
                motionKeys: Ln
              } = bn;
              const {
                motionType: Kn
              } = bn;
              nn.showFilteredOnly && (Ln = Ln.filter((Bn) => vt.filteredShownKeys.has(Bn))), Kn === "hide" && (vn.cachedFlattenNodes = cloneDeep(vt.flattenNodes)), vn.motionKeys = new Set(Ln), vn.motionType = Kn;
            }
          }
          vn.flattenNodes = flattenTreeData(un || vt.treeData, vn.filteredExpandedKeys || vt.filteredExpandedKeys, Qt, nn.showFilteredOnly && vt.filteredShownKeys);
        }
      } else {
        if (On("expandedKeys") || Et && On("autoExpandParent")) {
          if (vn.expandedKeys = calcExpandedKeys(nn.expandedKeys, gn, nn.autoExpandParent || !Et), Et && nn.motion && !un) {
            const {
              motionKeys: Zn,
              motionType: er
            } = calcMotionKeys(vt.expandedKeys, vn.expandedKeys, gn);
            vn.motionKeys = new Set(Zn), vn.motionType = er, er === "hide" && (vn.cachedFlattenNodes = cloneDeep(vt.flattenNodes));
          }
        } else !Et && (nn.defaultExpandAll || nn.expandAll) || zn ? vn.expandedKeys = new Set(Object.keys(gn)) : !Et && nn.defaultExpandedKeys ? vn.expandedKeys = calcExpandedKeys(nn.defaultExpandedKeys, gn) : !Et && nn.defaultValue ? vn.expandedKeys = calcExpandedKeysForValues(nn.defaultValue, gn, nn.multiple, dn) : !Et && nn.value ? vn.expandedKeys = calcExpandedKeysForValues(nn.value, gn, nn.multiple, dn) : !Pn && Xn && nn.value && (vt.treeData && ((Yn = vt.treeData) == null ? void 0 : Yn.length) > 0 && nn.loadData || (vn.expandedKeys = calcExpandedKeysForValues(nn.value, gn, nn.multiple, dn)));
        if (vn.expandedKeys || delete vn.expandedKeys, un || vn.expandedKeys) {
          const Zn = flattenTreeData(un || vt.treeData, vn.expandedKeys || vt.expandedKeys, Qt);
          vn.flattenNodes = Zn;
        }
      }
      const jn = nn.onChangeWithObject, kn = nn.multiple;
      if (!kn)
        On("value") ? vn.selectedKeys = findKeysForValues(
          // In both cases whether withObject is turned on, the value is standardized to string
          normalizeValue(nn.value, jn, Qt),
          dn,
          kn
        ) : !Et && nn.defaultValue ? vn.selectedKeys = findKeysForValues(normalizeValue(nn.defaultValue, jn, Qt), dn, kn) : un && nn.value && (vn.selectedKeys = findKeysForValues(normalizeValue(nn.value, jn, Qt) || "", dn, kn));
      else {
        let Zn;
        if (On("value") ? Zn = findKeysForValues(normalizeValue(nn.value, jn, Qt), dn, kn) : !Et && nn.defaultValue ? Zn = findKeysForValues(normalizeValue(nn.defaultValue, jn, Qt), dn, kn) : un && (nn.value ? Zn = findKeysForValues(normalizeValue(nn.value, jn, Qt) || [], dn, kn) : Zn = updateKeys(nn.checkRelation === "related" ? vt.checkedKeys : vt.realCheckedKeys, gn)), Zn) {
          if (nn.checkRelation === "unRelated")
            vn.realCheckedKeys = new Set(Zn);
          else if (nn.checkRelation === "related") {
            const {
              checkedKeys: er,
              halfCheckedKeys: bn
            } = calcCheckedKeys(Zn, gn);
            vn.checkedKeys = er, vn.halfCheckedKeys = bn;
          }
        }
      }
      return On("loadedKeys") && (vn.loadedKeys = new Set(nn.loadedKeys)), un && nn.disableStrictly && nn.checkRelation === "related" && (vn.disabledKeys = calcDisabledKeys(gn, Qt)), vn;
    }
    watch([() => s.filterTreeNode, () => s.treeData, () => s.draggable, () => s.treeDataSimpleJson, () => s.motion, () => s.expandAll, () => s.autoExpandParent, () => s.defaultExpandAll, () => s.defaultExpandedKeys, () => s.multiple, () => s.value, () => s.treeNodeFilterProp, () => s.showFilteredOnly, () => s.onChangeWithObject, () => s.defaultValue, () => s.loadedKeys, () => s.disableStrictly, () => s.checkRelation, () => c.keyEntities, () => c.cachedKeyValuePairs, () => c.inputValue, () => c.expandedKeys, () => c.flattenNodes, () => c.treeData, () => c.filteredExpandedKeys, () => c.filteredShownKeys, () => c.checkedKeys], (nn, vt, Et) => {
      const Qt = N({
        ...s
      }, {
        ...c
      });
      Qt && Object.keys(Qt).forEach((un) => {
        c[un] = Qt[un];
      });
    }, {
      immediate: !0
    });
    const O = (nn) => {
      T.handleInputChange(nn);
    };
    function z() {
      const {
        searchClassName: nn,
        searchStyle: vt,
        searchRender: Et,
        searchPlaceholder: Qt,
        showClear: un
      } = s, gn = cls(`${prefixcls$3}-input`), {
        inputValue: dn
      } = c, yn = {
        value: dn,
        className: gn,
        onChange: (Pn) => O(Pn),
        prefix: createVNode(IconComponent$9, null, null),
        showClear: un,
        placeholder: Qt
      }, vn = cls(`${prefixcls$3}-search-wrapper`, nn);
      return createVNode("div", {
        class: vn,
        style: vt
      }, [createVNode(LocaleConsumer$6, {
        componentName: "Tree"
      }, {
        default: (Pn) => (yn.placeholder = Qt || lodashExports.get(Pn, "searchPlaceholder"), lodashExports.isFunction(Et) ? Et({
          ...yn
        }) : Et === !1 ? null : createVNode(Input$1, mergeProps$1({
          "aria-label": "Filter Tree",
          ref: m
        }, yn), null))
      })]);
    }
    const Q = () => {
      const {
        emptyContent: nn
      } = s;
      return nn ? createVNode(TreeNode$1, {
        key: "empty_tree",
        empty: !0,
        emptyContent: s.emptyContent
      }, null) : createVNode(LocaleConsumer$6, {
        componentName: "Tree"
      }, {
        default: (vt) => createVNode(TreeNode$1, {
          key: "empty_tree",
          empty: !0,
          emptyContent: lodashExports.get(vt, "emptyText")
        }, null)
      });
    }, W = (nn, vt) => {
      T.handleNodeSelect(nn, vt);
    }, ue = (nn) => new Promise((vt) => {
      const {
        loadingKeys: Et
      } = T.handleNodeLoad(c.loadedKeys || /* @__PURE__ */ new Set([]), c.loadingKeys || /* @__PURE__ */ new Set([]), nn, vt);
      c.loadingKeys = Et;
    }), te = (nn, vt) => {
      T.handleNodeSelect(nn, vt);
    }, K = (nn, vt) => {
      T.handleNodeExpand(nn, vt);
    }, ve = (nn, vt) => {
      T.handleNodeRightClick(nn, vt);
    }, ee = (nn, vt) => {
      T.handleNodeDoubleClick(nn, vt);
    }, Re = (nn, vt) => {
      T.handleNodeDragStart(nn, vt);
    }, wt = (nn, vt) => {
      T.handleNodeDragEnter(nn, vt, g);
    }, yt = (nn, vt) => {
      T.handleNodeDragOver(nn, vt, g);
    }, xt = (nn, vt) => {
      T.handleNodeDragLeave(nn, vt);
    }, Kt = (nn, vt) => {
      T.handleNodeDragEnd(nn, vt);
    }, tn = (nn, vt) => {
      T.handleNodeDrop(nn, vt, g);
    }, ln = (nn, vt, Et) => {
      const {
        data: Qt,
        key: un
      } = nn, gn = T.getTreeNodeProps(un);
      if (!gn)
        return null;
      const {
        keyMaps: dn,
        showLine: yn
      } = s, vn = lodashExports.pick(nn, ["key", "label", "disabled", "isLeaf", "icon", "isEnd"]), Pn = Qt[lodashExports.get(dn, "children", "children")];
      return !lodashExports.isUndefined(Pn) && (vn.children = Pn), createVNode(TreeNode$1, mergeProps$1(gn, Qt, vn, {
        showLine: yn,
        data: Qt,
        style: lodashExports.isEmpty(Et) ? {} : Et
      }), null);
    }, rn = (nn, vt) => vt[nn].key, an = ({
      index: nn,
      style: vt,
      data: Et
    }) => ln(Et[nn], nn, vt);
    function Gt() {
      const {
        flattenNodes: nn,
        cachedFlattenNodes: vt,
        motionKeys: Et,
        motionType: Qt
      } = c, {
        virtualize: un,
        motion: gn
      } = s, {
        direction: dn
      } = u.value;
      if (!lodashExports.isEmpty(nn))
        return !un || lodashExports.isEmpty(un) ? createVNode(Fragment, null, [createVNode(NodeList, {
          flattenNodes: nn,
          flattenList: vt,
          motionKeys: gn ? Et : /* @__PURE__ */ new Set([]),
          motionType: Qt,
          onMotionEnd: l,
          renderTreeNode: ln
        }, null)]) : createVNode(AutoSizer, {
          defaultHeight: un.height,
          defaultWidth: un.width,
          children: ({
            height: yn,
            width: vn
          }) => createVNode(Jt$1, {
            ref: v,
            itemCount: nn.length,
            itemSize: un.itemSize,
            height: parseInt("" + yn),
            width: vn,
            itemKey: rn,
            itemData: nn,
            className: `${prefixcls$3}-virtual-list`,
            style: {
              direction: dn
            }
          }, _isSlot$u(an) ? an : {
            default: () => [an]
          })
        }, null);
    }
    return () => {
      let nn;
      const {
        keyEntities: vt,
        motionKeys: Et,
        motionType: Qt,
        inputValue: un,
        filteredKeys: gn,
        dragOverNodeKey: dn,
        dropPosition: yn,
        checkedKeys: vn,
        realCheckedKeys: Pn
      } = c, {
        blockNode: On,
        className: _n,
        style: Nn,
        filterTreeNode: Un,
        disabled: Xn,
        icon: zn,
        directory: jn,
        multiple: kn,
        showFilteredOnly: Yn,
        showLine: Zn,
        motion: er,
        expandAction: bn,
        loadData: Ln,
        renderLabel: Kn,
        draggable: Bn,
        renderFullLabel: Fn,
        labelEllipsis: Gn,
        virtualize: Wn,
        checkRelation: Mn
      } = s, Tn = cls(`${prefixcls$3}-wrapper`, _n), Rn = cls(`${prefixcls$3}-option-list`, {
        [`${prefixcls$3}-option-list-block`]: On
      }), hn = !!un && !gn.size, Qn = lodashExports.isEmpty(vt) || Yn && hn, rr = {
        role: Qn ? "none" : "tree"
      };
      return rr.role === "tree" && (rr["aria-multiselectable"] = !!kn), createVNode(TreeContext.Provider, {
        value: {
          treeDisabled: Xn,
          treeIcon: zn,
          motion: er,
          motionKeys: Et,
          motionType: Qt,
          filterTreeNode: Un,
          keyEntities: vt,
          onNodeClick: o,
          onNodeExpand: K,
          onNodeSelect: W,
          onNodeCheck: te,
          onNodeRightClick: ve,
          onNodeDoubleClick: ee,
          renderTreeNode: ln,
          onNodeDragStart: Re,
          onNodeDragEnter: wt,
          onNodeDragOver: yt,
          onNodeDragLeave: xt,
          onNodeDragEnd: Kt,
          onNodeDrop: tn,
          expandAction: bn,
          directory: jn,
          multiple: kn,
          showFilteredOnly: Yn,
          isSearching: !!un,
          loadData: Ln,
          onNodeLoad: ue,
          renderLabel: Kn,
          draggable: Bn,
          renderFullLabel: Fn,
          dragOverNodeKey: dn,
          dropPosition: yn,
          labelEllipsis: typeof Gn > "u" ? Wn : Gn
        }
      }, {
        default: () => [createVNode("div", mergeProps$1({
          "aria-label": s["aria-label"],
          class: Tn,
          style: Nn
        }, S()), [Un ? z() : null, createVNode("div", mergeProps$1({
          class: Rn
        }, rr), [Qn ? Q() : kn ? createVNode(CheckboxGroup$1, {
          value: Array.from(Mn === "related" ? vn : Pn)
        }, _isSlot$u(nn = Gt()) ? nn : {
          default: () => [nn]
        }) : Gt()])])]
      });
    };
  }
}), Tree$1 = Tree, cssClasses$u = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-tree-select`,
  PREFIX_TREE: `${BASE_CLASS_PREFIX$1}-tree`,
  PREFIX_OPTION: `${BASE_CLASS_PREFIX$1}-tree-select-option`
}, strings$8 = {
  SIZE_SET: ["small", "large", "default"],
  SEARCH_POSITION_DROPDOWN: "dropdown",
  SEARCH_POSITION_TRIGGER: "trigger",
  STATUS: VALIDATE_STATUS
};
class TreeSelectFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleKeyDown = (l) => {
      l.key === ESC_KEY && this.getState("isOpen") && this.close(l);
    }, this._registerClickOutsideHandler = () => {
      this._adapter.registerClickOutsideHandler((l) => {
        this.handlerTriggerBlur(l), this.close(l);
      });
    }, this.clearInputValue = () => {
      const { inputValue: l } = this.getStates();
      l && this._adapter.updateInputValue("");
    }, this.onClickSingleTriggerSearchItem = (l) => {
      this.focusInput(!0);
    };
  }
  init() {
    const { searchAutoFocus: o, searchPosition: l, filterTreeNode: u } = this.getProps(), c = l === strings$8.SEARCH_POSITION_TRIGGER && u, m = o && c;
    this._setDropdownWidth();
    const g = !this._isDisabled();
    (this.getProp("defaultOpen") || m) && g && (this.open(), this._registerClickOutsideHandler()), m && g && this.handleTriggerFocus(null);
  }
  destroy() {
    this._adapter.unregisterClickOutsideHandler();
  }
  _setDropdownWidth() {
    const { style: o, dropdownMatchSelectWidth: l } = this.getProps();
    let u;
    l && (o && lodashExports.isNumber(o.width) || o && lodashExports.isString(o.width) && !o.width.includes("%") ? u = o.width : u = this._adapter.getTriggerWidth(), this._adapter.setOptionWrapperWidth(u));
  }
  _isMultiple() {
    return this.getProp("multiple");
  }
  _isAnimated() {
    return this.getProp("motionExpand");
  }
  _isDisabled(o = {}) {
    return this.getProp("disabled") || o.disabled;
  }
  _isExpandControlled() {
    return this.getProp("expandedKeys");
  }
  _isSelectToClose() {
    return !this.getProp("expandAction");
  }
  _isLoadControlled() {
    return this.getProp("loadedKeys");
  }
  _showFilteredOnly() {
    const { inputValue: o } = this.getStates(), { showFilteredOnly: l } = this.getProps();
    return !!o && l;
  }
  findDataForValue(o) {
    const { value: l, defaultValue: u, keyMaps: c } = this.getProps(), m = lodashExports.get(c, "value", "value"), g = lodashExports.get(c, "key", "key");
    let v = [];
    return l ? v = Array.isArray(l) ? l : [l] : u && (v = Array.isArray(u) ? u : [u]), v.find((b) => b[m] === o || b[g] === o);
  }
  constructDataForValue(o) {
    const { treeNodeLabelProp: l, keyMaps: u } = this.getProps(), c = lodashExports.get(u, "key", "key"), m = lodashExports.get(u, "label", l);
    return {
      [c]: o,
      [m]: o
    };
  }
  getDataForKeyNotInKeyEntities(o) {
    const { onChangeWithObject: l } = this.getProps();
    return l ? this.findDataForValue(o) : this.constructDataForValue(o);
  }
  getTreeNodeProps(o) {
    const {
      expandedKeys: l = /* @__PURE__ */ new Set([]),
      selectedKeys: u = [],
      checkedKeys: c = /* @__PURE__ */ new Set([]),
      halfCheckedKeys: m = /* @__PURE__ */ new Set([]),
      realCheckedKeys: g = /* @__PURE__ */ new Set([]),
      keyEntities: v = {},
      filteredKeys: b = /* @__PURE__ */ new Set([]),
      inputValue: S = "",
      loadedKeys: E,
      loadingKeys: P,
      filteredExpandedKeys: T = /* @__PURE__ */ new Set([]),
      disabledKeys: N = /* @__PURE__ */ new Set([])
    } = this.getStates(), { treeNodeFilterProp: O, checkRelation: z } = this.getProps(), Q = v[o];
    if (!Q)
      return null;
    let ue = !1, te = !1;
    z === "related" ? (ue = c.has(o), te = m.has(o)) : z === "unRelated" && (ue = g.has(o), te = !1);
    const ve = {
      eventKey: o,
      expanded: !!S ? T.has(o) : l.has(o),
      selected: u.includes(o),
      checked: ue,
      halfChecked: te,
      pos: String(Q ? Q.pos : ""),
      level: Q.level,
      filtered: b.has(o),
      keyword: S,
      treeNodeFilterProp: O,
      loading: P.has(o) && !E.has(o),
      loaded: E.has(o)
    };
    return this.getProp("disableStrictly") && N.has(o) && (ve.disabled = !0), ve;
  }
  handleNodeLoad(o, l, u, c) {
    const { loadData: m } = this.getProps(), { key: g } = u;
    return !m || o.has(g) || l.has(g) ? {} : (m(u).then(() => {
      const v = new Set(this.getState("loadedKeys")), b = new Set(this.getState("loadingKeys")), S = v.add(g), E = /* @__PURE__ */ new Set([...b]);
      E.delete(g), this._adapter.notifyLoad(S, u), this._isLoadControlled() || this._adapter.updateState({
        loadedKeys: S
      }), this._adapter.setState({
        loadingKeys: E
      }), c();
    }), {
      loadingKeys: l.add(g)
    });
  }
  /* istanbul ignore next */
  focusInput(o) {
    this._adapter.updateInputFocus(o);
  }
  _notifyMultipleChange(o, l) {
    const { keyEntities: u } = this.getStates(), { leafOnly: c, checkRelation: m, keyMaps: g, autoMergeValue: v } = this.getProps();
    let b = [];
    m === "related" ? b = v ? normalizeKeyList(o, u, c, !0) : o : m === "unRelated" && (b = o);
    const S = b.map((E) => u[E] && u[E].key === E ? u[E].data : this.getDataForKeyNotInKeyEntities(E));
    if (this.getProp("onChangeWithObject"))
      this._adapter.notifyChangeWithObject(S, l);
    else {
      const E = getValueOrKey(S, g);
      this._adapter.notifyChange(E, S, l);
    }
  }
  _notifyChange(o, l) {
    const { keyEntities: u } = this.getStates(), { keyMaps: c } = this.getProps();
    if (this._isMultiple() && Array.isArray(o))
      this._notifyMultipleChange(o, l);
    else {
      const m = lodashExports.isUndefined(o) ? o : u[o].data, g = lodashExports.isUndefined(o) ? o : getValueOrKey(m, c);
      this.getProp("onChangeWithObject") ? this._adapter.notifyChangeWithObject(m, l) : this._adapter.notifyChange(g, m, l);
    }
  }
  // Scenes that may trigger focus:
  //  1、click selection
  _notifyFocus(o) {
    this._adapter.notifyFocus(o);
  }
  handleTriggerFocus(o) {
    this._adapter.updateIsFocus(!0), this._notifyFocus(o), this._registerClickOutsideHandler();
  }
  // Scenes that may trigger blur
  //  1、clickOutSide
  //  2、click option / press enter, and then select complete（when multiple is false
  //  3、press esc when dropdown list open
  _notifyBlur(o) {
    this._adapter.notifyBlur(o);
  }
  handlerTriggerBlur(o) {
    this.getState("isFocus") && (this._adapter.updateIsFocus(!1), this._notifyBlur(o), this._adapter.unregisterClickOutsideHandler());
  }
  toggleHoverState(o) {
    this._adapter.toggleHovering(o);
  }
  open() {
    this._adapter.openMenu(), this._setDropdownWidth();
  }
  close(o) {
    this._adapter.closeMenu(), this.getProp("motionExpand") && this._adapter.updateState({ motionKeys: /* @__PURE__ */ new Set([]) });
  }
  handleClick(o) {
    const l = this._isDisabled(), { isOpen: u, inputValue: c, isFocus: m } = this.getStates(), { searchPosition: g, clickTriggerToHide: v } = this.getProps();
    if (!l)
      if (m || this.handleTriggerFocus(o), u) {
        if (g === "trigger" && c)
          return;
        v && this.close(o);
      } else
        this.open();
  }
  /**
   * A11y: simulate selection click
   */
  /* istanbul ignore next */
  handleSelectionEnterPress(o) {
    isEnterPress(o) && this.handleClick(o);
  }
  handleClear(o) {
    const { searchPosition: l, filterTreeNode: u } = this.getProps(), { inputValue: c, selectedKeys: m } = this.getStates(), g = this._isMultiple(), v = this._isControlledComponent(), b = g ? [] : void 0;
    this._notifyChange(b, o), v || (this._adapter.rePositionDropdown(), this._adapter.updateState({
      selectedKeys: [],
      checkedKeys: /* @__PURE__ */ new Set(),
      halfCheckedKeys: /* @__PURE__ */ new Set(),
      realCheckedKeys: /* @__PURE__ */ new Set([])
    })), u && l === strings$8.SEARCH_POSITION_TRIGGER && c !== "" && (lodashExports.isEmpty(m) ? this.handleInputChange("") : this.clearInput()), this._adapter.notifyClear(o);
  }
  /**
   * A11y: simulate clear button click
   */
  /* istanbul ignore next */
  handleClearEnterPress(o) {
    isEnterPress(o) && this.handleClear(o);
  }
  removeTag(o) {
    const { disableStrictly: l, checkRelation: u, keyMaps: c } = this.getProps(), { keyEntities: m, disabledKeys: g, realCheckedKeys: v } = this.getStates(), b = m[o] && m[o].key === o ? m[o].data : this.getDataForKeyNotInKeyEntities(o), S = lodashExports.get(c, "disabled", "disabled");
    if (!(b[S] || l && g.has(o))) {
      if (u === "unRelated") {
        const E = new Set(v);
        E.delete(o), this._notifyChange([...E], null), this._isControlledComponent() || (this._adapter.updateState({ realCheckedKeys: E }), this._adapter.rePositionDropdown());
      } else if (u === "related") {
        const { checkedKeys: E, halfCheckedKeys: P } = this.calcCheckedKeys(o, !1);
        this._notifyChange([...E], null), this._isControlledComponent() || (this._adapter.updateState({ checkedKeys: E, halfCheckedKeys: P }), this._adapter.rePositionDropdown());
      }
      this._adapter.notifySelect(o, !1, b), this._adapter.rePositionDropdown();
    }
  }
  clearInput() {
    const { flattenNodes: o, expandedKeys: l, selectedKeys: u, keyEntities: c, treeData: m } = this.getStates(), { keyMaps: g } = this.getProps(), v = new Set(l);
    this._isExpandControlled();
    const b = findAncestorKeys(u, c, !1);
    b.forEach((E) => v.add(E));
    const S = flattenTreeData(m, v, g);
    this._adapter.updateState({
      expandedKeys: v,
      flattenNodes: S,
      inputValue: "",
      motionKeys: /* @__PURE__ */ new Set([]),
      filteredKeys: /* @__PURE__ */ new Set([]),
      filteredExpandedKeys: new Set(b),
      filteredShownKeys: /* @__PURE__ */ new Set([])
    }), this._adapter.rePositionDropdown();
  }
  handleInputChange(o) {
    this._adapter.updateInputValue(o);
    const { flattenNodes: l, expandedKeys: u, selectedKeys: c, keyEntities: m, treeData: g } = this.getStates(), { showFilteredOnly: v, filterTreeNode: b, treeNodeFilterProp: S, keyMaps: E } = this.getProps(), P = S !== "label" ? S : lodashExports.get(E, "label", "label"), T = new Set(u);
    let N = [], O = [], z = [], Q = [], W = /* @__PURE__ */ new Set([]);
    if (!o)
      z = findAncestorKeys(c, m, !1), z.forEach((te) => T.add(te)), Q = flattenTreeData(g, T, E);
    else {
      const te = Object.values(m).filter((ve) => {
        const { data: ee } = ve;
        return filter$1(o, ee, b, P);
      });
      N = te.map((ve) => ve.data), O = te.map((ve) => ve.key), z = findAncestorKeys(O, m, !1);
      const K = findDescendantKeys(O, m, !0);
      W = /* @__PURE__ */ new Set([...K, ...z]), Q = flattenTreeData(g, new Set(z), E, v && W);
    }
    const ue = new Set(z);
    this._adapter.notifySearch(o, Array.from(ue), N), this._adapter.updateState({
      expandedKeys: T,
      flattenNodes: Q,
      motionKeys: /* @__PURE__ */ new Set([]),
      filteredKeys: new Set(O),
      filteredExpandedKeys: ue,
      filteredShownKeys: W
    }), this._adapter.rePositionDropdown();
  }
  handleNodeSelect(o, l) {
    this._isDisabled(l) || (this._isMultiple() ? this.handleMultipleSelect(o, l) : this.handleSingleSelect(o, l));
  }
  handleSingleSelect(o, l) {
    let u = [...this.getState("selectedKeys")];
    const { clickToHide: c } = this.getProps(), { selected: m, eventKey: g, data: v } = l;
    this._adapter.notifySelect(g, !0, v), !u.includes(g) && !m && (u = [g], this._notifyChange(g, o), this._isControlledComponent() || this._adapter.updateState({ selectedKeys: u })), c && (this._isSelectToClose() || !v.children) && (this.close(o), this.handlerTriggerBlur(o));
  }
  calcCheckedKeys(o, l) {
    const { keyEntities: u } = this.getStates(), c = new Set(this.getState("checkedKeys")), m = new Set(this.getState("halfCheckedKeys"));
    return l ? calcCheckedKeysForChecked(o, u, c, m) : calcCheckedKeysForUnchecked(o, u, c, m);
  }
  handleMultipleSelect(o, l) {
    const { searchPosition: u, disableStrictly: c, checkRelation: m } = this.getProps(), { inputValue: g, realCheckedKeys: v } = this.getStates(), { checked: b, eventKey: S, data: E } = l;
    if (m === "related") {
      const P = c ? this.calcCheckedStatus(!b, S) : !b, { checkedKeys: T, halfCheckedKeys: N } = c ? this.calcNonDisabledCheckedKeys(S, P) : this.calcCheckedKeys(S, P);
      this._adapter.notifySelect(S, P, E), this._notifyChange([...T], o), this._isControlledComponent() || (this._adapter.updateState({ checkedKeys: T, halfCheckedKeys: N }), this._adapter.rePositionDropdown());
    } else if (m === "unRelated") {
      const P = new Set(v);
      let T;
      v.has(S) ? (P.delete(S), T = !1) : (P.add(S), T = !0), this._adapter.notifySelect(S, T, E), this._notifyChange([...P], o), this._isControlledComponent() || (this._adapter.updateState({ realCheckedKeys: P }), this._adapter.rePositionDropdown());
    }
    u === strings$8.SEARCH_POSITION_TRIGGER && g !== "" && this._adapter.updateState({ inputValue: "" });
  }
  calcNonDisabledCheckedKeys(o, l) {
    const { keyEntities: u, disabledKeys: c } = this.getStates(), m = new Set(this.getState("checkedKeys")), g = normalizeKeyList(findDescendantKeys([o], u, !1), u, !0);
    if (!g.some((E) => c.has(E)))
      return this.calcCheckedKeys(o, l);
    const b = g.filter((E) => !c.has(E)), S = l ? [...b, ...m] : lodashExports.difference(normalizeKeyList([...m], u, !0, !0), b);
    return calcCheckedKeys(S, u);
  }
  calcCheckedStatus(o, l) {
    if (!o)
      return o;
    const { checkedKeys: u, keyEntities: c, disabledKeys: m } = this.getStates(), g = normalizeKeyList(findDescendantKeys([l], c, !1), c, !0);
    return g.some((E) => m.has(E)) ? !g.filter((E) => !m.has(E)).every((E) => u.has(E)) : o;
  }
  handleNodeExpandInSearch(o, l) {
    const { treeData: u, filteredShownKeys: c, keyEntities: m, keyMaps: g } = this.getStates(), v = this._showFilteredOnly(), b = new Set(this.getState("filteredExpandedKeys"));
    let S = "show";
    const { eventKey: E, expanded: P, data: T } = l;
    if (P ? b.has(E) && (b.delete(E), S = "hide") : b.add(E), this._adapter.cacheFlattenNodes(S === "hide" && this._isAnimated()), !this._isExpandControlled()) {
      const N = flattenTreeData(u, b, g, v && c), O = this._isAnimated() ? getMotionKeys(E, b, m) : [], z = {
        filteredExpandedKeys: b,
        flattenNodes: N,
        motionKeys: new Set(O),
        motionType: S
      };
      this._adapter.updateState(z);
    }
    this._adapter.notifyExpand(b, {
      expanded: !P,
      node: T
    });
  }
  handleNodeExpand(o, l) {
    const { loadData: u, keyMaps: c } = this.getProps(), { inputValue: m, keyEntities: g } = this.getStates(), v = !!m;
    if (!u && (!l.children || !l.children.length))
      return;
    const b = this._isExpandControlled();
    if (v) {
      this.handleNodeExpandInSearch(o, l);
      return;
    }
    const { treeData: S } = this.getStates(), E = new Set(this.getState("expandedKeys"));
    let P = "show";
    const { eventKey: T, expanded: N, data: O } = l;
    if (N ? E.has(T) && (E.delete(T), P = "hide") : E.add(T), this._adapter.cacheFlattenNodes(P === "hide" && this._isAnimated()), !b) {
      const z = flattenTreeData(S, E, c), Q = this._isAnimated() ? getMotionKeys(T, E, g) : [], W = {
        expandedKeys: E,
        flattenNodes: z,
        motionKeys: new Set(Q),
        motionType: P
      };
      this._adapter.updateState(W);
    }
    this._adapter.notifyExpand(E, {
      expanded: !N,
      node: O
    });
  }
  /**
   * The selected items that need to be displayed in the search box when obtaining a single selection
   */
  getRenderTextInSingle() {
    const { renderSelectedItem: o, treeNodeLabelProp: l, keyMaps: u } = this.getProps(), { selectedKeys: c, keyEntities: m } = this.getStates(), g = lodashExports.get(u, "label", l), v = lodashExports.isFunction(o) ? o : (E) => lodashExports.get(E, g, null);
    let b;
    if (c.length) {
      const E = c[0];
      b = m[E] && m[E].key === E ? m[E].data : this.getDataForKeyNotInKeyEntities(E);
    }
    return b ? v(b) : null;
  }
  /**
   * When the search box is on the trigger, the blur event handling method
   */
  handleInputTriggerBlur() {
    this._adapter.updateState({
      inputTriggerFocus: !1
    });
  }
  /**
   * When the search box is on the trigger, the focus event processing method
   */
  handleInputTriggerFocus() {
    this.clearInput(), this._adapter.updateState({
      inputTriggerFocus: !0
    });
  }
  setLoadKeys(o, l) {
    this._adapter.updateLoadKeys(o, l);
  }
  handlePopoverVisibleChange(o) {
    const { filterTreeNode: l, searchAutoFocus: u, searchPosition: c } = this.getProps();
    o === !1 && l && this.clearInputValue(), l && c === strings$8.SEARCH_POSITION_DROPDOWN && o && u && this.focusInput(!0);
  }
  handleAfterClose() {
    const { filterTreeNode: o } = this.getProps();
    o && this.clearInput();
  }
}
function _isSlot$t(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$2 = cssClasses$u.PREFIX, prefixTree = cssClasses$u.PREFIX_TREE, key = 0, propTypes$19 = {
  "aria-describedby": string$3,
  "aria-errormessage": string$3,
  "aria-invalid": bool,
  "aria-labelledby": string$3,
  "aria-required": bool,
  "aria-label": string$3,
  borderless: bool,
  loadedKeys: array$1,
  loadData: func,
  onLoad: func,
  arrowIcon: node$1,
  clearIcon: node$1,
  defaultOpen: bool,
  defaultValue: oneOfType([string$3, array$1]),
  defaultExpandAll: bool,
  defaultExpandedKeys: array$1,
  expandAll: bool,
  disabled: bool,
  disableStrictly: bool,
  // Whether to turn on the input box filtering function, when it is a function, it represents a custom filtering function
  filterTreeNode: oneOfType([func, bool]),
  multiple: bool,
  searchPlaceholder: string$3,
  searchAutoFocus: bool,
  virtualize: object$1,
  treeNodeFilterProp: string$3,
  onChange: func,
  onClear: func,
  onSearch: func,
  onSelect: func,
  onExpand: func,
  onChangeWithObject: bool,
  onBlur: func,
  onFocus: func,
  value: oneOfType([string$3, number$2, array$1, object$1]),
  expandedKeys: array$1,
  autoExpandParent: bool,
  showClear: bool,
  showSearchClear: bool,
  autoAdjustOverflow: bool,
  showFilteredOnly: bool,
  showLine: bool,
  motionExpand: bool,
  emptyContent: node$1,
  leafOnly: bool,
  keyMaps: object$1,
  treeData: array$1,
  dropdownClassName: string$3,
  dropdownStyle: object$1,
  motion: oneOfType([bool, object$1, func]),
  placeholder: string$3,
  maxTagCount: number$2,
  size: String,
  className: string$3,
  style: object$1,
  treeNodeLabelProp: string$3,
  suffix: node$1,
  prefix: node$1,
  insetLabel: node$1,
  insetLabelId: string$3,
  zIndex: number$2,
  getPopupContainer: func,
  dropdownMatchSelectWidth: bool,
  validateStatus: String,
  mouseEnterDelay: number$2,
  mouseLeaveDelay: number$2,
  triggerRender: func,
  stopPropagation: oneOfType([bool, string$3]),
  outerBottomSlot: node$1,
  outerTopSlot: node$1,
  onVisibleChange: func,
  expandAction: oneOfType([bool, string$3]),
  searchPosition: String,
  clickToHide: bool,
  renderLabel: func,
  renderFullLabel: func,
  labelEllipsis: bool,
  optionListStyle: object$1,
  searchRender: oneOfType([func, bool]),
  renderSelectedItem: func,
  checkRelation: string$3,
  id: string$3,
  showRestTagsPopover: bool,
  restTagsPopoverProps: object$1,
  preventScroll: bool,
  clickTriggerToHide: bool,
  autoMergeValue: bool,
  dropdownMargin: oneOfType([number$2, object$1]),
  position: string$3
}, defaultProps$14 = {
  borderless: !1,
  searchPosition: strings$8.SEARCH_POSITION_DROPDOWN,
  arrowIcon: createVNode(IconComponent$A, null, null),
  autoExpandParent: !1,
  autoAdjustOverflow: !0,
  stopPropagation: !0,
  motion: !0,
  motionExpand: !0,
  expandAll: !1,
  zIndex: numbers$f.DEFAULT_Z_INDEX,
  disableStrictly: !1,
  multiple: !1,
  filterTreeNode: !1,
  size: "default",
  treeNodeFilterProp: "label",
  onChangeWithObject: !1,
  treeNodeLabelProp: "label",
  dropdownMatchSelectWidth: !0,
  defaultOpen: !1,
  showSearchClear: !0,
  showClear: !1,
  onVisibleChange: lodashExports.noop,
  expandAction: !1,
  clickToHide: !0,
  searchAutoFocus: !1,
  checkRelation: "related",
  "aria-label": "TreeSelect",
  showRestTagsPopover: !1,
  restTagsPopoverProps: {},
  clickTriggerToHide: !0,
  autoMergeValue: !0
}, vuePropsType$1R = vuePropsMake(propTypes$19, defaultProps$14), TreeSelect = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1R
  },
  name: "TreeSelect",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots(), u = reactive({
      inputTriggerFocus: !1,
      isOpen: !1,
      isFocus: !1,
      // isInput: false,
      rePosKey: key,
      dropdownMinWidth: null,
      inputValue: "",
      keyEntities: {},
      treeData: [],
      flattenNodes: [],
      cachedFlattenNodes: void 0,
      selectedKeys: [],
      checkedKeys: /* @__PURE__ */ new Set(),
      halfCheckedKeys: /* @__PURE__ */ new Set(),
      realCheckedKeys: /* @__PURE__ */ new Set([]),
      disabledKeys: /* @__PURE__ */ new Set(),
      motionKeys: /* @__PURE__ */ new Set([]),
      motionType: "hide",
      expandedKeys: new Set(s.expandedKeys),
      filteredKeys: /* @__PURE__ */ new Set(),
      filteredExpandedKeys: /* @__PURE__ */ new Set(),
      filteredShownKeys: /* @__PURE__ */ new Set(),
      prevProps: null,
      isHovering: !1,
      cachedKeyValuePairs: {},
      loadedKeys: /* @__PURE__ */ new Set(),
      loadingKeys: /* @__PURE__ */ new Set()
    }), c = ref$1(), m = ref$1(), g = ref$1(), v = ref$1();
    let b = null;
    Math.random().toString(36).slice(2);
    let S, E;
    const {
      adapter: P,
      context: T,
      getDataAttr: N
    } = useBaseComponent(s, u);
    function O() {
      const bn = {
        updateInputValue: (Bn) => {
          u.inputValue = Bn;
        }
      }, Ln = {
        registerClickOutsideHandler: (Bn) => {
          z.unregisterClickOutsideHandler(), b = (Fn) => {
            var hn, Qn;
            const Gn = v && ((Qn = (hn = v.value).getRef) == null ? void 0 : Qn.call(hn).vnode.el), Wn = g && g.value, Mn = Gn, Tn = Fn.target, Rn = Fn.composedPath && Fn.composedPath() || [Tn];
            Mn && (!Mn.contains(Tn) || !Mn.contains(Tn.parentNode)) && Wn && !Wn.contains(Tn) && !(Rn.includes(Wn) || Rn.includes(Mn)) && Bn(Fn);
          }, document.addEventListener("mousedown", b, !1);
        },
        unregisterClickOutsideHandler: () => {
          document.removeEventListener("mousedown", b, !1), b = null;
        },
        rePositionDropdown: () => {
          let {
            rePosKey: Bn
          } = u;
          Bn = Bn + 1, u.rePosKey = Bn;
        }
      }, Kn = {
        updateState: (Bn) => {
          Object.keys(Bn).forEach((Fn) => {
            u[Fn] = Bn[Fn];
          });
        },
        notifySelect: (Bn, Fn, Gn) => {
          s.onSelect && s.onSelect(Bn, Fn, Gn);
        },
        notifySearch: (Bn, Fn, Gn) => {
          s.onSearch && s.onSearch(Bn, Fn, Gn);
        },
        cacheFlattenNodes: (Bn) => {
          u.cachedFlattenNodes = Bn ? cloneDeep(u.flattenNodes) : void 0;
        },
        notifyLoad: (Bn, Fn) => {
          const {
            onLoad: Gn
          } = s;
          lodashExports.isFunction(Gn) && Gn(Bn, Fn);
        },
        notifyClear: (Bn) => {
          s.onClear && s.onClear(Bn);
        }
      };
      return {
        ...P(),
        ...bn,
        ...Ln,
        ...Kn,
        updateLoadKeys: (Bn, Fn) => {
          const {
            loadingKeys: Gn
          } = Q.handleNodeLoad(u.loadedKeys || /* @__PURE__ */ new Set([]), u.loadingKeys || /* @__PURE__ */ new Set([]), Bn, Fn);
          u.loadingKeys = Gn;
        },
        updateState: (Bn) => {
          Object.keys(Bn).forEach((Fn) => {
            u[Fn] = Bn[Fn];
          });
        },
        openMenu: () => {
          u.isOpen = !0, nextTick(() => {
            s.onVisibleChange(!0);
          });
        },
        closeMenu: (Bn) => {
          u.isOpen = !1, nextTick(() => {
            Bn && Bn(), s.onVisibleChange(!1);
          });
        },
        getTriggerWidth: () => {
          const Bn = g.value;
          return Bn && Bn.getBoundingClientRect().width;
        },
        setOptionWrapperWidth: (Bn) => {
          u.dropdownMinWidth = Bn;
        },
        notifyChange: (Bn, Fn, Gn) => {
          s.onChange && s.onChange(Bn, Fn, Gn);
        },
        notifyChangeWithObject: (Bn, Fn) => {
          s.onChange && s.onChange(Bn, Fn);
        },
        notifyExpand: (Bn, {
          expanded: Fn,
          node: Gn
        }) => {
          s.onExpand && s.onExpand([...Bn], {
            expanded: Fn,
            node: Gn
          }), Fn && s.loadData && _n(Gn);
        },
        notifyFocus: (...Bn) => {
          s.onFocus && s.onFocus(...Bn);
        },
        notifyBlur: (...Bn) => {
          s.onBlur && s.onBlur(...Bn);
        },
        toggleHovering: (Bn) => {
          u.isHovering = Bn;
        },
        updateInputFocus: (Bn) => {
          if (Bn) {
            if (c.value) {
              const {
                preventScroll: Fn
              } = s;
              c.value.focus({
                preventScroll: Fn
              });
            }
            m.value && m.value.focus();
          } else
            c.value && c.value.blur(), m.value && m.value.blur();
        },
        updateIsFocus: (Bn) => {
          u.isFocus = Bn;
        }
      };
    }
    const z = O(), Q = new TreeSelectFoundation(z), W = () => {
      z.rePositionDropdown();
    };
    function ue(bn, Ln) {
      const {
        prevProps: Kn,
        rePosKey: Bn
      } = Ln, {
        keyMaps: Fn
      } = bn, Gn = (An) => !Kn && An in bn || Kn && !lodashExports.isEqual(Kn[An], bn[An]);
      let Wn;
      const Mn = bn.onChangeWithObject;
      let Tn = Ln.keyEntities || {}, Rn = Ln.cachedKeyValuePairs || {};
      const hn = {
        prevProps: bn
      }, Qn = Gn("treeData"), rr = Gn("expandedKeys"), tr = !!(bn.filterTreeNode && Ln.inputValue && Ln.inputValue.length);
      if (Qn) {
        Wn = bn.treeData, hn.treeData = Wn;
        const An = convertDataToEntities$1(Wn, Fn);
        hn.keyEntities = {
          ...An.keyEntities
        }, Tn = hn.keyEntities, hn.cachedKeyValuePairs = {
          ...An.valueEntities
        }, Rn = hn.cachedKeyValuePairs;
      }
      Wn && bn.motion && !lodashExports.isEqual(Object.keys(hn.keyEntities), Object.keys(Ln.keyEntities)) && Kn && bn.motion && (hn.motionKeys = /* @__PURE__ */ new Set([]), hn.motionType = null);
      const Cr = Qn && bn.expandAll;
      if (tr) {
        let An;
        if (Wn && (An = filterTreeData({
          treeData: Wn,
          inputValue: Ln.inputValue,
          filterTreeNode: bn.filterTreeNode,
          filterProps: bn.treeNodeFilterProp,
          showFilteredOnly: bn.showFilteredOnly,
          keyEntities: hn.keyEntities,
          prevExpandedKeys: [...Ln.filteredExpandedKeys],
          keyMaps: Fn
        }), hn.flattenNodes = An.flattenNodes, hn.motionKeys = /* @__PURE__ */ new Set([]), hn.filteredKeys = An.filteredKeys, hn.filteredShownKeys = An.filteredShownKeys, hn.filteredExpandedKeys = An.filteredExpandedKeys), bn.expandedKeys) {
          if (hn.filteredExpandedKeys = calcExpandedKeys(bn.expandedKeys, Tn, bn.autoExpandParent || !Kn), Kn && bn.motion) {
            const Hn = Ln ? Ln.filteredExpandedKeys : /* @__PURE__ */ new Set([]);
            if (!Wn) {
              const ir = calcMotionKeys(Hn, hn.filteredExpandedKeys, Tn);
              let {
                motionKeys: dr
              } = ir;
              const {
                motionType: ar
              } = ir;
              bn.showFilteredOnly && (dr = dr.filter((Or) => Ln.filteredShownKeys.has(Or))), ar === "hide" && (hn.cachedFlattenNodes = cloneDeep(Ln.flattenNodes)), hn.motionKeys = new Set(dr), hn.motionType = ar;
            }
          }
          hn.flattenNodes = flattenTreeData(Wn || Ln.treeData, hn.filteredExpandedKeys || Ln.filteredExpandedKeys, Fn, bn.showFilteredOnly && Ln.filteredShownKeys);
        }
      } else {
        if (rr || Kn && Gn("autoExpandParent")) {
          if (hn.expandedKeys = calcExpandedKeys(bn.expandedKeys, Tn, bn.autoExpandParent || !Kn), Kn && bn.motion && !Wn) {
            const {
              motionKeys: An,
              motionType: Hn
            } = calcMotionKeys(Ln.expandedKeys, hn.expandedKeys, Tn);
            hn.motionKeys = new Set(An), hn.motionType = Hn, Hn === "hide" && (hn.cachedFlattenNodes = cloneDeep(Ln.flattenNodes));
          }
        } else !Kn && (bn.defaultExpandAll || bn.expandAll) || Cr ? hn.expandedKeys = new Set(Object.keys(Tn)) : !Kn && bn.defaultExpandedKeys ? hn.expandedKeys = calcExpandedKeys(bn.defaultExpandedKeys, Tn) : !Kn && bn.defaultValue ? hn.expandedKeys = calcExpandedKeysForValues(normalizeValue(bn.defaultValue, Mn, Fn), Tn, bn.multiple, Rn) : !Kn && bn.value && (hn.expandedKeys = calcExpandedKeysForValues(normalizeValue(bn.value, Mn, Fn), Tn, bn.multiple, Rn));
        if (hn.expandedKeys || delete hn.expandedKeys, Wn || hn.expandedKeys) {
          const An = flattenTreeData(Wn || Ln.treeData, hn.expandedKeys || Ln.expandedKeys, Fn);
          hn.flattenNodes = An;
        }
      }
      const Fr = bn.multiple;
      if (!Fr)
        Gn("value") ? hn.selectedKeys = findKeysForValues(normalizeValue(bn.value, Mn, Fn), Rn, Fr) : !Kn && bn.defaultValue ? hn.selectedKeys = findKeysForValues(normalizeValue(bn.defaultValue, Mn, Fn), Rn, Fr) : Wn && (bn.value ? hn.selectedKeys = findKeysForValues(normalizeValue(bn.value, Mn, Fn) || "", Rn, Fr) : hn.selectedKeys = updateKeys(Ln.selectedKeys, Tn));
      else {
        let An;
        if (Gn("value") ? An = findKeysForValues(normalizeValue(bn.value, Mn, Fn), Rn, Fr) : !Kn && bn.defaultValue ? An = findKeysForValues(normalizeValue(bn.defaultValue, Mn, Fn), Rn, Fr) : Wn && (bn.value ? An = findKeysForValues(normalizeValue(bn.value, Mn, Fn) || [], Rn, Fr) : An = updateKeys(bn.checkRelation === "related" ? Ln.checkedKeys : Ln.realCheckedKeys, Tn)), An) {
          if (bn.checkRelation === "unRelated")
            hn.realCheckedKeys = new Set(An);
          else if (bn.checkRelation === "related") {
            const {
              checkedKeys: Hn,
              halfCheckedKeys: ir
            } = calcCheckedKeys(An, Tn);
            hn.checkedKeys = Hn, hn.halfCheckedKeys = ir;
          }
        }
      }
      return Gn("loadedKeys") && (hn.loadedKeys = new Set(bn.loadedKeys)), (Qn || Gn("value")) && (hn.rePosKey = Bn + 1), Wn && bn.disableStrictly && bn.checkRelation === "related" && (hn.disabledKeys = calcDisabledKeys(Tn, Fn)), hn;
    }
    watch([() => s.loadedKeys, () => s.loadData, () => s.onLoad, () => s.arrowIcon, () => s.defaultOpen, () => s.defaultValue, () => s.defaultExpandAll, () => s.defaultExpandedKeys, () => s.expandAll, () => s.disabled, () => s.disableStrictly, () => s.filterTreeNode, () => s.multiple, () => s.searchPlaceholder, () => s.searchAutoFocus, () => s.virtualize, () => s.treeNodeFilterProp, () => s.onChange, () => s.onSearch, () => s.onSelect, () => s.onExpand, () => s.onChangeWithObject, () => s.onBlur, () => s.onFocus, () => s.value, () => s.expandedKeys, () => s.autoExpandParent, () => s.showClear, () => s.showSearchClear, () => s.autoAdjustOverflow, () => s.showFilteredOnly, () => s.motionExpand, () => s.emptyContent, () => s.leafOnly, () => s.treeData, () => s.dropdownClassName, () => s.dropdownStyle, () => s.motion, () => s.placeholder, () => s.maxTagCount, () => s.size, () => s.className, () => s.style, () => s.treeNodeLabelProp, () => s.suffix, () => s.prefix, () => s.insetLabel, () => s.insetLabelId, () => s.zIndex, () => s.getPopupContainer, () => s.dropdownMatchSelectWidth, () => s.validateStatus, () => s.mouseEnterDelay, () => s.mouseLeaveDelay, () => s.triggerRender, () => s.stopPropagation, () => s.outerBottomSlot, () => s.outerTopSlot, () => s.onVisibleChange, () => s.expandAction, () => s.searchPosition, () => s.clickToHide, () => s.renderLabel, () => s.renderFullLabel, () => s.labelEllipsis, () => s.optionListStyle, () => s.searchRender, () => s.renderSelectedItem, () => s.checkRelation, () => l.defautl], () => {
      const bn = ue({
        ...s
      }, {
        ...u
      });
      Object.keys(bn).forEach((Ln) => {
        u[Ln] = bn[Ln];
      });
    }, {
      immediate: !0
    }), onMounted(() => {
      Q.init();
    }), onUnmounted(() => {
      Q.destroy();
    });
    const te = () => {
      const {
        suffix: bn
      } = s, Ln = cls({
        [`${prefixcls$2}-suffix`]: !0,
        [`${prefixcls$2}-suffix-text`]: bn && lodashExports.isString(bn),
        [`${prefixcls$2}-suffix-icon`]: isSemiIcon(bn)
      });
      return createVNode("div", {
        class: Ln,
        "x-semi-prop": "suffix"
      }, [bn]);
    }, K = () => {
      const {
        prefix: bn,
        insetLabel: Ln,
        insetLabelId: Kn
      } = s, Bn = bn || Ln, Fn = cls({
        [`${prefixcls$2}-prefix`]: !0,
        // to be doublechecked
        [`${prefixcls$2}-inset-label`]: Ln,
        [`${prefixcls$2}-prefix-text`]: Bn && lodashExports.isString(Bn),
        [`${prefixcls$2}-prefix-icon`]: isSemiIcon(Bn)
      });
      return createVNode("div", {
        class: Fn,
        id: Kn,
        "x-semi-prop": "prefix,insetLabel"
      }, [Bn]);
    }, ve = () => {
      const {
        dropdownMinWidth: bn
      } = u, {
        dropdownStyle: Ln,
        dropdownClassName: Kn
      } = s, Bn = {
        minWidth: isNaN(bn) ? bn : bn + "px",
        ...Ln
      }, Fn = cls(Kn, `${prefixcls$2}-popover`);
      return createVNode("div", {
        class: Fn,
        style: Bn,
        onKeydown: Q.handleKeyDown
      }, [er()]);
    }, ee = (bn) => {
      Q.removeTag(bn);
    }, Re = (bn) => {
      Q.handleClick(bn);
    }, wt = (bn) => Q.getDataForKeyNotInKeyEntities(bn), yt = (bn) => {
      Q.handleSelectionEnterPress(bn);
    }, xt = () => {
      const {
        multiple: bn,
        checkRelation: Ln
      } = s, {
        realCheckedKeys: Kn,
        checkedKeys: Bn,
        selectedKeys: Fn
      } = u;
      let Gn = !1;
      return bn ? Ln === "related" ? Gn = !!Bn.size : Ln === "unRelated" && (Gn = !!Kn.size) : Gn = !!Fn.length, Gn;
    }, Kt = () => {
      const {
        showClear: bn,
        disabled: Ln,
        searchPosition: Kn
      } = s, {
        inputValue: Bn,
        isOpen: Fn,
        isHovering: Gn
      } = u, Wn = Kn === strings$8.SEARCH_POSITION_TRIGGER && Bn;
      return bn && (xt() || Wn) && !Ln && (Fn || Gn);
    }, tn = (bn) => {
      const {
        keyEntities: Ln,
        disabledKeys: Kn
      } = u, {
        treeNodeLabelProp: Bn,
        leafOnly: Fn,
        disabled: Gn,
        disableStrictly: Wn,
        size: Mn,
        renderSelectedItem: Tn,
        keyMaps: Rn
      } = s, hn = lodashExports.get(Rn, "label", Bn), Qn = lodashExports.isFunction(Tn) ? Tn : (tr) => ({
        isRenderInTag: !0,
        content: lodashExports.get(tr, hn, null)
      }), rr = [];
      return bn.forEach((tr, Cr) => {
        const Fr = Ln[tr] && Ln[tr].key === tr ? Ln[tr].data : wt(tr), An = (Or, Sr) => {
          Sr && typeof Sr.preventDefault == "function" && Sr.preventDefault(), ee(tr);
        }, {
          content: Hn,
          isRenderInTag: ir
        } = Fr ? Qn(Fr, {
          index: Cr,
          onClose: An
        }) : {};
        if (!Hn)
          return;
        const ar = {
          closable: !(Gn || Fr.disabled || Wn && Kn.has(Fr.key)),
          color: "white",
          visible: !0,
          onClose: An,
          key: `tag-${tr}-${Cr}`,
          size: Mn === "small" ? "small" : "large"
        };
        ir ? rr.push(createVNode(Tag, ar, _isSlot$t(Hn) ? Hn : {
          default: () => [Hn]
        })) : rr.push(Hn);
      }), rr;
    }, ln = () => {
      const {
        placeholder: bn,
        disabled: Ln
      } = s, {
        inputTriggerFocus: Kn
      } = u, Bn = Q.getRenderTextInSingle(), Fn = cls(`${prefixcls$2}-selection-TriggerSearchItem`, {
        [`${prefixcls$2}-selection-TriggerSearchItem-placeholder`]: (Kn || !Bn) && !Ln,
        [`${prefixcls$2}-selection-TriggerSearchItem-disabled`]: Ln
      });
      return createVNode("span", {
        class: Fn,
        onClick: Q.onClickSingleTriggerSearchItem
      }, [Bn || bn]);
    }, rn = () => {
      const {
        inputValue: bn
      } = u;
      return createVNode(Fragment, null, [Pn(), !bn && ln()]);
    }, an = (bn) => {
      const {
        multiple: Ln,
        placeholder: Kn,
        maxTagCount: Bn,
        searchPosition: Fn,
        filterTreeNode: Gn,
        showRestTagsPopover: Wn,
        restTagsPopoverProps: Mn
      } = s;
      if (Gn && Fn === strings$8.SEARCH_POSITION_TRIGGER)
        return Ln ? vn(bn) : rn();
      if (!Ln || !xt()) {
        const hn = Q.getRenderTextInSingle(), Qn = cls(`${prefixcls$2}-selection-content`, {
          [`${prefixcls$2}-selection-placeholder`]: !hn
        });
        return createVNode("span", {
          class: Qn
        }, [hn || Kn]);
      }
      const Rn = tn(bn);
      return createVNode(TagGroup, {
        maxTagCount: Bn,
        tagList: Rn,
        size: "large",
        mode: "custom",
        showPopover: Wn,
        popoverProps: Mn
      }, null);
    }, Gt = (bn) => {
      bn && bn.stopPropagation(), Q.handleClear(bn);
    }, nn = (bn) => {
      bn && bn.stopPropagation(), Q.handleClearEnterPress(bn);
    }, vt = (bn) => {
      Q.toggleHoverState(!0);
    }, Et = (bn) => {
      Q.toggleHoverState(!1);
    }, Qt = (bn) => {
      const {
        isOpen: Ln
      } = u;
      Ln || Q.open(), Q.handleInputChange(bn);
    }, un = () => {
      const bn = Kt(), {
        arrowIcon: Ln
      } = s;
      return bn ? null : Ln ? createVNode("div", {
        class: cls(`${prefixcls$2}-arrow`),
        "x-semi-prop": "arrowIcon"
      }, [Ln]) : null;
    }, gn = () => {
      const bn = Kt(), {
        clearIcon: Ln
      } = s, Kn = cls(`${prefixcls$2}-clearbtn`);
      return bn ? createVNode("div", {
        role: "button",
        tabindex: 0,
        "aria-label": "Clear TreeSelect value",
        class: Kn,
        onClick: Gt,
        onKeypress: nn
      }, [Ln || createVNode(IconComponent$w, null, null)]) : null;
    }, dn = () => {
      const {
        disabled: bn,
        multiple: Ln,
        filterTreeNode: Kn,
        validateStatus: Bn,
        prefix: Fn,
        suffix: Gn,
        style: Wn,
        size: Mn,
        insetLabel: Tn,
        className: Rn,
        placeholder: hn,
        showClear: Qn,
        leafOnly: rr,
        searchPosition: tr,
        triggerRender: Cr,
        borderless: Fr,
        autoMergeValue: An,
        checkRelation: Hn,
        ...ir
      } = s, {
        inputValue: dr,
        selectedKeys: ar,
        checkedKeys: Or,
        keyEntities: Sr,
        isFocus: kr,
        realCheckedKeys: Nr
      } = u, Ur = !!Kn, _r = typeof Cr == "function", Zr = Qn ? {
        onMouseenter: (Oi) => vt(),
        onMouseleave: (Oi) => Et()
      } : {}, Jr = tr === strings$8.SEARCH_POSITION_TRIGGER && Ur, ii = Jr && lodashExports.isEmpty(Or), Ti = Jr && !lodashExports.isEmpty(Or), Mi = _r ? cls(Rn) : cls(prefixcls$2, {
        [`${prefixcls$2}-borderless`]: Fr,
        [`${prefixcls$2}-focus`]: kr,
        [`${prefixcls$2}-disabled`]: bn,
        [`${prefixcls$2}-single`]: !Ln,
        [`${prefixcls$2}-multiple`]: Ln,
        [`${prefixcls$2}-multiple-tagInput-empty`]: Ln && ii,
        [`${prefixcls$2}-multiple-tagInput-notEmpty`]: Ln && Ti,
        [`${prefixcls$2}-filterable`]: Ur,
        [`${prefixcls$2}-error`]: Bn === "error",
        [`${prefixcls$2}-warning`]: Bn === "warning",
        [`${prefixcls$2}-small`]: Mn === "small",
        [`${prefixcls$2}-large`]: Mn === "large",
        [`${prefixcls$2}-with-prefix`]: Fn || Tn,
        [`${prefixcls$2}-with-suffix`]: Gn,
        [`${prefixcls$2}-with-suffix`]: Gn
      }, Rn);
      let ui, Ii = [];
      return Ln ? An ? Hn === "related" ? Ii = normalizeKeyList([...Or], Sr, rr, !0) : Hn === "unRelated" && (Ii = [...Nr]) : Ii = [...Or] : Ii = ar, _r ? ui = createVNode(Index$6, {
        inputValue: dr,
        value: Ii.map((Oi) => lodashExports.get(Sr, [Oi, "data"])),
        disabled: bn,
        placeholder: hn,
        onClear: Gt,
        componentName: "TreeSelect",
        triggerRender: Cr,
        componentProps: {
          ...s
        },
        onSearch: Qt,
        onRemove: ee
      }, null) : ui = [createVNode(Fragment, {
        key: "prefix"
      }, [Fn || Tn ? K() : null]), createVNode(Fragment, {
        key: "selection"
      }, [createVNode("div", {
        class: `${prefixcls$2}-selection`
      }, [an(Ii)])]), createVNode(Fragment, {
        key: "suffix"
      }, [Gn ? te() : null]), createVNode(Fragment, {
        key: "clearBtn"
      }, [Qn || Jr && dr ? gn() : null]), createVNode(Fragment, {
        key: "arrow"
      }, [un()])], createVNode("div", mergeProps$1({
        role: "combobox",
        "aria-disabled": bn,
        "aria-haspopup": "tree",
        tabindex: bn ? null : 0,
        class: Mi,
        style: Wn,
        ref: g,
        onClick: Re,
        onKeypress: yt,
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-label": s["aria-label"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-required": s["aria-required"]
      }, Zr, N()), {
        default: () => ui
      });
    }, yn = (bn, Ln) => {
      const {
        keyEntities: Kn,
        disabledKeys: Bn
      } = u, {
        size: Fn,
        leafOnly: Gn,
        disabled: Wn,
        disableStrictly: Mn,
        renderSelectedItem: Tn,
        treeNodeLabelProp: Rn,
        keyMaps: hn
      } = s;
      lodashExports.get(hn, "label", Rn);
      const rr = normalizeKeyList([bn], Kn, Gn, !0).map((Sr) => Kn[bn] && Kn[bn].key === bn ? Kn[bn].data : wt(bn)), tr = getValueOrKey(rr, hn), Cr = cls(`${prefixcls$2}-selection-tag`, {
        [`${prefixcls$2}-selection-tag-disabled`]: Wn
      }), Fr = !lodashExports.isEmpty(rr) && !lodashExports.isEmpty(rr[0]), An = Mn && Fr && Bn.has(rr[0].key), Hn = Fr && !rr[0].disabled && !Wn && !An, ir = (Sr, kr) => {
        kr.preventDefault(), ee(bn);
      }, dr = {
        size: Fn === "small" ? "small" : "large",
        key: `tag-${tr}-${Ln}`,
        color: "white",
        className: Cr,
        closable: Hn,
        onClose: ir
      }, ar = rr[0], Or = lodashExports.isFunction(Tn) ? Tn : (Sr) => ({
        isRenderInTag: !0,
        content: lodashExports.get(Sr, Rn, null)
      });
      if (lodashExports.isFunction(Or)) {
        const {
          content: Sr,
          isRenderInTag: kr
        } = ar ? Or(ar, {
          index: Ln,
          onClose: ir
        }) : {};
        return kr ? createVNode(Tag, dr, _isSlot$t(Sr) ? Sr : {
          default: () => [Sr]
        }) : Sr;
      }
      return createVNode(Tag, dr, _isSlot$t(tr) ? tr : {
        default: () => [tr]
      });
    }, vn = (bn) => {
      const {
        disabled: Ln,
        size: Kn,
        searchAutoFocus: Bn,
        placeholder: Fn,
        maxTagCount: Gn,
        showRestTagsPopover: Wn,
        restTagsPopoverProps: Mn,
        searchPosition: Tn,
        filterTreeNode: Rn,
        preventScroll: hn
      } = s, {
        inputValue: Qn
      } = u, rr = Rn && Tn === strings$8.SEARCH_POSITION_TRIGGER ? Bn : void 0;
      return createVNode(TagInput, {
        maxTagCount: Gn,
        disabled: Ln,
        onInputChange: (tr) => Qt(tr),
        ref: m,
        placeholder: Fn,
        value: bn,
        inputValue: Qn,
        size: Kn,
        showRestTagsPopover: Wn,
        restTagsPopoverProps: Mn,
        autoFocus: rr,
        renderTagItem: (tr, Cr) => yn(tr, Cr),
        onRemove: (tr) => ee(tr),
        expandRestTagsOnClick: !1,
        preventScroll: hn
      }, null);
    }, Pn = () => {
      const {
        searchPlaceholder: bn,
        searchRender: Ln,
        showSearchClear: Kn,
        searchPosition: Bn,
        searchAutoFocus: Fn,
        multiple: Gn,
        disabled: Wn,
        preventScroll: Mn
      } = s, Tn = Bn === strings$8.SEARCH_POSITION_DROPDOWN, Rn = cls({
        [`${prefixTree}-input`]: Tn,
        [`${prefixcls$2}-inputTrigger`]: !Tn
      }), {
        inputValue: hn
      } = u, Qn = {
        value: hn,
        className: Rn,
        preventScroll: Mn,
        onChange: (Hn) => Qt(Hn)
      }, rr = {
        showClear: Kn,
        prefix: createVNode(IconComponent$9, null, null)
      }, Cr = Tn ? rr : {
        autofocus: Fn,
        onFocus: (Hn) => Q.handleInputTriggerFocus(),
        onBlur: (Hn) => Q.handleInputTriggerBlur(),
        disabled: Wn
      }, Fr = cls({
        [`${prefixTree}-search-wrapper`]: Tn,
        [`${prefixcls$2}-triggerSingleSearch-wrapper`]: !Tn && !Gn
      }), An = typeof Ln == "function" || typeof Ln == "boolean";
      return An && !Ln ? null : createVNode("div", {
        class: Fr
      }, [createVNode(LocaleConsumer$6, {
        componentName: "TreeSelect"
      }, {
        default: (Hn) => {
          const ir = Tn ? bn || Hn.searchPlaceholder : "";
          return An ? Ln({
            ...Cr,
            ...Qn,
            placeholder: ir
          }) : createVNode(Input$1, mergeProps$1({
            "aria-label": "Filter TreeSelect item",
            ref: c,
            placeholder: ir
          }, Qn, Cr), null);
        }
      })]);
    }, On = () => {
      const {
        emptyContent: bn
      } = s;
      return bn ? createVNode(TreeNode$1, {
        key: "treeSelectTreeNode",
        empty: !0,
        emptyContent: s.emptyContent
      }, null) : createVNode(LocaleConsumer$6, {
        componentName: "Tree"
      }, {
        default: (Ln) => createVNode(TreeNode$1, {
          key: "treeSelectTreeNode",
          empty: !0,
          emptyContent: Ln.emptyText
        }, null)
      });
    }, _n = (bn) => new Promise((Ln) => Q.setLoadKeys(bn, Ln)), Nn = (bn, Ln) => {
      Q.handleNodeSelect(bn, Ln);
    }, Un = (bn, Ln) => {
      Q.handleNodeSelect(bn, Ln);
    }, Xn = (bn, Ln) => {
      Q.handleNodeExpand(bn, Ln);
    }, zn = (bn) => {
      Q.handlePopoverVisibleChange(bn);
    }, jn = () => {
      Q.handleAfterClose();
    }, kn = (bn, Ln, Kn) => {
      const {
        data: Bn,
        key: Fn
      } = bn, Gn = Q.getTreeNodeProps(Fn), {
        showLine: Wn
      } = s;
      if (!Gn)
        return null;
      const Mn = lodashExports.pick(bn, ["key", "label", "disabled", "isLeaf", "icon", "isEnd"]), {
        keyMaps: Tn
      } = Mn, Rn = Bn[lodashExports.get(Tn, "children", "children")];
      return !lodashExports.isUndefined(Rn) && (Mn.children = Rn), createVNode(TreeNode$1, mergeProps$1(Gn, Bn, Mn, {
        data: Bn,
        style: Kn,
        showLine: Wn
      }), null);
    }, Yn = (bn, Ln) => {
      const {
        visibleOptions: Kn
      } = Ln;
      return Kn[bn].key;
    }, Zn = () => {
      const {
        flattenNodes: bn,
        cachedFlattenNodes: Ln,
        motionKeys: Kn,
        motionType: Bn,
        filteredKeys: Fn
      } = u, {
        direction: Gn
      } = T.value, {
        virtualize: Wn,
        motionExpand: Mn
      } = s, Tn = "expandedKeys" in o(s);
      if (!Wn || lodashExports.isEmpty(Wn))
        return createVNode(NodeList, {
          flattenNodes: bn,
          flattenList: Ln,
          motionKeys: Mn ? Kn : /* @__PURE__ */ new Set([]),
          motionType: Bn,
          searchTargetIsDeep: Tn && Mn && lodashExports.isEmpty(Kn) && !lodashExports.isEmpty(Fn),
          onMotionEnd: W,
          renderTreeNode: kn
        }, null);
      const Rn = {
        visibleOptions: bn,
        renderOption: kn
      };
      return createVNode(AutoSizer, {
        defaultHeight: styleNum(Wn.height),
        defaultWidth: styleNum(Wn.width),
        children: ({
          height: hn,
          width: Qn
        }) => createVNode(Jt$1, {
          itemCount: bn.length,
          itemSize: Wn.itemSize,
          height: hn,
          width: Qn,
          itemKey: Yn,
          itemData: Rn,
          className: `${prefixTree}-virtual-list`,
          style: {
            direction: Gn
          }
        }, _isSlot$t(VirtualRow) ? VirtualRow : {
          default: () => [VirtualRow]
        })
      }, null);
    }, er = () => {
      let bn;
      const {
        keyEntities: Ln,
        motionKeys: Kn,
        motionType: Bn,
        inputValue: Fn,
        filteredKeys: Gn,
        flattenNodes: Wn,
        checkedKeys: Mn,
        realCheckedKeys: Tn
      } = u, {
        loadData: Rn,
        filterTreeNode: hn,
        disabled: Qn,
        multiple: rr,
        showFilteredOnly: tr,
        motionExpand: Cr,
        outerBottomSlot: Fr,
        outerTopSlot: An,
        expandAction: Hn,
        labelEllipsis: ir,
        virtualize: dr,
        optionListStyle: ar,
        searchPosition: Or,
        renderLabel: Sr,
        renderFullLabel: kr,
        checkRelation: Nr
      } = s, Ur = cls(`${prefixTree}-wrapper`), _r = cls(`${prefixTree}-option-list`, {
        [`${prefixTree}-option-list-block`]: !0
      }), Zr = !!Fn && !Gn.size, Jr = lodashExports.isEmpty(Wn) || tr && Zr, ii = Or === strings$8.SEARCH_POSITION_DROPDOWN;
      return createVNode(TreeContext.Provider, {
        value: {
          loadData: Rn,
          treeDisabled: Qn,
          motion: Cr,
          motionKeys: Kn,
          motionType: Bn,
          expandAction: Hn,
          filterTreeNode: hn,
          keyEntities: Ln,
          onNodeClick: S,
          onNodeDoubleClick: E,
          // tree node will call this function when treeNode is right clicked
          onNodeRightClick: lodashExports.noop,
          onNodeExpand: Xn,
          onNodeSelect: Nn,
          onNodeCheck: Un,
          renderTreeNode: kn,
          multiple: rr,
          showFilteredOnly: tr,
          isSearching: !!Fn,
          renderLabel: Sr,
          renderFullLabel: kr,
          labelEllipsis: typeof ir > "u" ? dr : ir
        }
      }, {
        default: () => [createVNode("div", {
          class: Ur
        }, [An, !An && hn && ii && Pn(), createVNode("div", {
          class: _r,
          role: "tree",
          "aria-multiselectable": !!rr,
          style: ar
        }, [Jr ? On() : rr ? createVNode(CheckboxGroup$1, {
          value: Array.from(Nr === "related" ? Mn : Tn)
        }, _isSlot$t(bn = Zn()) ? bn : {
          default: () => [bn]
        }) : Zn()]), Fr])]
      });
    };
    return () => {
      const bn = ve(), {
        motion: Ln,
        zIndex: Kn,
        mouseLeaveDelay: Bn,
        mouseEnterDelay: Fn,
        autoAdjustOverflow: Gn,
        stopPropagation: Wn,
        getPopupContainer: Mn,
        dropdownMargin: Tn,
        position: Rn
      } = s, {
        isOpen: hn,
        rePosKey: Qn
      } = u, rr = dn();
      return createVNode(Popover$1, {
        stopPropagation: Wn,
        getPopupContainer: Mn,
        zIndex: Kn,
        motion: Ln,
        margin: Tn,
        ref: v,
        content: bn,
        visible: hn,
        trigger: "custom",
        rePosKey: Qn,
        position: Rn || "bottomLeft",
        autoAdjustOverflow: Gn,
        mouseLeaveDelay: Bn,
        mouseEnterDelay: Fn,
        onVisibleChange: zn,
        afterClose: jn
      }, _isSlot$t(rr) ? rr : {
        default: () => [rr]
      });
    };
  }
}), TreeSelect$1 = TreeSelect, cssClasses$t = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-anchor`
}, strings$7 = {
  SIZE: ["small", "default"],
  SLIDE_COLOR: ["primary", "tertiary", "muted"],
  MAX_WIDTH: "200px",
  MAX_HEIGHT: "750px",
  POSITION_SET: [
    "top",
    "topLeft",
    "topRight",
    "left",
    "leftTop",
    "leftBottom",
    "right",
    "rightTop",
    "rightBottom",
    "bottom",
    "bottomLeft",
    "bottomRight",
    "leftTopOver",
    "rightTopOver"
  ]
};
function t(s) {
  return typeof s == "object" && s != null && s.nodeType === 1;
}
function e(s, o) {
  return (!o || s !== "hidden") && s !== "visible" && s !== "clip";
}
function n(s, o) {
  if (s.clientHeight < s.scrollHeight || s.clientWidth < s.scrollWidth) {
    var l = getComputedStyle(s, null);
    return e(l.overflowY, o) || e(l.overflowX, o) || function(u) {
      var c = function(m) {
        if (!m.ownerDocument || !m.ownerDocument.defaultView) return null;
        try {
          return m.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      }(u);
      return !!c && (c.clientHeight < u.scrollHeight || c.clientWidth < u.scrollWidth);
    }(s);
  }
  return !1;
}
function r(s, o, l, u, c, m, g, v) {
  return m < s && g > o || m > s && g < o ? 0 : m <= s && v <= l || g >= o && v >= l ? m - s - u : g > o && v < l || m < s && v > l ? g - o + c : 0;
}
var i$1 = function(s, o) {
  var l = window, u = o.scrollMode, c = o.block, m = o.inline, g = o.boundary, v = o.skipOverflowHiddenElements, b = typeof g == "function" ? g : function(kn) {
    return kn !== g;
  };
  if (!t(s)) throw new TypeError("Invalid target");
  for (var S, E, P = document.scrollingElement || document.documentElement, T = [], N = s; t(N) && b(N); ) {
    if ((N = (E = (S = N).parentElement) == null ? S.getRootNode().host || null : E) === P) {
      T.push(N);
      break;
    }
    N != null && N === document.body && n(N) && !n(document.documentElement) || N != null && n(N, v) && T.push(N);
  }
  for (var O = l.visualViewport ? l.visualViewport.width : innerWidth, z = l.visualViewport ? l.visualViewport.height : innerHeight, Q = window.scrollX || pageXOffset, W = window.scrollY || pageYOffset, ue = s.getBoundingClientRect(), te = ue.height, K = ue.width, ve = ue.top, ee = ue.right, Re = ue.bottom, wt = ue.left, yt = c === "start" || c === "nearest" ? ve : c === "end" ? Re : ve + te / 2, xt = m === "center" ? wt + K / 2 : m === "end" ? ee : wt, Kt = [], tn = 0; tn < T.length; tn++) {
    var ln = T[tn], rn = ln.getBoundingClientRect(), an = rn.height, Gt = rn.width, nn = rn.top, vt = rn.right, Et = rn.bottom, Qt = rn.left;
    if (u === "if-needed" && ve >= 0 && wt >= 0 && Re <= z && ee <= O && ve >= nn && Re <= Et && wt >= Qt && ee <= vt) return Kt;
    var un = getComputedStyle(ln), gn = parseInt(un.borderLeftWidth, 10), dn = parseInt(un.borderTopWidth, 10), yn = parseInt(un.borderRightWidth, 10), vn = parseInt(un.borderBottomWidth, 10), Pn = 0, On = 0, _n = "offsetWidth" in ln ? ln.offsetWidth - ln.clientWidth - gn - yn : 0, Nn = "offsetHeight" in ln ? ln.offsetHeight - ln.clientHeight - dn - vn : 0, Un = "offsetWidth" in ln ? ln.offsetWidth === 0 ? 0 : Gt / ln.offsetWidth : 0, Xn = "offsetHeight" in ln ? ln.offsetHeight === 0 ? 0 : an / ln.offsetHeight : 0;
    if (P === ln) Pn = c === "start" ? yt : c === "end" ? yt - z : c === "nearest" ? r(W, W + z, z, dn, vn, W + yt, W + yt + te, te) : yt - z / 2, On = m === "start" ? xt : m === "center" ? xt - O / 2 : m === "end" ? xt - O : r(Q, Q + O, O, gn, yn, Q + xt, Q + xt + K, K), Pn = Math.max(0, Pn + W), On = Math.max(0, On + Q);
    else {
      Pn = c === "start" ? yt - nn - dn : c === "end" ? yt - Et + vn + Nn : c === "nearest" ? r(nn, Et, an, dn, vn + Nn, yt, yt + te, te) : yt - (nn + an / 2) + Nn / 2, On = m === "start" ? xt - Qt - gn : m === "center" ? xt - (Qt + Gt / 2) + _n / 2 : m === "end" ? xt - vt + yn + _n : r(Qt, vt, Gt, gn, yn + _n, xt, xt + K, K);
      var zn = ln.scrollLeft, jn = ln.scrollTop;
      yt += jn - (Pn = Math.max(0, Math.min(jn + Pn / Xn, ln.scrollHeight - an / Xn + Nn))), xt += zn - (On = Math.max(0, Math.min(zn + On / Un, ln.scrollWidth - Gt / Un + _n)));
    }
    Kt.push({ el: ln, top: Pn, left: On });
  }
  return Kt;
};
function isOptionsObject(s) {
  return s === Object(s) && Object.keys(s).length !== 0;
}
function defaultBehavior(s, o) {
  o === void 0 && (o = "auto");
  var l = "scrollBehavior" in document.body.style;
  s.forEach(function(u) {
    var c = u.el, m = u.top, g = u.left;
    c.scroll && l ? c.scroll({
      top: m,
      left: g,
      behavior: o
    }) : (c.scrollTop = m, c.scrollLeft = g);
  });
}
function getOptions$1(s) {
  return s === !1 ? {
    block: "end",
    inline: "nearest"
  } : isOptionsObject(s) ? s : {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(s, o) {
  var l = s.isConnected || s.ownerDocument.documentElement.contains(s);
  if (isOptionsObject(o) && typeof o.behavior == "function")
    return o.behavior(l ? i$1(s, o) : []);
  if (l) {
    var u = getOptions$1(o);
    return defaultBehavior(i$1(s, u), u.behavior);
  }
}
const prefixCls$r = cssClasses$t.PREFIX;
class AnchorFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...AnchorFoundation.defaultAdapter, ...o }), this.init = () => {
    }, this.destroy = () => {
    }, this.addLink = (l) => {
      this._adapter.addLink(l);
    }, this.removeLink = (l) => {
      this._adapter.removeLink(l);
    }, this.setActiveLink = (l, u, c = !0) => {
      const m = this._adapter.getState("activeLink"), g = this._adapter.getProp("onChange");
      m !== l && (this._adapter.setActiveLink(l, this._setActiveSlide), g && c && this._adapter.notifyChange(l, u));
    }, this.setScrollHeight = () => {
      const l = `.${prefixCls$r}-link-wrapper`, u = this._adapter.getAnchorNode(l);
      if (u) {
        const c = `${u.scrollHeight}px`;
        this._adapter.setScrollHeight(c);
      }
    }, this.updateScrollHeight = (l, u) => {
      const c = l.links.join(""), m = u.links.join("");
      c !== m && this.setScrollHeight();
    }, this.setChildMap = () => {
      const l = this._adapter.getProp("children"), u = {};
      if (lodashExports.isArray(l))
        for (const c of l)
          this._getLinkToMap(c, [], u);
      else
        this._getLinkToMap(l, [], u);
      this._adapter.setChildMap(u);
    }, this.updateChildMap = (l, u) => {
      const c = l.links.join(""), m = u.links.join("");
      c !== m && this.setChildMap();
    }, this.getLinksTop = () => this._adapter.getLinksBoundingTop(), this.handleScroll = () => {
      const { clickLink: l, links: u, activeLink: c } = this.getStates();
      if (l)
        return;
      const m = this.getLinksTop();
      let g = -1 / 0, v = -1;
      for (let S = 0; S < m.length; S++)
        m[S] < 0 && m[S] > g && (g = m[S], v = S);
      const b = u[v];
      this.setActiveLink(b, c);
    }, this.handleClick = (l, u, c = !0) => {
      const m = this._adapter.getContentNode(u), g = this._adapter.getState("activeLink");
      if (this.setActiveLink(u, g, c), m)
        try {
          this._adapter.setClickLinkWithCallBack(!0, u, this._scrollIntoView);
        } catch {
        }
      c && this._adapter.notifyClick(l, u);
    }, this.handleClickLink = () => {
      this._adapter.setClickLink(!1);
    }, this._getLinkToMap = (l, u, c) => {
      const m = l && l.props;
      if (!(!m || !m.href)) {
        m.href in c || (c[m.href] = /* @__PURE__ */ new Set());
        for (const g of u)
          c[g].add(m.href);
        if (m.children && m.children.length) {
          u.push(m.href);
          for (const g of m.children)
            this._getLinkToMap(g, u, c);
          u.pop();
        }
      }
    }, this._scrollIntoView = (l) => {
      const { scrollMotion: u, targetOffset: c } = this.getProps(), m = u ? "smooth" : "auto", g = this._adapter.canSmoothScroll();
      if (l) {
        const v = this._adapter.getContentNode(l);
        v && scrollIntoView(v, {
          /**
           * Behavior defines scrolling behavior
           *  - Optional'auto '|' smooth '| Function
           *  - Function Custom scrolling behavior
           *    - Enter parameters as actions, each action contains an element that should be scrolled
           *    - Actions include scrolling containers to the outermost scrollable container (document.body), the scrollable capacity needs to meet
           *      1. The parent of the scroll container (directly or indirectly)
           *      2. There is a scroll axis (clientHeight < scrollHeight | | clientWidth < scrollWidth)
           *      3.overflowX or overflowY has a value and is not visible or clip
           *       For details, please see https://github.com/stipsan/compute-scroll-into-view
           *
           * behavior定义滚动行为
           *  - 可选 'auto' | 'smooth' | Function
           *  - Function 自定义滚动行为
           *    - 入参为 actions，每个action包含一个应该滚动的元素
           *    - actions包括滚动容器到最外层的可滚动容器（document.body），可滚动容需满足
           *      1. 滚动容器的父级（直接或间接）
           *      2. 有滚动轴（clientHeight < scrollHeight || clientWidth < scrollWidth）
           *      3. overflowX 或 overflowY 有值且不为 visible 或 clip
           *      详情请看https://github.com/stipsan/compute-scroll-into-view
           */
          behavior: (S) => {
            const E = S.find((N) => {
              const { el: O } = N;
              return O.scrollHeight > O.clientHeight;
            }), P = lodashExports.get(E, "el"), T = lodashExports.get(E, "top");
            if (P) {
              const N = T - c;
              P.scroll && g ? P.scroll({ top: N, behavior: m }) : P.scrollTop = N;
            }
          },
          block: "start"
        });
      }
    }, this._setActiveSlide = () => {
      const l = `.${cssClasses$t.PREFIX}-link-title-active`, u = this._adapter.getAnchorNode(l);
      if (u) {
        const c = u.offsetTop;
        this._adapter.setSlideBarTop(c);
      }
    };
  }
}
class LinkFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
  }
  destroy() {
  }
  handleAddLink() {
    const o = this._adapter.getProp("href");
    this._adapter.addLink(o);
  }
  handleUpdateLink(o, l) {
    o !== l && (this._adapter.removeLink(l), this._adapter.addLink(o));
  }
  handleRemoveLink() {
    const o = this._adapter.getProp("href");
    this._adapter.removeLink(o);
  }
}
function useAnchorContext() {
  return {
    context: inject("AnchorContext", ref$1(null))
  };
}
const vuePropsType$1Q = {
  name: String
}, Consumer$e = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useAnchorContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$1Q
  }
});
function _isSlot$s(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$q = cssClasses$t.PREFIX, propTypes$18 = {
  href: string$3,
  title: oneOfType([string$3, node$1]),
  className: string$3,
  style: object$1,
  disabled: bool,
  level: number$2,
  direction: string$3,
  children: node$1
}, defaultProps$13 = {
  href: "#",
  title: "",
  className: ""
}, vuePropsType$1P = vuePropsMake(propTypes$18, defaultProps$13), Link = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1P
  },
  name: "Link",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useAnchorContext(), l = reactive({}), {
      adapter: u
    } = useBaseComponent(s, l);
    function c() {
      return {
        ...u(),
        addLink: (N) => {
          o.value.addLink(N);
        },
        removeLink: (N) => {
          o.value.removeLink(N);
        }
      };
    }
    const m = c(), g = new LinkFoundation(m);
    function v() {
      g.handleAddLink();
    }
    function b() {
      g.handleRemoveLink();
    }
    function S(N, O) {
      g.handleUpdateLink(N, O);
    }
    function E(N) {
      const {
        disabled: O,
        href: z
      } = s, {
        onClick: Q
      } = o.value;
      !O && Q(N, z);
    }
    onMounted(() => {
      v();
    }), watch(() => s.href, (N, O) => {
      const z = O, {
        href: Q
      } = s;
      S(Q, z);
    }), onBeforeUnmount(() => {
      b();
    });
    const P = () => {
      const {
        href: N,
        title: O,
        disabled: z = !1
      } = s, {
        activeLink: Q,
        showTooltip: W,
        position: ue,
        size: te
      } = o.value, K = Q === N, ve = cls(`${prefixCls$q}-link-tooltip`, {
        [`${prefixCls$q}-link-tooltip-small`]: te === "small",
        [`${prefixCls$q}-link-tooltip-active`]: K,
        [`${prefixCls$q}-link-tooltip-disabled`]: z
      });
      if (W) {
        const ee = lodashExports.isObject(W) ? Object.assign({
          opts: {}
        }, W) : {
          opts: {}
        };
        return ue && (ee.opts.position = ue), createVNode(TypographyText, {
          size: te === "default" ? "normal" : "small",
          ellipsis: {
            showTooltip: ee
          },
          type: "tertiary",
          className: ve
        }, _isSlot$s(O) ? O : {
          default: () => [O]
        });
      } else
        return O;
    }, T = () => {
      const {
        activeLink: N,
        childMap: O
      } = o.value, {
        href: z,
        children: Q
      } = s;
      return o.value.autoCollapse ? N === z || O[z] && O[z].has(N) ? createVNode("div", {
        role: "list"
      }, [Q]) : null : createVNode("div", {
        role: "list"
      }, [Q]);
    };
    return () => {
      const {
        href: N,
        className: O,
        style: z,
        disabled: Q = !1,
        title: W,
        level: ue,
        direction: te
      } = s, {
        activeLink: K,
        showTooltip: ve
      } = o.value, ee = K === N, Re = cls(`${prefixCls$q}-link`, O), wt = cls(`${prefixCls$q}-link-title`, {
        [`${prefixCls$q}-link-title-active`]: ee,
        [`${prefixCls$q}-link-title-disabled`]: Q
      }), xt = {
        "aria-disabled": Q,
        style: {
          [te === "rtl" ? "paddingRight" : "paddingLeft"]: 8 * ue + "px"
        }
      };
      return ee && (xt["aria-details"] = "active"), !ve && typeof W == "string" && (xt.title = W), createVNode("div", {
        class: Re,
        style: z,
        role: "listitem"
      }, [createVNode("div", mergeProps$1({
        role: "link",
        tabindex: 0
      }, xt, {
        class: wt,
        onClick: (Kt) => E(Kt),
        onKeypress: (Kt) => E(Kt)
      }), [P()]), T()]);
    };
  }
}), Link$1 = Link, vuePropsType$1O = {
  value: Object
}, Provider$d = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0,
    immediate: !0
  }), provide("AnchorContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$1O
  },
  name: "AnchorContextProvider"
}), AnchorContext = {
  Provider: Provider$d,
  Consumer: Consumer$e
}, prefixCls$p = cssClasses$t.PREFIX, propTypes$17 = {
  size: string$3,
  railTheme: string$3,
  className: string$3,
  style: object$1,
  scrollMotion: bool,
  autoCollapse: bool,
  offsetTop: number$2,
  targetOffset: number$2,
  showTooltip: bool,
  position: string$3,
  maxWidth: oneOfType([string$3, number$2]),
  maxHeight: oneOfType([string$3, number$2]),
  getContainer: func,
  onChange: func,
  onClick: func,
  defaultAnchor: string$3,
  "aria-label": string$3
}, defaultProps$12 = {
  size: "default",
  railTheme: "primary",
  className: "",
  scrollMotion: !1,
  autoCollapse: !1,
  offsetTop: 0,
  targetOffset: 0,
  showTooltip: !1,
  maxWidth: strings$7.MAX_WIDTH,
  maxHeight: strings$7.MAX_HEIGHT,
  getContainer: lodashExports.noop,
  onChange: lodashExports.noop,
  onClick: lodashExports.noop,
  defaultAnchor: ""
}, vuePropsType$1N = vuePropsMake(propTypes$17, defaultProps$12), Anchor = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1N
  },
  name: "Anchor",
  setup(s, {}) {
    const o = useSlots(), {
      context: l
    } = useConfigContext(), u = reactive({
      activeLink: "",
      links: [],
      clickLink: !1,
      scrollHeight: "100%",
      slideBarTop: "0"
    }), {
      adapter: c,
      getDataAttr: m
    } = useBaseComponent(s, u), g = ref$1([]);
    function v() {
      return {
        ...c(),
        getProp: (yt) => yt === "children" ? g.value : s[yt],
        addLink: (yt) => {
          u.links = [...u.links, yt];
        },
        removeLink: (yt) => {
          const xt = u.links.slice(), Kt = xt.indexOf(yt);
          Kt !== -1 && (xt.splice(Kt, 1), u.links = xt);
        },
        setChildMap: (yt) => {
          T = yt;
        },
        setScrollHeight: (yt) => {
          u.scrollHeight = yt;
        },
        setSlideBarTop: (yt) => {
          u.slideBarTop = `${yt}px`;
        },
        setClickLink: (yt) => {
          u.clickLink = yt;
        },
        setActiveLink: (yt, xt) => {
          u.activeLink = yt, nextTick(() => {
            xt();
          });
        },
        setClickLinkWithCallBack: (yt, xt, Kt) => {
          u.clickLink = yt, nextTick(() => {
            Kt(xt);
          });
        },
        getContainer: () => {
          const {
            getContainer: yt
          } = s, xt = yt();
          return xt || window;
        },
        getContainerBoundingTop: () => {
          const yt = b.getContainer();
          return "getBoundingClientRect" in yt ? yt.getBoundingClientRect().top : 0;
        },
        getLinksBoundingTop: () => {
          const {
            links: yt
          } = u, {
            offsetTop: xt
          } = s, Kt = b.getContainerBoundingTop();
          return yt.map((ln) => {
            let rn = null;
            try {
              rn = document.querySelector(ln);
            } catch {
            }
            return rn && rn.getBoundingClientRect().top - Kt - xt || -1 / 0;
          });
        },
        getAnchorNode: (yt) => {
          const xt = `#${E} ${yt}`;
          return document.querySelector(xt);
        },
        getContentNode: (yt) => document.querySelector(yt),
        notifyChange: (yt, xt) => s.onChange(yt, xt),
        notifyClick: (yt, xt) => s.onClick(yt, xt),
        canSmoothScroll: () => "scrollBehavior" in document.body.style
      };
    }
    const b = v(), S = new AnchorFoundation(b);
    let E, P, T = {}, N, O;
    const z = (yt) => {
      S.addLink(yt);
    }, Q = (yt) => {
      S.removeLink(yt);
    }, W = () => {
      S.handleScroll();
    }, ue = (yt, xt) => {
      S.handleClick(yt, xt);
    }, te = () => {
      S.handleClickLink();
    }, K = () => {
      S.setChildMap();
    }, ve = () => {
      S.setScrollHeight();
    }, ee = (yt, xt) => {
      S.updateScrollHeight(yt, xt);
    }, Re = (yt, xt) => {
      S.updateChildMap(yt, xt);
    }, wt = () => {
      const yt = (xt, Kt = 1) => xt.map((tn) => {
        if (isVNode(tn)) {
          const ln = {
            direction: l.value.direction,
            level: Kt,
            children: []
          }, rn = tn.children;
          return rn && rn.length > 0 && (ln.children = yt(rn, Kt + 1)), cloneVNode(tn, ln);
        }
        return null;
      });
      return yt(g.value);
    };
    return onMounted(() => {
      const {
        defaultAnchor: yt = ""
      } = s;
      E = getUuid("semi-anchor").replace(".", ""), P = b.getContainer(), N = lodashExports.throttle(W, 100), O = lodashExports.debounce(te, 100), P.addEventListener("scroll", N), P.addEventListener("scroll", O), ve(), K(), yt && S.handleClick(null, yt, !1);
    }), watch([() => u.activeLink, () => u.links, () => u.clickLink, () => u.scrollHeight, () => u.slideBarTop], (yt, xt, Kt) => {
      if (!lodashExports.isEqual(yt, xt)) {
        const [tn, ln, rn, an, Gt] = xt, nn = {
          activeLink: tn,
          links: ln,
          clickLink: rn,
          scrollHeight: an,
          slideBarTop: Gt
        };
        ee(nn, u), Re(nn, u);
      }
    }), onBeforeUnmount(() => {
      P.removeEventListener("scroll", N), P.removeEventListener("scroll", O);
    }), () => {
      var On;
      g.value = (On = o.default) == null ? void 0 : On.call(o);
      const {
        size: yt,
        railTheme: xt,
        style: Kt,
        className: tn,
        maxWidth: ln,
        maxHeight: rn,
        showTooltip: an,
        position: Gt,
        autoCollapse: nn
      } = s, vt = s["aria-label"], {
        activeLink: Et,
        scrollHeight: Qt,
        slideBarTop: un
      } = u, gn = cls(prefixCls$p, tn, {
        [`${prefixCls$p}-size-${yt}`]: yt
      }), dn = cls(`${prefixCls$p}-slide`, `${prefixCls$p}-slide-${xt}`), yn = cls(`${prefixCls$p}-slide-bar`, {
        [`${prefixCls$p}-slide-bar-${yt}`]: yt,
        [`${prefixCls$p}-slide-bar-${xt}`]: xt,
        [`${prefixCls$p}-slide-bar-active`]: Et
      }), vn = `${prefixCls$p}-link-wrapper`, Pn = {
        ...Kt,
        maxWidth: ln,
        maxHeight: rn
      };
      return createVNode(AnchorContext.Provider, {
        value: {
          activeLink: Et,
          showTooltip: an,
          position: Gt,
          childMap: T,
          autoCollapse: nn,
          size: yt,
          onClick: (_n, Nn) => ue(_n, Nn),
          addLink: z,
          removeLink: Q
        }
      }, {
        default: () => [createVNode("div", mergeProps$1({
          role: "navigation",
          "aria-label": vt || "Side navigation",
          class: gn,
          style: Pn,
          id: E
        }, m()), [createVNode("div", {
          "aria-hidden": !0,
          class: dn,
          style: {
            height: Qt
          }
        }, [createVNode("span", {
          class: yn,
          style: {
            top: un
          }
        }, null)]), createVNode("div", {
          class: vn,
          role: "list"
        }, [wt()])])]
      });
    };
  }
}), Anchor$1 = Anchor, prefixCls$o = cssClasses$M.PREFIX, vuePropsType$1M = {
  style: [Object, String],
  className: String,
  shape: {
    type: String,
    default: "circle"
  },
  size: {
    type: String,
    default: "medium"
  },
  overlapFrom: {
    type: String,
    default: "start"
  },
  maxCount: Number,
  renderMore: Function
}, AvatarGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1M
  },
  name: "AvatarGroup",
  setup(s, {
    slots: o
  }) {
    function l(c) {
      const {
        maxCount: m
      } = s;
      let g = c;
      const v = c.length - m, b = c.slice(0, m), S = c.slice(m);
      if (v > 0) {
        const E = u(v, S);
        b.push(E), g = b;
      }
      return g;
    }
    function u(c, m) {
      const {
        renderMore: g
      } = s, v = cls(`${prefixCls$o}-item-more`);
      let b = createVNode(Avatar$1, {
        className: v,
        key: "_+n"
      }, {
        default: () => [`+${c}`]
      });
      return lodashExports.isFunction(g) && (b = createVNode(Fragment, {
        key: "_+n"
      }, [g(c, m)])), b;
    }
    return () => {
      const c = o.default ? o.default() : null;
      function m() {
        return Array.isArray(c) ? c : [c];
      }
      const {
        maxCount: g,
        overlapFrom: v,
        size: b,
        shape: S,
        renderMore: E,
        ...P
      } = s;
      let T;
      const N = cls({
        [`${prefixCls$o}-group`]: !0
      });
      if (c) {
        const O = m();
        T = (lodashExports.isNumber(g) ? l(O) : O).map((z, Q) => {
          const W = cls(lodashExports.get(z.props, "className"), {
            [`${prefixCls$o}-item-start-${Q}`]: v === "start",
            [`${prefixCls$o}-item-end-${Q}`]: v === "end"
          });
          return cloneVNode(z, {
            ...P,
            class: W,
            size: b,
            shape: S,
            key: Q
          });
        });
      }
      return createVNode("div", {
        class: N
      }, [T]);
    };
  }
}), AvatarGroup$1 = AvatarGroup, cssClasses$s = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-backtop`
};
class BackTopFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.scrollTo = (l, u, c) => {
      const { duration: m } = this.getProps();
      this.animation = new Animation(
        {
          from: { scrollTop: u },
          to: { scrollTop: c }
        },
        {
          duration: m,
          easing: "easeInOutCubic"
        }
      ), this.animation.on("frame", ({ scrollTop: g }) => {
        this._adapter.targetScrollToTop(l, g);
      }), this.animation.start();
    }, this.handleScroll = () => {
      const { target: l, visibilityHeight: u } = this.getProps(), c = l();
      requestAnimationFrame(() => {
        const g = this.getScroll(c);
        this._adapter.updateVisible(g > u);
      });
    };
  }
  init() {
    const { target: o } = this.getProps();
    o().addEventListener("scroll", this.handleScroll), this.handleScroll();
  }
  destroy() {
    const { target: o } = this.getProps(), l = o();
    l && l.removeEventListener("scroll", this.handleScroll), this.animation && this.animation.destroy();
  }
  getScroll(o) {
    return this._adapter.isWindowUndefined() ? 0 : this._adapter.targetIsWindow(o) ? o["pageYOffset"] : o["scrollTop"];
  }
  setScrollTop(o) {
    const { target: l } = this.getProps(), u = l(), c = this.getScroll(u);
    this.scrollTo(u, c, o);
  }
  onClick(o) {
    this.setScrollTop(0), this._adapter.notifyClick(o);
  }
}
const prefixCls$n = cssClasses$s.PREFIX, getDefaultTarget = () => window, defaultProps$11 = {
  visibilityHeight: 400,
  target: getDefaultTarget,
  duration: 450
}, propTypes$16 = {
  target: func,
  visibilityHeight: number$2,
  duration: number$2,
  onClick: func,
  style: object$1,
  className: string$3
}, vuePropsType$1L = vuePropsMake(propTypes$16, defaultProps$11), BackTop = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1L
  },
  name: "BackTop",
  setup(s, {}) {
    const o = useSlots();
    let l;
    const u = reactive({
      visible: !1
    }), {
      adapter: c
    } = useBaseComponent(s, u);
    function m() {
      return {
        ...c(),
        updateVisible: (E) => {
          u.visible = E;
        },
        notifyClick: (E) => {
          s.onClick && s.onClick(E);
        },
        targetIsWindow: (E) => E === window,
        isWindowUndefined: () => window === void 0,
        targetScrollToTop: (E, P) => {
          E === window ? (document.body.scrollTop = P, document.documentElement.scrollTop = P) : E.scrollTop = P;
        }
      };
    }
    const g = m(), v = new BackTopFoundation(g);
    onMounted(() => {
      v.init(), l = lodashExports.throttle(b, s.duration ?? defaultProps$11.duration);
    }), onBeforeUnmount(() => {
      v.destroy();
    });
    function b(E) {
      v.onClick(E);
    }
    function S() {
      return createVNode(Button$3, {
        theme: "light",
        icon: createVNode(IconComponent$x, null, null)
      }, null);
    }
    return () => {
      var ve;
      const E = (ve = o.default) == null ? void 0 : ve.call(o), {
        className: P,
        style: T,
        onClick: N,
        visibilityHeight: O,
        target: z,
        ...Q
      } = s, {
        visible: W
      } = u, ue = cls(prefixCls$n, P), te = E || S();
      return W ? (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        createVNode("div", mergeProps$1(Q, {
          class: ue,
          style: T,
          onClick: (ee) => l(ee),
          "x-semi-prop": "children"
        }), [te])
      ) : null;
    };
  }
}), BackTop$1 = BackTop, cssClasses$r = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-badge`
}, prefixCls$m = cssClasses$r.PREFIX, propTypes$15 = {
  count: node$1,
  dot: bool,
  type: string$3,
  theme: string$3,
  position: string$3,
  overflowCount: number$2,
  style: object$1,
  className: string$3,
  onClick: func,
  onMouseEnter: func,
  onMouseLeave: func,
  countClassName: string$3,
  countStyle: object$1
}, defaultProps$10 = {
  dot: !1,
  type: "primary",
  theme: "solid",
  className: "",
  onClick: () => lodashExports.noop,
  onMouseEnter: () => lodashExports.noop,
  onMouseLeave: () => lodashExports.noop
}, vuePropsType$1K = vuePropsMake(propTypes$15, defaultProps$10), Badge = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1K
  },
  name: "Badge",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots(), {
      context: u
    } = useConfigContext();
    return () => {
      var ve;
      const {
        direction: c
      } = u.value, m = c === "rtl" ? "leftTop" : "rightTop", {
        count: g,
        dot: v,
        type: b,
        countClassName: S,
        countStyle: E,
        theme: P,
        position: T = m,
        overflowCount: N,
        className: O,
        ...z
      } = o(s), Q = (ve = l.default) == null ? void 0 : ve.call(l), W = g && !(lodashExports.isNumber(g) || lodashExports.isString(g)), ue = g !== null && typeof g < "u", te = cls(S, {
        [`${prefixCls$m}-${b}`]: !W,
        [`${prefixCls$m}-${P}`]: !W,
        [`${prefixCls$m}-${T}`]: !!T && !!Q,
        [`${prefixCls$m}-block`]: !Q,
        [`${prefixCls$m}-dot`]: v,
        [`${prefixCls$m}-count`]: !v && !W && ue,
        [`${prefixCls$m}-custom`]: W
      });
      let K;
      return lodashExports.isNumber(g) ? K = N && N < g ? `${N}+` : `${g}` : K = g, createVNode("span", mergeProps$1({
        class: cls(prefixCls$m, O)
      }, z), [Q, createVNode("span", {
        class: te,
        style: E,
        "x-semi-prop": "count"
      }, [v ? null : K])]);
    };
  }
}), Badge$1 = Badge, cssClasses$q = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-banner`
};
class BannerFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...BannerFoundation.defaultAdapter, ...o });
  }
  removeBanner(o) {
    this._adapter.notifyClose(o), this._adapter.setVisible();
  }
}
function _isSlot$r(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$l = cssClasses$q.PREFIX, propTypes$14 = {
  // target: PropTypes.func,
  fullMode: bool,
  // insertAfter: PropTypes.func,
  type: String,
  title: node$1,
  description: node$1,
  icon: node$1,
  closeIcon: node$1,
  style: object$1,
  className: string$3,
  onClose: func,
  bordered: bool
}, defaultProps$$ = {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  onClose: () => {
  },
  type: "info",
  fullMode: !0
}, vuePropsType$1J = vuePropsMake(propTypes$14, defaultProps$$), Banner = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1J
  },
  name: "Banner",
  setup(s, {}) {
    warning$1("target" in s, "[Semi Banner] 'target' has been deprecated, please write JSX directly instead.");
    const o = useSlots(), l = reactive({
      visible: !0
    });
    let u;
    const {
      adapter: c,
      getDataAttr: m
    } = useBaseComponent(s, l);
    function g() {
      return {
        ...c(),
        setVisible: () => {
          l.visible = !1;
        },
        notifyClose: (P) => {
          const {
            onClose: T
          } = s;
          T(P);
        }
      };
    }
    const v = g();
    onMounted(() => {
      u = new BannerFoundation(v), u.init();
    }), onUnmounted(() => {
      u.destroy();
    });
    const b = (P) => {
      P && P.stopPropagation(), u.removeBanner(P);
    };
    function S() {
      const {
        closeIcon: P
      } = s;
      return P === null ? P : createVNode(Button$3, {
        className: `${prefixCls$l}-close`,
        onClick: b,
        icon: P || createVNode(IconComponent$u, {
          "x-semi-prop": "closeIcon",
          "aria-hidden": !0
        }, null),
        theme: "borderless",
        size: "small",
        type: "tertiary",
        "aria-label": "Close"
      }, null);
    }
    function E() {
      const {
        type: P,
        icon: T
      } = s;
      let O = {
        warning: createVNode(IconComponent$J, {
          size: "large",
          "aria-label": "warning"
        }, null),
        success: createVNode(IconComponent$5, {
          size: "large",
          "aria-label": "success"
        }, null),
        info: createVNode(IconComponent$h, {
          size: "large",
          "aria-label": "info"
        }, null),
        danger: createVNode(IconComponent$K, {
          size: "large",
          "aria-label": "danger"
        }, null)
      }[P];
      const z = cls({
        [`${prefixCls$l}-icon`]: !0
        // [prefixCls + '-' + type]: true,
      });
      return typeof T < "u" && (O = T), O ? createVNode("div", {
        class: z,
        "x-semi-prop": "icon"
      }, [O]) : null;
    }
    return () => {
      var ee;
      const P = (ee = o.default) == null ? void 0 : ee.call(o), {
        type: T,
        className: N,
        style: O,
        bordered: z,
        title: Q,
        description: W,
        fullMode: ue
      } = s, {
        visible: te
      } = l, K = cls(prefixCls$l, N, {
        [`${prefixCls$l}-${T}`]: T,
        [`${prefixCls$l}-full`]: ue,
        [`${prefixCls$l}-in-container`]: !ue,
        [`${prefixCls$l}-bordered`]: !ue && z
      });
      return te ? createVNode("div", mergeProps$1({
        class: K,
        style: O,
        role: "alert"
      }, m()), [createVNode("div", {
        class: `${prefixCls$l}-content-wrapper`
      }, [createVNode("div", {
        class: `${prefixCls$l}-content`
      }, [E(), createVNode("div", {
        class: `${prefixCls$l}-content-body`
      }, [Q ? createVNode(TypographyTitle, {
        heading: 5,
        className: `${prefixCls$l}-title`,
        component_: "div",
        "x-semi-prop": "title"
      }, _isSlot$r(Q) ? Q : {
        default: () => [Q]
      }) : null, W ? createVNode(Paragraph$1, {
        className: `${prefixCls$l}-description`,
        component_: "div",
        "x-semi-prop": "description"
      }, _isSlot$r(W) ? W : {
        default: () => [W]
      }) : null])]), S()]), P ? createVNode("div", {
        class: `${prefixCls$l}-extra`,
        "x-semi-prop": "children"
      }, [P]) : null]) : null;
    };
  }
}), Banner$1 = Banner, cssClasses$p = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-breadcrumb`
};
class BreadcrumbFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  handleClick(o, l) {
    this._adapter.notifyClick(o, l);
  }
  handleExpand(o) {
    this._adapter.expandCollapsed(o);
  }
  /**
   * A11y: simulate clear button click
   */
  handleExpandEnterPress(o) {
    isEnterPress(o) && this.handleExpand(o);
  }
  genRoutes(o) {
    return o.map((l) => {
      if (typeof l != "object")
        return {
          name: l,
          _origin: {
            name: l
          }
        };
      let u = {};
      return u._origin = l, { ...u, ...l };
    });
  }
}
class BreadcrumbItemFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  handleClick(o, l) {
    this._adapter.notifyClick(o, l), this._adapter.notifyParent(o, l);
  }
}
function useBreadContext() {
  return {
    context: inject("BreadContext", ref$1({}))
  };
}
const vuePropsType$1I = {
  name: String
}, Consumer$d = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1I
  },
  name: "BreadContextConsumer",
  setup() {
    const s = useSlots(), {
      context: o
    } = useBreadContext();
    return () => s.default ? s.default(o) : null;
  }
});
function _isSlot$q(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const clsPrefix$2 = cssClasses$p.PREFIX, propTypes_$1 = {
  onClick: func,
  route: [object$1, string$3],
  active: bool,
  shouldRenderSeparator: bool,
  icon: node$1,
  separator: node$1,
  noLink: bool,
  //@ts-ignore
  path: string$3,
  //@ts-ignore
  href: string$3,
  //@ts-ignore
  name: string$3,
  //@ts-ignore
  _origin: object$1
}, defaultProps$_ = {
  onClick: noop$1,
  shouldRenderSeparator: !0
}, vuePropsType$1H = vuePropsMake(propTypes_$1, defaultProps$_), BreadcrumbItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1H
  },
  name: "BreadcrumbItem",
  setup(s, {}) {
    const o = useSlots(), l = reactive({}), {
      context: u
    } = useBreadContext(), {
      adapter: c,
      getDataAttr: m
    } = useBaseComponent(s, l);
    function g() {
      return {
        ...c(),
        notifyClick: (...N) => {
          s.onClick(...N);
        },
        notifyParent: (...N) => {
          u.value.onClick(...N);
        }
      };
    }
    const v = new BreadcrumbItemFoundation(g());
    onMounted(() => {
      v.init();
    }), onUnmounted(() => {
      v.destroy();
    });
    const b = () => {
      const N = s.icon, {
        compact: O
      } = u.value, z = O ? "small" : "default", Q = `${clsPrefix$2}-item-icon`;
      return isVNode(N) ? cloneVNode(N, {
        class: Q,
        size: z
      }) : N;
    }, S = () => {
      const {
        showTooltip: N
      } = u.value;
      if (!N)
        return {
          width: 150,
          ellipsisPos: "end"
        };
      const O = {
        width: 150,
        ellipsisPos: "end",
        opts: {
          autoAdjustOverflow: !0,
          position: "top"
        }
      };
      return typeof N == "object" ? lodashExports.merge(O, N) : O;
    }, E = () => {
      var ue;
      let N = {};
      const O = (ue = o.default) == null ? void 0 : ue.call(o), {
        route: z,
        href: Q
      } = s, W = !lodashExports.isUndefined(Q) && !lodashExports.isNull(Q);
      return z ? N = z : (N.name = O, W && (N.href = Q)), N;
    }, P = () => {
      const N = getFragmentChildren(o), {
        compact: O
      } = u.value, z = S(), Q = b();
      if (N && N[0].type.toString() === "Symbol(v-txt)") {
        const {
          opts: W,
          ellipsisPos: ue,
          width: te
        } = z;
        return createVNode(Fragment, null, [Q, createVNode("span", {
          class: `${clsPrefix$2}-item-title`
        }, [createVNode(TypographyText, {
          ellipsis: {
            showTooltip: W ? {
              opts: W
            } : !1,
            pos: ue
          },
          style: {
            maxWidth: styleNum(te)
          },
          size: O ? "small" : "normal"
        }, _isSlot$q(N) ? N : {
          default: () => [N]
        })])]);
      }
      return createVNode(Fragment, null, [Q, N ? createVNode("span", {
        class: `${clsPrefix$2}-item-title ${clsPrefix$2}-item-title-inline`
      }, [N]) : null]);
    }, T = () => {
      const {
        href: N,
        active: O,
        noLink: z
      } = s, Q = N !== null && typeof N < "u", W = cls({
        [`${clsPrefix$2}-item`]: !0,
        [`${clsPrefix$2}-item-active`]: O,
        [`${clsPrefix$2}-item-link`]: !z
      }), ue = P(), te = O || !Q ? "span" : "a", K = E();
      return h(te, {
        className: W,
        onClick: (ve) => v.handleClick(K, ve),
        href: N
      }, ue);
    };
    return () => {
      var te;
      const {
        active: N,
        shouldRenderSeparator: O
        // children,
      } = s, z = N ? {
        "aria-current": "page"
      } : {}, Q = T(), W = s.separator || createVNode("span", {
        class: `${clsPrefix$2}-separator`
      }, [(te = u.value) == null ? void 0 : te.separator]), ue = cls({
        [`${clsPrefix$2}-item-wrap`]: !0
        // [`${clsPrefix}-item-wrap-iconOnly`]: !!children && props.icon,
      });
      return createVNode("span", mergeProps$1({
        class: ue
      }, z, m()), [Q, O && W]);
    };
  }
}), BreadcrumbItem$1 = BreadcrumbItem, vuePropsType$1G = {
  value: Object
}, Provider$c = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1G
  },
  name: "BreadContextProvider",
  setup(s, {
    slots: o
  }) {
    const l = ref$1(s.value);
    return watch(() => s.value, () => {
      l.value = s.value;
    }, {
      deep: !0
    }), provide("BreadContext", l), () => o.default ? o.default(l.value) : null;
  }
}), BreadContext = {
  Consumer: Consumer$d,
  Provider: Provider$c
}, clsPrefix$1 = cssClasses$p.PREFIX, propTypes_ = {
  activeIndex: number$2,
  routes: array$1,
  onClick: func,
  separator: node$1,
  compact: bool,
  style: object$1,
  renderItem: func,
  showTooltip: [object$1, bool],
  className: string$3,
  autoCollapse: bool,
  maxItemCount: number$2,
  /* Customize the contents of the ellipsis area */
  renderMore: func,
  /* Type of ellipsis area */
  moreType: String,
  "aria-label": string$3
}, defaultProps$Z = {
  routes: [],
  onClick: noop$1,
  renderItem: void 0,
  separator: "/",
  compact: !0,
  showTooltip: {
    width: 150,
    ellipsisPos: "end"
  },
  autoCollapse: !0,
  moreType: "default",
  maxItemCount: 4,
  "aria-label": "Breadcrumb"
}, vuePropsType$1F = vuePropsMake(propTypes_, defaultProps$Z), Breadcrumb = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1F
  },
  name: "Breadcrumb",
  setup(s, {}) {
    const o = reactive({
      isCollapsed: !0
    }), {
      adapter: l,
      getDataAttr: u
    } = useBaseComponent(s, o);
    function c() {
      return {
        ...l(),
        notifyClick: (...T) => {
          s.onClick(...T);
        },
        expandCollapsed: () => o.isCollapsed = !1
      };
    }
    const m = new BreadcrumbFoundation(c());
    onMounted(() => {
      m.init();
    }), onUnmounted(() => {
      m.destroy();
    });
    function g(T) {
      const {
        separator: N
      } = s, O = createVNode(Fragment, null, [T.map((z, Q) => createVNode(Fragment, {
        key: `restItem-${Q}`
      }, [z, Q !== T.length - 1 && createVNode("span", {
        class: `${clsPrefix$1}-restItem`
      }, [N])]))]);
      return createVNode(Popover$1, {
        content: O,
        style: {
          padding: 12
        },
        showArrow: !0
      }, {
        default: () => [createVNode(IconComponent$f, null, null)]
      });
    }
    const v = (T, N) => {
      const {
        maxItemCount: O,
        renderMore: z,
        moreType: Q
      } = s, W = lodashExports.isFunction(z), ue = T.slice(1, N - O + 1), te = createVNode("span", {
        class: `${clsPrefix$1}-collapse`,
        key: `more-${N}`
      }, [createVNode("span", {
        class: `${clsPrefix$1}-item-wrap`
      }, [createVNode("span", {
        role: "button",
        tabindex: 0,
        "aria-label": "Expand breadcrumb items",
        class: `${clsPrefix$1}-item ${clsPrefix$1}-item-more`,
        onClick: (K) => m.handleExpand(K),
        onKeypress: (K) => m.handleExpandEnterPress(K)
      }, [W && z(ue), !W && Q === "default" && createVNode(IconComponent$f, null, null), !W && Q === "popover" && g(ue)]), createVNode("span", {
        class: `${clsPrefix$1}-separator`,
        "x-semi-prop": "separator"
      }, [s.separator])])]);
      return T.splice(1, N - O, te), T;
    }, b = (T, N, O) => {
      const {
        renderItem: z,
        renderMore: Q,
        maxItemCount: W
      } = s, ue = T.length - W, te = lodashExports.isFunction(Q);
      return T.map((ve, ee) => {
        const Re = ve._origin.key || `item-${ve.name || ve.path}-${ee}`, wt = ee > 0 && ee <= ue;
        return createVNode(BreadcrumbItem$1, mergeProps$1(ve, {
          key: Re,
          active: s.activeIndex !== void 0 ? s.activeIndex === ee : ee === T.length - 1,
          route: ve._origin,
          shouldRenderSeparator: ee !== T.length - 1 && !(N && (te || O) && wt)
        }), {
          default: () => [z ? z(ve._origin) : ve.name]
        });
      });
    }, S = useSlots(), E = () => {
      const {
        routes: T,
        autoCollapse: N,
        maxItemCount: O,
        renderMore: z,
        moreType: Q
      } = s, {
        isCollapsed: W
      } = o, ue = T && T.length > 0, te = ue ? m.genRoutes(T) : getFragmentChildren(S) || [];
      let K;
      const ve = te.length, ee = ve - O, Re = te && N && ve > O && W, wt = lodashExports.isFunction(z), yt = Q === "popover";
      return ue ? K = b(te, Re, yt) : K = te.map((xt, Kt) => {
        const tn = Kt > 0 && Kt <= ee;
        return xt && (warning$1(xt.type && xt.type.name !== "BreadcrumbItem", "[Semi Breadcrumb]: Only accepts Breadcrumb.Item as its children"), cloneVNode(xt, {
          key: `${Kt}-item`,
          active: s.activeIndex !== void 0 ? s.activeIndex === Kt : Kt === te.length - 1,
          shouldRenderSeparator: Kt !== te.length - 1 && !(Re && (wt || yt) && tn)
        }));
      }), Re ? v(K, te.length) : K;
    }, P = (T, N) => {
      m.handleClick(T, N);
    };
    return () => {
      const T = E(), {
        compact: N,
        className: O,
        style: z,
        separator: Q,
        showTooltip: W
      } = s, ue = cls(O, {
        [`${clsPrefix$1}-wrapper`]: !0,
        [`${clsPrefix$1}-wrapper-compact`]: N,
        [`${clsPrefix$1}-wrapper-loose`]: !N
      });
      return createVNode(BreadContext.Provider, {
        value: {
          onClick: P,
          showTooltip: W,
          compact: N,
          separator: Q
        }
      }, {
        default: () => [createVNode("nav", mergeProps$1({
          "aria-label": s["aria-label"],
          class: ue,
          style: z
        }, u()), [T])]
      });
    };
  }
}), Breadcrumb$1 = Breadcrumb, cssClasses$o = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-card`
}, cssClasses$n = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-skeleton`
}, generator = (s) => (o) => (l) => createVNode(o, mergeProps$1({
  type: s
}, l), null), propTypes$13 = {
  type: string$3,
  prefixCls: string$3,
  style: object$1,
  className: string$3,
  size: String,
  shape: String
}, defaultProps$Y = {
  prefixCls: cssClasses$n.PREFIX,
  size: "medium",
  shape: "circle"
}, vuePropsTypeGeneric = vuePropsMake(propTypes$13, defaultProps$Y), Generic = /* @__PURE__ */ defineComponent({
  props: vuePropsTypeGeneric,
  name: "Generic",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        prefixCls: o,
        className: l,
        type: u,
        size: c,
        shape: m,
        ...g
      } = s, v = cls(l, `${o}-${u}`, {
        [`${o}-${u}-${c}`]: u.toUpperCase() === "AVATAR"
      }, {
        [`${o}-${u}-${m}`]: u.toUpperCase() === "AVATAR"
      });
      return h("div", {
        className: v,
        ...g
      });
    };
  }
}), Avatar = generator("avatar")(Generic), Image$2 = generator("image")(Generic), Title = generator("title")(Generic), Button = generator("button")(Generic), propTypesParagraph = {
  rows: number$2,
  prefixCls: string$3,
  style: object$1,
  className: string$3
}, defaultPropsParagraph = {
  prefixCls: cssClasses$n.PREFIX,
  rows: 4
}, vuePropsTypeParagraph = vuePropsMake(propTypesParagraph, defaultPropsParagraph), Paragraph = /* @__PURE__ */ defineComponent({
  props: vuePropsTypeParagraph,
  name: "Paragraph",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        prefixCls: o,
        className: l,
        style: u,
        rows: c
      } = s, m = cls(l, `${o}-paragraph`);
      return createVNode("ul", {
        class: m,
        style: u
      }, [[...Array(c)].map((g, v) => createVNode("li", {
        key: v
      }, null))]);
    };
  }
}), prefixCls$k = cssClasses$n.PREFIX, defaultProps$X = {
  loading: !0
}, propTypes$12 = {
  active: bool,
  placeholder: node$1,
  style: object$1,
  className: string$3,
  loading: bool
}, vuePropsType$1E = vuePropsMake(propTypes$12, defaultProps$X), Skeleton = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1E
  },
  name: "Skeleton",
  setup(s, {}) {
    const o = useSlots();
    return () => {
      var P;
      const l = (P = o.default) == null ? void 0 : P.call(o), {
        placeholder: u,
        active: c,
        className: m,
        loading: g,
        style: v,
        ...b
      } = s, S = cls(prefixCls$k, {
        [`${prefixCls$k}-active`]: !!c
      }, m);
      let E;
      return g ? E = createVNode("div", mergeProps$1({
        class: S,
        style: v
      }, b, {
        "x-semi-prop": "placeholder"
      }), [u]) : E = l, E;
    };
  }
}), BaseSkeleton = Skeleton;
BaseSkeleton.Avatar = Avatar;
BaseSkeleton.Image = Image$2;
BaseSkeleton.Title = Title;
BaseSkeleton.Button = Button;
BaseSkeleton.Paragraph = Paragraph;
const Skeleton$1 = BaseSkeleton;
function _isSlot$p(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls$1 = cssClasses$o.PREFIX, propTypes$11 = {
  actions: array$1,
  bodyStyle: object$1,
  bordered: bool,
  children: node$1,
  className: string$3,
  cover: node$1,
  footer: node$1,
  footerLine: bool,
  footerStyle: object$1,
  header: node$1,
  headerExtraContent: node$1,
  headerLine: bool,
  headerStyle: object$1,
  loading: bool,
  shadows: string$3,
  style: object$1,
  title: node$1,
  "aria-label": string$3
}, defaultProps$W = {
  bordered: !0,
  footerLine: !1,
  headerLine: !0,
  loading: !1
}, vuePropsType$1D = vuePropsMake(propTypes$11, defaultProps$W), Card = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1D
  },
  name: "Card",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots(), u = () => {
      const {
        title: v,
        headerExtraContent: b,
        header: S,
        headerLine: E,
        headerStyle: P
      } = s, T = cls(`${prefixcls$1}-header`, {
        [`${prefixcls$1}-header-bordered`]: !!E
      }), N = cls(`${prefixcls$1}-header-wrapper`), O = cls(`${prefixcls$1}-header-wrapper-title`, {
        [`${prefixcls$1}-header-wrapper-spacing`]: !!b
      });
      return S || b || v ? createVNode("div", {
        style: P,
        class: T
      }, [S || // Priority of header over title and headerExtraContent
      createVNode("div", {
        class: N
      }, [b && createVNode("div", {
        class: `${prefixcls$1}-header-wrapper-extra`,
        "x-semi-prop": "headerExtraContent"
      }, [b]), v && createVNode("div", {
        class: O
      }, [lodashExports.isString(v) ? createVNode(TypographyTitle, {
        heading: 6,
        ellipsis: {
          showTooltip: !0,
          rows: 1
        },
        "x-semi-prop": "title"
      }, _isSlot$p(v) ? v : {
        default: () => [v]
      }) : v])])]) : null;
    }, c = () => {
      const {
        cover: v
      } = s, b = cls(`${prefixcls$1}-cover`);
      return v && createVNode("div", {
        class: b,
        "x-semi-prop": "cover"
      }, [v]);
    }, m = () => {
      var Q;
      let v;
      const b = (Q = l.default) == null ? void 0 : Q.call(l), {
        bodyStyle: S,
        actions: E,
        loading: P
      } = s, T = cls(`${prefixcls$1}-body`), N = cls(`${prefixcls$1}-body-actions`), O = cls(`${prefixcls$1}-body-actions-item`), z = createVNode("div", null, [createVNode(Title, null, null), createVNode("br", null, null), createVNode(Paragraph, {
        rows: 3
      }, null)]);
      return createVNode("div", {
        style: S,
        class: T
      }, [b && createVNode(Skeleton$1, {
        placeholder: z,
        loading: P,
        active: !0
      }, _isSlot$p(b) ? b : {
        default: () => [b]
      }), Array.isArray(E) && createVNode("div", {
        class: N
      }, [createVNode(Space, {
        spacing: 12
      }, _isSlot$p(v = E.map((W, ue) => createVNode("div", {
        key: ue,
        class: O,
        "x-semi-prop": `actions.${ue}`
      }, [W]))) ? v : {
        default: () => [v]
      })])]);
    }, g = () => {
      const {
        footer: v,
        footerLine: b,
        footerStyle: S
      } = s, E = cls(`${prefixcls$1}-footer`, {
        [`${prefixcls$1}-footer-bordered`]: b
      });
      return v && createVNode("div", {
        style: S,
        class: E,
        "x-semi-prop": "footer"
      }, [v]);
    };
    return () => {
      const {
        bordered: v,
        shadows: b,
        style: S,
        className: E,
        children: P,
        ...T
      } = o(s), N = lodashExports.omit(T, [
        // Remove APIs in otherProps that do not need to be hung on the outer node
        "actions",
        "bodyStyle",
        "cover",
        "headerExtraContent",
        "footer",
        "footerLine",
        "footerStyle",
        "header",
        "headerLine",
        "headerStyle",
        "loading",
        "title"
      ]), O = cls(prefixcls$1, E, {
        [`${prefixcls$1}-bordered`]: v,
        [`${prefixcls$1}-shadows`]: b,
        [`${prefixcls$1}-shadows-${b}`]: b
      });
      return createVNode("div", mergeProps$1(N, {
        "aria-busy": s.loading,
        class: O,
        style: S
      }), [u(), c(), m(), g()]);
    };
  }
}), Card$1 = Card;
function _isSlot$o(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixcls = cssClasses$o.PREFIX, propTypes$10 = {
  className: string$3,
  spacing: [number$2, array$1],
  style: object$1,
  type: string$3
}, defaultProps$V = {
  spacing: 16
}, vuePropsType$1C = vuePropsMake(propTypes$10, defaultProps$V), CardGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1C
  },
  name: "CardGroup",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots();
    return () => {
      var P;
      const u = (P = l.default) == null ? void 0 : P.call(l), {
        className: c,
        spacing: m,
        style: g,
        type: v,
        ...b
      } = o(s), S = v === "grid", E = cls(`${prefixcls}-group`, c, {
        [`${prefixcls}-group-grid`]: S
      });
      return createVNode(Space, mergeProps$1({
        spacing: S ? 0 : m,
        wrap: !0,
        className: E,
        style: g
      }, b), _isSlot$o(u) ? u : {
        default: () => [u]
      });
    };
  }
}), CardGroup$1 = CardGroup, cssClasses$m = {
  CAROUSEL: `${BASE_CLASS_PREFIX$1}-carousel`,
  CAROUSEL_INDICATOR: `${BASE_CLASS_PREFIX$1}-carousel-indicator`,
  CAROUSEL_INDICATOR_LINE: `${BASE_CLASS_PREFIX$1}-carousel-indicator-line`,
  CAROUSEL_INDICATOR_DOT: `${BASE_CLASS_PREFIX$1}-carousel-indicator-dot`,
  CAROUSEL_INDICATOR_COLUMNAR: `${BASE_CLASS_PREFIX$1}-carousel-indicator-columnar`,
  CAROUSEL_INDICATOR_INACTIVE: `${BASE_CLASS_PREFIX$1}-carousel-indicator-inactive`,
  CAROUSEL_INDICATOR_ACTIVE: `${BASE_CLASS_PREFIX$1}-carousel-indicator-active`,
  CAROUSEL_CONTENT: `${BASE_CLASS_PREFIX$1}-carousel-content`,
  CAROUSEL_ARROW: `${BASE_CLASS_PREFIX$1}-carousel-arrow`
}, numbers$7 = {
  DEFAULT_ACTIVE_INDEX: 0,
  DEFAULT_INTERVAL: 2e3,
  DEFAULT_SPEED: 300
};
class CarouselFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this._interval = null, this._forcePlay = !1;
  }
  setForcePlay(o) {
    this._forcePlay = o;
  }
  play(o) {
    this._interval && clearInterval(this._interval), this._interval = setInterval(() => {
      this.next();
    }, o);
  }
  stop() {
    this._interval && clearInterval(this._interval);
  }
  goTo(o) {
    const { activeIndex: l } = this.getStates(), u = this.getValidIndex(o);
    this._adapter.setIsReverse(l > u), this.getIsControlledComponent() ? this._notifyChange(u) : (this._notifyChange(u), this.handleNewActiveIndex(u));
  }
  next() {
    this.stop();
    const { activeIndex: o } = this.getStates(), l = this.getValidIndex(o + 1);
    this._adapter.setIsReverse(!1), this.getIsControlledComponent() ? this._notifyChange(l) : (this._notifyChange(l), this.handleNewActiveIndex(l)), this.handleAutoPlay();
  }
  prev() {
    this.stop();
    const { activeIndex: o } = this.getStates(), l = this.getValidIndex(o - 1);
    this._adapter.setIsReverse(!0), this.getIsControlledComponent() ? this._notifyChange(l) : (this._notifyChange(l), this.handleNewActiveIndex(l)), this.handleAutoPlay();
  }
  destroy() {
    this._unregisterInterval();
  }
  _unregisterInterval() {
    this._interval && (clearInterval(this._interval), this._interval = null);
  }
  _notifyChange(o) {
    const { activeIndex: l, isInit: u } = this.getStates();
    u && this._adapter.setIsInit(!1), l !== o && (this._adapter.setPreActiveIndex(l), this._adapter.notifyChange(o, l));
  }
  getValidIndex(o) {
    const { children: l } = this.getStates();
    return (o + l.length) % l.length;
  }
  getSwitchingTime() {
    const { autoPlay: o, speed: l } = this.getProps();
    return typeof o === "boolean" ? numbers$7.DEFAULT_INTERVAL + l : lodashExports.isObject(o) ? lodashExports.get(o, "interval", numbers$7.DEFAULT_INTERVAL) + l : l;
  }
  getIsControlledComponent() {
    return this._isInProps("activeIndex");
  }
  handleAutoPlay() {
    const { autoPlay: o } = this.getProps(), { children: l } = this.getStates();
    l.length > 1 && (o === !0 || lodashExports.isObject(o) || this._forcePlay) && this.play(this.getSwitchingTime());
  }
  handleKeyDown(o) {
    o.key === "ArrowLeft" && this.prev(), o.key === "ArrowRight" && this.next();
  }
  onIndicatorChange(o) {
    const { activeIndex: l } = this.getStates();
    this._adapter.setIsReverse(l > o), this._notifyChange(o), this.getIsControlledComponent() || this.handleNewActiveIndex(o);
  }
  handleNewActiveIndex(o) {
    const { activeIndex: l } = this.getStates();
    l !== o && this._adapter.setNewActiveIndex(o);
  }
  getDefaultActiveIndex() {
    let o;
    const l = this.getProps();
    return "activeIndex" in l ? o = l.activeIndex : "defaultActiveIndex" in l && (o = l.defaultActiveIndex), o;
  }
}
const propTypes$$ = {
  activeKey: number$2,
  className: string$3,
  position: string$3,
  size: string$3,
  style: object$1,
  theme: string$3,
  total: number$2,
  onIndicatorChange: func,
  type: String,
  trigger: string$3,
  activeIndex: number$2,
  defaultActiveIndex: number$2
}, vuePropsType$1B = vuePropsMake(propTypes$$, {}), CarouselIndicator = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1B
  },
  name: "CarouselIndicator",
  setup(s, {}) {
    useSlots();
    const o = (m) => {
      s.onIndicatorChange(m);
    }, l = (m) => {
      const {
        trigger: g
      } = s;
      g === "click" && o(m);
    }, u = (m) => {
      const {
        trigger: g
      } = s;
      g === "hover" && o(m);
    };
    function c() {
      const {
        total: m,
        theme: g,
        size: v,
        activeIndex: b
      } = s, S = [];
      for (let E = 0; E < m; E++)
        S.push(createVNode("span", {
          key: E,
          "data-index": E,
          class: cls([`${cssClasses$m.CAROUSEL_INDICATOR}-item`], {
            [`${cssClasses$m.CAROUSEL_INDICATOR}-item-active`]: E === b,
            [`${cssClasses$m.CAROUSEL_INDICATOR}-item-${g}`]: g,
            [`${cssClasses$m.CAROUSEL_INDICATOR}-item-${v}`]: v
          }),
          onClick: () => l(E),
          onMouseenter: () => u(E)
        }, null));
      return S;
    }
    return () => {
      const {
        type: m,
        size: g,
        theme: v,
        style: b,
        className: S,
        position: E,
        ...P
      } = s, T = cls(S, {
        [cssClasses$m.CAROUSEL_INDICATOR]: !0,
        [`${cssClasses$m.CAROUSEL_INDICATOR}-${m}`]: m,
        [`${cssClasses$m.CAROUSEL_INDICATOR}-${E}`]: E
      }), N = c();
      return createVNode("div", mergeProps$1({
        class: T,
        style: b
      }, getDataAttr(P)), [N]);
    };
  }
}), vuePropsType$1A = {
  type: String,
  theme: String,
  prev: Function,
  next: Function,
  arrowProps: Object
}, CarouselArrow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1A
  },
  name: "CarouselArrow",
  setup(s, {}) {
    useSlots();
    const o = () => lodashExports.get(s, "arrowProps.leftArrow.children", createVNode(IconComponent$z, {
      "aria-label": "Previous index",
      size: "inherit"
    }, null)), l = () => lodashExports.get(s, "arrowProps.rightArrow.children", createVNode(IconComponent$y, {
      "aria-label": "Next index",
      size: "inherit"
    }, null));
    return () => {
      const {
        type: u,
        theme: c,
        prev: m,
        next: g
      } = s, v = cls({
        [cssClasses$m.CAROUSEL_ARROW]: !0,
        [`${cssClasses$m.CAROUSEL_ARROW}-${c}`]: c,
        [`${cssClasses$m.CAROUSEL_ARROW}-hover`]: u === "hover"
      }), b = cls({
        [`${cssClasses$m.CAROUSEL_ARROW}-prev`]: !0,
        [`${cssClasses$m.CAROUSEL_ARROW}-${c}`]: c
      }), S = cls({
        [`${cssClasses$m.CAROUSEL_ARROW}-next`]: !0,
        [`${cssClasses$m.CAROUSEL_ARROW}-${c}`]: c
      });
      return createVNode("div", {
        class: v
      }, [createVNode("div", mergeProps$1({
        className: b,
        onClick: m
      }, lodashExports.get(s, "arrowProps.leftArrow.props"), {
        "x-semi-prop": "arrowProps.leftArrow.children"
      }), [o()]), createVNode("div", mergeProps$1({
        className: S,
        onClick: g
      }, lodashExports.get(s, "arrowProps.rightArrow.props"), {
        "x-semi-prop": "arrowProps.rightArrow.children"
      }), [l()])]);
    };
  }
}), propTypes$_ = {
  activeIndex: number$2,
  animation: string$3,
  arrowProps: object$1,
  autoPlay: oneOfType([bool, object$1]),
  className: string$3,
  defaultActiveIndex: number$2,
  indicatorPosition: string$3,
  indicatorSize: string$3,
  indicatorType: string$3,
  theme: string$3,
  onChange: func,
  arrowType: string$3,
  showArrow: bool,
  showIndicator: bool,
  slideDirection: string$3,
  speed: number$2,
  style: object$1,
  trigger: string$3
}, defaultProps$U = {
  // children: [],
  animation: "slide",
  autoPlay: !0,
  arrowType: "always",
  defaultActiveIndex: numbers$7.DEFAULT_ACTIVE_INDEX,
  indicatorPosition: "center",
  indicatorSize: "small",
  indicatorType: "dot",
  theme: "light",
  onChange: () => {
  },
  showArrow: !0,
  showIndicator: !0,
  slideDirection: "left",
  speed: numbers$7.DEFAULT_SPEED,
  trigger: "click"
}, vuePropsType$1z = vuePropsMake(propTypes$_, defaultProps$U), Carousel = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1z
  },
  name: "Carousel",
  setup(s, {
    expose: o
  }) {
    const l = useSlots();
    shallowRef({
      children: []
    });
    let u = [];
    const c = reactive({
      activeIndex: -1,
      children: [],
      preIndex: -1,
      isReverse: !1,
      isInit: !0
    }), {
      adapter: m,
      getDataAttr: g
    } = useBaseComponent(s, c);
    function v() {
      return {
        ...m(),
        getStates() {
          return {
            ...c,
            children: u
          };
        },
        notifyChange: (yt, xt) => {
          s.onChange(yt, xt);
        },
        setNewActiveIndex: (yt) => {
          c.activeIndex = yt;
        },
        setPreActiveIndex: (yt) => {
          c.preIndex = yt;
        },
        setIsReverse: (yt) => {
          c.isReverse = yt;
        },
        setIsInit: (yt) => {
          c.isInit = yt;
        }
      };
    }
    const b = v(), S = new CarouselFoundation(b), E = S.getDefaultActiveIndex();
    c.activeIndex = E, c.preIndex = E;
    function P(yt) {
      const xt = {};
      return !isNullOrUndefined(yt.activeIndex) && yt.activeIndex !== c.activeIndex && (xt.activeIndex = yt.activeIndex), xt;
    }
    watch([() => s.activeIndex, () => c.activeIndex], (yt) => {
      const xt = P({
        ...s
      });
      xt && Object.keys(xt).forEach((Kt) => {
        c[Kt] = xt[Kt];
      });
    }), onMounted(() => {
      W();
    }), onBeforeUnmount(() => {
      S.destroy();
    });
    const T = () => (S.setForcePlay(!0), S.handleAutoPlay()), N = () => (S.setForcePlay(!1), S.stop()), O = (yt) => S.goTo(yt), z = () => S.prev(), Q = () => S.next();
    o({
      play: T,
      stop: N,
      goTo: O,
      prev: z,
      next: Q
    });
    const W = () => {
      S.getIsControlledComponent() || S.handleAutoPlay();
    }, ue = () => {
      const {
        autoPlay: yt
      } = s;
      (yt === !0 || typeof yt == "object" && yt.hoverToPause) && S.stop();
    }, te = () => {
      const {
        autoPlay: yt
      } = s;
      (typeof yt != "object" || yt.hoverToPause) && !S.getIsControlledComponent() && S.handleAutoPlay();
    }, K = (yt) => S.onIndicatorChange(yt), ve = (yt) => S.getValidIndex(yt), ee = () => {
      const {
        speed: yt,
        animation: xt
      } = s, {
        activeIndex: Kt,
        preIndex: tn,
        isInit: ln
      } = c;
      return createVNode(Fragment, null, [u.map((rn, an) => {
        const Gt = an === Kt, nn = an === ve(Kt - 1), vt = an === ve(Kt + 1), Et = {
          transitionTimingFunction: "ease",
          transitionDuration: `${yt}ms`,
          animationTimingFunction: "ease",
          animationDuration: `${yt}ms`
        };
        return cloneVNode(rn, {
          style: {
            ...rn.props.style,
            ...Et
          },
          className: cls(rn.props.class, {
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-prev`]: nn,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-next`]: vt,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-current`]: Gt,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item`]: !0,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-active`]: Gt,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-slide-in`]: xt === "slide" && !ln && Gt,
            [`${cssClasses$m.CAROUSEL_CONTENT}-item-slide-out`]: xt === "slide" && !ln && an === tn
          })
        });
      })]);
    }, Re = () => {
      const {
        activeIndex: yt
      } = c, {
        showIndicator: xt,
        indicatorType: Kt,
        theme: tn,
        indicatorPosition: ln,
        indicatorSize: rn,
        trigger: an
      } = s, Gt = cls({
        [cssClasses$m.CAROUSEL_INDICATOR]: !0
      });
      return xt && u.length > 1 ? createVNode("div", {
        class: Gt
      }, [createVNode(CarouselIndicator, {
        type: Kt,
        total: u.length,
        activeIndex: yt,
        position: ln,
        trigger: an,
        size: rn,
        theme: tn,
        onIndicatorChange: K
      }, null)]) : null;
    }, wt = () => {
      const {
        showArrow: yt,
        arrowType: xt,
        theme: Kt,
        arrowProps: tn
      } = s;
      return yt && u.length > 1 ? createVNode(CarouselArrow, {
        type: xt,
        theme: Kt,
        prev: z,
        next: Q,
        arrowProps: tn
      }, null) : null;
    };
    return () => {
      u = getFragmentChildren(l);
      const {
        animation: yt,
        className: xt,
        style: Kt,
        slideDirection: tn
      } = s, {
        isReverse: ln
      } = c, rn = cls(xt, {
        [cssClasses$m.CAROUSEL]: !0
      });
      return createVNode("div", mergeProps$1({
        class: rn,
        style: Kt,
        onMouseenter: lodashExports.debounce(ue, 400),
        onMouseleave: lodashExports.debounce(te, 400)
      }, g()), [createVNode("div", {
        class: cls([`${cssClasses$m.CAROUSEL_CONTENT}-${yt}`], {
          [`${cssClasses$m.CAROUSEL_CONTENT}`]: !0,
          [`${cssClasses$m.CAROUSEL_CONTENT}-reverse`]: tn === "left" ? ln : !ln
        }),
        "x-semi-prop": "children"
      }, [ee()]), Re(), wt()]);
    };
  }
}), Carousel$1 = Carousel, cssClasses$l = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-collapse`
};
class CollapseFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({
      ...o
    });
  }
  initActiveKey() {
    const {
      defaultActiveKey: o,
      activeKey: l,
      accordion: u
    } = this.getProps();
    let c = l || o;
    return u && (c = Array.isArray(c) ? c[0] : c), c && c.length ? (c = Array.isArray(c) ? c : [c], c) : [];
  }
  handleChange(o, l) {
    const {
      activeKey: u,
      accordion: c
    } = this.getProps(), {
      activeSet: m
    } = this.getStates();
    let g = new Set(m);
    g.has(o) ? g.delete(o) : c ? g = /* @__PURE__ */ new Set([o]) : g.add(o), this._adapter.handleChange([...g.values()], l), typeof u > "u" && this._adapter.addActiveKey(g);
  }
}
class CollapsibleFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({
      ...o
    }), this.updateDOMInRenderTree = (l) => {
      this._adapter.setDOMInRenderTree(l);
    }, this.updateDOMHeight = (l) => {
      this._adapter.setDOMHeight(l);
    }, this.updateVisible = (l) => {
      this._adapter.setVisible(l);
    }, this.updateIsTransitioning = (l) => {
      this._adapter.setIsTransitioning(l);
    };
  }
}
const propTypes$Z = {
  motion: bool,
  isOpen: bool,
  duration: number$2,
  keepDOM: bool,
  lazyRender: bool,
  collapseHeight: number$2,
  style: object$1,
  className: string$3,
  reCalcKey: oneOfType([string$3, number$2]),
  id: string$3,
  onMotionEnd: func,
  fade: bool
}, defaultProps$T = {
  isOpen: !1,
  duration: 250,
  motion: !0,
  keepDOM: !1,
  lazyRender: !1,
  collapseHeight: 0,
  fade: !1
}, vuePropsType$1y = vuePropsMake(propTypes$Z, defaultProps$T), Collapsible = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1y
  },
  name: "Collapsible",
  setup(s, {}) {
    const o = useSlots(), l = ref$1();
    let u, c = !1;
    const m = reactive({
      domInRenderTree: !1,
      domHeight: 0,
      visible: s.isOpen,
      isTransitioning: !1
    }), {
      adapter: g,
      getDataAttr: v
    } = useBaseComponent(s, m);
    function b() {
      return {
        ...g(),
        setDOMInRenderTree: (O) => {
          m.domInRenderTree !== O && (m.domInRenderTree = O);
        },
        setDOMHeight: (O) => {
          m.domHeight !== O && (m.domHeight = O);
        },
        setVisible: (O) => {
          m.visible !== O && (m.visible = O);
        },
        setIsTransitioning: (O) => {
          m.isTransitioning !== O && (m.isTransitioning = O);
        }
      };
    }
    const S = b(), E = new CollapsibleFoundation(S), P = (O) => {
      let z;
      O.borderBoxSize ? z = !(O.borderBoxSize[0].blockSize === 0 && O.borderBoxSize[0].inlineSize === 0) : z = !(O.contentRect.height === 0 && O.contentRect.width === 0);
      let Q = 0;
      return O.borderBoxSize ? Q = Math.ceil(O.borderBoxSize[0].blockSize) : Q = O.target.clientHeight, {
        isShown: z,
        height: Q
      };
    };
    onMounted(() => {
      u = new ResizeObserver(T), u.observe(l.value);
      const O = N();
      E.updateDOMInRenderTree(O), O && E.updateDOMHeight(l.value.scrollHeight);
    }), watch(() => s.reCalcKey, (O, z, Q) => {
      E.updateDOMHeight(l.value.scrollHeight);
    }), watch(() => m.domInRenderTree, (O, z, Q) => {
      m.domInRenderTree && E.updateDOMHeight(l.value.scrollHeight);
    }), watch(() => s.isOpen, (O, z, Q) => {
      (s.isOpen || !s.motion) && E.updateVisible(s.isOpen);
    }), watch([() => s.isOpen, () => s.motion], (O, z, Q) => {
      s.motion && z[0] !== s.isOpen && E.updateIsTransitioning(!0);
    }), onBeforeUnmount(() => {
      u.disconnect();
    });
    const T = (O) => {
      const z = O[0];
      if (z) {
        const Q = P(z);
        E.updateDOMHeight(Q.height), E.updateDOMInRenderTree(Q.isShown);
      }
    }, N = () => l.value ? l.value.offsetHeight > 0 : !1;
    return () => {
      var ue;
      const O = {
        overflow: "hidden",
        height: (s.isOpen ? m.domHeight : s.collapseHeight) + "px",
        opacity: s.isOpen || !s.fade || s.collapseHeight !== 0 ? 1 : 0,
        transitionDuration: `${s.motion && m.isTransitioning ? s.duration : 0}ms`,
        ...s.style
      }, z = cls(`${cssClasses$v.PREFIX}-wrapper`, {
        [`${cssClasses$v.PREFIX}-transition`]: s.motion && m.isTransitioning
      }, s.className), Q = (ue = o.default) == null ? void 0 : ue.call(o), W = s.keepDOM && (s.lazyRender ? c : !0) || s.collapseHeight !== 0 || m.visible || s.isOpen;
      return W && !c && (c = !0), createVNode("div", mergeProps$1({
        class: z,
        style: O,
        onTransitionend: () => {
          var te;
          s.isOpen || E.updateVisible(!1), E.updateIsTransitioning(!1), (te = s.onMotionEnd) == null || te.call(s);
        }
      }, v()), [createVNode("div", {
        "x-semi-prop": "children",
        ref: l,
        style: {
          overflow: "hidden"
        },
        id: s.id
      }, [W && Q])]);
    };
  }
}), Collapsible$1 = Collapsible;
function useCollapseContext() {
  return {
    context: inject("CollapseContext", ref$1({}))
  };
}
const vuePropsType$1x = {
  name: String
}, Consumer$c = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1x
  },
  name: "CollapseConsumer",
  setup() {
    const s = useSlots(), {
      context: o
    } = useCollapseContext();
    return () => s.default ? s.default(o) : null;
  }
}), propTypes$Y = {
  itemKey: {
    type: string$3,
    required: !0
  },
  extra: node$1,
  header: oneOfType([string$3, node$1]),
  className: string$3,
  reCalcKey: oneOfType([string$3, number$2]),
  showArrow: bool,
  disabled: bool,
  style: object$1,
  onMotionEnd: func
}, defaultProps$S = {
  showArrow: !0,
  disabled: !1
}, vuePropsType$1w = vuePropsMake(propTypes$Y, defaultProps$S), CollapsePanel = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1w
  },
  name: "CollapsePanel",
  setup(s, {}) {
    let o = "";
    onMounted(() => {
      o = getUuidShort({});
    });
    const l = useSlots(), u = ref$1(), {
      context: c
    } = useCollapseContext();
    function m(v, b = !0) {
      const {
        showArrow: S,
        header: E,
        extra: P
      } = s;
      let {
        expandIcon: T,
        collapseIcon: N
      } = c.value;
      const {
        expandIconPosition: O
      } = c.value;
      typeof T > "u" && (T = createVNode(IconComponent$A, null, null)), typeof N > "u" && (N = createVNode(IconComponent$x, null, null));
      const z = createVNode("span", {
        ref: u,
        "aria-hidden": "true",
        class: cls([`${cssClasses$l.PREFIX}-header-icon`, {
          [`${cssClasses$l.PREFIX}-header-iconDisabled`]: !b
        }])
      }, [b && v ? N : T]), Q = O === "left";
      return typeof E == "string" ? createVNode(Fragment, null, [S && (Q ? z : null), createVNode("span", null, [E]), createVNode("span", {
        class: `${cssClasses$l.PREFIX}-header-right`
      }, [createVNode("span", null, [P]), S && (Q ? null : z)])]) : createVNode(Fragment, null, [S && (Q ? z : null), E, S && (Q ? null : z)]);
    }
    const g = (v, b) => {
      var S;
      (c.value.clickHeaderToExpand || (S = u.value) != null && S.contains(b.target)) && c.value.onClick(v, b);
    };
    return () => {
      var yt;
      const v = (yt = l.default) == null ? void 0 : yt.call(l), {
        className: b,
        itemKey: S,
        reCalcKey: E,
        header: P,
        extra: T,
        showArrow: N,
        disabled: O,
        ...z
      } = s, {
        keepDOM: Q,
        expandIconPosition: W,
        activeSet: ue,
        motion: te,
        lazyRender: K
      } = c.value, ve = ue.has(S), ee = cls(b, {
        [`${cssClasses$l.PREFIX}-item`]: !0
      }), Re = cls({
        [`${cssClasses$l.PREFIX}-header`]: !0,
        [`${cssClasses$l.PREFIX}-header-disabled`]: O,
        [`${cssClasses$l.PREFIX}-header-iconLeft`]: W === "left"
      }), wt = cls({
        [`${cssClasses$l.PREFIX}-content`]: !0
      });
      return createVNode("div", mergeProps$1({
        class: ee
      }, z), [createVNode("div", {
        role: "button",
        tabindex: 0,
        class: Re,
        "aria-disabled": O,
        "aria-expanded": ve ? "true" : "false",
        "aria-owns": o,
        onClick: (xt) => !O && g(S, xt)
      }, [m(ve, v !== void 0 && !O)]), v && createVNode(Collapsible$1, {
        lazyRender: K,
        isOpen: ve,
        keepDOM: Q,
        motion: te,
        reCalcKey: E,
        onMotionEnd: s.onMotionEnd
      }, {
        default: () => [createVNode("div", {
          class: wt,
          "aria-hidden": !ve,
          id: o
        }, [createVNode("div", {
          class: `${cssClasses$l.PREFIX}-content-wrapper`
        }, [v])])]
      })]);
    };
  }
}), CollapsePanel$1 = CollapsePanel, vuePropsType$1v = {
  value: Object
}, Provider$b = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1v
  },
  name: "CollapseProvider",
  setup(s, {
    slots: o
  }) {
    const l = ref$1();
    return watch(() => s.value, () => {
      l.value = s.value;
    }, {
      deep: !0,
      immediate: !0
    }), provide("CollapseContext", l), () => o.default ? o.default(l.value) : null;
  }
}), CollapseContext = {
  Provider: Provider$b,
  Consumer: Consumer$c
};
function _isSlot$n(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$X = {
  activeKey: oneOfType([string$3, array$1]),
  defaultActiveKey: oneOfType([string$3, array$1]),
  accordion: bool,
  clickHeaderToExpand: bool,
  onChange: func,
  expandIcon: node$1,
  collapseIcon: node$1,
  style: object$1,
  className: string$3,
  keepDOM: bool,
  motion: oneOfType([bool, func, object$1]),
  expandIconPosition: string$3,
  lazyRender: bool
}, defaultProps$R = {
  defaultActiveKey: "",
  clickHeaderToExpand: !0,
  onChange: noop$1,
  expandIconPosition: "right",
  lazyRender: !1
}, vuePropsType$1u = vuePropsMake(propTypes$X, defaultProps$R), Collapse = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1u
  },
  name: "Collapse",
  setup(s, {}) {
    const o = useSlots(), l = reactive({
      activeSet: /* @__PURE__ */ new Set()
    }), {
      adapter: u,
      getDataAttr: c
    } = useBaseComponent(s, l);
    function m() {
      return {
        ...u(),
        handleChange: (P, T) => s.onChange(P, T),
        addActiveKey: (P) => l.activeSet = P
      };
    }
    const g = m(), v = new CollapseFoundation(g), b = v.initActiveKey();
    l.activeSet = new Set(b);
    function S(P) {
      if (P.activeKey) {
        const T = Array.isArray(P.activeKey) ? P.activeKey : [P.activeKey], N = new Set(T);
        return lodashExports.isEqual(N, l.activeSet) ? l : {
          ...l,
          activeSet: N
        };
      }
      return l;
    }
    watch([() => s.activeKey, () => l.activeSet], () => {
      const P = S({
        ...s
      });
      P && Object.keys(P).forEach((T) => {
        l[T] = P[T];
      });
    }, {
      deep: !0
    }), onBeforeUnmount(() => {
      v.destroy();
    });
    const E = (P, T) => {
      v.handleChange(P, T);
    };
    return () => {
      var xt;
      const P = (xt = o.default) == null ? void 0 : xt.call(o), {
        defaultActiveKey: T,
        lazyRender: N,
        accordion: O,
        style: z,
        motion: Q,
        className: W,
        keepDOM: ue,
        expandIconPosition: te,
        expandIcon: K,
        collapseIcon: ve,
        clickHeaderToExpand: ee,
        ...Re
      } = s, wt = cls(cssClasses$l.PREFIX, W), {
        activeSet: yt
      } = l;
      return createVNode("div", mergeProps$1({
        class: wt,
        style: z
      }, c()), [createVNode(CollapseContext.Provider, {
        value: {
          activeSet: yt,
          expandIcon: K,
          collapseIcon: ve,
          clickHeaderToExpand: ee,
          keepDOM: ue,
          expandIconPosition: te,
          onClick: E,
          motion: Q,
          lazyRender: N
        }
      }, _isSlot$n(P) ? P : {
        default: () => [P]
      })]);
    };
  }
}), Collapse$1 = Collapse, cssClasses$k = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-descriptions`
}, vuePropsType$1t = {
  value: Object
}, Provider$a = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1t
  },
  name: "DescriptionsProvider",
  setup(s, {
    slots: o
  }) {
    const l = ref$1();
    return watch(() => s.value, () => {
      l.value = s.value;
    }, {
      deep: !0,
      immediate: !0
    }), provide("DescriptionsContext", l), () => o.default ? o.default(l.value) : null;
  }
});
function useDescriptionsContext() {
  return {
    context: inject("DescriptionsContext", ref$1(null))
  };
}
const vuePropsType$1s = {
  name: String
}, Consumer$b = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1s
  },
  name: "DescriptionsConsumer",
  setup() {
    const s = useSlots(), {
      context: o
    } = useDescriptionsContext();
    return () => s.default ? s.default(o) : null;
  }
}), DescriptionsContext = {
  Provider: Provider$a,
  Consumer: Consumer$b
}, prefixCls$j = cssClasses$k.PREFIX, keyCls = `${prefixCls$j}-key`, valCls = `${prefixCls$j}-value`, propTypes$W = {
  itemKey: node$1,
  hidden: bool,
  className: string$3,
  style: object$1,
  span: number$2,
  value: node$1
}, vuePropsType$1r = vuePropsMake(propTypes$W, {}), DescriptionsItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1r
  },
  name: "DescriptionsItem",
  setup(s, {}) {
    const o = useSlots();
    useAttrs();
    const {
      context: l
    } = useDescriptionsContext();
    return () => {
      var Q;
      const u = (Q = o.default) == null ? void 0 : Q.call(o), {
        itemKey: c,
        hidden: m,
        className: g,
        span: v,
        style: b,
        ...S
      } = s, {
        align: E,
        layout: P
      } = l.value;
      if (m)
        return null;
      const T = createVNode("td", {
        class: `${prefixCls$j}-item`,
        colspan: v || 1
      }, [createVNode("span", {
        class: keyCls
      }, [c, createTextVNode(":")]), createVNode("span", {
        class: valCls
      }, [u])]), N = createVNode(Fragment, null, [createVNode("th", {
        class: `${prefixCls$j}-item ${prefixCls$j}-item-th`
      }, [createVNode("span", {
        class: keyCls
      }, [c])]), createVNode("td", {
        class: `${prefixCls$j}-item ${prefixCls$j}-item-td`,
        colspan: v ? v * 2 - 1 : 1
      }, [createVNode("span", {
        class: valCls
      }, [u])])]), O = E === "plain" ? createVNode("tr", mergeProps$1({
        class: g,
        style: b
      }, getDataAttr(S)), [T]) : createVNode("tr", mergeProps$1({
        class: g,
        style: b
      }, getDataAttr(S)), [N]);
      return P === "horizontal" ? E === "plain" ? T : N : O;
    };
  }
}), Item$2 = DescriptionsItem;
class DescriptionsFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  getHorizontalList() {
    const { column: o, data: l, children: u } = this.getProps(), c = this._adapter.getColumns(), m = [], g = { totalSpan: 0, itemList: [] };
    for (const v of c)
      g.totalSpan += v.span || 1, g.itemList.push(v), g.totalSpan >= o && (m.push(g.itemList), g.itemList = [], g.totalSpan = 0);
    if (g.itemList.length != 0) {
      const v = g.itemList[g.itemList.length - 1];
      if (isNaN(v.span)) {
        let b = 0;
        g.itemList.forEach((S) => b += isNaN(S.span) ? 1 : S.span), b < o && (v.span = o - b + 1);
      }
      m.push(g.itemList);
    }
    return m;
  }
}
function _isSlot$m(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$i = cssClasses$k.PREFIX, propTypes$V = {
  align: string$3,
  row: bool,
  size: string$3,
  style: object$1,
  className: string$3,
  data: array$1,
  layout: string$3,
  column: number$2
}, defaultProps$Q = {
  align: "center",
  row: !1,
  size: "medium",
  data: [],
  layout: "vertical",
  column: 3
}, vuePropsType$1q = vuePropsMake(propTypes$V, defaultProps$Q), Descriptions = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1q
  },
  name: "Descriptions",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs(), {
      adapter: u
    } = useBaseComponent(s, {});
    function c() {
      return {
        ...u(),
        getColumns: () => {
          var E;
          if ((E = s.data) != null && E.length)
            return s.data;
          const S = getFragmentChildren(o);
          return S ? S.map((P) => {
            var T, N;
            return isVNode(P) ? {
              //@ts-ignore
              value: (N = (T = P.children).default) == null ? void 0 : N.call(T),
              ...P.props
            } : [];
          }) : [];
        }
      };
    }
    const m = c();
    new DescriptionsFoundation(m);
    function g(S) {
      const {
        column: E
      } = m.getProps();
      if (S.length === 0)
        return;
      const P = S[S.length - 1];
      if (P.span && !isNaN(P.span))
        return;
      let T = 0;
      S.forEach((N) => T += isNaN(N.span) ? 1 : N.span), T < E && (P.span = E - T + 1);
    }
    function v() {
      const {
        column: S
      } = m.getProps(), E = m.getColumns(), P = [], T = {
        totalSpan: 0,
        itemList: []
      };
      return E.forEach((N, O) => {
        let z = N.span || 1, Q = S - T.totalSpan;
        z <= Q ? (T.itemList.push(N), T.totalSpan = T.totalSpan + z) : (z > S && (z = S), g(T.itemList), P.push(T.itemList), T.totalSpan = z, T.itemList = [N]), O === E.length - 1 && (g(T.itemList), P.push(T.itemList));
      }), P;
    }
    const b = () => {
      const S = getFragmentChildren(o), {
        layout: E,
        data: P
      } = s;
      return E === "horizontal" ? v().map((N, O) => createVNode("tr", {
        key: O
      }, [N.map((z, Q) => lodashExports.isPlainObject(z) ? createVNode(Item$2, mergeProps$1({
        itemKey: z.key
      }, z, {
        key: O + "-" + Q
      }), {
        default: () => [z.value]
      }) : null)])) : P && P.length ? P.map((T, N) => lodashExports.isPlainObject(T) ? createVNode(Item$2, mergeProps$1({
        itemKey: T.key
      }, T, {
        key: N
      }), {
        default: () => [T.value]
      }) : null) : S;
    };
    return () => {
      let S;
      const {
        align: E,
        row: P,
        size: T,
        className: N,
        style: O,
        data: z,
        layout: Q,
        ...W
      } = s, ue = cls(prefixCls$i, N, {
        [`${prefixCls$i}-${E}`]: !P,
        [`${prefixCls$i}-double`]: P,
        [`${prefixCls$i}-double-${T}`]: P,
        [`${prefixCls$i}-horizontal`]: Q === "horizontal",
        [`${prefixCls$i}-vertical`]: Q === "vertical"
      });
      return createVNode("div", mergeProps$1({
        class: ue,
        style: O
      }, getDataAttr({
        ...W,
        ...l
      })), [createVNode("table", null, [createVNode("tbody", null, [createVNode(DescriptionsContext.Provider, {
        value: {
          align: E,
          layout: Q
        }
      }, _isSlot$m(S = b()) ? S : {
        default: () => [S]
      })])])]);
    };
  }
}), Descriptions$1 = Descriptions, cssClasses$j = {
  DIALOG: `${BASE_CLASS_PREFIX$1}-modal`
};
class ModalFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({
      ...o
    }), this.toggleDisplayNone = (l, u) => {
      this._adapter.toggleDisplayNone(l, u);
    };
  }
  destroy() {
    this.afterHide();
  }
  handleCancel(o) {
    var u;
    const l = this._adapter.notifyCancel(o);
    isPromise(l) && (this._adapter.setState({ onCancelReturnPromiseStatus: "pending" }), (u = l == null ? void 0 : l.then(() => {
      this._adapter.setState({ onCancelReturnPromiseStatus: "fulfilled" });
    })) == null || u.catch((c) => {
      throw this._adapter.setState({ onCancelReturnPromiseStatus: "rejected" }), c;
    }));
  }
  handleOk(o) {
    var u;
    const l = this._adapter.notifyOk(o);
    isPromise(l) && (this._adapter.setState({ onOKReturnPromiseStatus: "pending" }), (u = l == null ? void 0 : l.then(() => {
      this._adapter.setState({ onOKReturnPromiseStatus: "fulfilled" });
    })) == null || u.catch((c) => {
      throw this._adapter.setState({ onOKReturnPromiseStatus: "rejected" }), c;
    }));
  }
  beforeShow() {
    this._adapter.disabledBodyScroll();
  }
  afterHide() {
    this._adapter.enabledBodyScroll(), this._adapter.notifyClose();
  }
  enabledBodyScroll() {
    this._adapter.enabledBodyScroll();
  }
  // mergeMotionProp = (motion: Motion, prop: string, cb: () => void) => {
  //     const mergedMotion = typeof (motion) === 'undefined' || motion ? {
  //         ...(motion as { [key: string]: (() => void) | boolean }),
  //         [prop]: (...args: any) => {
  //             const curr = get(motion, prop);
  //             if (typeof curr === 'function') {
  //                 curr(...args);
  //             }
  //             cb();
  //         }
  //     } : false;
  //     return mergedMotion;
  // };
  //
  // getMergedMotion() {
  //     let { motion } = this._adapter.getProps();
  //     const { keepDOM } = this._adapter.getProps();
  //     motion = this.mergeMotionProp(motion, 'didLeave', this.afterClose.bind(this));
  //     if (!keepDOM) {
  //         return motion;
  //     }
  //     const mergedMotion = this.mergeMotionProp(motion, 'didLeave', this.toggleHidden.bind(this, true));
  //     return mergedMotion;
  // }
}
class ModalContentFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...ModalContentFoundation.defaultAdapter, ...o }), this.handleKeyDown = (l) => {
      const { closeOnEsc: u } = this.getProps();
      if (u && l.keyCode === KeyCode.ESC) {
        l.stopPropagation(), this.close(l);
        return;
      }
    };
  }
  destroy() {
    this.handleKeyDownEventListenerUnmount(), this.modalDialogBlur(), this.prevFocusElementReFocus();
  }
  handleDialogMouseDown() {
    this._adapter.notifyDialogMouseDown();
  }
  handleMaskMouseUp() {
    this._adapter.notifyDialogMouseUp();
  }
  handleKeyDownEventListenerMount() {
    this._adapter.addKeyDownEventListener();
  }
  handleKeyDownEventListenerUnmount() {
    this._adapter.removeKeyDownEventListener();
  }
  getMouseState() {
    this._adapter.getMouseState();
  }
  handleMaskClick(o) {
    const { dialogMouseDown: l } = this.getStates();
    o.target === o.currentTarget && !l && this.close(o);
  }
  close(o) {
    this._adapter.notifyClose(o);
  }
  modalDialogFocus() {
    this._adapter.modalDialogFocus();
  }
  modalDialogBlur() {
    this._adapter.modalDialogBlur();
  }
  prevFocusElementReFocus() {
    this._adapter.prevFocusElementReFocus();
  }
}
class FocusTrapHandle {
  constructor(o, l) {
    this.addFocusRedirectListener = (u) => (this.focusRedirectListenerList.push(u), () => this.removeFocusRedirectListener(u)), this.removeFocusRedirectListener = (u) => {
      this.focusRedirectListenerList = lodashExports.without(this.focusRedirectListenerList, u);
    }, this.destroy = () => {
      var u;
      (u = this.container) == null || u.removeEventListener("keydown", this.onKeyPress);
    }, this.shouldFocusRedirect = (u) => {
      if (!this.enable)
        return !1;
      for (const c of this.focusRedirectListenerList)
        if (!c(u))
          return !1;
      return !0;
    }, this.focusElement = (u, c) => {
      const { preventScroll: m } = this.options;
      u == null || u.focus({ preventScroll: m }), c.preventDefault();
    }, this.onKeyPress = (u) => {
      if (u && u.key === "Tab") {
        const c = FocusTrapHandle.getFocusableElements(this.container);
        c.length && (u.shiftKey ? this.handleContainerShiftTabKeyDown(c, u) : this.handleContainerTabKeyDown(c, u));
      }
    }, this.handleContainerTabKeyDown = (u, c) => {
      const m = FocusTrapHandle.getActiveElement(), g = u[u.length - 1] === m, v = u[0];
      g && this.shouldFocusRedirect(v) && this.focusElement(v, c);
    }, this.handleContainerShiftTabKeyDown = (u, c) => {
      const m = FocusTrapHandle.getActiveElement(), g = u[0] === m, v = u[u.length - 1];
      g && this.shouldFocusRedirect(v) && this.focusElement(v, c);
    }, Object.freeze(l), this.container = o, this.options = l, this.enable = (l == null ? void 0 : l.enable) ?? !0, this.focusRedirectListenerList = l != null && l.onFocusRedirectListener ? Array.isArray(l.onFocusRedirectListener) ? [...l.onFocusRedirectListener] : [l.onFocusRedirectListener] : [], this.container.addEventListener("keydown", this.onKeyPress);
  }
  get enable() {
    return this._enable;
  }
  set enable(o) {
    this._enable = o;
  }
  // ---- static func ----
  static getFocusableElements(o) {
    if (!isElement$1(o))
      return [];
    const u = [
      "input:not([disabled]):not([tabindex='-1'])",
      "textarea:not([disabled]):not([tabindex='-1'])",
      "button:not([disabled]):not([tabindex='-1'])",
      "a[href]:not([tabindex='-1'])",
      "select:not([disabled]):not([tabindex='-1'])",
      "area[href]:not([tabindex='-1'])",
      "iframe:not([tabindex='-1'])",
      "object:not([tabindex='-1'])",
      "*[tabindex]:not([tabindex='-1'])",
      "*[contenteditable]:not([tabindex='-1'])"
    ].join(",");
    return Array.from(o.querySelectorAll(u));
  }
  static getActiveElement() {
    return document ? document.activeElement : null;
  }
}
function _isSlot$l(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
let uuid$1 = 0;
const propTypes$U = {
  onClose: {
    type: Function,
    required: !0
  },
  // close: PropTypes.func as PropType<ModalContentReactProps['close']>,
  getContainerContext: {
    type: func,
    required: !0
  },
  contentClassName: string$3,
  maskClassName: string$3,
  onAnimationEnd: func,
  preventScroll: bool,
  isFullScreen: bool,
  maskExtraProps: Object,
  contentExtraProps: Object,
  title: any$1,
  afterClose: Function,
  bodyStyle: Object,
  cancelButtonProps: any$1,
  cancelText: string$3,
  centered: bool,
  className: string$3,
  closable: bool,
  confirmLoading: bool,
  cancelLoading: bool,
  content: {
    type: any$1,
    default: void 0
  },
  footer: {
    type: any$1,
    default: void 0
  },
  hasCancel: bool,
  header: {
    type: any$1,
    default: void 0
  },
  height: [bool, string$3],
  mask: bool,
  maskClosable: bool,
  maskStyle: Object,
  maskFixed: bool,
  motion: any$1,
  okButtonProps: any$1,
  okText: String,
  okType: String,
  onCancel: Function,
  onOk: Function,
  style: Object,
  visible: bool,
  width: [String, Number],
  zIndex: Number,
  icon: any$1,
  getPopupContainer: Function,
  closeIcon: any$1,
  closeOnEsc: bool,
  size: String,
  lazyRender: bool,
  keepDOM: bool,
  direction: any$1,
  fullScreen: bool,
  modalContentClass: String,
  footerFill: Boolean
}, defaultProps$P = {
  close: lodashExports.noop,
  onClose: lodashExports.noop,
  getContainerContext: lodashExports.noop,
  contentClassName: "",
  maskClassName: ""
}, vuePropsType$1p = vuePropsMake(propTypes$U, defaultProps$P), ModalContent = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1p
  },
  name: "ModalContent",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs();
    let u, {
      context: c
    } = useConfigContext(), m;
    const g = reactive({
      dialogMouseDown: !1,
      prevFocusElement: FocusTrapHandle.getActiveElement()
    });
    let v = `dialog-${uuid$1++}`;
    const b = ref$1(), {
      adapter: S
    } = useBaseComponent(s, g);
    function E() {
      return {
        ...S(),
        notifyClose: (Re) => {
          s.onClose(Re);
        },
        notifyDialogMouseDown: () => {
          g.dialogMouseDown = !0;
        },
        notifyDialogMouseUp: () => {
          g.dialogMouseDown && (u = setTimeout(() => {
            g.dialogMouseDown = !1;
          }, 0));
        },
        addKeyDownEventListener: () => {
          s.closeOnEsc && document.addEventListener("keydown", T.handleKeyDown.bind(T));
        },
        removeKeyDownEventListener: () => {
          s.closeOnEsc && document.removeEventListener("keydown", T.handleKeyDown.bind(T));
        },
        getMouseState: () => g.dialogMouseDown,
        modalDialogFocus: () => {
          const {
            preventScroll: Re
          } = s;
          let wt;
          if (b.value) {
            const yt = FocusTrapHandle.getActiveElement();
            wt = b.value.contains(yt), m == null || m.destroy(), m = new FocusTrapHandle(b.value, {
              preventScroll: Re
            });
          }
          wt || b == null || b.value.focus({
            preventScroll: Re
          });
        },
        modalDialogBlur: () => {
          b.value.blur(), m == null || m.destroy();
        },
        prevFocusElementReFocus: () => {
          const {
            prevFocusElement: Re
          } = g, {
            preventScroll: wt
          } = s, yt = lodashExports.get(Re, "focus");
          lodashExports.isFunction(yt) && Re.focus({
            preventScroll: wt
          });
        }
      };
    }
    const P = E(), T = new ModalContentFoundation(P);
    onMounted(() => {
      var wt;
      T.handleKeyDownEventListenerMount(), T.modalDialogFocus();
      const Re = FocusTrapHandle.getFocusableElements(b.value);
      b.value.contains(document.activeElement) || (wt = Re[0]) == null || wt.focus();
    }), onBeforeUnmount(() => {
      clearTimeout(u), T.destroy();
    });
    const N = () => {
      T.handleDialogMouseDown();
    }, O = () => {
      T.handleMaskMouseUp();
    }, z = (Re) => {
      T.handleMaskClick(Re);
    }, Q = (Re) => {
      T.close(Re);
    }, W = () => {
      const {
        mask: Re,
        maskClassName: wt
      } = s;
      if (Re) {
        const yt = cls(`${cssClasses$j.DIALOG}-mask`, {
          // [`${cssClasses.DIALOG}-mask-hidden`]: !props.visible,
        });
        return createVNode("div", {
          key: "mask",
          class: cls(yt, wt),
          style: s.maskStyle
        }, null);
      }
      return null;
    }, ue = () => {
      const {
        closable: Re,
        closeIcon: wt
      } = s;
      let yt;
      if (Re) {
        const xt = (typeof wt == "function" ? wt() : wt) || createVNode(IconComponent$u, {
          "x-semi-prop": "closeIcon"
        }, null);
        yt = createVNode(Button$3, {
          "aria-label": "close",
          class: `${cssClasses$j.DIALOG}-close`,
          key: "close-btn",
          onClick: Q,
          type: "tertiary",
          icon: xt,
          theme: "borderless",
          size: "small"
        }, null);
      }
      return yt;
    }, te = () => {
      const {
        icon: Re
      } = s;
      return Re ? createVNode("span", {
        class: `${cssClasses$j.DIALOG}-icon-wrapper`,
        "x-semi-prop": "icon"
      }, [typeof Re == "function" ? Re() : Re]) : null;
    }, K = () => {
      if ("header" in P.getProps())
        return typeof s.header == "function" ? s.header() : s.header;
      const {
        title: Re
      } = s, wt = ue(), yt = te();
      return Re == null ? null : createVNode("div", {
        class: `${cssClasses$j.DIALOG}-header`
      }, [yt, createVNode(TypographyTitle, {
        heading: 5,
        class: `${cssClasses$j.DIALOG}-title`,
        id: `${cssClasses$j.DIALOG}-title`,
        "x-semi-prop": "title"
      }, _isSlot$l(Re) ? Re : {
        default: () => [Re]
      }), wt]);
    }, ve = () => {
      const {
        bodyStyle: Re,
        title: wt
      } = s, yt = cls(`${cssClasses$j.DIALOG}-body`, {
        [`${cssClasses$j.DIALOG}-withIcon`]: s.icon
      }), xt = ue(), Kt = te();
      return wt != null || "header" in P.getProps() ? createVNode("div", {
        class: yt,
        id: `${cssClasses$j.DIALOG}-body`,
        style: Re,
        "x-semi-prop": "children"
      }, {
        default: o.default
      }) : createVNode("div", {
        class: `${cssClasses$j.DIALOG}-body-wrapper`
      }, [Kt, createVNode("div", {
        class: yt,
        style: Re,
        "x-semi-prop": "children"
      }, {
        default: o.default
      }), xt]);
    }, ee = () => {
      const Re = {}, wt = cls(`${cssClasses$j.DIALOG}`, {
        [`${cssClasses$j.DIALOG}-centered`]: s.centered,
        [`${cssClasses$j.DIALOG}-${s.size}`]: s.size
      });
      s.width && (Re.width = lodashExports.isNumber(s.width) ? s.width + "px" : s.width), s.height && (Re.height = lodashExports.isNumber(s.height) ? s.height + "px" : s.height), s.isFullScreen && (Re.width = "100%", Re.height = "100%", Re.margin = "unset");
      const yt = ve(), xt = K(), Kt = s.footer ? createVNode("div", {
        class: `${cssClasses$j.DIALOG}-footer`,
        "x-semi-prop": "footer"
      }, [s.footer]) : null;
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        createVNode("div", {
          key: "dialog-element",
          class: wt,
          onMousedown: N,
          style: {
            ...s.style,
            ...Re
          },
          id: v
        }, [createVNode("div", {
          role: "dialog",
          ref: b,
          "aria-modal": "true",
          "aria-labelledby": `${cssClasses$j.DIALOG}-title`,
          "aria-describedby": `${cssClasses$j.DIALOG}-body`,
          onAnimationend: s.onAnimationEnd,
          class: cls([`${cssClasses$j.DIALOG}-content`, s.contentClassName, {
            [`${cssClasses$j.DIALOG}-content-fullScreen`]: s.isFullScreen
          }])
        }, [xt, yt, Kt])])
      );
    };
    return () => {
      const {
        maskClosable: Re,
        className: wt,
        getPopupContainer: yt,
        maskFixed: xt,
        getContainerContext: Kt,
        ...tn
      } = s, {
        direction: ln
      } = c.value, rn = cls(wt, {
        [`${cssClasses$j.DIALOG}-popup`]: yt && yt() !== document.body && !xt,
        [`${cssClasses$j.DIALOG}-fixed`]: xt,
        [`${cssClasses$j.DIALOG}-rtl`]: ln === "rtl"
      }), an = Kt(), Gt = getDataAttr({
        ...tn,
        ...l
      }), nn = createVNode("div", mergeProps$1({
        class: rn
      }, Gt), [W(), createVNode("div", mergeProps$1({
        role: "none",
        class: cls({
          [`${cssClasses$j.DIALOG}-wrap`]: !0,
          [`${cssClasses$j.DIALOG}-wrap-center`]: s.centered
        }),
        onClick: Re ? z : null,
        onMouseup: Re ? O : null
      }, s.contentExtraProps), [ee()])]);
      return an && an.Provider ? createVNode(an.Provider, {
        value: an.value
      }, _isSlot$l(nn) ? nn : {
        default: () => [nn]
      }) : nn;
    };
  }
}), propTypes$T = {
  type: {
    type: String,
    required: !0
  },
  mask: {
    type: bool,
    default: void 0
  },
  closable: {
    type: bool,
    default: void 0
  },
  centered: {
    type: bool,
    default: void 0
  },
  visible: {
    type: bool,
    default: void 0
  },
  width: oneOfType([string$3, number$2]),
  height: oneOfType([string$3, number$2]),
  confirmLoading: {
    type: bool,
    default: void 0
  },
  cancelLoading: {
    type: bool,
    default: void 0
  },
  okText: string$3,
  okType: string$3,
  cancelText: string$3,
  maskClosable: {
    type: bool,
    default: void 0
  },
  onCancel: func,
  onOk: func,
  afterClose: func,
  okButtonProps: object$1,
  cancelButtonProps: object$1,
  style: object$1,
  className: string$3,
  maskStyle: object$1,
  bodyStyle: object$1,
  zIndex: number$2,
  title: node$1,
  icon: node$1,
  header: node$1,
  footer: node$1,
  hasCancel: {
    type: bool,
    default: void 0
  },
  motion: oneOfType([bool, func, object$1]),
  getPopupContainer: func,
  getContainerContext: func,
  maskFixed: {
    type: bool,
    default: void 0
  },
  closeIcon: node$1,
  closeOnEsc: {
    type: bool,
    default: void 0
  },
  size: String,
  keepDOM: {
    type: bool,
    default: void 0
  },
  lazyRender: {
    type: bool,
    default: void 0
  },
  direction: String,
  fullScreen: {
    type: bool,
    default: void 0
  },
  content: [String, Object, Function],
  modalContentClass: String,
  preventScroll: Boolean,
  footerFill: Boolean
}, defaultProps$O = {}, vuePropsType$1o = vuePropsMake(propTypes$T, defaultProps$O), ConfirmModal = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1o
  },
  name: "ConfirmModal",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    const l = ref$1(!0);
    function u(E) {
      l.value = E;
    }
    const c = ref$1();
    function m(E) {
      c.value = E;
    }
    const g = ref$1();
    function v(E) {
      g.value = E;
    }
    const b = computed(() => (E) => {
      const P = s.onOk && s.onOk(E);
      P && P.then ? (m(!0), P.then((...T) => {
        u(!1), m(!1);
      }, (T) => {
        m(!1);
      })) : u(!1);
    }), S = computed(() => (E) => {
      const P = s.onCancel && s.onCancel(E);
      P && P.then ? (v(!0), P.then((...T) => {
        u(!1), v(!1);
      }, (T) => {
        v(!1);
      })) : u(!1);
    });
    return () => {
      const {
        direction: E
      } = s, {
        title: P,
        content: T,
        icon: N,
        type: O,
        onCancel: z,
        onOk: Q,
        className: W,
        ...ue
      } = o(s), te = `${cssClasses$j.DIALOG}-confirm`, K = cls(W, te, {
        [`${te}-rtl`]: E === "rtl"
      }), ve = cls(`${cssClasses$j.DIALOG}-${O}`), ee = isSemiIcon(N) ? cloneVNode(N, {
        class: `${te}-icon ${ve}-icon`,
        size: "extra-large"
      }) : N, Re = P == null ? null : createVNode("span", {
        class: `${te}-title-text`
      }, [P]), wt = cls(`${te}-content`, {
        [`${te}-content-withIcon`]: s.icon
      });
      return createVNode(Modal, {
        className: K,
        title: Re,
        confirmLoading: c.value,
        cancelLoading: g.value,
        onOk: b.value,
        onCancel: S.value,
        icon: ee,
        visible: l.value,
        ...ue
      }, {
        default: () => [createVNode("div", {
          class: wt,
          "x-semi-prop": "content"
        }, [typeof T == "function" ? T() : T])]
      });
    };
  }
});
function confirm(s) {
  const o = document.createElement("div");
  document.body.appendChild(o);
  let l, u = {
    ...s
  };
  function c(v) {
    l = createApp(h(ConfirmModal, {
      ...v,
      motion: s.motion
    })), l.mount(o);
  }
  function m() {
    u = {
      ...u,
      visible: !1
    }, c(u);
  }
  function g(v) {
    u = {
      ...u,
      ...v
    }, c(u);
  }
  return c(u), destroyFns.push(m), {
    destroy: m,
    update: g
  };
}
function withInfo(s) {
  return {
    type: "info",
    icon: createVNode(IconComponent$h, null, null),
    ...s
  };
}
function withSuccess(s) {
  return {
    type: "success",
    icon: createVNode(IconComponent$5, null, null),
    ...s
  };
}
function withWarning(s) {
  return {
    type: "warning",
    icon: createVNode(IconComponent$J, null, null),
    ...s
  };
}
function withError(s) {
  return {
    type: "error",
    icon: createVNode(IconComponent$K, null, null),
    okButtonProps: {
      type: "danger",
      ...s.okButtonProps
    },
    ...lodashExports.omit(s, ["okButtonProps"])
  };
}
function withConfirm(s) {
  return {
    type: "confirm",
    icon: createVNode(IconComponent$i, null, null),
    ...s
  };
}
const vuePropsType$1n = {
  afterClose: {
    type: Function,
    required: !0
  },
  config: {
    type: Object,
    required: !0
  },
  motion: [Object, Function]
}, HookModal = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1n
  },
  name: "HookModal",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const {
      afterClose: l,
      config: u,
      ...c
    } = s, m = ref$1(u);
    return o({
      destroy: () => {
        m.value = {
          ...m.value,
          visible: !1
        };
      },
      update: (g) => {
        m.value = {
          ...m.value,
          ...g
        };
      }
    }), () => {
      const {
        motion: g
      } = c, v = typeof g > "u" || g ? {
        ...g,
        didLeave: (...S) => {
          const E = lodashExports.get(c.motion, "didLeave");
          typeof E == "function" && E(...S), l();
        }
      } : !1, b = m.value;
      return createVNode(ConfirmModal, mergeProps$1(b, {
        motion: v
      }), null);
    };
  }
});
let uuid = 0;
function usePatchElement$2() {
  const s = ref$1([]);
  function o(l) {
    return s.value = [...Array.from(s.value), l], () => {
      s.value = Array.from(s.value).filter((u) => u !== l);
    };
  }
  return [s, o];
}
function useModal() {
  const [s, o] = usePatchElement$2();
  function l(u) {
    return function(m) {
      uuid += 1;
      let g;
      const v = h(HookModal, {
        key: `semi-modal-${uuid}`,
        config: u(m),
        afterClose: () => {
          g();
        }
      });
      return g = o(v), {
        destroy: () => {
          const b = s.value.findIndex((S) => S === v);
          s.value.splice(b, 1);
        },
        update: (b) => {
          v && v.component.update(b);
        }
      };
    };
  }
  return [{
    info: l(withInfo),
    success: l(withSuccess),
    error: l(withError),
    warning: l(withWarning),
    confirm: l(withConfirm)
  }, s];
}
let destroyFns = [];
const propTypes$S = {
  mask: bool,
  closable: bool,
  centered: bool,
  visible: bool,
  width: oneOfType([string$3, number$2]),
  height: oneOfType([string$3, number$2]),
  confirmLoading: bool,
  cancelLoading: bool,
  okText: string$3,
  okType: string$3,
  cancelText: string$3,
  maskClosable: bool,
  onCancel: func,
  onOk: func,
  afterClose: func,
  okButtonProps: object$1,
  cancelButtonProps: object$1,
  style: object$1,
  className: string$3,
  maskStyle: object$1,
  bodyStyle: object$1,
  zIndex: number$2,
  title: any$1,
  icon: node$1,
  header: any$1,
  footer: any$1,
  hasCancel: bool,
  motion: oneOfType([bool, func, object$1]),
  getPopupContainer: func,
  getContainerContext: func,
  maskFixed: bool,
  closeIcon: node$1,
  closeOnEsc: bool,
  size: String,
  keepDOM: bool,
  lazyRender: bool,
  direction: String,
  fullScreen: bool,
  footerFill: bool,
  content: [Object, String],
  type: String,
  modalContentClass: String,
  preventScroll: Boolean
}, defaultProps$N = {
  zIndex: 1e3,
  motion: !0,
  mask: !0,
  centered: !1,
  closable: !0,
  visible: !1,
  okType: "primary",
  maskClosable: !0,
  hasCancel: !0,
  onCancel: lodashExports.noop,
  onOk: lodashExports.noop,
  afterClose: lodashExports.noop,
  maskFixed: !1,
  closeOnEsc: !0,
  size: "small",
  keepDOM: !1,
  lazyRender: !0,
  fullScreen: !1,
  getContainerContext: lodashExports.noop
}, vuePropsType$1m = vuePropsMake(propTypes$S, defaultProps$N), Modal = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1m
  },
  name: "Modal",
  emits: {
    cancel: (s) => {
    },
    ok: (s) => {
    }
  },
  setup(s, {
    expose: o
  }) {
    const l = useSlots(), u = reactive({
      displayNone: !s.visible,
      isFullScreen: s.fullScreen
    }), c = ref$1();
    let m = null, g = 0, v = "100%", b;
    const {
      adapter: S
    } = useBaseComponent(s, u);
    function E() {
      return {
        ...S(),
        // getProps: () => props,
        disabledBodyScroll: () => {
          const {
            getPopupContainer: te
          } = s;
          m = document.body.style.overflow || "", (!te || te() === document.body) && m !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${v || "100%"} - ${g}px)`);
        },
        enabledBodyScroll: () => {
          const {
            getPopupContainer: te
          } = s;
          (!te || te() === document.body) && m !== null && m !== "hidden" && (document.body.style.overflow = m, document.body.style.width = v);
        },
        notifyCancel: (te) => s.onCancel(te),
        notifyOk: (te) => s.onOk(te),
        notifyClose: () => {
          s.afterClose();
        },
        toggleDisplayNone: (te, K) => {
          te !== u.displayNone && (u.displayNone = te, nextTick(() => {
            (K || lodashExports.noop)();
          }));
        },
        notifyFullScreen: (te) => {
          te !== u.isFullScreen && (u.isFullScreen = te);
        }
      };
    }
    const P = E(), T = new ModalFoundation(P);
    function N(te, K) {
      const ve = {};
      return te.fullScreen !== K.isFullScreen && (ve.isFullScreen = te.fullScreen), te.visible && K.displayNone && (ve.displayNone = !1), ve;
    }
    watch(() => s.fullScreen, (te) => {
      const K = N({
        ...s
      }, {
        ...u
      });
      K && Object.keys(K).forEach((ve) => {
        u[ve] = K[ve];
      });
    }), onMounted(() => {
      g = getScrollbarWidth(), v = document.body.style.width, s.visible && T.beforeShow();
    }), watch(() => s.visible, (te, K) => {
      !K && te && T.beforeShow(), K && !te && T.afterHide();
    }), onUnmounted(() => {
      s.visible ? T.destroy() : T.enabledBodyScroll();
    });
    const O = (te) => {
      T.handleCancel(te);
    }, z = (te) => {
      T.handleOk(te);
    }, Q = () => {
      const {
        visible: te
      } = s;
      T.toggleDisplayNone(!te);
    }, W = () => {
      const {
        okText: te,
        okType: K,
        cancelText: ve,
        confirmLoading: ee,
        cancelLoading: Re,
        hasCancel: wt,
        footerFill: yt
      } = s, xt = (Kt) => {
        var tn;
        return wt ? createVNode(Button$2, mergeProps$1({
          "aria-label": "cancel",
          onClick: O,
          loading: Re === void 0 ? u.onCancelReturnPromiseStatus === "pending" : Re,
          type: "tertiary",
          block: yt,
          autoFocus: !0
        }, s.cancelButtonProps, {
          style: {
            ...yt ? {
              marginLeft: "unset"
            } : {},
            ...((tn = s.cancelButtonProps) == null ? void 0 : tn.style) || {}
          },
          "x-semi-children-alias": "cancelText"
        }), {
          default: () => [ve || Kt.cancel]
        }) : null;
      };
      return createVNode(LocaleConsumer$6, {
        componentName: "Modal"
      }, {
        default: (Kt, tn) => createVNode("div", {
          class: cls({
            [`${cssClasses$j.DIALOG}-footerfill`]: yt
          })
        }, [xt(Kt), createVNode(Button$2, mergeProps$1({
          "aria-label": "confirm",
          type: K,
          theme: "solid",
          block: yt,
          loading: ee === void 0 ? u.onOKReturnPromiseStatus === "pending" : ee,
          onClick: z
        }, s.okButtonProps, {
          "x-semi-children-alias": "okText"
        }), {
          default: () => [te || Kt.confirm]
        })])
      });
    }, ue = () => {
      let {
        footer: te,
        className: K,
        motion: ve,
        maskStyle: ee,
        keepDOM: Re,
        style: wt,
        zIndex: yt,
        getPopupContainer: xt,
        visible: Kt,
        modalContentClass: tn,
        //@ts-ignore
        getContainerContext: ln,
        ...rn
      } = P.getProps(), an = wt;
      const Gt = ee, nn = "footer" in P.getProps() ? typeof te == "function" ? te() : te : W();
      let vt = {
        zIndex: yt
      };
      xt && xt() !== document.body && (vt = {
        zIndex: yt,
        position: "static"
      });
      const Et = cls(K, {
        [`${cssClasses$j.DIALOG}-displayNone`]: Re && u.displayNone
      }), Qt = s.visible || s.keepDOM && (!s.lazyRender || b) || s.motion && !u.displayNone;
      return Qt && (b = !0), createVNode(CSSAnimation, {
        motion: s.motion,
        animationState: Kt ? "enter" : "leave",
        startClassName: Kt ? `${cssClasses$j.DIALOG}-content-animate-show` : `${cssClasses$j.DIALOG}-content-animate-hide`,
        onAnimationEnd: () => {
          Q();
        },
        children: ({
          animationClassName: un,
          animationEventsNeedBind: gn
        }) => createVNode(CSSAnimation, {
          motion: s.motion,
          animationState: Kt ? "enter" : "leave",
          startClassName: Kt ? `${cssClasses$j.DIALOG}-mask-animate-show` : `${cssClasses$j.DIALOG}-mask-animate-hide`,
          onAnimationEnd: () => {
            Q();
          },
          children: ({
            animationClassName: dn,
            animationEventsNeedBind: yn
          }) => Qt ? createVNode(Index$9, {
            style: vt,
            getPopupContainer: xt
          }, {
            default: () => [createVNode(ModalContent, mergeProps$1(rn, {
              getContainerContext: ln,
              contentExtraProps: gn,
              maskExtraProps: yn,
              isFullScreen: u.isFullScreen,
              contentClassName: `${un} ${tn}`,
              maskClassName: dn,
              className: Et,
              getPopupContainer: xt,
              maskStyle: Gt,
              style: an,
              ref: c,
              footer: nn,
              onClose: O
            }), {
              default: l.default
            })]
          }) : null
        }, null)
      }, null);
    };
    return () => ue();
  }
});
class ModalClass {
}
gc(ModalClass, "useModal", useModal), gc(ModalClass, "info", function(o) {
  return confirm(withInfo(o));
}), gc(ModalClass, "success", function(o) {
  return confirm(withSuccess(o));
}), gc(ModalClass, "error", function(o) {
  return confirm(withError(o));
}), gc(ModalClass, "warning", function(o) {
  return confirm(withWarning(o));
}), gc(ModalClass, "confirm", function(o) {
  return confirm(withConfirm(o));
}), gc(ModalClass, "destroyAll", function() {
  for (let l = 0, u = destroyFns.length; l < u; l++) {
    const c = destroyFns[l];
    c && c();
  }
  destroyFns = [];
});
const cssClasses$i = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-list`
};
function useListContext() {
  return {
    context: inject("ListContext", ref$1(null))
  };
}
const vuePropsType$1l = {
  name: String
}, Consumer$a = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useListContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$1l
  },
  name: "ListContextConsumer"
});
function _isSlot$k(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$h = cssClasses$i.PREFIX, propTypes$R = {
  extra: node$1,
  header: node$1,
  main: node$1,
  align: string$3,
  className: string$3,
  style: object$1,
  onClick: func,
  onRightClick: func,
  onMouseEnter: func,
  onMouseLeave: func
}, defaultProps$M = {
  align: "flex-start",
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop
}, vuePropsType$1k = vuePropsMake(propTypes$R, defaultProps$M), ListItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1k
  },
  name: "ListItem",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs(), {
      context: u
    } = useListContext();
    function c(m) {
      const {
        grid: g
      } = u.value, {
        gutter: v,
        justify: b,
        type: S,
        align: E,
        ...P
      } = g;
      return createVNode(Col$1, P, _isSlot$k(m) ? m : {
        default: () => [m]
      });
    }
    return () => {
      var xt;
      const m = (xt = o.default) == null ? void 0 : xt.call(o), {
        header: g,
        main: v,
        className: b,
        style: S,
        extra: E,
        align: P,
        onClick: T,
        onRightClick: N,
        onMouseEnter: O,
        onMouseLeave: z,
        ...Q
      } = s, {
        onRightClick: W,
        onClick: ue,
        grid: te
      } = u.value, K = N || W, ve = T || ue, ee = cls(`${prefixCls$h}-item`, b), Re = cls(`${prefixCls$h}-item-body`, {
        [`${prefixCls$h}-item-body-${P}`]: P
      });
      let wt;
      (g || v) && (wt = createVNode("div", {
        class: Re
      }, [g ? createVNode("div", {
        class: `${prefixCls$h}-item-body-header`
      }, [g]) : null, v ? createVNode("div", {
        class: `${prefixCls$h}-item-body-main`
      }, [v]) : null]));
      let yt = (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-noninteractive-element-interactions
        createVNode("li", mergeProps$1({
          class: ee,
          style: S,
          onClick: ve,
          onContextmenu: K,
          onMouseenter: O,
          onMouseleave: z
        }, getDataAttr({
          ...Q,
          ...l
        })), [wt || null, m, E ? createVNode("div", {
          class: `${prefixCls$h}-item-extra`
        }, [E]) : null])
      );
      return u.value && te && (yt = c(yt)), yt;
    };
  }
}), ListItem$1 = ListItem, vuePropsType$1j = {
  value: Object
}, Provider$9 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0,
    immediate: !0
  }), provide("ListContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$1j
  },
  name: "ListContextProvider"
}), ListContext = {
  Provider: Provider$9,
  Consumer: Consumer$a
};
function _isSlot$j(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$g = cssClasses$i.PREFIX;
function List_() {
  const s = {
    style: object$1,
    className: string$3,
    bordered: bool,
    footer: node$1,
    header: node$1,
    layout: string$3,
    size: string$3,
    split: bool,
    emptyContent: node$1,
    dataSource: array$1,
    renderItem: func,
    grid: object$1,
    loading: bool,
    loadMore: node$1,
    onRightClick: func,
    onClick: func
  }, o = {
    bordered: !1,
    split: !0,
    loading: !1,
    layout: "vertical",
    size: "default",
    onRightClick: lodashExports.noop,
    onClick: lodashExports.noop
  }, l = vuePropsMake(s, o);
  return /* @__PURE__ */ defineComponent({
    props: {
      ...l
    },
    name: "List",
    setup(u, {}) {
      const c = useSlots(), m = useAttrs(), g = () => {
        const {
          emptyContent: b
        } = u;
        return b ? createVNode("div", {
          class: `${cssClasses$i.PREFIX}-empty`,
          "x-semi-prop": "emptyContent"
        }, [b]) : createVNode(LocaleConsumer$6, {
          componentName: "List"
        }, {
          default: (S) => createVNode("div", {
            class: `${cssClasses$i.PREFIX}-empty`
          }, [S.emptyText])
        });
      };
      function v(b, S) {
        const {
          grid: E
        } = u;
        if (E) {
          const P = {};
          return ["align", "gutter", "justify", "type"].forEach((T) => {
            T in E && (P[T] = E[T]);
          }), createVNode(Row$1, mergeProps$1({
            type: "flex"
          }, P), {
            default: () => [b || null, S]
          });
        }
        return createVNode("ul", {
          class: `${prefixCls$g}-items`
        }, [b || null, S]);
      }
      return () => {
        var tn;
        let b;
        const S = (tn = c.default) == null ? void 0 : tn.call(c), {
          style: E,
          className: P,
          header: T,
          loading: N,
          onRightClick: O,
          onClick: z,
          footer: Q,
          layout: W,
          grid: ue,
          size: te,
          split: K,
          loadMore: ve,
          bordered: ee,
          dataSource: Re,
          renderItem: wt,
          ...yt
        } = u, xt = cls(prefixCls$g, P, {
          [`${prefixCls$g}-flex`]: W === "horizontal",
          [`${prefixCls$g}-${te}`]: te,
          [`${prefixCls$g}-grid`]: ue,
          [`${prefixCls$g}-split`]: K,
          [`${prefixCls$g}-bordered`]: ee
        });
        let Kt;
        return Re && Re.length ? (Kt = [], (wt ? Re.map((rn, an) => wt(rn, an)) : []).forEach((rn, an) => {
          const Gt = rn.key || `list-item-${an}`;
          Kt.push(cloneVNode(rn, {
            key: Gt
          }));
        })) : !S && !N && (Kt = g()), createVNode("div", mergeProps$1({
          class: xt,
          style: E
        }, getDataAttr({
          ...yt,
          ...m
        })), [T ? createVNode("div", {
          class: `${cssClasses$i.PREFIX}-header`,
          "x-semi-prop": "header"
        }, [T]) : null, createVNode(ListContext.Provider, {
          value: {
            grid: ue,
            onRightClick: O,
            onClick: z
          }
        }, {
          default: () => [createVNode(Spin, {
            spinning: N,
            size: "large"
          }, _isSlot$j(b = v(Kt, S)) ? b : {
            default: () => [b]
          })]
        }), Q ? createVNode("div", {
          class: `${cssClasses$i.PREFIX}-footer`,
          "x-semi-prop": "footer"
        }, [Q]) : null, ve || null]);
      };
    }
  });
}
const List = List_(), List$1 = List, cssClasses$h = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-form`
}, strings$6 = {
  LAYOUT: ["horizontal", "vertical"],
  LABEL_POS: ["left", "top", "inset"],
  LABEL_ALIGN: ["left", "right"],
  EXTRA_POS: ["middle", "bottom"],
  DEFAULT_TRIGGER: "change"
}, LocaleConsumer$1 = LocaleConsumerFunc(), prefixCls$f = cssClasses$h.PREFIX, propTypes$Q = {
  id: string$3,
  required: bool,
  text: node$1,
  disabled: bool,
  name: string$3,
  align: string$3,
  width: oneOfType([number$2, string$3]),
  style: object$1,
  className: string$3,
  extra: node$1,
  optional: bool
}, defaultProps$L = {
  required: !1,
  name: "",
  align: "left",
  className: "",
  optional: !1
}, VuePropsType$1 = vuePropsMake(propTypes$Q, defaultProps$L), Label = /* @__PURE__ */ defineComponent({
  props: VuePropsType$1,
  name: "Label",
  setup(s, {
    slots: o
  }) {
    return () => {
      const l = o.default ? o.default() : null, {
        required: u,
        text: c,
        disabled: m,
        name: g,
        width: v,
        align: b,
        style: S,
        className: E,
        extra: P,
        id: T,
        optional: N
      } = s, O = cls(E, {
        [`${prefixCls$f}-field-label`]: !0,
        [`${prefixCls$f}-field-label-left`]: b === "left",
        [`${prefixCls$f}-field-label-right`]: b === "right",
        [`${prefixCls$f}-field-label-required`]: u,
        [`${prefixCls$f}-field-label-disabled`]: m,
        [`${prefixCls$f}-field-label-with-extra`]: P
      }), z = S || {};
      v && (z.width = styleNum(v));
      const Q = createVNode(LocaleConsumer$1, {
        componentName: "Form"
      }, {
        default: (te) => createVNode("span", {
          class: `${prefixCls$f}-field-label-optional-text`
        }, [te.optional])
      }), W = createVNode("div", {
        class: `${prefixCls$f}-field-label-text`,
        "x-semi-prop": "label"
      }, [typeof c < "u" ? c : l, N ? Q : null]), ue = createVNode(Fragment, null, [W, createVNode("div", {
        class: `${prefixCls$f}-field-label-extra`
      }, [P])]);
      return createVNode("label", {
        class: O,
        for: g,
        style: z,
        id: T
      }, [P ? ue : W]);
    };
  }
}), prefixCls$e = cssClasses$O.PREFIX, VuePropsType = {
  className: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: "default"
  },
  style: [String, Object],
  onBlur: {
    type: Function,
    default: noop$1
  },
  onFocus: {
    type: Function,
    default: noop$1
  },
  label: Object,
  labelPosition: String,
  disabled: Boolean
}, InputGroup$1 = /* @__PURE__ */ defineComponent({
  props: VuePropsType,
  name: "InputGroup",
  setup(s, {
    slots: o
  }) {
    function l(u) {
      const {
        size: c,
        className: m,
        label: g,
        labelPosition: v,
        ...b
      } = s, S = cls({
        [`${prefixCls$e}-group-wrapper`]: !0,
        [`${prefixCls$e}-group-wrapper-with-top-label`]: v === "top",
        [`${prefixCls$e}-group-wrapper-with-left-label`]: v === "left"
      }), E = cls(`${prefixCls$e}-group`, m, {
        [`${prefixCls$e}-${c}`]: c !== "default"
      }), P = "input-group";
      return createVNode("div", {
        class: S
      }, [g && g.text ? createVNode(Label, mergeProps$1({
        name: P
      }, g), null) : null, createVNode("span", {
        role: "group",
        "aria-disabled": s.disabled,
        id: g && g.name || P,
        class: E,
        style: s.style,
        onFocus: s.onFocus,
        onBlur: s.onBlur
      }, [u])]);
    }
    return () => {
      const {
        size: u,
        style: c,
        className: m,
        label: g,
        onBlur: v,
        onFocus: b,
        disabled: S,
        labelPosition: E,
        ...P
      } = s, T = o.default ? o.default() : null, N = cls(`${prefixCls$e}-group`, {
        [`${prefixCls$e}-${u}`]: u !== "default"
      }, m);
      let O;
      return T && (O = (Array.isArray(T) ? T : [T]).map((z, Q) => {
        if (z) {
          const {
            onBlur: W,
            onFocus: ue,
            disabled: te
          } = z.props, K = lodashExports.isFunction(W) && lodashExports.get(W, "name") !== "noop" ? W : v, ve = lodashExports.isFunction(ue) && lodashExports.get(ue, "name") !== "noop" ? ue : b;
          return cloneVNode(z, {
            key: Q,
            ...P,
            size: u,
            onBlur: K,
            onFocus: ve,
            disabled: typeof te == "boolean" ? te : S
          });
        }
        return null;
      })), g && g.text ? l(O) : createVNode("span", {
        role: "group",
        "aria-label": "Input group",
        "aria-disabled": s.disabled,
        class: N,
        style: c,
        onFocus: s.onFocus,
        onBlur: s.onBlur
      }, [O]);
    };
  }
}), InputGroup$2 = InputGroup$1, MODE_HORIZONTAL = "horizontal", MODE_VERTICAL = "vertical", cssClasses$g = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-navigation`
}, strings$5 = {
  MODE: [MODE_VERTICAL, MODE_HORIZONTAL],
  MODE_VERTICAL,
  MODE_HORIZONTAL,
  ICON_POS_LEFT: "left",
  ICON_POS_RIGHT: "right",
  DEFAULT_LOGO_ICON_SIZE: "extra-large",
  TOGGLE_ICON_LEFT: "left",
  TOGGLE_ICON_RIGHT: "right"
}, numbers$6 = {
  DEFAULT_SUBNAV_MAX_HEIGHT: 999,
  DEFAULT_TOOLTIP_SHOW_DELAY: 0,
  // ms
  DEFAULT_TOOLTIP_HIDE_DELAY: 100,
  // ms
  DEFAULT_SUBNAV_OPEN_DELAY: 0,
  // ms
  DEFAULT_SUBNAV_CLOSE_DELAY: 100
  // ms
}, DEFAULT_TOGGLE_ICON = {
  open: "chevron_up",
  closed: "chevron_down"
};
let NavItem$1 = class Sx {
  constructor(o = {}) {
    (o == null || typeof o != "object") && (o = {
      text: o,
      itemKey: o,
      maxHeight: numbers$6.DEFAULT_SUBNAV_MAX_HEIGHT,
      // selected: false,
      // isOpen: false,
      link: null,
      items: null,
      icon: "",
      indent: !1
    });
    for (const l of Object.keys(o))
      this[l] = o[l];
    o.items && Array.isArray(o.items) && o.items.length ? (this.items = o.items.map((l) => new Sx(l)), "toggleIcon" in o ? this.toggleIcon = Sx.isValidToggleIcon(o.toggleIcon) ? { ...o.toggleIcon } : { ...DEFAULT_TOGGLE_ICON } : this.toggleIcon = { ...DEFAULT_TOGGLE_ICON }) : this.items = null;
  }
  static isValidToggleIcon(o) {
    return !!(o && typeof o == "object" && typeof o.open == "string" && o.open.length && typeof o.closed == "string" && o.closed.length);
  }
};
class NavigationFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  /* istanbul ignore next */
  static getZeroParentKeys(o = {}, ...l) {
    const u = [];
    if (l.length) {
      for (const c of l)
        if (Array.isArray(o[c]) && o[c].length) {
          const m = o[c][0];
          isNullOrUndefined(m) || u.push(m);
        }
    }
    return u;
  }
  static buildItemKeysMap(o = [], l = {}, u = [], c = "itemKey") {
    if (Array.isArray(o) && o.length)
      for (const m of o)
        if (Array.isArray(m))
          NavigationFoundation.buildItemKeysMap(m, l, [...u], c);
        else {
          let g;
          if (m && typeof m == "object" && (g = m[c] || m.props && m.props[c]), g) {
            if (l[g] = [...u], Array.isArray(m.items) && m.items.length)
              NavigationFoundation.buildItemKeysMap(
                m.items,
                l,
                [...u, g],
                c
              );
            else if (m.props && m.props.children) {
              const v = Array.isArray(m.props.children) ? m.props.children : [m.props.children];
              NavigationFoundation.buildItemKeysMap(
                v,
                l,
                [...u, g],
                c
              );
            }
          }
        }
    return l;
  }
  /**
   * init is called in constructor and componentDidMount.
   * if you want to update state in constructor, please add it to return object;
   * if you want to update state in componentDidMount, please call adapter in else logic.
   * @param {*} lifecycle
   * @returns
   */
  init(o) {
    const { defaultSelectedKeys: l, selectedKeys: u } = this.getProps();
    let c = u || l || [];
    const { itemKeysMap: m, willOpenKeys: g, formattedItems: v } = this.getCalcState(), b = this.selectLevelZeroParentKeys(m, c);
    if (c = c.concat(b), o === "constructor")
      return {
        selectedKeys: c,
        itemKeysMap: m,
        openKeys: g,
        items: v
      };
    this._adapter.updateSelectedKeys(c, !1), this._adapter.setItemKeysMap(m), this._adapter.updateOpenKeys(g), this._adapter.updateItems(v), this._adapter.setItemsChanged(!0);
  }
  /**
   * Get the state to be calculated
   */
  getCalcState() {
    const { itemKeysMap: o, formattedItems: l } = this.getFormattedItems(), u = this.getWillOpenKeys(o);
    return { itemKeysMap: o, willOpenKeys: u, formattedItems: l };
  }
  /**
   * Calculate formatted items and itemsKeyMap
   */
  getFormattedItems() {
    const { items: o, children: l } = this.getProps(), u = this.formatItems(o), c = Array.isArray(o) && o.length ? u : l;
    return {
      itemKeysMap: NavigationFoundation.buildItemKeysMap(c),
      formattedItems: u
    };
  }
  /**
   * Calculate the keys that will need to be opened soon
   * @param {*} itemKeysMap
   */
  getWillOpenKeys(o) {
    const { defaultOpenKeys: l, openKeys: u, defaultSelectedKeys: c, selectedKeys: m, mode: g } = this.getProps(), { openKeys: v = [] } = this.getStates();
    let b = u || l || [];
    if (!(Array.isArray(l) || Array.isArray(u)) && g === strings$5.MODE_VERTICAL && (Array.isArray(c) || Array.isArray(m))) {
      const S = Array.isArray(m) ? m : c;
      b = v.concat(this.getShouldOpenKeys(o, S)), b = Array.from(new Set(b));
    }
    return [...b];
  }
  getShouldOpenKeys(o = {}, l = []) {
    const u = /* @__PURE__ */ new Set();
    return Array.isArray(l) && l.length && l.forEach((c) => {
      if (c) {
        const m = lodashExports.get(o, c);
        Array.isArray(m) && m.forEach((g) => u.add(g));
      }
    }), [...u];
  }
  destroy() {
  }
  selectLevelZeroParentKeys(o, l) {
    const u = isNullOrUndefined(o) ? this.getState("itemKeysMap") : o, c = [];
    if (l.length) {
      for (const m of l)
        if (Array.isArray(u[m]) && u[m].length) {
          const g = u[m][0];
          isNullOrUndefined(g) || c.push(g);
        }
    }
    return c.length ? c : [];
  }
  formatItems(o = []) {
    const l = [];
    for (const u of o)
      l.push(new NavItem$1(u));
    return l;
  }
  handleSelect(o) {
    this._adapter.notifySelect(o);
  }
  /* istanbul ignore next */
  judgeIfOpen(o, l) {
    let u = !1;
    const c = Array.isArray(o) ? o : o && [o];
    if (c && Array.isArray(l) && l.length) {
      for (const m of l)
        if (u = c.includes(m.itemKey) || this.judgeIfOpen(c, m.items), u)
          break;
    }
    return u;
  }
  handleCollapseChange() {
    const o = !this.getState("isCollapsed");
    this._isControlledComponent("isCollapsed") || this._adapter.setIsCollapsed(o), this._adapter.notifyCollapseChange(o);
  }
  handleItemsChange(o) {
    this._adapter.setItemsChanged(o);
  }
}
const addKeys = function(o = [], ...l) {
  const u = new Set(o);
  return l.forEach((c) => c && u.add(c)), Array.from(u);
}, removeKeys = function(o = [], ...l) {
  const u = new Set(o);
  return l.forEach((c) => c && u.delete(c)), Array.from(u);
};
class SubNavFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    this._timer = null;
  }
  destroy() {
    this.clearDelayTimer();
  }
  clearDelayTimer() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
  isValidKey(o) {
    return o != null && (typeof o == "number" || typeof o == "string");
  }
  handleDropdownVisibleChange(o) {
    const l = this.getProp("itemKey"), u = this._adapter.getOpenKeysIsControlled(), c = this._adapter.getCanUpdateOpenKeys(), m = this._adapter.getOpenKeys(), g = o ? addKeys(m, l) : removeKeys(m, l);
    this.clearDelayTimer(), u || c && this._adapter.updateOpen(o), this._adapter.notifyGlobalOpenChange({ itemKey: l, openKeys: g, isOpen: o });
  }
  /**
   *
   * @param {Event} e
   * @param {HTMLElement} titleRef
   */
  handleClick(o, l) {
    const { itemKey: u, disabled: c } = this.getProps();
    if (c)
      return;
    const m = l && l.contains(o.target);
    let g = !!this._adapter.getIsOpen();
    m ? g = !g : g = !1;
    const v = g ? addKeys(this._adapter.getOpenKeys(), u) : removeKeys(this._adapter.getOpenKeys(), u), b = { itemKey: u, openKeys: v, isOpen: g, domEvent: o }, S = this._adapter.getOpenKeysIsControlled(), E = this._adapter.getCanUpdateOpenKeys();
    !S && E && this._adapter.updateOpen(g), this._adapter.notifyGlobalOpenChange(b), this._adapter.notifyGlobalOnClick(b);
  }
  /**
   * A11y: simulate sub nav click
   * @param e 
   * @param titleRef 
   */
  handleKeyPress(o, l) {
    isEnterPress(o) && this.handleClick(o, l);
  }
}
class ItemFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    this._timer = null, this._mounted = !0;
  }
  destroy() {
    this._mounted = !1;
  }
  isValidKey(o) {
    return o != null && (typeof o == "string" || typeof o == "number");
  }
  handleClick(o) {
    const { isSubNav: l, itemKey: u, text: c, disabled: m } = this.getProps();
    if (m)
      return;
    !l && this.isValidKey(u) && !this._adapter.getSelectedKeysIsControlled() && !this._adapter.getSelected() && this._adapter.updateSelected(!0);
    const g = [u];
    if (!l) {
      if (!this._adapter.getSelected()) {
        const v = [this._adapter.cloneDeep(this.getProps())];
        this._adapter.notifyGlobalOnSelect({ itemKey: u, selectedKeys: g, selectedItems: v, domEvent: o });
      }
      this._adapter.notifyGlobalOnClick({ itemKey: u, text: c, domEvent: o });
    }
    this._adapter.notifyClick({ itemKey: u, text: c, domEvent: o });
  }
  /**
   * A11y: simulate item click
   */
  handleKeyPress(o) {
    if (isEnterPress(o)) {
      const { link: l, linkOptions: u } = this.getProps(), c = lodashExports.get(u, "target", "_self");
      this.handleClick(o), typeof l == "string" && (c === "_blank" ? window.open(l) : window.location.href = l);
    }
  }
}
function useNavContext() {
  return {
    context: inject("NavContext", ref$1({
      isCollapsed: !1,
      selectedKeys: [],
      openKeys: []
    }))
  };
}
const vuePropsType$1i = {}, Consumer$9 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useNavContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$1i
  },
  name: "NavContextConsumer"
});
function _isSlot$i(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const clsPrefix = `${cssClasses$g.PREFIX}-item`, vuePropsType$1h = {
  text: node$1,
  itemKey: [string$3, number$2],
  onClick: {
    type: func,
    default: lodashExports.noop
  },
  onMouseEnter: {
    type: func,
    default: lodashExports.noop
  },
  onMouseLeave: {
    type: func,
    default: lodashExports.noop
  },
  icon: node$1,
  className: string$3,
  toggleIcon: string$3,
  style: object$1,
  forwardRef: {
    type: func,
    default: lodashExports.noop
  },
  indent: {
    type: [bool, number$2],
    default: !1
  },
  isCollapsed: {
    type: bool,
    default: !1
  },
  // Is it in a state of folding to the side
  isSubNav: {
    type: bool,
    default: !1
  },
  // Whether to navigate for children
  link: string$3,
  linkOptions: object$1,
  disabled: {
    type: bool,
    default: !1
  },
  items: Array,
  level: Number,
  maxHeight: Number,
  tabIndex: {
    type: number$2,
    default: 0
  },
  tooltipHideDelay: number$2,
  tooltipShowDelay: number$2
}, NavItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1h
  },
  name: "NavItem",
  setup(s, {
    attrs: o,
    slots: l
  }) {
    const {
      context: u
    } = useNavContext(), c = reactive({
      tooltipShow: !1
    }), {
      adapter: m
    } = useBaseComponent(s, c), g = new ItemFoundation(v());
    function v() {
      return {
        ...m(),
        cloneDeep: cloneDeep$1,
        updateTooltipShow: (O) => c.tooltipShow = O,
        updateSelected: (O) => b("updateSelectedKeys", [s.itemKey]),
        updateGlobalSelectedKeys: (O) => b("updateSelectedKeys", [...O]),
        getSelectedKeys: () => u.value && u.value.selectedKeys,
        getSelectedKeysIsControlled: () => u.value && u.value.selectedKeysIsControlled,
        notifyGlobalOnSelect: (...O) => b("onSelect", ...O),
        notifyGlobalOnClick: (...O) => b("onClick", ...O),
        notifyClick: (...O) => s.onClick(...O),
        notifyMouseEnter: (...O) => s.onMouseEnter(...O),
        notifyMouseLeave: (...O) => s.onMouseLeave(...O),
        getIsCollapsed: () => s.isCollapsed || !!(u.value && u.value.isCollapsed) || !1,
        getSelected: () => !!(u.value && u.value.selectedKeys && u.value.selectedKeys.includes(s.itemKey)),
        getIsOpen: () => !!(u.value && u.value.openKeys && u.value.openKeys.includes(s.itemKey))
      };
    }
    function b(O, ...z) {
      return O && u.value && typeof u.value[O] == "function" ? u.value[O](...z) : null;
    }
    function S(O, z, Q = !1, W = 0) {
      if (s.isSubNav || !O && u.value.mode === strings$5.MODE_HORIZONTAL)
        return null;
      let ue = "large";
      z === strings$5.ICON_POS_RIGHT && (ue = "default");
      const te = cls(`${clsPrefix}-icon`, {
        [`${clsPrefix}-icon-toggle-${u.value.toggleIconPosition}`]: Q,
        [`${clsPrefix}-icon-info`]: !Q
      });
      return createVNode("i", {
        class: te,
        key: W
      }, [isSemiIcon(O) ? cloneVNode(O, ue ? {
        size: ue
      } : {}) : O]);
    }
    const E = (O) => {
      s.forwardRef && s.forwardRef(O);
    }, P = (O) => {
      const {
        text: z,
        tooltipHideDelay: Q,
        tooltipShowDelay: W
      } = s, ue = Q ?? u.value.tooltipHideDelay, te = W ?? u.value.tooltipShowDelay;
      return createVNode(Tooltip$1, {
        content: z,
        position: "right",
        trigger: "hover",
        mouseEnterDelay: te,
        mouseLeaveDelay: ue
      }, _isSlot$i(O) ? O : {
        default: () => [O]
      });
    }, T = (O) => {
      g.handleClick(O);
    }, N = (O) => g.handleKeyPress(O);
    return () => {
      var un;
      const {
        text: O,
        icon: z,
        toggleIcon: Q,
        className: W,
        isSubNav: ue,
        style: te,
        indent: K,
        onMouseEnter: ve,
        onMouseLeave: ee,
        link: Re,
        linkOptions: wt,
        disabled: yt,
        level: xt = 0,
        tabIndex: Kt
      } = s, tn = (un = l.default) == null ? void 0 : un.call(l), {
        mode: ln,
        isInSubNav: rn,
        prefixCls: an,
        limitIndent: Gt
      } = u.value, nn = v().getIsCollapsed(), vt = v().getSelected();
      let Et = null;
      if (!isNullOrUndefined(tn))
        Et = tn;
      else {
        let gn = null;
        if (ln === strings$5.MODE_VERTICAL && !Gt && !nn) {
          const dn = z && !K ? xt : xt - 1;
          gn = lodashExports.times(dn, (yn) => S(null, strings$5.ICON_POS_RIGHT, !1, yn));
        }
        Et = createVNode(Fragment, null, [gn, u.value.toggleIconPosition === strings$5.TOGGLE_ICON_LEFT && S(Q, strings$5.ICON_POS_RIGHT, !0, "key-toggle-pos-right"), z || K || rn ? S(z, strings$5.ICON_POS_LEFT, !1, "key-position-left") : null, isNullOrUndefined(O) ? "" : createVNode("span", {
          class: `${cssClasses$g.PREFIX}-item-text`
        }, [O]), u.value.toggleIconPosition === strings$5.TOGGLE_ICON_RIGHT && S(Q, strings$5.ICON_POS_RIGHT, !0, "key-toggle-pos-right")]);
      }
      typeof Re == "string" && (Et = createVNode("a", mergeProps$1({
        class: `${an}-item-link`,
        href: Re,
        tabindex: -1
      }, wt), [Et]));
      let Qt = "";
      if (rn && (nn || ln === strings$5.MODE_HORIZONTAL)) {
        const gn = cls({
          [clsPrefix]: !0,
          [`${clsPrefix}-sub`]: ue,
          [`${clsPrefix}-selected`]: vt,
          [`${clsPrefix}-collapsed`]: nn,
          [`${clsPrefix}-disabled`]: yt
        });
        Qt = createVNode(DropdownItem$1, {
          selected: vt,
          active: vt,
          ref: E,
          className: gn,
          onClick: T,
          onMouseenter: ve,
          onMouseleave: ee,
          disabled: yt,
          onKeyDown: N
        }, _isSlot$i(Et) ? Et : {
          default: () => [Et]
        });
      } else {
        const gn = cls(`${W || `${clsPrefix}-normal`}`, {
          [clsPrefix]: !0,
          [`${clsPrefix}-sub`]: ue,
          [`${clsPrefix}-selected`]: vt && !ue,
          [`${clsPrefix}-collapsed`]: nn,
          [`${clsPrefix}-disabled`]: yt,
          [`${clsPrefix}-has-link`]: typeof Re == "string"
        }), dn = {
          "aria-disabled": yt
        };
        if (ue) {
          const yn = v().getIsOpen();
          dn["aria-expanded"] = yn;
        }
        Qt = createVNode("li", mergeProps$1({
          role: ue ? null : "menuitem",
          tabindex: ue ? -1 : Kt
        }, dn, {
          style: te,
          ref: E,
          class: gn,
          onClick: T,
          onMouseenter: ve,
          onMouseleave: ee,
          onKeypress: N
        }, getDataAttr(s)), [Et]);
      }
      return (nn && !rn && !ue || nn && ue && yt) && (Qt = P(Qt)), typeof u.value.renderWrapper == "function" ? u.value.renderWrapper({
        itemElement: Qt,
        isSubNav: ue,
        isInSubNav: rn,
        props: s
      }) : Qt;
    };
  }
}), Item$1 = NavItem, vuePropsType$1g = {
  value: Object
}, Provider$8 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("NavContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$1g
  },
  name: "NavContextProvider"
}), NavContext = {
  Consumer: Consumer$9,
  Provider: Provider$8
};
function _isSlot$h(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$P = {
  /**
   * Unique identification
   */
  itemKey: [string$3, number$2],
  /**
   * Copywriting
   */
  text: node$1,
  expandIcon: node$1,
  /**
   * Whether child navigation is expanded
   */
  isOpen: bool,
  /**
   * Whether it is in the state of being stowed to the sidebar
   */
  isCollapsed: bool,
  /**
   * Whether to keep the left Icon placeholder
   */
  indent: [bool, number$2],
  /**
   * The icon name of the right control switch (on and off status)
   */
  toggleIcon: node$1,
  style: object$1,
  /**
   * Icon name on the left
   */
  icon: node$1,
  /**
   * Maximum height (for animation)
   */
  maxHeight: number$2,
  onMouseEnter: func,
  onMouseLeave: func,
  // Is it disabled
  disabled: bool,
  level: number$2,
  dropdownStyle: object$1,
  className: string$3
}, defaultProps$K = {
  level: 0,
  indent: !1,
  isCollapsed: !1,
  isOpen: !1,
  maxHeight: numbers$6.DEFAULT_SUBNAV_MAX_HEIGHT,
  toggleIcon: {
    open: createVNode(IconComponent$x, null, null),
    closed: createVNode(IconComponent$A, null, null)
  },
  disabled: !1
}, vuePropsType$1f = vuePropsMake(propTypes$P, defaultProps$K), SubNav = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1f
  },
  name: "SubNav",
  setup(s, {}) {
    const o = useSlots(), {
      context: l
    } = useNavContext(), u = ref$1(), c = ref$1(), m = reactive({
      isHovered: !1
    }), {
      adapter: g
    } = useBaseComponent(s, m), v = T();
    v.setCache("firstMounted", !0);
    const b = new SubNavFoundation(v), S = (K) => {
      c.value = K;
    }, E = (K) => {
      u.value = K;
    };
    function P(K, ...ve) {
      return K && l.value && typeof l.value[K] == "function" ? l.value[K](...ve) : null;
    }
    function T() {
      return {
        ...g(),
        updateIsHovered: (K) => m.isHovered = K,
        getOpenKeys: () => l.value && l.value.openKeys,
        getOpenKeysIsControlled: () => l.value && l.value.openKeysIsControlled,
        getCanUpdateOpenKeys: () => l.value && l.value.canUpdateOpenKeys,
        updateOpen: (K) => P(K ? "addOpenKeys" : "removeOpenKeys", s.itemKey),
        notifyGlobalOpenChange: (...K) => P("onOpenChange", ...K),
        notifyGlobalOnSelect: (...K) => P("onSelect", ...K),
        notifyGlobalOnClick: (...K) => P("onClick", ...K),
        getIsSelected: (K) => !!(!isNullOrUndefined(K) && lodashExports.get(l.value, "selectedKeys", []).includes(String(K))),
        getIsOpen: () => !!(l.value && l.value.openKeys && l.value.openKeys.includes(String(s.itemKey)))
      };
    }
    const N = (K) => {
      b.handleClick(K, u.value);
    }, O = (K) => {
      b.handleKeyPress(K, u.value);
    }, z = (K) => b.handleDropdownVisibleChange(K);
    function Q(K, ve, ee, Re = !1, wt = 0) {
      const {
        prefixCls: yt
      } = l.value;
      let xt = "large";
      ve === strings$5.ICON_POS_RIGHT && (xt = "default");
      const Kt = cls(`${yt}-item-icon`, {
        [`${yt}-item-icon-toggle-${l.value.toggleIconPosition}`]: Re,
        [`${yt}-item-icon-info`]: !Re
      }), tn = v.getIsOpen(), ln = isVNode(K) ? ee ? createVNode(CSSAnimation, {
        animationState: tn ? "enter" : "leave",
        startClassName: `${cssClasses$g.PREFIX}-icon-rotate-${tn ? "180" : "0"}`,
        children: ({
          animationClassName: rn
        }) => cloneVNode(K, {
          size: xt,
          class: rn
        })
      }, null) : cloneVNode(K, {
        size: xt
      }) : null;
      return createVNode("i", {
        key: wt,
        class: Kt
      }, [ln]);
    }
    function W() {
      const {
        text: K,
        icon: ve,
        itemKey: ee,
        indent: Re,
        disabled: wt,
        level: yt,
        expandIcon: xt
      } = s, {
        mode: Kt,
        isInSubNav: tn,
        isCollapsed: ln,
        prefixCls: rn,
        subNavMotion: an,
        limitIndent: Gt
      } = l.value, nn = v.getIsOpen(), vt = cls(`${rn}-sub-title`, {
        [`${rn}-sub-title-selected`]: v.getIsSelected(ee),
        [`${rn}-sub-title-disabled`]: wt
      });
      let Et = !1, Qt = "";
      ln ? tn ? Qt = createVNode(IconComponent$y, null, null) : Qt = null : Kt === strings$5.MODE_HORIZONTAL ? tn ? Qt = createVNode(IconComponent$y, null, null) : Qt = xt || createVNode(IconComponent$A, {
        "aria-hidden": !0
      }, null) : (an && (Et = !0), Qt = xt || createVNode(IconComponent$A, {
        "aria-hidden": !0
      }, null));
      let un = null;
      if (Kt === strings$5.MODE_VERTICAL && !Gt && !ln) {
        const yn = ve && !Re ? yt : yt - 1;
        un = lodashExports.times(yn, (vn) => Q(null, strings$5.ICON_POS_RIGHT, !1, !1, vn));
      }
      const gn = !ln && tn && Kt === strings$5.MODE_HORIZONTAL || ln && tn;
      return createVNode("div", {
        role: "menuitem",
        tabindex: gn ? -1 : 0,
        ref: E,
        class: vt,
        onClick: N,
        onKeypress: O,
        "aria-expanded": nn ? "true" : "false"
      }, [createVNode("div", {
        class: `${rn}-item-inner`
      }, [un, l.value.toggleIconPosition === strings$5.TOGGLE_ICON_LEFT && Q(Qt, strings$5.ICON_POS_RIGHT, Et, !0, "key-toggle-position-left"), ve || Re || tn && Kt !== strings$5.MODE_HORIZONTAL ? Q(ve, strings$5.ICON_POS_LEFT, !1, !1, "key-inSubNav-position-left") : null, createVNode("span", {
        class: `${rn}-item-text`
      }, [K]), l.value.toggleIconPosition === strings$5.TOGGLE_ICON_RIGHT && Q(Qt, strings$5.ICON_POS_RIGHT, Et, !0, "key-toggle-position-right")])]);
    }
    function ue() {
      const {
        isCollapsed: K,
        mode: ve,
        subNavMotion: ee,
        prefixCls: Re
      } = l.value, wt = v.getIsOpen(), yt = ve === strings$5.MODE_HORIZONTAL, xt = cls(`${Re}-sub`, {
        [`${Re}-sub-open`]: wt,
        [`${Re}-sub-popover`]: K || yt
      }), Kt = createVNode(Collapsible$1, {
        motion: ee,
        isOpen: wt,
        keepDOM: !1,
        fade: !0
      }, {
        default: () => [K ? null : createVNode("ul", {
          class: xt
        }, {
          default: o.default
        })]
      });
      return yt ? null : ee ? Kt : wt && !K ? createVNode("ul", {
        class: xt
      }, {
        default: o.default
      }) : null;
    }
    function te(K = "") {
      var Qt, un;
      let ve = K;
      const ee = (un = (Qt = useSlots()).default) == null ? void 0 : un.call(Qt), {
        dropdownStyle: Re,
        disabled: wt
      } = s, {
        mode: yt,
        isInSubNav: xt,
        isCollapsed: Kt,
        subNavCloseDelay: tn,
        subNavOpenDelay: ln,
        prefixCls: rn,
        getPopupContainer: an
      } = l.value, Gt = v.getIsOpen(), nn = v.getOpenKeysIsControlled(), vt = cls({
        [`${rn}-popover`]: Kt
      }), Et = {
        trigger: "hover",
        style: Re
      };
      return nn && (Et.trigger = "custom", Et.visible = Gt), an && (Et.getPopupContainer = an), (Kt || yt === strings$5.MODE_HORIZONTAL) && (ve = wt ? ve : createVNode(BaseDropdown, mergeProps$1({
        className: vt,
        render: createVNode(DropdownMenu$1, null, {
          default: () => [createVNode("li", {
            class: `${rn}-popover-crumb`
          }, null), ee]
        }),
        position: yt === strings$5.MODE_HORIZONTAL && !xt ? "bottomLeft" : "rightTop",
        mouseEnterDelay: ln,
        mouseLeaveDelay: tn,
        onVisibleChange: z
      }, Et), _isSlot$h(K) ? K : {
        default: () => [K]
      })), ve;
    }
    return () => {
      const {
        itemKey: K,
        style: ve,
        onMouseEnter: ee,
        onMouseLeave: Re,
        disabled: wt,
        text: yt
      } = s, {
        mode: xt,
        isCollapsed: Kt,
        prefixCls: tn
      } = l.value;
      let ln = W();
      const rn = ue();
      return (Kt || xt === strings$5.MODE_HORIZONTAL) && (ln = te(ln)), createVNode(Item$1, {
        style: ve,
        isSubNav: !0,
        itemKey: K,
        forwardRef: S,
        isCollapsed: Kt,
        className: `${tn}-sub-wrap`,
        onMouseEnter: ee,
        onMouseLeave: Re,
        disabled: wt,
        text: yt
      }, {
        default: () => [createVNode(NavContext.Provider, {
          value: {
            ...l.value,
            isInSubNav: !0
          }
        }, {
          default: () => [ln, rn]
        })]
      });
    };
  }
}), SubNav$1 = SubNav;
function _isSlot$g(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const vuePropsType$1e = {
  prefixCls: String,
  locale: Object,
  collapseText: Function,
  isCollapsed: {
    type: Boolean,
    default: void 0
  },
  onClick: Function
}, CollapseButton = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1e
  },
  name: "CollapseButton",
  setup(s, o) {
    const l = () => {
      typeof s.onClick == "function" && s.onClick(!s.isCollapsed);
    }, u = {
      icon: createVNode(IconComponent$8, null, null),
      type: "tertiary",
      theme: "borderless",
      onClick: l
    };
    return () => {
      const {
        prefixCls: c,
        locale: m,
        collapseText: g,
        isCollapsed: v,
        onClick: b = lodashExports.noop
      } = s;
      let S = v ? m == null ? void 0 : m.expandText : m == null ? void 0 : m.collapseText;
      return typeof g == "function" && (S = g(v)), createVNode("div", {
        class: `${c}-collapse-btn`
      }, [v ? createVNode(Tooltip$1, {
        content: S,
        position: "right"
      }, {
        default: () => [createVNode(Button$2, u, null)]
      }) : createVNode(Button$2, u, _isSlot$g(S) ? S : {
        default: () => [S]
      })]);
    };
  }
}), vuePropsType$1d = {
  // children: PropTypes.node,
  style: object$1,
  className: string$3,
  collapseButton: {
    type: any$1,
    default: !1
  },
  collapseText: func,
  onClick: {
    type: func,
    default: lodashExports.noop
  }
}, NavFooter = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1d
  },
  name: "NavFooter",
  setup(s, {
    slots: o
  }) {
    const {
      context: l
    } = useNavContext(), u = () => {
      const {
        collapseButton: c,
        collapseText: m
      } = s;
      if (isVNode(c))
        return c;
      const {
        onCollapseChange: g,
        prefixCls: v,
        locale: b,
        isCollapsed: S
      } = l.value;
      return createVNode(CollapseButton, mergeProps$1({
        prefixCls: v,
        isCollapsed: S,
        locale: b,
        onClick: g,
        collapseText: m
      }, typeof c == "object" ? c : {}), null);
    };
    return () => {
      var T;
      const {
        style: c,
        className: m,
        collapseButton: g,
        onClick: v
      } = s;
      let b = (T = o.default) == null ? void 0 : T.call(o);
      const {
        isCollapsed: S,
        mode: E
      } = l.value;
      !isVNode(b) && g && E !== strings$5.MODE_HORIZONTAL && (b = u());
      const P = cls(m, `${cssClasses$g.PREFIX}-footer`, {
        [`${cssClasses$g.PREFIX}-footer-collapsed`]: S
      });
      return createVNode("div", {
        class: P,
        style: c,
        onClick: v
      }, [b]);
    };
  }
}), Footer$1 = NavFooter, vuePropsType$1c = {
  prefixCls: {
    type: string$3,
    default: cssClasses$g.PREFIX
  },
  logo: node$1,
  text: node$1,
  style: object$1,
  class: string$3,
  link: string$3,
  linkOptions: object$1,
  className: string$3
}, NavHeader = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1c
  },
  name: "NavHeader",
  setup(s, {
    slots: o
  }) {
    const {
      context: l
    } = useNavContext();
    function u(c) {
      return isVNode(c) ? c : null;
    }
    return () => {
      var z;
      const {
        style: c,
        className: m,
        logo: g,
        text: v,
        link: b,
        linkOptions: S,
        prefixCls: E
      } = s, P = (z = o.default) == null ? void 0 : z.call(o), {
        isCollapsed: T
      } = l.value, N = cls(m, `${cssClasses$g.PREFIX}-header`, {
        [`${cssClasses$g.PREFIX}-header-collapsed`]: T
      });
      let O = createVNode(Fragment, null, [g ? createVNode("i", {
        class: `${cssClasses$g.PREFIX}-header-logo`
      }, [u(g)]) : null, !isNullOrUndefined(v) && !T ? createVNode("span", {
        class: `${cssClasses$g.PREFIX}-header-text`
      }, [v]) : null, P]);
      return typeof b == "string" && (O = createVNode("a", mergeProps$1({
        class: `${E}-header-link`,
        href: b
      }, S), [O])), createVNode("div", {
        class: N,
        style: c
      }, [O]);
    };
  }
}), Header$1 = NavHeader;
function _isSlot$f(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$O = {
  // Initial expanded SubNav navigation key array
  defaultOpenKeys: Array,
  openKeys: Array,
  // Initial selected navigation key array
  defaultSelectedKeys: Array,
  selectedKeys: Array,
  // Navigation type, now supports vertical, horizontal
  mode: String,
  // Triggered when selecting a navigation item
  onSelect: func,
  // Triggered when clicking a navigation item
  onClick: func,
  // SubNav expand/close callback
  onOpenChange: func,
  // Array of options (nested options can continue)
  items: array$1,
  // Is it in the state of being stowed to the sidebar
  isCollapsed: {
    type: bool,
    default: void 0
  },
  defaultIsCollapsed: {
    type: bool,
    default: void 0
  },
  onCollapseChange: func,
  multiple: {
    type: bool,
    default: void 0
  },
  onDeselect: func,
  subNavMotion: [bool, object$1, func],
  subNavCloseDelay: number$2,
  subNavOpenDelay: number$2,
  tooltipShowDelay: number$2,
  tooltipHideDelay: number$2,
  children: node$1,
  style: object$1,
  bodyStyle: object$1,
  className: string$3,
  toggleIconPosition: string$3,
  prefixCls: string$3,
  header: node$1,
  footer: node$1,
  limitIndent: {
    type: bool,
    default: void 0
  },
  getPopupContainer: func,
  expandIcon: node$1,
  renderWrapper: func
}, defaultProps$J = {
  subNavCloseDelay: numbers$6.DEFAULT_SUBNAV_CLOSE_DELAY,
  subNavOpenDelay: numbers$6.DEFAULT_SUBNAV_OPEN_DELAY,
  tooltipHideDelay: numbers$6.DEFAULT_TOOLTIP_HIDE_DELAY,
  tooltipShowDelay: numbers$6.DEFAULT_TOOLTIP_SHOW_DELAY,
  onCollapseChange: lodashExports.noop,
  onSelect: lodashExports.noop,
  onClick: lodashExports.noop,
  onOpenChange: lodashExports.noop,
  toggleIconPosition: "right",
  limitIndent: !0,
  prefixCls: cssClasses$g.PREFIX,
  subNavMotion: !0,
  // isOpen: false,
  mode: strings$5.MODE_VERTICAL
  // defaultOpenKeys: [],
  // defaultSelectedKeys: [],
  // items: [],
}, vuePropsType$1b = vuePropsMake(propTypes$O, defaultProps$J), index$7 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1b
  },
  name: "Navigation",
  setup(s, {
    slots: o
  }) {
    var Q;
    const l = useSlots();
    let u = !0;
    const c = reactive({
      isCollapsed: !1,
      itemKeysMap: {},
      items: [],
      openKeys: [],
      selectedKeys: []
    }), {
      adapter: m,
      isControlled: g,
      getDataAttr: v
    } = useBaseComponent(s, c);
    let b = {
      isCollapsed: !!(g("isCollapsed") ? s.isCollapsed : s.defaultIsCollapsed),
      // calc state
      openKeys: [],
      items: [],
      itemKeysMap: {},
      // itemKey to parentKeys
      selectedKeys: []
    };
    Object.keys(b).forEach((W) => {
      c[W] = b[W];
    });
    function S(W) {
      return function(...ue) {
        const te = new Set(c[W]);
        ue.forEach((K) => K && te.add(K)), c[W] = Array.from(te);
      };
    }
    function E(W) {
      return function(...ue) {
        const te = new Set(c[W]);
        ue.forEach((K) => K && te.delete(K)), c[W] = Array.from(te);
      };
    }
    function P() {
      return {
        ...m(),
        notifySelect: (...W) => s.onSelect(...W),
        notifyOpenChange: (...W) => s.onOpenChange(...W),
        setIsCollapsed: (W) => c.isCollapsed = W,
        notifyCollapseChange: (...W) => {
          s.onCollapseChange(...W);
        },
        updateItems: (W) => c.items = [...W],
        setItemKeysMap: (W) => c.itemKeysMap = {
          ...W
        },
        addSelectedKeys: S("selectedKeys"),
        removeSelectedKeys: E("selectedKeys"),
        /**
         * when `includeParentKeys` is `true`, select a nested nav item will select parent nav sub
         */
        updateSelectedKeys: (W, ue = !0) => {
          let te = W;
          if (ue) {
            const K = N.selectLevelZeroParentKeys(null, W);
            te = Array.from(new Set(W.concat(K)));
          }
          c.selectedKeys = te;
        },
        updateOpenKeys: (W) => c.openKeys = [...W],
        addOpenKeys: S("openKeys"),
        removeOpenKeys: E("openKeys"),
        setItemsChanged: (W) => {
          u = W;
        }
      };
    }
    const T = P(), N = new NavigationFoundation(T);
    if (s.items && s.items.length || (Q = l.default) != null && Q.call(l)) {
      const W = N.init("constructor");
      let ue = {
        ...b,
        ...W
      };
      Object.keys(ue).forEach((te) => {
        c[te] = ue[te];
      });
    }
    watch(() => s.isCollapsed, (W) => {
      c.isCollapsed = W, N.handleItemsChange(!1);
    }), watch(() => s.selectedKeys, (W) => {
      if (W) {
        T.updateSelectedKeys(s.selectedKeys);
        const ue = N.getWillOpenKeys(c.itemKeysMap);
        T.updateOpenKeys(ue);
      }
    }), watch(() => s.openKeys, (W) => {
      W && T.updateOpenKeys(s.openKeys);
    }), watch([() => s.items], (W, ue, te) => {
      N.init("");
    }, {}), watchEffect(() => {
      o.default && N.init("");
    });
    function O(W = [], ue = 0) {
      const {
        expandIcon: te
      } = s;
      return createVNode(Fragment, null, [W.map((ve, ee) => {
        if (Array.isArray(ve.items) && ve.items.length) {
          let Re;
          return createVNode(SubNav$1, mergeProps$1({
            key: ve.itemKey || String(ue) + ee
          }, ve, {
            level: ue,
            expandIcon: te
          }), _isSlot$f(Re = O(ve.items, ue + 1)) ? Re : {
            default: () => [Re]
          });
        } else
          return createVNode(Item$1, mergeProps$1({
            key: ve.itemKey || String(ue) + ee
          }, ve, {
            level: ue
          }), null);
      })]);
    }
    const z = () => {
      N.handleCollapseChange();
    };
    return () => {
      var bn;
      const W = (bn = o.default) == null ? void 0 : bn.call(o), {
        mode: ue,
        onOpenChange: te,
        onSelect: K,
        onClick: ve,
        style: ee,
        className: Re,
        subNavCloseDelay: wt,
        subNavOpenDelay: yt,
        subNavMotion: xt,
        tooltipShowDelay: Kt,
        tooltipHideDelay: tn,
        prefixCls: ln,
        bodyStyle: rn,
        footer: an,
        header: Gt,
        toggleIconPosition: nn,
        limitIndent: vt,
        renderWrapper: Et,
        getPopupContainer: Qt,
        ...un
      } = s, {
        selectedKeys: gn,
        openKeys: dn,
        items: yn,
        isCollapsed: vn
      } = c, {
        updateOpenKeys: Pn,
        addOpenKeys: On,
        removeOpenKeys: _n,
        updateSelectedKeys: Nn,
        addSelectedKeys: Un,
        removeSelectedKeys: Xn
      } = T, zn = {
        ...ee
      };
      let jn = W;
      const kn = [], Yn = [];
      if (isVNode(an) ? kn.push(createVNode(Footer$1, {
        key: 0
      }, _isSlot$f(an) ? an : {
        default: () => [an]
      })) : an && typeof an == "object" && kn.push(createVNode(Footer$1, mergeProps$1({
        key: 0
      }, an), null)), isVNode(Gt) ? Yn.push(createVNode(Header$1, {
        key: 0
      }, _isSlot$f(Gt) ? Gt : {
        default: () => [Gt]
      })) : Gt && typeof Gt == "object" && Yn.push(createVNode(Header$1, mergeProps$1({
        key: 0
      }, Gt), null)), Array.isArray(jn) && jn.length) {
        jn = [...jn];
        let Ln = jn.length;
        for (let Kn = 0; Kn < Ln; Kn++) {
          const Bn = jn[Kn];
          Bn.type === Footer$1 || lodashExports.get(Bn, "type.elementType") === "NavFooter" ? (kn.push(Bn), jn.splice(Kn, 1), Kn--, Ln--) : (Bn.type === Header$1 || lodashExports.get(Bn, "type.elementType") === "NavHeader") && (Yn.push(Bn), jn.splice(Kn, 1), Kn--, Ln--);
        }
      }
      const Zn = cls(ln, Re, {
        [`${ln}-collapsed`]: vn,
        [`${ln}-horizontal`]: ue === "horizontal",
        [`${ln}-vertical`]: ue === "vertical"
      }), er = cls(`${ln}-header-list-outer`, {
        [`${ln}-header-list-outer-collapsed`]: vn
      });
      return u && T.setCache("itemElems", O(yn)), createVNode(LocaleConsumer$6, {
        componentName: "Navigation"
      }, {
        default: (Ln) => createVNode(NavContext.Provider, {
          value: {
            subNavCloseDelay: wt,
            subNavOpenDelay: yt,
            subNavMotion: xt,
            tooltipShowDelay: Kt,
            tooltipHideDelay: tn,
            openKeys: dn,
            openKeysIsControlled: g("openKeys") && ue === "vertical" && !vn,
            // canUpdateOpenKeys: mode === 'vertical' && !isCollapsed,
            canUpdateOpenKeys: !0,
            selectedKeys: gn,
            selectedKeysIsControlled: g("selectedKeys"),
            isCollapsed: vn,
            onCollapseChange: z,
            mode: ue,
            onSelect: K,
            onOpenChange: te,
            updateOpenKeys: Pn,
            addOpenKeys: On,
            removeOpenKeys: _n,
            updateSelectedKeys: Nn,
            addSelectedKeys: Un,
            removeSelectedKeys: Xn,
            onClick: ve,
            locale: Ln,
            prefixCls: ln,
            toggleIconPosition: nn,
            limitIndent: vt
          }
        }, {
          default: () => [createVNode("div", mergeProps$1({
            class: Zn,
            style: zn
          }, v()), [createVNode("div", {
            class: `${ln}-inner`
          }, [createVNode("div", {
            class: er
          }, [Yn, createVNode("div", {
            style: rn,
            class: `${ln}-list-wrapper`
          }, [createVNode("ul", {
            role: "menu",
            "aria-orientation": ue,
            class: `${ln}-list`
          }, [T.getCache("itemElems"), jn])])]), kn])])]
        })
      });
    };
  }
}), BaseNav = index$7;
BaseNav.Item = Item$1;
BaseNav.Header = Header$1;
BaseNav.Footer = Footer$1;
BaseNav.SubNav = SubNav$1;
const BaseNav$1 = BaseNav;
class NotificationListFoundation extends BaseFoundation$1 {
  addNotice(o) {
    const l = this._adapter.getNotices();
    this._adapter.updateNotices([o, ...l]);
  }
  has(o) {
    return this._adapter.getNotices().some((l) => l.id === o);
  }
  update(o, l) {
    let u = this._adapter.getNotices();
    u = u.map((m) => m.id === o ? { ...m, ...l } : m);
    const c = u.filter((m) => m.id === o);
    this._adapter.updateNotices(u, [], c);
  }
  removeNotice(o) {
    let l = this._adapter.getNotices();
    const u = [];
    l = l.filter((c) => c.id === o ? (u.push(c), !1) : !0), this._adapter.updateNotices(l, u);
  }
  destroyAll() {
    const o = this._adapter.getNotices();
    o.length > 0 && this._adapter.updateNotices([], o);
  }
}
const cssClasses$f = {
  WRAPPER: `${BASE_CLASS_PREFIX$1}-notification-wrapper`,
  LIST: `${BASE_CLASS_PREFIX$1}-notification-list`,
  NOTICE: `${BASE_CLASS_PREFIX$1}-notification-notice`
}, strings$4 = {
  types: ["warning", "success", "info", "error", "default"],
  themes: ["normal", "light"],
  directions: ["ltr", "rtl"]
}, numbers$5 = {
  duration: 3
  // default close time, unit: s
};
class NotificationFoundation extends BaseFoundation$1 {
  // cache id
  constructor(o) {
    super({ ...NotificationFoundation.defaultAdapter, ...o }), this._timer = null, this._id = null;
  }
  init() {
    this._startCloseTimer(), this._id = this.getProp("id");
  }
  destroy() {
    this._clearCloseTimer();
  }
  _startCloseTimer() {
    const o = this.getProp("duration");
    o && lodashExports.isNumber(o) && (this._timer = setTimeout(() => {
      this.close();
    }, o * 1e3));
  }
  close(o) {
    o && o.stopPropagation(), this._adapter.notifyWrapperToRemove(this._id), this._adapter.notifyClose();
  }
  _clearCloseTimer() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
  restartCloseTimer() {
    this._clearCloseTimer(), this._startCloseTimer();
  }
}
const prefixCls$d = cssClasses$f.NOTICE, {
  duration
} = numbers$5, {
  types: types$4,
  themes,
  directions
} = strings$4, propTypes$N = {
  duration: number$2,
  id: string$3,
  title: node$1,
  content: node$1,
  // strings、numbers、array、element
  type: String,
  theme: String,
  icon: node$1,
  onClick: func,
  onClose: func,
  onCloseClick: func,
  showClose: bool,
  // private props
  close: func,
  direction: String,
  onHookClose: func,
  style: object$1,
  className: string$3,
  position: string$3,
  zIndex: number$2,
  getPopupContainer: func
}, defaultProps$I = {
  duration,
  id: "",
  close: lodashExports.noop,
  onClose: lodashExports.noop,
  onClick: lodashExports.noop,
  onCloseClick: lodashExports.noop,
  content: "",
  title: "",
  showClose: !0,
  theme: "normal"
}, vuePropsType$1a = vuePropsMake(propTypes$N, defaultProps$I), Notice = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1a
  },
  name: "Notice",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const l = reactive({
      visible: !0
    }), {
      adapter: u
    } = useBaseComponent(s, l);
    function c() {
      return {
        ...u(),
        notifyWrapperToRemove: (N) => {
          s.close(N);
        },
        notifyClose: () => {
          s.onClose(), s.onHookClose && s.onHookClose();
        }
      };
    }
    const m = c(), g = new NotificationFoundation(m), {
      context: v
    } = useConfigContext();
    onMounted(() => {
      g.init();
    }), onUnmounted(() => {
      g.destroy();
    });
    function b() {
      const {
        type: N,
        icon: O
      } = s;
      let Q = {
        warning: createVNode(IconComponent$J, {
          size: "large"
        }, null),
        success: createVNode(IconComponent$5, {
          size: "large"
        }, null),
        info: createVNode(IconComponent$h, {
          size: "large"
        }, null),
        error: createVNode(IconComponent$K, {
          size: "large"
        }, null)
      }[N];
      const W = cls({
        [`${prefixCls$d}-icon`]: !0,
        [`${prefixCls$d}-${N}`]: !0
      });
      return O && (Q = O), Q ? createVNode("div", {
        class: W,
        "x-semi-prop": "icon"
      }, [isSemiIcon(Q) ? cloneVNode(Q, {
        size: Q.props.size || "large"
      }) : Q]) : null;
    }
    const S = () => {
      g._clearCloseTimer();
    }, E = () => {
      g._startCloseTimer();
    }, P = (N) => {
      s.onCloseClick(s.id), g.close(N);
    }, T = (N) => {
      s.onClick(N);
    };
    return o({
      getFoundation() {
        return g;
      }
    }), () => {
      const N = s.direction || v.value.direction, O = N === "rtl" ? "topLeft" : "topRight", {
        content: z,
        title: Q,
        theme: W,
        position: ue = O,
        type: te,
        id: K,
        onCloseClick: ve,
        className: ee,
        showClose: Re,
        style: wt,
        ...yt
      } = s, {
        visible: xt
      } = l, Kt = cls(prefixCls$d, ee, {
        [`${prefixCls$d}-close`]: !xt,
        [`${prefixCls$d}-icon-show`]: types$4.includes(te),
        [`${prefixCls$d}-${te}`]: !0,
        [`${prefixCls$d}-${W}`]: W === "light",
        [`${prefixCls$d}-rtl`]: N === "rtl"
      }), tn = getUuidShort({});
      return (
        // eslint-disable-next-line jsx-a11y/no-static-element-interactions
        createVNode("div", {
          class: Kt,
          style: wt,
          onMouseenter: S,
          onMouseleave: E,
          onClick: T,
          "aria-labelledby": tn,
          role: "alert"
        }, [createVNode("div", null, [b()]), createVNode("div", {
          class: `${prefixCls$d}-inner`
        }, [createVNode("div", {
          class: `${prefixCls$d}-content-wrapper`
        }, [Q ? createVNode("div", {
          id: tn,
          class: `${prefixCls$d}-title`,
          "x-semi-prop": "title"
        }, [Q]) : "", z ? createVNode("div", {
          class: `${prefixCls$d}-content`,
          "x-semi-prop": "content"
        }, [z]) : ""]), Re && createVNode(Button$3, {
          className: `${prefixCls$d}-icon-close`,
          type: "tertiary",
          icon: createVNode(IconComponent$u, null, null),
          theme: "borderless",
          size: "small",
          onClick: P
        }, null)])])
      );
    };
  }
}), vuePropsType$19 = {
  position: String,
  children: {
    type: [Object, Function],
    required: !0
  },
  motion: [Object, String, Boolean]
}, NoticeTransition = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$19
  },
  name: "NoticeTransition",
  setup(s, {}) {
    useSlots();
    let o;
    return () => {
      let {
        motion: l = {}
      } = s;
      const {
        position: u = "topRight"
      } = s, c = function({
        translate: g,
        opacity: v
      }) {
        let b = `translateX(${g}%)`;
        return u && typeof u == "string" && (/left/i.test(u) ? b = `translateX(${-g}%)` : /right/i.test(u) ? b = `translateX(${g}%)` : /top/i.test(u) ? b = `translateY(${-g}%)` : b = `translateY(${g}%)`), {
          transform: b,
          opacity: v
        };
      };
      return typeof l == "function" ? l = l(s) : (!l || typeof l != "object") && (l = {}), o || (o = s.children), createVNode(Transition, mergeProps$1({
        from: {
          translate: 100,
          opacity: 0
        },
        enter: {
          translate: {
            val: 0,
            tension: 560,
            friction: 32
          },
          opacity: {
            val: 1,
            duration: 200
          }
        },
        leave: {
          translate: {
            val: 100,
            easing: "easeOutCubic",
            duration: 300
          },
          opacity: {
            val: 0,
            duration: 200
          }
        },
        children: typeof s.children == "function" ? (m) => {
          let g;
          return s.children === null ? g = o : g = s.children, g == null ? void 0 : g(c(m));
        } : s.children
      }, l), null);
    };
  }
}), vuePropsType$18 = {
  id: String,
  afterClose: {
    type: Function,
    required: !0
  },
  motion: [Object, String, Boolean]
}, HookNotice = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$18
  },
  name: "HookNotice",
  setup(s, {
    expose: o,
    attrs: l
  }) {
    useSlots();
    const u = ref$1(!0);
    function c(g) {
      u.value = g;
    }
    const m = () => {
      c(!1);
    };
    return watch(u, () => {
      u.value || s.afterClose(String(s.id));
    }, {
      immediate: !0
    }), () => {
      const {
        afterClose: g,
        ...v
      } = l;
      return u ? createVNode(Notice, mergeProps$1(v, {
        onHookClose: m
      }), null) : null;
    };
  }
}), defaultConfig$1 = {
  duration: 3,
  position: "topRight",
  motion: !0,
  content: "",
  title: "",
  zIndex: 1010
};
function usePatchElement$1() {
  const s = ref$1([]);
  function o(c) {
    s.value = c;
  }
  function l(c, m) {
    return o([{
      element: c,
      config: m
    }, ...s.value]), (g) => {
      o(s.value.filter(({
        config: v
      }) => (console.log(v.id, g), v.id !== g)));
    };
  }
  function u() {
    const c = {
      top: [],
      topLeft: [],
      topRight: [],
      bottom: [],
      bottomLeft: [],
      bottomRight: []
    };
    return s.value.forEach(({
      element: m,
      config: g
    }) => {
      const {
        position: v
      } = g;
      c[v].push(m);
    }), Object.entries(c).map((m) => {
      const g = m[0], v = m[1];
      return Array.isArray(v) && v.length ? (
        // @ts-ignore
        createVNode("div", {
          key: g,
          class: cls(cssClasses$f.LIST),
          placement: g
        }, [v.map((b) => b())])
      ) : null;
    });
  }
  return [u, l];
}
function useNotification() {
  const [s, o] = usePatchElement$1(), l = /* @__PURE__ */ new Map(), u = (m) => {
    const g = getUuid("semi_notice_"), v = {
      ...m,
      id: g
    };
    let b;
    const S = (P) => {
      l.set(g, P);
    };
    return b = o(() => createVNode(HookNotice, mergeProps$1({
      key: g
    }, v, {
      afterClose: (P) => b(P),
      ref: S
    }), null), {
      ...v
    }), g;
  };
  return [{
    success: (m) => u({
      ...defaultConfig$1,
      ...m,
      type: "success"
    }),
    info: (m) => u({
      ...defaultConfig$1,
      ...m,
      type: "info"
    }),
    error: (m) => u({
      ...defaultConfig$1,
      ...m,
      type: "error"
    }),
    warning: (m) => u({
      ...defaultConfig$1,
      ...m,
      type: "warning"
    }),
    open: (m) => u({
      ...defaultConfig$1,
      ...m,
      type: "default"
    }),
    close: (m) => {
      const g = l.get(m);
      g && g.close();
    }
  }, s];
}
const defaultConfig = {
  duration: 3,
  position: "topRight",
  motion: !0,
  content: "",
  title: "",
  zIndex: 1010
}, propTypes$M = {
  style: object$1,
  className: string$3,
  direction: String
  // ref: [Function, Object]
}, defaultProps$H = {}, vuePropsType$17 = vuePropsMake(propTypes$M, defaultProps$H), NotificationList = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$17
  },
  name: "NotificationList",
  setup(s, {
    expose: o
  }) {
    useSlots();
    let l = [];
    const u = reactive({
      notices: [],
      removedItems: [],
      updatedItems: []
    }), {
      adapter: c
    } = useBaseComponent(s, u);
    function m() {
      return {
        ...c(),
        updateNotices: (Q, W = [], ue = []) => {
          l = [...Q], [...W], u.notices = Q, u.removedItems = W, u.updatedItems = ue;
        },
        getNotices: () => l
      };
    }
    const g = m(), v = new NotificationListFoundation(g), {
      context: b
    } = useConfigContext(), S = (Q) => v.addNotice(Q), E = (Q) => v.has(Q), P = (Q) => {
      v.removeNotice(String(Q));
    }, T = (Q, W) => v.update("" + Q, W), N = () => v.destroyAll(), O = (Q, W, ue = [], te = []) => {
      const K = cls(cssClasses$f.LIST);
      if (Q.length) {
        const ve = z(Q[0]);
        return createVNode("div", {
          placement: W,
          key: W,
          class: K,
          style: ve
        }, [Q.map((ee, Re) => ee.motion ? createVNode(NoticeTransition, {
          key: ee.id || Re,
          position: W,
          motion: ee.motion,
          children: ue.find((wt) => wt.id === ee.id) ? null : (wt) => createVNode(Notice, mergeProps$1(ee, {
            ref: (yt) => {
              yt && te.some((xt) => xt.id === yt.$props.id) && yt.getFoundation().restartCloseTimer();
            },
            style: {
              ...wt,
              ...ee.style
            },
            key: ee.id,
            close: P
          }), null)
        }, null) : createVNode(Notice, mergeProps$1(ee, {
          style: {
            ...ee.style
          },
          key: ee.id,
          close: P
        }), null))]);
      }
      return null;
    };
    function z(Q) {
      const W = {};
      return ["top", "left", "bottom", "right"].forEach((ue) => {
        if (ue in Q) {
          const te = Q[ue];
          W[ue] = typeof te == "number" ? `${te}px` : te;
        }
      }), W;
    }
    return o({
      add: S,
      has: E,
      remove: P,
      destroyAll: N,
      update: T
    }), () => {
      let {
        notices: Q
      } = u;
      const {
        removedItems: W,
        updatedItems: ue
      } = u;
      Q = Array.from(/* @__PURE__ */ new Set([...Q, ...W]));
      const te = {
        top: [],
        topLeft: [],
        topRight: [],
        bottom: [],
        bottomLeft: [],
        bottomRight: []
      };
      Q.forEach((ve) => {
        const Re = (ve.direction || b.value.direction) === "rtl" ? "topLeft" : "topRight", wt = ve.position || Re;
        te[wt].push(ve);
      });
      const K = Object.entries(te).map((ve) => {
        const ee = ve[0], Re = ve[1];
        return O(Re, ee, W, ue);
      });
      return createVNode(Fragment, null, [K]);
    };
  }
}), NotificationList$1 = NotificationList;
class NotificationListClass {
  static addNotice(o) {
    o = {
      ...defaultConfig,
      ...o
    };
    const l = o.id ?? getUuid("notification");
    if (this.NotificationListRef)
      this.NotificationListRef.has(`${l}`) ? this.NotificationListRef.update(l, o) : this.NotificationListRef.add({
        ...o,
        id: l
      });
    else {
      const {
        getPopupContainer: u
      } = o, c = document.createElement("div");
      this.wrapperId || (this.wrapperId = getUuid("notification-wrapper").slice(0, 32)), c.className = cssClasses$f.WRAPPER, c.id = this.wrapperId, c.style.zIndex = String(typeof o.zIndex == "number" ? o.zIndex : defaultConfig.zIndex), u ? u().appendChild(c) : document.body.appendChild(c), this.app = createApp(() => createVNode(NotificationList, {
        ref: (m) => {
          this.NotificationListRef || m.add({
            ...o,
            id: l
          }), this.NotificationListRef = m;
        }
      })), this.app.mount(c);
    }
    return l;
  }
  static removeNotice(o) {
    return this.NotificationListRef && this.NotificationListRef.remove(o), o;
  }
  static info(o) {
    return this.addNotice({
      ...o,
      type: "info"
    });
  }
  static success(o) {
    return this.addNotice({
      ...o,
      type: "success"
    });
  }
  static error(o) {
    return this.addNotice({
      ...o,
      type: "error"
    });
  }
  static warning(o) {
    return this.addNotice({
      ...o,
      type: "warning"
    });
  }
  static open(o) {
    return this.addNotice({
      ...o,
      type: "default"
    });
  }
  static close(o) {
    return this.removeNotice(o);
  }
  static destroyAll() {
    if (this.NotificationListRef) {
      this.NotificationListRef.destroyAll();
      const o = document.querySelector(`#${this.wrapperId}`);
      this.app.unmount(), o && o.parentNode.removeChild(o), this.NotificationListRef = null, this.wrapperId = null;
    }
  }
  static config(o) {
    ["top", "left", "bottom", "right"].map((l) => {
      l in o && (defaultConfig[l] = o[l]);
    }), typeof o.zIndex == "number" && (defaultConfig.zIndex = o.zIndex), typeof o.duration == "number" && (defaultConfig.duration = o.duration), typeof o.position == "string" && (defaultConfig.position = o.position);
  }
}
gc(NotificationListClass, "useNotification", useNotification), gc(NotificationListClass, "NotificationListRef", null);
const cssClasses$e = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-page`
}, numbers$4 = {
  PAGE_SHOW_MAX: 7,
  REST_PAGE_SHOW_MAX: 5,
  DEFAULT_PAGE_SIZE: 10,
  PAGE_SIZE_OPTION: [10, 20, 40, 100],
  REST_PAGE_MAX_SIZE: 1e6
};
class PaginationFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  init() {
    const { currentPage: o, total: l, pageSize: u } = this.getStates();
    this._updateDisabled({ currentPage: o, total: l, pageSize: u }), this._updatePageList({ currentPage: o, total: l, pageSize: u }), this._registerEventHandler();
  }
  destroy() {
    this._unregisterEventHandler();
  }
  _registerEventHandler() {
    this._adapter.registerKeyDownHandler(this.handleKeyDown);
  }
  _unregisterEventHandler() {
    this._adapter.unregisterKeyDownHandler(this.handleKeyDown);
  }
  _updateDisabled(o) {
    const { currentPage: l, total: u, pageSize: c } = o, m = this._getTotalPageNumber(u, c);
    let g = !1, v = !1;
    l === 1 ? (g = !0, v = m < 2) : l === m && (g = !1, v = !0), this._adapter.setDisabled(g, v);
  }
  goPage(o) {
    if (o === "...")
      return;
    const { pageSize: l, currentPage: u } = this.getStates(), c = this._isInProps("currentPage");
    o !== u && (c ? (this._adapter.notifyPageChange(o), this._adapter.notifyChange(o, l)) : (this.updatePage(o), this._adapter.notifyPageChange(o), this._adapter.notifyChange(o, l)));
  }
  updatePage(o = 1, l, u) {
    (l === null || typeof l > "u") && (l = this.getState("total")), (u === null || typeof u > "u") && (u = this.getState("pageSize")), this._updateDisabled({ currentPage: o, total: l, pageSize: u }), this._updatePageList({ currentPage: o, total: l, pageSize: u }), this._adapter.updateTotal(l), this._adapter.setCurrentPage(o), this._adapter.updatePageSize(u);
  }
  updateAllPageNumbers(o, l) {
    const { size: u, hoverShowPageSelect: c, disabled: m } = this.getProps();
    if (!(u !== "small" || !c || m)) {
      const g = Array.from({ length: Math.ceil(o / l) }, (v, b) => b + 1);
      this._adapter.updateAllPageNumbers(g);
    }
  }
  goPrev() {
    const { currentPage: o } = this.getStates();
    o > 1 && this.goPage(o - 1);
  }
  goNext() {
    const { currentPage: o, total: l, pageSize: u } = this.getStates(), c = this._getTotalPageNumber(l, u);
    o <= c - 1 && this.goPage(o + 1);
  }
  _updatePageList(o) {
    const { currentPage: l, total: u, pageSize: c } = o;
    let m = [], g = [], v = [];
    const b = this._getTotalPageNumber(u, c), { PAGE_SHOW_MAX: S, REST_PAGE_MAX_SIZE: E } = numbers$4;
    if (b <= S)
      m = Array.from({ length: b }, (P, T) => T + 1), g = [], v = [];
    else
      switch (!0) {
        case l < 4:
          m = [1, 2, 3, 4, "...", b - 1, b], v = Array.from({ length: Math.min(b - 6, E) }, (N, O) => O + 5), g = [];
          break;
        case l === 4:
          m = [1, 2, 3, 4, 5, "...", b], v = Array.from({ length: Math.min(b - 6, E) }, (N, O) => O + 6), g = [];
          break;
        case (4 < l && l < b - 3):
          const P = Array.from({ length: 3 }, (N, O) => l + (O - 1));
          m = [1].concat("...", P, "...", b), v = Array.from(
            { length: Math.min(b - l - 2, E) },
            (N, O) => l + O + 2
          ), g = Array.from({ length: Math.min(l - 3, E) }, (N, O) => O + 2);
          break;
        case (l - 3 <= l && l <= b):
          const T = Array.from({ length: 5 }, (N, O) => b - (4 - O));
          m = [1, "..."].concat(T), v = [], g = Array.from({ length: Math.min(T[0] - 2, E) }, (N, O) => O + 2);
          break;
      }
    this._adapter.setPageList({ pageList: m, restLeftPageList: g, restRightPageList: v });
  }
  changePageSize(o) {
    const { pageSize: l } = this.getStates();
    this._adapter.updatePageSize(o), this._adapter.notifyPageSizeChange(o);
    const { total: u, currentPage: c } = this.getStates(), m = (c - 1) * l + 1, g = Math.ceil(m / o);
    this.updatePage(g, u, o), c !== g && this._adapter.notifyPageChange(g), this._adapter.notifyChange(g, o);
  }
  // TODO handle tab/enter events
  handleKeyDown() {
  }
  // If pageSize is not in the Opts array, insert it
  pageSizeInOpts() {
    const { pageSizeOpts: o } = this.getProps(), { pageSize: l } = this.getStates(), u = [...o];
    if (u.indexOf(l) === -1) {
      const c = u.findIndex((m) => m > l);
      u.splice(c, 0, l);
    }
    return u;
  }
  handleQuickJumpNumberChange(o) {
    this._adapter.updateQuickJumpPage(o);
  }
  _handleQuickJump(o) {
    let l = Number(o);
    const { pageSize: u, total: c } = this.getStates(), m = this._getTotalPageNumber(c, u);
    Number.isNaN(l) || (l > m && (l = m), l <= 0 && (l = 1), this._adapter.updateQuickJumpPage(""), this.goPage(l));
  }
  handleQuickJumpBlur() {
    const { quickJumpPage: o } = this.getStates();
    (typeof o == "string" && o || typeof o == "number") && this._handleQuickJump(o);
  }
  handleQuickJumpEnterPress(o) {
    this._handleQuickJump(o);
  }
  _getTotalPageNumber(o, l) {
    return Math.ceil(o / l);
  }
}
function _isSlot$e(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$c = cssClasses$e.PREFIX, propTypes$L = {
  total: number$2,
  showTotal: bool,
  pageSize: number$2,
  pageSizeOpts: array$1,
  size: string$3,
  currentPage: number$2,
  defaultCurrentPage: number$2,
  onPageChange: func,
  onPageSizeChange: func,
  onChange: func,
  prevText: node$1,
  nextText: node$1,
  showSizeChanger: bool,
  popoverZIndex: number$2,
  popoverPosition: string$3,
  style: object$1,
  className: string$3,
  hideOnSinglePage: bool,
  hoverShowPageSelect: bool,
  showQuickJumper: bool,
  disabled: bool,
  position: string$3
}, defaultProps$G = {
  total: 1,
  popoverZIndex: numbers$f.DEFAULT_Z_INDEX,
  showTotal: !1,
  pageSize: null,
  pageSizeOpts: numbers$4.PAGE_SIZE_OPTION,
  defaultCurrentPage: 1,
  size: "default",
  onPageChange: lodashExports.noop,
  onPageSizeChange: lodashExports.noop,
  onChange: lodashExports.noop,
  showSizeChanger: !1,
  className: "",
  hideOnSinglePage: !1,
  showQuickJumper: !1,
  disabled: !1
}, vuePropsType$16 = vuePropsMake(propTypes$L, defaultProps$G), Pagination = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$16
  },
  name: "Pagination",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useConfigContext(), l = s.total, u = s.pageSize || s.pageSizeOpts[0] || numbers$4.DEFAULT_PAGE_SIZE, c = s.size === "small" && s.hoverShowPageSelect && !s.disabled, m = reactive({
      total: l,
      showTotal: s.showTotal,
      currentPage: s.currentPage || s.defaultCurrentPage,
      pageSize: u,
      pageList: [],
      prevDisabled: !1,
      nextDisabled: !1,
      restLeftPageList: [],
      restRightPageList: [],
      quickJumpPage: "",
      allPageNumbers: c ? Array.from({
        length: Math.ceil(l / u)
      }, (K, ve) => ve + 1) : []
      // only need to count in smallPage mode, when props.size = small
    }), {
      adapter: g,
      getDataAttr: v
    } = useBaseComponent(s, m);
    function b() {
      return {
        ...g(),
        setPageList: (K) => {
          const {
            pageList: ve,
            restLeftPageList: ee,
            restRightPageList: Re
          } = K;
          m.pageList = ve, m.restLeftPageList = ee, m.restRightPageList = Re;
        },
        setDisabled: (K, ve) => {
          m.prevDisabled = K, m.nextDisabled = ve;
        },
        updateTotal: (K) => m.total = K,
        updatePageSize: (K) => m.pageSize = K,
        updateQuickJumpPage: (K) => m.quickJumpPage = K,
        // updateRestPageList: () => {},
        setCurrentPage: (K) => {
          m.currentPage = K;
        },
        registerKeyDownHandler: (K) => {
          document.addEventListener("keydown", K);
        },
        updateAllPageNumbers: (K) => m.allPageNumbers = K,
        unregisterKeyDownHandler: (K) => {
          document.removeEventListener("keydown", K);
        },
        notifyPageChange: (K) => {
          s.onPageChange(K);
        },
        notifyPageSizeChange: (K) => {
          s.onPageSizeChange(K);
        },
        notifyChange: (K, ve) => {
          s.onChange(K, ve);
        }
      };
    }
    const S = b(), E = new PaginationFoundation(S);
    warning$1(!!(s.showSizeChanger && s.hideOnSinglePage), "[Semi Pagination] You should not use showSizeChanger and hideOnSinglePage in ths same time. At this time, hideOnSinglePage no longer takes effect, otherwise there may be a problem that the switch entry disappears"), onMounted(() => {
      E.init();
    }), onUnmounted(() => {
      E.destroy();
    }), watch([() => s.currentPage, () => s.total, () => s.pageSize], (K, [ve, ee, Re], wt) => {
      const yt = {
        currentPage: s.currentPage,
        total: s.total,
        pageSize: s.pageSize
      };
      let xt = !1, Kt = !1;
      ve !== s.currentPage && (xt = !0), ee !== s.total && (xt = !0, Kt = !0), Re !== s.pageSize && (xt = !0, Kt = !0), xt && E.updatePage(yt.currentPage, yt.total, yt.pageSize), Kt && E.updateAllPageNumbers(yt.total, yt.pageSize);
    });
    function P() {
      const {
        prevText: K,
        disabled: ve
      } = s, {
        prevDisabled: ee
      } = m, Re = ee || ve, wt = cls({
        [`${prefixCls$c}-item`]: !0,
        [`${prefixCls$c}-prev`]: !0,
        [`${prefixCls$c}-item-disabled`]: Re
      });
      return createVNode("li", {
        role: "button",
        "aria-disabled": !!Re,
        "aria-label": "Previous",
        onClick: (yt) => !Re && E.goPrev(),
        class: wt,
        "x-semi-prop": "prevText"
      }, [K || createVNode(IconComponent$z, {
        size: "large"
      }, null)]);
    }
    function T() {
      const {
        nextText: K,
        disabled: ve
      } = s, {
        nextDisabled: ee
      } = m, Re = ee || ve, wt = cls({
        [`${prefixCls$c}-item`]: !0,
        [`${prefixCls$c}-item-disabled`]: Re,
        [`${prefixCls$c}-next`]: !0
      });
      return createVNode("li", {
        role: "button",
        "aria-disabled": !!Re,
        "aria-label": "Next",
        onClick: (yt) => !Re && E.goNext(),
        class: wt,
        "x-semi-prop": "nextText"
      }, [K || createVNode(IconComponent$y, {
        size: "large"
      }, null)]);
    }
    function N(K) {
      const {
        direction: ve
      } = o.value, ee = ve === "rtl" ? "bottomRight" : "bottomLeft", {
        showSizeChanger: Re,
        popoverPosition: wt = ee,
        disabled: yt,
        popoverZIndex: xt
      } = s, {
        pageSize: Kt
      } = m, tn = cls(`${prefixCls$c}-switch`);
      if (!Re)
        return null;
      const ln = E.pageSizeInOpts(), rn = K.pageSize, an = ln.map((Gt) => createVNode(Option$1, {
        value: Gt,
        key: Gt
      }, {
        default: () => [createVNode("span", null, [rn.replace("${pageSize}", Gt.toString())])]
      }));
      return createVNode("div", {
        class: tn
      }, [createVNode(Select, {
        "aria-label": "Page size selector",
        disabled: yt,
        onChange: (Gt) => {
          E.changePageSize(Gt);
        },
        value: Kt,
        key: Kt,
        position: wt || "bottomRight",
        clickToHide: !0,
        zIndex: xt,
        dropdownClassName: `${prefixCls$c}-select-dropdown`
      }, _isSlot$e(an) ? an : {
        default: () => [an]
      })]);
    }
    function O(K) {
      const {
        showQuickJumper: ve,
        disabled: ee
      } = s, {
        quickJumpPage: Re,
        total: wt,
        pageSize: yt
      } = m;
      if (!ve)
        return null;
      const Kt = E._getTotalPageNumber(wt, yt) === 1 || ee, tn = cls({
        [`${prefixCls$c}-quickjump`]: !0,
        [`${prefixCls$c}-quickjump-disabled`]: Kt
      });
      return createVNode("div", {
        class: tn
      }, [createVNode("span", null, [K.jumpTo]), createVNode(InputNumber$1, {
        value: Re,
        className: `${prefixCls$c}-quickjump-input-number`,
        hideButtons: !0,
        disabled: Kt,
        onBlur: (ln) => E.handleQuickJumpBlur(),
        onEnterPress: (ln) => E.handleQuickJumpEnterPress(ln.target.value),
        onChange: (ln) => E.handleQuickJumpNumberChange(ln)
      }, null), createVNode("span", null, [K.page])]);
    }
    function z() {
      const {
        pageList: K,
        currentPage: ve,
        restLeftPageList: ee,
        restRightPageList: Re
      } = m, {
        popoverPosition: wt,
        popoverZIndex: yt,
        disabled: xt
      } = s;
      return K.map((Kt, tn) => {
        const ln = cls(`${prefixCls$c}-item`, {
          [`${prefixCls$c}-item-active`]: ve === Kt,
          [`${prefixCls$c}-item-all-disabled`]: xt,
          [`${prefixCls$c}-item-all-disabled-active`]: ve === Kt && xt
          // [`${prefixCls}-item-rest-opening`]: (i < 3 && isLeftRestHover && page ==='...') || (i > 3 && isRightRestHover && page === '...')
        }), rn = createVNode("li", {
          key: `${Kt}${tn}`,
          onClick: () => !xt && E.goPage(Kt),
          class: ln,
          "aria-label": Kt === "..." ? "More" : `Page ${Kt}`,
          "aria-current": ve === Kt ? "page" : !1
        }, [Kt]);
        if (Kt === "..." && !xt) {
          let an;
          return tn < 3 ? an = ee : an = Re, createVNode(Popover$1, {
            rePosKey: s.currentPage,
            trigger: "hover",
            content: Q(an),
            key: `${Kt}${tn}`,
            position: wt,
            zIndex: yt
          }, _isSlot$e(rn) ? rn : {
            default: () => [rn]
          });
        }
        return rn;
      });
    }
    function Q(K) {
      const {
        direction: ve
      } = o.value, ee = cls(`${prefixCls$c}-rest-item`), Re = K.length, wt = (Kt) => {
        const {
          index: tn,
          style: ln
        } = Kt, rn = K[tn];
        return createVNode("div", {
          role: "listitem",
          key: `${rn}${tn}`,
          class: ee,
          onClick: () => E.goPage(rn),
          style: ln,
          "aria-label": `${rn}`
        }, [rn]);
      }, yt = 32, xt = Re >= 5 ? yt * 5 : yt * Re;
      return (
        // @ts-ignore skip type check cause react-window not update with @types/react 18
        createVNode(Jt$1, {
          className: `${prefixCls$c}-rest-list`,
          itemData: K,
          itemSize: yt,
          width: 78,
          itemCount: Re,
          height: xt,
          style: {
            direction: ve
          }
        }, _isSlot$e(wt) ? wt : {
          default: () => [wt]
        })
      );
    }
    function W(K) {
      const ve = m.allPageNumbers, ee = Q(ve);
      return createVNode(Popover$1, {
        content: ee
      }, _isSlot$e(K) ? K : {
        default: () => [K]
      });
    }
    function ue(K) {
      const {
        className: ve,
        style: ee,
        hideOnSinglePage: Re,
        hoverShowPageSelect: wt,
        showSizeChanger: yt,
        disabled: xt,
        ...Kt
      } = s, tn = cls(`${prefixCls$c}-small`, prefixCls$c, ve, {
        [`${prefixCls$c}-disabled`]: xt
      }), {
        currentPage: ln,
        total: rn,
        pageSize: an
      } = m, Gt = Math.ceil(rn / an);
      if (Gt < 2 && Re && !yt)
        return null;
      const nn = cls({
        [`${prefixCls$c}-item`]: !0,
        [`${prefixCls$c}-item-small`]: !0,
        [`${prefixCls$c}-item-all-disabled`]: xt
      }), vt = createVNode("div", {
        class: nn
      }, [ln, createTextVNode("/"), Gt, " "]);
      return createVNode("div", mergeProps$1({
        class: tn,
        style: ee
      }, v()), [P(), wt && !xt ? W(vt) : vt, T(), O(K)]);
    }
    function te(K) {
      const {
        total: ve,
        pageSize: ee
      } = m, {
        showTotal: Re,
        className: wt,
        style: yt,
        hideOnSinglePage: xt,
        showSizeChanger: Kt,
        disabled: tn,
        ...ln
      } = s, rn = cls(wt, `${prefixCls$c}`, {
        [`${prefixCls$c}-disabled`]: tn
      }), an = `${prefixCls$c}-total`;
      if (Math.ceil(ve / ee) < 2 && xt && !Kt)
        return null;
      const nn = Math.ceil(ve / ee), vt = K.total.replace("${total}", nn.toString());
      return createVNode("ul", mergeProps$1({
        class: rn,
        style: yt
      }, v()), [Re ? createVNode("span", {
        class: an
      }, [vt]) : null, P(), z(), T(), N(K), O(K)]);
    }
    return () => {
      const {
        size: K
      } = s;
      return createVNode(LocaleConsumer$6, {
        componentName: "Pagination"
      }, {
        default: (ve) => K === "small" ? ue(ve) : te(ve)
      });
    };
  }
}), Pagination$1 = Pagination, cssClasses$d = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-popconfirm`,
  POPOVER: `${BASE_CLASS_PREFIX$1}-popconfirm-popover`
}, numbers$3 = {
  SPACING: 4,
  DEFAULT_Z_INDEX: 1030
};
class PopConfirmFoundation extends BaseFoundation$1 {
  init() {
  }
  destroy() {
  }
  handleCancel(o) {
    const l = this._adapter.notifyCancel(o);
    isPromise(l) ? (this._adapter.updateCancelLoading(!0), l.then(
      (u) => {
        this.handleVisibleChange(!1), this._adapter.updateCancelLoading(!1);
      },
      (u) => {
        this._adapter.updateCancelLoading(!1);
      }
    )) : this.handleVisibleChange(!1);
  }
  handleConfirm(o) {
    const l = this._adapter.notifyConfirm(o);
    isPromise(l) ? (this._adapter.updateConfirmLoading(!0), l.then(
      (u) => {
        this._adapter.updateConfirmLoading(!1), this.handleVisibleChange(!1);
      },
      (u) => {
        this._adapter.updateConfirmLoading(!1);
      }
    )) : this.handleVisibleChange(!1);
  }
  handleClickOutSide(o) {
    this._adapter.notifyClickOutSide(o);
  }
  handleVisibleChange(o) {
    this._isControlledComponent("visible") || this._adapter.setVisible(o), o ? this.handleFocusOperateButton() : this._adapter.focusPrevFocusElement(), this._adapter.notifyVisibleChange(o);
  }
  handleFocusOperateButton() {
    const { cancelButtonProps: o, okButtonProps: l } = this._adapter.getProps();
    lodashExports.get(o, "autoFocus") && !lodashExports.get(o, "disabled") ? this._adapter.focusCancelButton() : lodashExports.get(l, "autoFocus") && !lodashExports.get(l, "disabled") && this._adapter.focusOkButton();
  }
}
const propTypes$K = {
  ...vuePropsType$2Y,
  motion: oneOfType([bool, func, object$1]),
  disabled: bool,
  content: oneOfType([node$1, func]),
  title: any$1,
  prefixCls: string$3,
  className: string$3,
  style: object$1,
  icon: oneOfType([string$3, node$1]),
  okText: string$3,
  okType: string$3,
  cancelText: string$3,
  cancelType: string$3,
  onCancel: func,
  onConfirm: func,
  onClickOutSide: func,
  onVisibleChange: func,
  visible: bool,
  defaultVisible: bool,
  okButtonProps: object$1,
  cancelButtonProps: object$1,
  stopPropagation: oneOfType([bool, string$3]),
  showCloseIcon: bool,
  zIndex: number$2,
  // private
  trigger: string$3,
  position: string$3
}, defaultProps$F = {
  stopPropagation: !0,
  trigger: "click",
  // position: 'bottomLeft',
  onVisibleChange: lodashExports.noop,
  disabled: !1,
  icon: createVNode(IconComponent$J, {
    size: "extra-large"
  }, null),
  okType: "primary",
  cancelType: "tertiary",
  prefixCls: cssClasses$d.PREFIX,
  zIndex: numbers$3.DEFAULT_Z_INDEX,
  showCloseIcon: !0,
  onCancel: lodashExports.noop,
  onConfirm: lodashExports.noop,
  onClickOutSide: lodashExports.noop
}, vuePropsType$15 = vuePropsMake(propTypes$K, defaultProps$F), Popconfirm = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$15
  },
  name: "Popconfirm",
  setup(s, {}) {
    const o = useSlots(), {
      getProps: l
    } = useHasInProps(), {
      context: u
    } = useConfigContext(), c = reactive({
      cancelLoading: !1,
      confirmLoading: !1,
      visible: s.defaultVisible || !1
    }), m = ref$1(), g = ref$1(), {
      adapter: v,
      isControlled: b
    } = useBaseComponent(s, c);
    function S() {
      return {
        ...v(),
        setVisible: (K) => {
          c.visible = K;
        },
        updateConfirmLoading: (K) => {
          c.confirmLoading = K;
        },
        updateCancelLoading: (K) => {
          c.cancelLoading = K;
        },
        notifyConfirm: (K) => s.onConfirm(K),
        notifyCancel: (K) => s.onCancel(K),
        notifyVisibleChange: (K) => s.onVisibleChange(K),
        notifyClickOutSide: (K) => s.onClickOutSide(K),
        focusCancelButton: () => {
          var ve;
          const K = (ve = m.value) == null ? void 0 : ve.querySelector("[data-type=cancel]");
          K == null || K.focus({
            preventScroll: !0
          });
        },
        focusOkButton: () => {
          var ve;
          const K = (ve = m.value) == null ? void 0 : ve.querySelector("[data-type=ok]");
          K == null || K.focus({
            preventScroll: !0
          });
        },
        focusPrevFocusElement: () => {
          var K;
          (K = g.value) == null || K.focusTrigger();
        }
      };
    }
    const E = S(), P = new PopConfirmFoundation(E);
    function T(K, ve) {
      const ee = {}, {
        hasOwnProperty: Re
      } = Object.prototype;
      return Re.call(K, "visible") && (ee.visible = K.visible), ee;
    }
    watch(() => s.visible, (K) => {
      const ve = T({
        ...s
      }, {
        ...c
      });
      ve && Object.keys(ve).forEach((ee) => {
        c[ee] = ve[ee];
      });
    }, {
      immediate: !0
    });
    const N = (K) => P.handleCancel(K), O = (K) => P.handleConfirm(K), z = (K) => P.handleVisibleChange(K), Q = (K) => P.handleClickOutSide(K), W = (K) => K && K.nativeEvent && K.nativeEvent.stopImmediatePropagation();
    function ue() {
      const {
        okText: K,
        cancelText: ve,
        okType: ee,
        cancelType: Re,
        cancelButtonProps: wt,
        okButtonProps: yt
      } = s, {
        cancelLoading: xt,
        confirmLoading: Kt
      } = c;
      return createVNode(LocaleConsumer$6, {
        componentName: "Popconfirm"
      }, {
        default: (tn, ln) => createVNode(Fragment, null, [createVNode(Button$2, mergeProps$1({
          "data-type": "cancel",
          type: Re,
          onClick: N,
          loading: xt
        }, lodashExports.omit(wt, "autoFocus")), {
          default: () => [ve || lodashExports.get(tn, "cancel")]
        }), createVNode(Button$2, mergeProps$1({
          "data-type": "ok",
          type: ee,
          theme: "solid",
          onClick: O,
          loading: Kt
        }, lodashExports.omit(yt, "autoFocus")), {
          default: () => [K || lodashExports.get(tn, "confirm")]
        })])
      });
    }
    function te({
      initialFocusRef: K
    }) {
      const {
        content: ve,
        title: ee,
        className: Re,
        style: wt,
        cancelType: yt,
        icon: xt,
        prefixCls: Kt,
        showCloseIcon: tn
      } = s, {
        direction: ln
      } = u.value, rn = cls(Kt, Re, {
        [`${Kt}-rtl`]: ln === "rtl"
      }), an = ee !== null && typeof ee < "u", Gt = !(ve === null || typeof ve > "u"), nn = isVNode(xt), vt = cls({
        [`${Kt}-body`]: !0,
        [`${Kt}-body-withIcon`]: nn
      });
      return (
        // eslint-disable-next-line jsx-a11y/click-events-have-key-events, jsx-a11y/no-static-element-interactions
        createVNode("div", {
          class: rn,
          onClick: W,
          style: wt
        }, [createVNode("div", {
          class: `${Kt}-inner`
        }, [createVNode("div", {
          class: `${Kt}-header`
        }, [nn ? createVNode("i", {
          class: `${Kt}-header-icon`,
          "x-semi-prop": "icon"
        }, [xt]) : null, createVNode("div", {
          class: `${Kt}-header-body`
        }, [an ? createVNode("div", {
          class: `${Kt}-header-title`,
          "x-semi-prop": "title"
        }, [ee]) : null]), tn ? createVNode(Button$2, {
          className: `${Kt}-btn-close`,
          icon: createVNode(IconComponent$u, null, null),
          size: "small",
          theme: "borderless",
          type: yt,
          onClick: N
        }, null) : null]), Gt ? createVNode("div", {
          class: vt,
          "x-semi-prop": "content"
        }, [lodashExports.isFunction(ve) ? ve({
          initialFocusRef: K
        }) : ve]) : null, createVNode("div", {
          class: `${Kt}-footer`,
          ref: m
        }, [ue()])])])
      );
    }
    return () => {
      var vn;
      const {
        direction: K
      } = u.value, ve = K === "rtl" ? "bottomRight" : "bottomLeft", ee = (vn = o.default) == null ? void 0 : vn.call(o), {
        className: Re,
        prefixCls: wt,
        disabled: yt,
        style: xt,
        position: Kt = ve,
        title: tn,
        icon: ln,
        okType: rn,
        cancelType: an,
        defaultVisible: Gt,
        okButtonProps: nn,
        cancelButtonProps: vt,
        onCancel: Et,
        onConfirm: Qt,
        showCloseIcon: un,
        ...gn
      } = l(s);
      if (yt)
        return ee;
      const {
        visible: dn
      } = c, yn = {
        onVisibleChange: z,
        className: cssClasses$d.POPOVER,
        onClickOutSide: Q
      };
      return b("visible") && (yn.trigger = "custom"), createVNode(Popover$1, mergeProps$1({
        ref: g
      }, {
        ...gn,
        // A arrow function needs to be passed here, otherwise the content will not be updated after the Popconfirm state is updated
        // Popover is a PureComponent, same props will not trigger update
        content: ({
          initialFocusRef: Pn
        }) => te({
          initialFocusRef: Pn
        }),
        visible: dn,
        position: Kt,
        ...yn
      }), {
        default: o.default
      });
    };
  }
}), Popconfirm$1 = Popconfirm, cssClasses$c = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-sidesheet`,
  DIALOG: `${BASE_CLASS_PREFIX$1}-modal`
}, strings$3 = {
  PLACEMENT: ["top", "right", "bottom", "left"],
  SIZE: ["small", "medium", "large"],
  WIDTH: {
    small: 448,
    medium: 684,
    large: 920
  },
  HEIGHT: 448
}, prefixCls$b = cssClasses$c.PREFIX, propTypes$J = {
  size: {
    type: String,
    required: !0
  },
  onClose: func,
  closeIcon: node$1,
  mask: bool,
  maskStyle: object$1,
  maskClosable: bool,
  maskClassName: string$3,
  title: node$1,
  closable: bool,
  headerStyle: object$1,
  width: {
    type: [string$3, number$2],
    required: !0
  },
  height: {
    type: [string$3, number$2],
    required: !0
  },
  style: {
    type: object$1,
    required: !0
  },
  bodyStyle: object$1,
  className: {
    type: string$3,
    required: !0
  },
  dialogClassName: string$3,
  footer: node$1,
  "aria-label": string$3,
  maskExtraProps: object$1,
  wrapperExtraProps: object$1,
  // children: PropTypes.node as PropType<SideSheetContentProps['children']>,
  motion: bool,
  visible: bool
}, defaultProps$E = {
  onClose: lodashExports.noop
}, vuePropsType$14 = vuePropsMake(propTypes$J, defaultProps$E), SideSheetContent = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$14
  },
  name: "SideSheetContent",
  setup(s, {}) {
    const o = useSlots();
    let l;
    onMounted(() => {
    }), onBeforeUnmount(() => {
      clearTimeout(l);
    });
    const u = (b) => {
      b.target === b.currentTarget && c(b);
    }, c = (b) => {
      const {
        onClose: S
      } = s;
      S && S(b);
    };
    function m() {
      const {
        mask: b,
        maskStyle: S,
        maskClosable: E
      } = s;
      return b ? createVNode("div", mergeProps$1({
        "aria-hidden": !0,
        key: "mask",
        class: cls(`${prefixCls$b}-mask`, s.maskClassName ?? ""),
        style: S,
        onClick: E ? u : null
      }, s.maskExtraProps), null) : null;
    }
    function g() {
      const {
        title: b,
        closable: S,
        headerStyle: E,
        closeIcon: P
      } = s;
      let T, N;
      if (b && (T = createVNode("div", {
        class: `${prefixCls$b}-title`,
        "x-semi-prop": "title"
      }, [s.title])), S) {
        const O = P || createVNode(IconComponent$u, null, null);
        N = createVNode(Button$3, {
          className: `${prefixCls$b}-close`,
          key: "close-btn",
          onClick: c,
          type: "tertiary",
          icon: O,
          theme: "borderless",
          size: "small"
        }, null);
      }
      return createVNode("div", {
        class: `${prefixCls$b}-header`,
        role: "heading",
        "aria-level": 1,
        style: {
          ...E
        }
      }, [T, N]);
    }
    function v() {
      var P;
      const b = {};
      s.width && (b.width = typeof s.width == "string" ? s.width : s.width + "px", s.mask || (b.width = "100%")), s.height && (b.height = typeof s.height == "string" ? s.height : s.height + "px");
      const S = g();
      return createVNode("div", mergeProps$1({
        key: "dialog-element",
        role: "dialog",
        tabindex: -1,
        class: cls(`${prefixCls$b}-inner`, `${prefixCls$b}-inner-wrap`, s.dialogClassName ?? ""),
        style: {
          ...s.style,
          ...b
        }
      }, s.wrapperExtraProps), [createVNode("div", {
        class: `${prefixCls$b}-content`
      }, [S, createVNode("div", {
        class: `${prefixCls$b}-body`,
        style: s.bodyStyle,
        "x-semi-prop": "children"
      }, [(P = o.default) == null ? void 0 : P.call(o)]), s.footer ? createVNode("div", {
        class: `${prefixCls$b}-footer`,
        "x-semi-prop": "footer"
      }, [s.footer]) : null])]);
    }
    return () => {
      const {
        mask: b,
        className: S,
        width: E,
        onClose: P,
        maskStyle: T,
        maskClosable: N,
        maskClassName: O,
        title: z,
        closable: Q,
        headerStyle: W,
        height: ue,
        style: te,
        size: K,
        bodyStyle: ve,
        dialogClassName: ee,
        footer: Re,
        maskExtraProps: wt,
        wrapperExtraProps: yt,
        ...xt
      } = s, Kt = cls(S, {
        [`${prefixCls$b}-fixed`]: !b
      }), tn = {};
      !b && E && (tn.width = typeof E == "string" ? E : E + "px");
      const ln = getDataAttr(xt);
      return createVNode("div", mergeProps$1({
        class: Kt,
        style: tn
      }, ln), [m(), v()]);
    };
  }
});
class SideSheetFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...SideSheetFoundation.defaultAdapter, ...o }), this.toggleDisplayNone = (l) => {
      this._adapter.toggleDisplayNone(l);
    };
  }
  get defaultAdapter() {
    return {
      handleCancel: lodashExports.noop,
      beforeShow: lodashExports.noop,
      afterHide: lodashExports.noop
    };
  }
  destroy() {
    this.afterHide();
  }
  handleCancel(o) {
    this._adapter.notifyCancel(o);
  }
  beforeShow() {
    this.getProp("disableScroll") && this._adapter.disabledBodyScroll(), this._adapter.setOnKeyDownListener();
  }
  afterHide() {
    this.getProp("disableScroll") && this._adapter.enabledBodyScroll(), this._adapter.removeKeyDownListener();
  }
  handleKeyDown(o) {
    const { closeOnEsc: l } = this.getProps();
    if (l && o.keyCode === KeyCode.ESC) {
      o.stopPropagation(), this.handleCancel(o);
      return;
    }
  }
  onVisibleChange(o) {
    this._adapter.notifyVisibleChange(o);
  }
}
const prefixCls$a = cssClasses$c.PREFIX, defaultWidthList = strings$3.WIDTH, defaultHeight = strings$3.HEIGHT, propTypes$I = {
  bodyStyle: object$1,
  headerStyle: object$1,
  className: string$3,
  closable: bool,
  disableScroll: bool,
  getPopupContainer: func,
  height: oneOfType([number$2, string$3]),
  mask: bool,
  maskClosable: bool,
  maskStyle: object$1,
  motion: oneOfType([bool, object$1, func]),
  onCancel: func,
  placement: string$3,
  size: string$3,
  style: object$1,
  title: node$1,
  visible: bool,
  width: oneOfType([number$2, string$3]),
  zIndex: number$2,
  afterVisibleChange: func,
  closeOnEsc: bool,
  footer: node$1,
  keepDOM: bool,
  "aria-label": string$3,
  closeIcon: node$1
}, defaultProps$D = {
  visible: !1,
  motion: !0,
  mask: !0,
  placement: "right",
  closable: !0,
  footer: null,
  zIndex: 1e3,
  maskClosable: !0,
  size: "small",
  disableScroll: !0,
  closeOnEsc: !1,
  afterVisibleChange: lodashExports.noop,
  keepDOM: !1
}, vuePropsType$13 = vuePropsMake(propTypes$I, defaultProps$D), SideSheet = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$13
  },
  name: "SideSheet",
  setup(s, {}) {
    const o = useSlots();
    let l = "", u = 0, c = "100%";
    const m = reactive({
      displayNone: !s.visible
    }), {
      context: g
    } = useConfigContext(), {
      adapter: v
    } = useBaseComponent(s, m);
    function b() {
      return {
        ...v(),
        disabledBodyScroll: () => {
          const {
            getPopupContainer: Q
          } = s;
          l = document.body.style.overflow || "", !Q && l !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${c || "100%"} - ${u}px)`);
        },
        enabledBodyScroll: () => {
          const {
            getPopupContainer: Q
          } = s;
          !Q && l !== "hidden" && (document.body.style.overflow = l, document.body.style.width = c);
        },
        notifyCancel: (Q) => {
          s.onCancel && s.onCancel(Q);
        },
        notifyVisibleChange: (Q) => {
          s.afterVisibleChange(Q);
        },
        setOnKeyDownListener: () => {
          window && window.addEventListener("keydown", N);
        },
        removeKeyDownListener: () => {
          window && window.removeEventListener("keydown", N);
        },
        toggleDisplayNone: (Q) => {
          Q !== m.displayNone && (m.displayNone = Q);
        }
      };
    }
    const S = b(), E = new SideSheetFoundation(S);
    function P(Q) {
      const W = {};
      return Q.visible && m.displayNone && (W.displayNone = !1), !Q.visible && !Q.motion && !m.displayNone && (W.displayNone = !0), W;
    }
    watch([() => s.visible, () => s.motion, () => m.displayNone], () => {
      const Q = P({
        ...s
      });
      Q && Object.keys(Q).forEach((W) => {
        m[W] = Q[W];
      });
    }), onMounted(() => {
      u = getScrollbarWidth(), c = document.body.style.width, s.visible && E.beforeShow();
    }), watch([() => s.visible, () => m.displayNone], (Q, [W, ue], te) => {
      !W && s.visible && E.beforeShow(), W && !s.visible && E.afterHide(), ue !== m.displayNone && E.onVisibleChange(!m.displayNone);
    }), onBeforeUnmount(() => {
      s.visible && E.destroy();
    });
    const T = (Q) => {
      E.handleCancel(Q);
    }, N = (Q) => {
      E.handleKeyDown(Q);
    }, O = () => {
      E.toggleDisplayNone(!s.visible);
    };
    function z() {
      const {
        placement: Q,
        className: W,
        width: ue,
        height: te,
        motion: K,
        visible: ve,
        style: ee,
        maskStyle: Re,
        size: wt,
        zIndex: yt,
        getPopupContainer: xt,
        keepDOM: Kt,
        afterVisibleChange: tn,
        disableScroll: ln,
        closeOnEsc: rn,
        ...an
      } = s;
      let Gt = {
        zIndex: yt
      };
      xt && (Gt = {
        zIndex: yt,
        position: "static"
      });
      const {
        direction: nn
      } = g.value, vt = Q === "left" || Q === "right", Et = Q === "top" || Q === "bottom", Qt = vt ? ue || defaultWidthList[wt] : "100%", un = Et ? te || defaultHeight : "100%", gn = cls(prefixCls$a, W, {
        [`${prefixCls$a}-${Q}`]: Q,
        [`${prefixCls$a}-popup`]: xt,
        [`${prefixCls$a}-horizontal`]: Et,
        [`${prefixCls$a}-rtl`]: nn === "rtl",
        [`${prefixCls$a}-hidden`]: Kt && m.displayNone
      }), dn = {
        ...vt ? ue ? {
          width: ue
        } : {} : {
          width: "100%"
        },
        ...an,
        visible: ve,
        motion: !1,
        size: wt,
        className: gn,
        width: Qt,
        height: un,
        onClose: T
      }, yn = s.visible || s.keepDOM || s.motion && !m.displayNone;
      return createVNode(CSSAnimation, {
        motion: s.motion,
        animationState: ve ? "enter" : "leave",
        startClassName: ve ? `${prefixCls$a}-animation-mask_show` : `${prefixCls$a}-animation-mask_hide`,
        onAnimationEnd: O,
        children: ({
          animationClassName: vn,
          animationEventsNeedBind: Pn
        }) => createVNode(CSSAnimation, {
          motion: s.motion,
          animationState: ve ? "enter" : "leave",
          startClassName: ve ? `${prefixCls$a}-animation-content_show_${s.placement}` : `${prefixCls$a}-animation-content_hide_${s.placement}`,
          onAnimationEnd: O,
          children: ({
            animationClassName: On,
            animationStyle: _n,
            animationEventsNeedBind: Nn
          }) => yn ? createVNode(Index$9, {
            getPopupContainer: xt,
            style: Gt
          }, {
            default: () => [createVNode(SideSheetContent, mergeProps$1(dn, {
              maskExtraProps: Pn,
              wrapperExtraProps: Nn,
              dialogClassName: On,
              maskClassName: vn,
              maskStyle: {
                ...Re
              },
              style: {
                ..._n,
                ...ee
              }
            }), {
              default: o.default
            })]
          }) : null
        }, null)
      }, null);
    }
    return () => z();
  }
}), SideSheet$1 = SideSheet, stepsClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-steps`,
  ITEM: `${BASE_CLASS_PREFIX$1}-steps-item`
};
let stepSizeMapIconSize = /* @__PURE__ */ function(s) {
  return s.small = "large", s.default = "extra-large", s;
}({});
const propTypes$H = {
  prefixCls: string$3,
  description: node$1,
  icon: node$1,
  status: string$3,
  title: node$1,
  className: string$3,
  style: object$1,
  onClick: func,
  active: bool,
  done: bool,
  direction: string$3,
  // children: PropTypes.node as PropType<BasicStepProps['children']>,
  onChange: func,
  stepNumber: [number$2, string$3],
  size: string$3,
  onKeyDown: func,
  role: string$3,
  "aria-label": string$3
}, defaultProps$C = {
  prefixCls: stepsClasses.ITEM,
  active: !1,
  done: !1,
  status: "wait",
  className: "",
  size: "default",
  onChange: lodashExports.noop
}, vuePropsType$12 = vuePropsMake(propTypes$H, defaultProps$C), BasicStep = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$12
  },
  name: "BasicStep",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    return useSlots(), () => {
      const {
        prefixCls: l,
        className: u,
        size: c,
        title: m,
        description: g,
        status: v,
        style: b,
        active: S,
        done: E,
        icon: P,
        stepNumber: T,
        onClick: N,
        onChange: O,
        onKeyDown: z
      } = s, Q = () => {
        let K, ve;
        if ("icon" in o(s))
          isVNode(P) && (K = P);
        else if ("status" in o(s))
          switch (v) {
            case "error":
              K = createVNode(IconComponent$K, {
                size: stepSizeMapIconSize[c]
              }, null);
              break;
            case "wait":
              K = createVNode("span", {
                class: `${l}-number-icon`
              }, [T]);
              break;
            case "process":
              K = createVNode("span", {
                class: `${l}-number-icon`
              }, [T]), ve = !0;
              break;
            case "finish":
              K = createVNode(IconComponent$5, {
                size: stepSizeMapIconSize[c]
              }, null);
              break;
            case "warning":
              K = createVNode(IconComponent$J, {
                size: stepSizeMapIconSize[c]
              }, null);
              break;
            default:
              K = null;
              break;
          }
        const ee = cls({
          [`${l}-icon`]: !0,
          [`${l}-custom-icon`]: "icon" in o(s),
          [`${l}-icon-process`]: ve
        });
        return K ? createVNode("span", {
          class: ee
        }, [K]) : null;
      }, W = cls(l, `${l}-${v}`, {
        [`${l}-active`]: S,
        [`${l}-done`]: E,
        [`${l}-hover`]: O || s.onClick,
        [`${l}-clickable`]: O || N,
        [`${l}-${v}-hover`]: O || s.onClick
      }, u), ue = (K) => {
        N == null || N(K), O == null || O();
      }, te = (K) => {
        K.key === "Enter" && (z == null || z(K), O == null || O());
      };
      return createVNode("div", {
        role: s.role,
        "aria-label": s["aria-label"],
        tabindex: 0,
        "aria-current": "step",
        class: W,
        style: b,
        onClick: (K) => ue(K),
        onKeydown: te
      }, [createVNode("div", {
        class: `${l}-container`
      }, [createVNode("div", {
        class: `${l}-left`
      }, [Q()]), createVNode("div", {
        class: `${l}-content`
      }, [createVNode("div", {
        class: `${l}-title`
      }, [createVNode("div", {
        class: `${l}-title-text`
      }, [m])]), g && createVNode("div", {
        class: `${l}-description`
      }, [g])])])]);
    };
  }
}), propTypes$G = {
  prefixCls: string$3,
  description: node$1,
  icon: node$1,
  status: string$3,
  title: node$1,
  className: string$3,
  style: object$1,
  onClick: func,
  onChange: func,
  direction: string$3,
  stepNumber: string$3,
  onKeyDown: func,
  role: string$3,
  "aria-label": string$3
}, defaultProps$B = {
  prefixCls: stepsClasses.ITEM,
  status: "wait",
  className: "",
  onChange: lodashExports.noop
}, vuePropsType$11 = vuePropsMake(propTypes$G, defaultProps$B), FillStep = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$11
  },
  name: "FillStep",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    return useSlots(), () => {
      const {
        prefixCls: l,
        className: u,
        title: c,
        description: m,
        status: g,
        style: v,
        onClick: b,
        icon: S,
        onChange: E,
        stepNumber: P,
        onKeyDown: T
      } = s, N = () => {
        let Q, W;
        if ("icon" in o(s))
          Q = S;
        else if ("status" in o(s))
          switch (g) {
            case "error":
              Q = createVNode(IconComponent$K, {
                size: "extra-large"
              }, null);
              break;
            case "wait":
              Q = P;
              break;
            case "process":
              Q = P, W = !0;
              break;
            case "finish":
              Q = createVNode(IconComponent$5, {
                size: "extra-large"
              }, null);
              break;
            case "warning":
              Q = createVNode(IconComponent$J, {
                size: "extra-large"
              }, null);
              break;
            default:
              Q = null;
              break;
          }
        const ue = cls({
          [`${l}-left`]: !0,
          [`${l}-icon`]: "icon" in o(s),
          [`${l}-plain`]: !("icon" in o(s)),
          [`${l}-icon-process`]: W,
          [`${l}-hover`]: E || b
        });
        return Q ? createVNode("div", {
          class: ue
        }, [Q]) : null;
      }, O = (Q) => {
        b == null || b(Q), E == null || E();
      }, z = (Q) => {
        Q.key === "Enter" && (T == null || T(Q), E == null || E());
      };
      return createVNode("div", {
        role: s.role,
        "aria-label": s["aria-label"],
        "aria-current": "step",
        tabindex: 0,
        class: cls({
          [l]: !0,
          [`${l}-${g}`]: !!g,
          [`${l}-${g}-hover`]: !!g && (E || b),
          [`${l}-${g}-active`]: !!g && (E || b),
          [`${l}-clickable`]: E || b
        }, u),
        style: v,
        onClick: (Q) => {
          O(Q);
        },
        onKeydown: z
      }, [N(), createVNode("div", {
        class: `${l}-content`
      }, [createVNode("div", {
        class: `${l}-title`,
        title: typeof c == "string" ? c : null
      }, [createVNode("span", {
        class: `${l}-title-text`
      }, [c])]), createVNode("div", {
        class: `${l}-description`,
        title: typeof m == "string" ? m : null
      }, [m])])]);
    };
  }
}), propTypes$F = {
  prefixCls: string$3,
  title: node$1,
  className: string$3,
  style: object$1,
  onClick: func,
  active: bool,
  onChange: func,
  stepNumber: [number$2, string$3],
  onKeyDown: func,
  role: string$3,
  "aria-label": string$3,
  index: number$2,
  total: number$2
}, defaultProps$A = {
  prefixCls: stepsClasses.ITEM,
  active: !1,
  className: "",
  onChange: lodashExports.noop
}, vuePropsType$10 = vuePropsMake(propTypes$F, defaultProps$A), NavStep = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$10
  },
  name: "NavStep",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        prefixCls: o,
        className: l,
        title: u,
        style: c,
        active: m,
        index: g,
        total: v,
        onClick: b,
        onKeyDown: S,
        onChange: E
      } = s, P = cls(o, {
        [`${o}-active`]: m
      }, l), T = (O) => {
        b == null || b(O), E == null || E();
      }, N = (O) => {
        O.key === "Enter" && (S == null || S(O), E == null || E());
      };
      return createVNode("div", {
        role: s.role,
        "aria-label": s["aria-label"],
        "aria-current": "step",
        tabindex: 0,
        class: P,
        style: c,
        onClick: (O) => T(O),
        onKeydown: N
      }, [createVNode("div", {
        class: `${o}-container`
      }, [createVNode("div", {
        class: `${o}-content`
      }, [createVNode("div", {
        class: `${o}-title`
      }, [u])]), g !== v - 1 && createVNode("div", {
        class: `${o}-icon`
      }, [createVNode(IconComponent$y, {
        size: "small"
      }, null)])])]);
    };
  }
});
function useStepsContext() {
  return {
    context: inject("StepsContext", ref$1(null))
  };
}
const vuePropsType$$ = {
  name: String
}, Consumer$7 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useStepsContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$$
  },
  name: "StepsContextConsumer"
}), Consumer$8 = Consumer$7, vuePropsType$_ = {
  description: node$1,
  icon: node$1,
  status: string$3,
  title: node$1,
  className: string$3,
  style: object$1,
  onClick: func
}, Step = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$_
  },
  name: "Step",
  setup(s, {}) {
    const {
      context: o
    } = useStepsContext(), l = () => {
      switch (o.value.type) {
        case "fill":
          return createVNode(FillStep, s, null);
        case "basic":
          return createVNode(BasicStep, s, null);
        case "nav":
          return createVNode(NavStep, s, null);
        default:
          return null;
      }
    };
    return () => l();
  }
}), Step$1 = Step;
function _isSlot$d(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$E = {
  prefixCls: string$3,
  className: string$3,
  style: object$1,
  current: number$2,
  initial: number$2,
  direction: string$3,
  status: string$3,
  children: node$1,
  onChange: func,
  size: string$3,
  "aria-label": string$3
}, defaultProps$z = {
  prefixCls: stepsClasses.PREFIX,
  current: 0,
  direction: "horizontal",
  initial: 0,
  status: "process"
}, vuePropsType$Z = vuePropsMake(propTypes$E, defaultProps$z), FillSteps = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$Z
  },
  name: "FillSteps",
  setup(s, {}) {
    const o = useSlots();
    return () => {
      const {
        current: l,
        status: u,
        children: c,
        prefixCls: m,
        initial: g,
        direction: v,
        className: b,
        style: S,
        onChange: E
      } = s, P = () => {
        const N = getFragmentChildren(o).filter((Q) => isVNode(Q)), O = v === "vertical" ? null : {
          width: `${100 / N.length}%`
        };
        return N.map((Q, W) => {
          let ue;
          if (!Q)
            return null;
          const te = g + W, K = {
            stepNumber: `${te + 1}`,
            direction: v,
            ...Q.props
          };
          return u === "error" && W === l - 1 && (K.className = `${m}-next-error`), Q.props.status || (te === l ? K.status = u : te < l ? K.status = "finish" : K.status = "wait"), K.onChange = E ? () => {
            W !== l && E(W + g);
          } : void 0, createVNode(Col$1, {
            style: O
          }, _isSlot$d(ue = cloneVNode(Q, {
            ...K
          })) ? ue : {
            default: () => [ue]
          });
        });
      }, T = cls(b, {
        [m]: !0,
        [`${m}-${v}`]: !0
      });
      return createVNode("div", {
        class: T,
        style: S,
        "aria-label": s["aria-label"]
      }, [createVNode(Row$1, {
        type: "flex",
        justify: "start"
      }, _isSlot$d(P) ? P : {
        default: () => [P]
      })]);
    };
  }
}), propTypes$D = {
  prefixCls: string$3,
  className: string$3,
  style: object$1,
  current: number$2,
  initial: number$2,
  direction: string$3,
  status: string$3,
  hasLine: bool,
  children: node$1,
  onChange: func,
  "aria-label": string$3,
  size: string$3
}, defaultProps$y = {
  prefixCls: stepsClasses.PREFIX,
  current: 0,
  direction: "horizontal",
  size: "",
  initial: 0,
  hasLine: !0,
  status: "process",
  onChange: lodashExports.noop
}, vuePropsType$Y = vuePropsMake(propTypes$D, defaultProps$y), Steps$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$Y
  },
  name: "Steps",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs();
    return () => {
      var Q;
      (Q = o.default) == null || Q.call(o);
      const {
        size: u,
        current: c,
        status: m,
        prefixCls: g,
        initial: v,
        direction: b,
        className: S,
        style: E,
        hasLine: P,
        onChange: T,
        ...N
      } = s, O = () => getFragmentChildren(o).filter((te) => isVNode(te)).map((te, K) => {
        if (!te)
          return null;
        const ve = v + K, ee = {
          stepNumber: `${ve + 1}`,
          size: u,
          ...te.props
        };
        return m === "error" && K === c - 1 && (ee.className = `${g}-next-error`), te.props.status || (ve === c ? ee.status = m : ve < c ? ee.status = "finish" : ee.status = "wait"), ee.active = ve === c, ee.done = ve < c, ee.onChange = T ? () => {
          K !== c && T(K + v);
        } : void 0, cloneVNode(te, {
          ...ee
        });
      }), z = cls(S, {
        [`${g}-basic`]: !0,
        [`${g}-${b}`]: !0,
        [`${g}-${u}`]: u !== "default",
        [`${g}-hasline`]: P
      });
      return createVNode("div", mergeProps$1({
        "aria-label": s["aria-label"],
        class: z,
        style: E
      }, getDataAttr({
        ...N,
        ...l
      })), [O()]);
    };
  }
}), propTypes$C = {
  prefixCls: string$3,
  className: string$3,
  style: object$1,
  current: number$2,
  initial: number$2,
  children: node$1,
  onChange: func,
  "aria-label": string$3,
  direction: string$3,
  size: string$3,
  status: string$3
}, defaultProps$x = {
  prefixCls: stepsClasses.PREFIX,
  current: 0,
  direction: "horizontal",
  size: "default",
  initial: 0,
  status: "process",
  onChange: lodashExports.noop
}, vuePropsType$X = vuePropsMake(propTypes$C, defaultProps$x), NavSteps = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$X
  },
  name: "NavSteps",
  setup(s, {}) {
    useSlots();
    const o = useAttrs();
    return () => {
      const {
        size: l,
        current: u,
        initial: c,
        children: m,
        prefixCls: g,
        className: v,
        style: b,
        onChange: S,
        ...E
      } = s, P = () => {
        const N = m.filter((Q) => isVNode(Q)), O = N.length;
        return N.map((Q, W) => {
          if (!Q)
            return null;
          const ue = {
            index: W,
            total: O,
            ...Q.props
          };
          return ue.active = W === u, ue.onChange = S ? () => {
            W !== u && S(W + c);
          } : void 0, cloneVNode(Q, {
            ...ue
          });
        });
      }, T = cls(v, {
        [`${g}-nav`]: !0,
        [`${g}-${l}`]: l !== "default"
      });
      return createVNode("div", mergeProps$1({
        "aria-label": s["aria-label"],
        class: T,
        style: b
      }, getDataAttr({
        ...E,
        ...o
      })), [P()]);
    };
  }
}), vuePropsType$W = {
  value: Object
}, Provider$7 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("StepsContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$W
  },
  name: "StepsContextProvider"
}), Context = {
  Provider: Provider$7,
  Consumer: Consumer$8
};
function _isSlot$c(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$B = {
  onChange: func,
  // @ts-ignore
  type: string$3,
  size: string$3,
  current: number$2,
  style: object$1,
  direction: string$3,
  prefixCls: string$3,
  description: node$1,
  icon: node$1,
  status: string$3,
  title: node$1,
  className: string$3,
  onClick: func,
  active: bool,
  done: bool,
  children: node$1,
  stepNumber: [number$2, string$3],
  onKeyDown: func,
  role: string$3,
  "aria-label": string$3
}, defaultProps$w = {
  type: "fill",
  size: "default"
}, vuePropsType$V = vuePropsMake(propTypes$B, defaultProps$w), Steps = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$V
  },
  name: "Steps",
  setup(s, {}) {
    const o = useSlots(), l = ref$1([]);
    function u() {
      const {
        type: c,
        ...m
      } = s;
      switch (c) {
        case "fill":
          return createVNode(FillSteps, mergeProps$1(m, {
            children: l.value
          }), {
            default: o.default
          });
        case "basic":
          return createVNode(Steps$1, mergeProps$1(m, {
            children: l.value
          }), {
            default: o.default
          });
        case "nav":
          return createVNode(NavSteps, mergeProps$1(m, {
            children: l.value
          }), {
            default: o.default
          });
        default:
          return null;
      }
    }
    return () => {
      var g;
      let c;
      l.value = (g = o.default) == null ? void 0 : g.call(o);
      const {
        type: m
      } = s;
      return createVNode(Context.Provider, {
        value: {
          type: m
        }
      }, _isSlot$c(c = u()) ? c : {
        default: () => [c]
      });
    };
  }
}), BaseSteps = Steps;
BaseSteps.Step = Step$1;
const BaseSteps$1 = BaseSteps;
class SwitchFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleFocusVisible = (l) => {
      const { target: u } = l;
      try {
        u.matches(":focus-visible") && this._adapter.setFocusVisible(!0);
      } catch {
        warning$1(!0, "Warning: [Semi Switch] The current browser does not support the focus-visible");
      }
    }, this.handleBlur = () => {
      this._adapter.setFocusVisible(!1);
    };
  }
  init() {
    const { disabled: o } = this.getProps();
    this.setDisabled(o);
  }
  setChecked(o) {
    this._adapter.setNativeControlChecked(o);
  }
  setDisabled(o) {
    this._adapter.setNativeControlDisabled(o);
  }
  handleChange(o, l) {
    typeof this.getProps().checked < "u" ? this._adapter.notifyChange(o, l) : (this._adapter.setNativeControlChecked(o), this._adapter.notifyChange(o, l));
  }
  destroy() {
  }
}
const cssClasses$b = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-switch`,
  FOCUS: `${BASE_CLASS_PREFIX$1}-switch-focus`,
  LARGE: `${BASE_CLASS_PREFIX$1}-switch-large`,
  SMALL: `${BASE_CLASS_PREFIX$1}-switch-small`,
  CHECKED: `${BASE_CLASS_PREFIX$1}-switch-checked`,
  DISABLED: `${BASE_CLASS_PREFIX$1}-switch-disabled`,
  ACTIVE: `${BASE_CLASS_PREFIX$1}-switch-active`,
  KNOB: `${BASE_CLASS_PREFIX$1}-switch-knob`,
  NATIVE_CONTROL: `${BASE_CLASS_PREFIX$1}-switch-native-control`,
  CHECKED_TEXT: `${BASE_CLASS_PREFIX$1}-switch-checked-text`,
  UNCHECKED_TEXT: `${BASE_CLASS_PREFIX$1}-switch-unchecked-text`,
  LOADING_SPIN: `${BASE_CLASS_PREFIX$1}-switch-loading-spin`,
  LOADING: `${BASE_CLASS_PREFIX$1}-switch-loading`
}, propTypes$A = {
  "aria-label": string$3,
  "aria-labelledby": string$3,
  "aria-invalid": [bool, string$3],
  "aria-errormessage": string$3,
  "aria-describedby": string$3,
  className: string$3,
  checked: {
    type: bool,
    default: void 0
  },
  checkedText: node$1,
  defaultChecked: {
    type: bool,
    default: void 0
  },
  disabled: {
    type: bool,
    default: void 0
  },
  loading: {
    type: bool,
    default: void 0
  },
  onChange: func,
  onMouseEnter: func,
  onMouseLeave: func,
  style: object$1,
  size: String,
  uncheckedText: node$1,
  id: string$3
}, defaultProps$v = {
  disabled: !1,
  className: "",
  onChange: lodashExports.noop,
  loading: !1,
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop,
  size: "default"
}, vuePropsType$U = vuePropsMake(propTypes$A, defaultProps$v), Switch = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$U
  },
  name: "Switch",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      nativeControlChecked: s.defaultChecked || s.checked,
      nativeControlDisabled: !1,
      focusVisible: !1
    }), l = ref$1(), {
      adapter: u,
      getDataAttr: c
    } = useBaseComponent(s, o), m = ref$1(symbol());
    function g() {
      return {
        ...u(),
        setNativeControlChecked: (P) => {
          o.nativeControlChecked = P;
        },
        setNativeControlDisabled: (P) => {
          o.nativeControlDisabled = P;
        },
        setFocusVisible: (P) => {
          o.focusVisible = P;
        },
        notifyChange: (P, T) => {
          s.onChange(P, T), m.value = symbol();
        }
      };
    }
    const v = g(), b = new SwitchFoundation(v);
    onMounted(() => {
      b.init();
    }), onUnmounted(() => {
      b.init();
    }), watch(() => s.checked, () => {
      b.setChecked(s.checked);
    }), watch(() => s.disabled, () => {
      b.setDisabled(s.disabled);
    });
    const S = (P) => {
      b.handleFocusVisible(P);
    }, E = (P) => {
      b.handleBlur();
    };
    return () => {
      const {
        nativeControlChecked: P,
        nativeControlDisabled: T,
        focusVisible: N
      } = o, {
        className: O,
        style: z,
        onMouseEnter: Q,
        onMouseLeave: W,
        size: ue,
        checkedText: te,
        uncheckedText: K,
        loading: ve,
        id: ee
      } = s, Re = cls(O, {
        [cssClasses$b.PREFIX]: !0,
        [cssClasses$b.CHECKED]: P,
        [cssClasses$b.DISABLED]: T,
        [cssClasses$b.LARGE]: ue === "large",
        [cssClasses$b.SMALL]: ue === "small",
        [cssClasses$b.LOADING]: ve,
        [cssClasses$b.FOCUS]: N
      }), wt = {
        type: "checkbox",
        className: cssClasses$b.NATIVE_CONTROL,
        disabled: T || ve,
        checked: P || !1
      }, yt = te && P && ue !== "small", xt = K && !P && ue !== "small";
      return createVNode("div", mergeProps$1({
        class: Re,
        style: z,
        onMouseenter: Q,
        onMouseleave: W
      }, c()), [ve ? createVNode(Spin, {
        wrapperClassName: cssClasses$b.LOADING_SPIN,
        size: ue === "default" ? "middle" : ue
      }, null) : createVNode("div", {
        class: cssClasses$b.KNOB,
        "aria-hidden": !0
      }, null), yt ? createVNode("div", {
        class: cssClasses$b.CHECKED_TEXT,
        "x-semi-prop": "checkedText"
      }, [te]) : null, xt ? createVNode("div", {
        class: cssClasses$b.UNCHECKED_TEXT,
        "x-semi-prop": "uncheckedText"
      }, [K]) : null, createVNode("input", mergeProps$1(wt, {
        ref: l,
        key: m.value,
        id: ee,
        role: "switch",
        "aria-checked": P,
        "aria-invalid": s["aria-invalid"],
        "aria-errormessage": s["aria-errormessage"],
        "aria-label": s["aria-label"],
        "aria-labelledby": s["aria-labelledby"],
        "aria-describedby": s["aria-describedby"],
        "aria-disabled": s.disabled,
        onChange: (Kt) => {
          b.handleChange(Kt.target.checked, Kt);
        },
        onFocus: (Kt) => S(Kt),
        onBlur: (Kt) => E()
      }), null)]);
    };
  }
}), Switch$1 = Switch, cssClasses$a = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-table`,
  TABLE: `${BASE_CLASS_PREFIX$1}-table`,
  WRAP: `${BASE_CLASS_PREFIX$1}-table-wrapper`,
  THEAD: `${BASE_CLASS_PREFIX$1}-table-thead`,
  TR: `${BASE_CLASS_PREFIX$1}-table-row`,
  TH: `${BASE_CLASS_PREFIX$1}-table-row-head`,
  TD: `${BASE_CLASS_PREFIX$1}-table-row-cell`
}, strings$2 = {
  SIZE_SMALL: "small",
  SIZE_MIDDLE: "middle",
  SIZES: ["small", "default", "middle"],
  LAYOUTS: ["", "auto", "fixed"],
  PAGINATION_POSITIONS: ["bottom", "top", "both"],
  FOOTER_POSITIONS: [!1, !0, "left", "right"],
  SORT_DIRECTIONS: ["ascend", "descend"],
  FIXED_SET: [!1, !0, "left", "right"],
  ALIGNS: ["left", "right", "center"],
  JUSTIFY_CONTENT: ["flex-start", "flex-end", "center"],
  SCROLL_HORIZONTAL_POSITIONS: ["left", "middle", "right"],
  DEFAULT_KEY_COLUMN_SELECTION: "column-selection",
  DEFAULT_KEY_COLUMN_EXPAND: "column-expand",
  DEFAULT_KEY_COLUMN_TITLE: "column-title",
  DEFAULT_KEY_COLUMN_SORTER: "column-sorter",
  DEFAULT_KEY_COLUMN_FILTER: "column-filter",
  DEFAULT_KEY_COLUMN_SCROLLBAR: "column-scrollbar",
  DEFAULT_COMPONENTS: {
    table: "table",
    header: {
      outer: "table",
      wrapper: "thead",
      row: "tr",
      cell: "th"
    },
    body: {
      outer: "table",
      wrapper: "tbody",
      row: "tr",
      cell: "td"
    },
    footer: {
      wrapper: "tfoot",
      row: "tr",
      cell: "td"
    }
  },
  EXPAND_RELATED_PROPS: ["expandedRowRender", "dataSource", "hideExpandedColumn", "childrenRecordName", "rowExpandable"]
}, DEFAULT_CELL_BORDER_WITH_BOTTOM = 1, DEFAULT_CELL_BORDER_WITH_TOP = 0, DEFAULT_CELL_PADDING_TOP = 16, DEFAULT_CELL_PADDING_BOTTOM = 16, DEFAULT_CELL_MIDDLE_PADDING_TOP = 12, DEFAULT_CELL_MIDDLE_PADDING_BOTTOM = 12, DEFAULT_CELL_SMALL_PADDING_TOP = 8, DEFAULT_CELL_SMALL_PADDING_BOTTOM = 8, DEFAULT_CELL_LINE_HEIGHT = 20, DEFAULT_VIRTUALIZED_ROW_HEIGHT = DEFAULT_CELL_LINE_HEIGHT + DEFAULT_CELL_BORDER_WITH_BOTTOM + DEFAULT_CELL_BORDER_WITH_TOP + DEFAULT_CELL_PADDING_TOP + DEFAULT_CELL_PADDING_BOTTOM, DEFAULT_VIRTUALIZED_ROW_MIN_HEIGHT = DEFAULT_CELL_PADDING_TOP + DEFAULT_CELL_PADDING_BOTTOM + DEFAULT_CELL_BORDER_WITH_BOTTOM, DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT = DEFAULT_CELL_LINE_HEIGHT + DEFAULT_CELL_BORDER_WITH_BOTTOM + DEFAULT_CELL_BORDER_WITH_TOP + DEFAULT_CELL_MIDDLE_PADDING_TOP + DEFAULT_CELL_MIDDLE_PADDING_BOTTOM, DEFAULT_VIRTUALIZED_ROW_MIDDLE_MIN_HEIGHT = DEFAULT_CELL_MIDDLE_PADDING_TOP + DEFAULT_CELL_MIDDLE_PADDING_BOTTOM + DEFAULT_CELL_BORDER_WITH_BOTTOM, DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT = DEFAULT_CELL_LINE_HEIGHT + DEFAULT_CELL_BORDER_WITH_BOTTOM + DEFAULT_CELL_BORDER_WITH_TOP + DEFAULT_CELL_SMALL_PADDING_BOTTOM + DEFAULT_CELL_SMALL_PADDING_TOP, DEFAULT_VIRTUALIZED_ROW_SMALL_MIN_HEIGHT = DEFAULT_CELL_SMALL_PADDING_TOP + DEFAULT_CELL_SMALL_PADDING_BOTTOM + DEFAULT_CELL_BORDER_WITH_BOTTOM, numbers$2 = {
  DEFAULT_PAGE_SIZE: 10,
  DEFAULT_WIDTH_COLUMN_EXPAND: 60,
  DEFAULT_WIDTH_COLUMN_SELECTION: 60,
  DEFAULT_INDENT_WIDTH: 20,
  DEFAULT_CELL_PADDING_LEFT: 16,
  DEFAULT_CELL_PADDING_RIGHT: 16,
  DEFAULT_CELL_PADDING_TOP,
  DEFAULT_CELL_PADDING_BOTTOM,
  DEFAULT_CELL_MIDDLE_PADDING_TOP,
  DEFAULT_CELL_MIDDLE_PADDING_BOTTOM,
  DEFAULT_CELL_SMALL_PADDING_TOP,
  DEFAULT_CELL_SMALL_PADDING_BOTTOM,
  DEFAULT_CELL_BORDER_WIDTH_LEFT: 1,
  DEFAULT_CELL_BORDER_WIDTH_RIGHT: 1,
  DEFAULT_CELL_BORDER_WITH_BOTTOM,
  DEFAULT_CELL_LINE_HEIGHT,
  DEFAULT_VIRTUALIZED_BODY_HEIGHT: 600,
  DEFAULT_VIRTUALIZED_SECTION_ROW_HEIGHT: DEFAULT_VIRTUALIZED_ROW_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_MIN_HEIGHT,
  DEFAULT_VIRTUALIZED_SECTION_ROW_MIDDLE_HEIGHT: DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_MIDDLE_MIN_HEIGHT,
  DEFAULT_VIRTUALIZED_SECTION_ROW_SMALL_HEIGHT: DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT,
  DEFAULT_VIRTUALIZED_ROW_SMALL_MIN_HEIGHT
};
class Logger {
  /**
   * specify prefix
   * @param {string} prefix
   */
  constructor(o) {
    this._prefix = o;
  }
  _isEmpty(o) {
    return o == null || o === "";
  }
  _baseLog(o = "log", ...l) {
    if (typeof console[o] == "function") {
      const u = [...l];
      this._isEmpty(this._prefix) || u.unshift(this._prefix, ":"), console[o](...u);
    }
  }
  /* istanbul ignore next */
  log(...o) {
    this._baseLog("log", ...o);
  }
  /* istanbul ignore next */
  warn(...o) {
    this._baseLog("warn", ...o);
  }
  /* istanbul ignore next */
  error(...o) {
    this._baseLog("error", ...o);
  }
  /* istanbul ignore next */
  info(...o) {
    this._baseLog("info", ...o);
  }
}
function equalWith(s, o, l) {
  return lodashExports.isEqualWith(s, o, (u, c, ...m) => {
    if (typeof u == "function" && typeof c == "function")
      return lodashExports.toString(u) === lodashExports.toString(c);
  });
}
function getColumnKey(s, o) {
  o = Array.isArray(o) ? o : ["key", "dataIndex"];
  let l = null;
  return lodashExports.each(o, (u) => {
    if (l = lodashExports.get(s, u), l != null)
      return !1;
  }), l;
}
function arrayAdd(s = [], o = 0, l) {
  o = o < 0 || typeof o != "number" ? 0 : o, l = l > s.length || typeof l != "number" ? s.length : l;
  let u = 0;
  return lodashExports.each(s, (c, m) => {
    m >= o && m < l && (u += typeof c == "number" && !isNaN(c) ? c : 0);
  }), u;
}
function isLastLeftFixed(s, o, l = ["key"]) {
  const u = lodashExports.filter(s, (m) => m.fixed === !0 || m.fixed === "left"), c = lodashExports.findIndex(
    u,
    (m) => l.every((g) => m[g] != null && m[g] === o[g])
  );
  return u.length > 0 && c === u.length - 1;
}
function isFirstFixedRight(s, o, l = ["key"]) {
  const u = lodashExports.filter(s, (m) => m.fixed === "right"), c = lodashExports.findIndex(
    u,
    (m) => l.every((g) => m[g] != null && m[g] === o[g])
  );
  return u.length > 0 && c === 0;
}
function isFixedLeft(s) {
  return ["left", !0].includes(lodashExports.get(s, "fixed"));
}
function isFixedRight(s) {
  return ["right"].includes(lodashExports.get(s, "fixed"));
}
function isInnerColumnKey(s) {
  return [
    strings$2.DEFAULT_KEY_COLUMN_EXPAND,
    strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR,
    strings$2.DEFAULT_KEY_COLUMN_SELECTION
  ].includes(s);
}
function isExpandedColumn(s) {
  return lodashExports.get(s, "key") === strings$2.DEFAULT_KEY_COLUMN_EXPAND;
}
function isScrollbarColumn(s) {
  return lodashExports.get(s, "key") === strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR;
}
function filterColumns(s, o = [strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR]) {
  return lodashExports.filter(s, (l) => !o.includes(l.key));
}
function getRecordKey(s, o) {
  return o === void 0 && (o = "key"), typeof o == "function" ? o(s) : lodashExports.get(s, o);
}
function isExpanded(s, o) {
  return o != null && lodashExports.includes(s, o);
}
function isSelected(s, o) {
  return o !== null && s.has(o);
}
function isDisabled(s, o) {
  return o !== null && s.has(o);
}
function getRecord(s, o, l) {
  return l === void 0 && (l = "key"), lodashExports.find(s, (u) => o != null && o !== "" && getRecordKey(u, l) === o);
}
function getRecordChildren(s, o) {
  return o === void 0 && (o = "children"), lodashExports.get(s, o);
}
function genExpandedRowKey(s = "", o) {
  return o === void 0 && (o = "__expanded_row"), s + o;
}
function getDefaultVirtualizedRowConfig(s = "", o = !1) {
  const l = {};
  return s === "small" ? (l.height = o ? numbers$2.DEFAULT_VIRTUALIZED_SECTION_ROW_SMALL_HEIGHT : numbers$2.DEFAULT_VIRTUALIZED_ROW_SMALL_HEIGHT, l.minHeight = numbers$2.DEFAULT_VIRTUALIZED_ROW_SMALL_MIN_HEIGHT) : s === "middle" ? (l.height = o ? numbers$2.DEFAULT_VIRTUALIZED_SECTION_ROW_MIDDLE_HEIGHT : numbers$2.DEFAULT_VIRTUALIZED_ROW_MIDDLE_HEIGHT, l.minHeight = numbers$2.DEFAULT_VIRTUALIZED_ROW_MIDDLE_MIN_HEIGHT) : (l.height = o ? numbers$2.DEFAULT_VIRTUALIZED_SECTION_ROW_HEIGHT : numbers$2.DEFAULT_VIRTUALIZED_ROW_HEIGHT, l.minHeight = numbers$2.DEFAULT_VIRTUALIZED_ROW_MIN_HEIGHT), l;
}
function flattenColumns(s, o = "children") {
  const l = [];
  if (Array.isArray(s) && s.length)
    for (const u of s)
      Array.isArray(u[o]) && u[o].length ? l.push(...flattenColumns(u[o], o)) : (warnIfNoDataIndex(u), l.push(u));
  return l;
}
function assignColumnKeys(s, o = "children", l = 0) {
  const u = [];
  return lodashExports.each(s, (c, m) => {
    if (c.key == null) {
      const g = c.dataIndex || m;
      c.key = `${l}-${g}`;
    }
    Array.isArray(c[o]) && c[o].length && u.push(...c[o]);
  }), u.length && assignColumnKeys(u, o, l + 1), s;
}
function sliceColumnsByLevel(s, o = 0, l = "children", u = 0) {
  const c = [];
  return Array.isArray(s) && s.length && u <= o && s.forEach((m) => {
    const g = m[l];
    Array.isArray(g) && g.length && u < o ? c.push(...sliceColumnsByLevel(g, o, l, u + 1)) : c.push(m);
  }), c;
}
function findColumn(s, o, l = "children") {
  let u;
  return lodashExports.each(s, (c) => {
    if (c && c.key != null && !u && c.key === o.key && (u = c), c && Array.isArray(c[l]) && !u && (u = findColumn(c[l], o, l)), u)
      return !1;
  }), u;
}
function expandBtnShouldInRow(s) {
  const { expandedRowRender: o, dataSource: l, hideExpandedColumn: u, childrenRecordName: c, rowExpandable: m } = s, g = typeof o == "function";
  return u && g || !g && l.some((v) => {
    const b = lodashExports.get(v, c);
    return !!(Array.isArray(b) && b.length || m(v));
  });
}
function mergeQueries(s, o = []) {
  let l;
  const u = o.findIndex((c) => s.dataIndex === c.dataIndex ? (l = { ...c, ...s }, !0) : !1);
  return u > -1 ? o.splice(u, 1, l) : o.push(l), [...o];
}
function withResizeWidth(s, o) {
  const l = [...o];
  for (const u of s)
    if (!isNullOrUndefined(u.width)) {
      const c = u.key, m = lodashExports.findIndex(l, (g) => g.key === c);
      m !== -1 && (l[m].width = lodashExports.get(u, "width"));
    }
  return l;
}
function getAllDisabledRowKeys({ dataSource: s, getCheckboxProps: o, childrenRecordName: l, rowKey: u }) {
  const c = [];
  if (Array.isArray(s) && s.length && typeof o == "function")
    for (const m of s) {
      const g = o(m), v = typeof u == "function" ? u(m) : lodashExports.get(m, u);
      g && g.disabled && c.push(v);
      const b = lodashExports.get(m, l);
      if (Array.isArray(b) && b.length) {
        const S = getAllDisabledRowKeys({ dataSource: b, getCheckboxProps: o });
        c.push(...S);
      }
    }
  return c;
}
function warnIfNoDataIndex(s) {
  if (typeof s == "object" && s !== null) {
    const { filters: o, sorter: l, dataIndex: u, onFilter: c } = s, m = new Logger("[@douyinfe/semi-ui Table]");
    (Array.isArray(o) || lodashExports.isFunction(c) || lodashExports.isFunction(l)) && isNullOrUndefined(u) && m.warn("The column with sorter or filter must pass the 'dataIndex' prop");
  }
}
function isTreeTable({ dataSource: s, childrenRecordName: o = "children" }) {
  let l = !1;
  if (Array.isArray(s))
    for (const u of s) {
      const c = lodashExports.get(u, o);
      if (Array.isArray(c) && c.length) {
        l = !0;
        break;
      }
    }
  return l;
}
function getRTLAlign(s, o) {
  if (o === "rtl")
    switch (s) {
      case "left":
        return "right";
      case "right":
        return "left";
      default:
        return s;
    }
  return s;
}
function getRTLFlexAlign(s, o) {
  if (o === "rtl")
    switch (s) {
      case "left":
        return "flex-end";
      case "right":
        return "flex-start";
      default:
        return s;
    }
  else
    switch (s) {
      case "left":
        return "flex-start";
      case "right":
        return "flex-end";
      default:
        return s;
    }
}
function shouldShowEllipsisTitle(s) {
  return s === !0 || lodashExports.get(s, "showTitle", !0);
}
class Store {
  constructor(o) {
    this._state = { ...o }, this._listeners = [];
  }
  subscribe(o) {
    return this._listeners.push(o), () => {
      const u = this._listeners.indexOf(o);
      u > -1 && this._listeners.splice(u, 1);
    };
  }
  setState(o) {
    Object.assign(this._state, { ...o });
    for (const l of this._listeners)
      typeof l == "function" && l(this._state);
  }
  getState() {
    return this._state;
  }
}
var safeIsNaN = Number.isNaN || function(o) {
  return typeof o == "number" && o !== o;
};
function isEqual(s, o) {
  return !!(s === o || safeIsNaN(s) && safeIsNaN(o));
}
function areInputsEqual(s, o) {
  if (s.length !== o.length)
    return !1;
  for (var l = 0; l < s.length; l++)
    if (!isEqual(s[l], o[l]))
      return !1;
  return !0;
}
function memoizeOne(s, o) {
  o === void 0 && (o = areInputsEqual);
  var l, u = [], c, m = !1;
  function g() {
    for (var v = [], b = 0; b < arguments.length; b++)
      v[b] = arguments[b];
    return m && l === this && o(v, u) || (c = s.apply(this, v), m = !0, l = this, u = v), c;
  }
  return g;
}
function copySet(s) {
  return new Set(s);
}
function pullAll$1(s, o) {
  if (s === o && (o = copySet(o)), lodashExports.isSet(s) && s.size && lodashExports.isSet(o) && o.size) {
    for (const l of o)
      s.has(l) && s.delete(l);
    return s;
  }
  return s;
}
function pullAll(s, o) {
  if (s !== null && s.length && o !== null && o.length) {
    const l = new Set(s), u = new Set(o), c = pullAll$1(l, u);
    return Array.from(c);
  }
  return s;
}
function withOrderSort(s, o = "ascend") {
  switch (o) {
    case "descend":
      return (l, u) => {
        const c = Number(s(l, u, o));
        return c !== 0 ? -c : c;
      };
    case "ascend":
    default:
      return (l, u) => s(l, u, o);
  }
}
class TableFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.setPage = (c, m) => {
      c = c || this._adapter.getCurrentPage();
      const g = this.getState("pagination"), { dataSource: v, pagination: b, disabledRowKeys: S, allRowKeys: E } = this.getCurrentPageData(null, {
        ...g,
        currentPage: c,
        pageSize: m
      });
      !this._pagerIsControlled() && c > 0 && (this._adapter.setDisabledRowKeys(S), this._adapter.setAllRowKeys(E), this._adapter.setPagination(b), this._adapter.setDataSource(v)), this._notifyChange(b);
    }, this.setCachedFilteredSortedDataSource = (c) => {
      this._adapter.setCachedFilteredSortedDataSource(c);
      const m = this.getAllRowKeys(c);
      this._adapter.setCachedFilteredSortedRowKeys(m);
    }, this.isSortOrderValid = (c) => strings$2.SORT_DIRECTIONS.includes(c) || c === !1;
    const l = this._adapter.getHandleColumns(), u = this._adapter.getMergePagination();
    this.memoizedWithFnsColumns = memoizeOne(l, lodashExports.isEqual), this.memoizedFilterColumns = memoizeOne(filterColumns), this.memoizedFlattenFnsColumns = memoizeOne(flattenColumns), this.memoizedPagination = memoizeOne(u, lodashExports.isEqual);
  }
  /**
   * update columns in place, and use default values as initial values if the sorting and filtering columns have no values
   */
  static initColumnsFilteredValueAndSorterOrder(o) {
    return o.forEach((l) => {
      TableFoundation.initFilteredValue(l), TableFoundation.initSorterOrder(l);
    }), o;
  }
  /**
   * init filteredValue of filtering column, use defaultFilteredValue or [] when it is undefined
   */
  static initFilteredValue(o) {
    const { defaultFilteredValue: l, filteredValue: u } = o;
    lodashExports.isUndefined(u) && (Array.isArray(l) && l.length ? o.filteredValue = l : o.filteredValue = []);
  }
  /**
   * init sortOrder of sorting column, use defaultSortOrder or [] when it is undefined
   */
  static initSorterOrder(o) {
    const { defaultSortOrder: l, sortOrder: u, sorter: c } = o;
    c && lodashExports.isUndefined(u) && (lodashExports.isUndefined(l) ? o.sortOrder = !1 : o.sortOrder = l);
  }
  init() {
    const o = [...this.getProp("dataSource")], { queries: l } = this._adapter.getStates(), u = this.getFilteredSortedDataSource(o, l), c = this.getAllDisabledRowKeys(u), m = this.getCurrentPageData(u);
    this.setAdapterPageData(m), this.initExpandedRowKeys(m), this.initSelectedRowKeys(m), this.setCachedFilteredSortedDataSource(u), this.setAllDisabledRowKeys(c);
  }
  initExpandedRowKeys({ groups: o } = {}) {
    const {
      defaultExpandAllRows: l,
      defaultExpandedRowKeys: u = [],
      expandedRowKeys: c = [],
      dataSource: m = [],
      expandAllRows: g,
      defaultExpandAllGroupRows: v,
      expandAllGroupRows: b
    } = this.getProps(), S = [];
    l || g ? this._addNoDuplicatedItemsToArr(
      S,
      this.getAllRowKeys(m),
      o && lodashExports.isMap(o) && o.size ? Array.from(o.keys()) : []
    ) : v || b ? this._addNoDuplicatedItemsToArr(
      S,
      c,
      o && lodashExports.isMap(o) && o.size ? Array.from(o.keys()) : []
    ) : Array.isArray(u) && u.length ? this._addNoDuplicatedItemsToArr(S, u) : Array.isArray(c) && c.length && this._addNoDuplicatedItemsToArr(S, c), this._adapter.setExpandedRowKeys(S);
  }
  initSelectedRowKeys({ disabledRowKeys: o }) {
    const l = this.getProp("rowSelection"), u = [];
    if (l) {
      const c = lodashExports.get(l, "selectedRowKeys"), m = lodashExports.get(l, "defaultSelectedRowKeys");
      Array.isArray(c) ? this._addNoDuplicatedItemsToArr(u, c) : Array.isArray(m) && this._addNoDuplicatedItemsToArr(u, m), Array.isArray(o) && o.length && lodashExports.pull(u, ...o), this._adapter.setSelectedRowKeys(u);
    }
  }
  /**
   * Get filtered and sorted data
   * @param {Object[]} dataSource
   * @param {Object[]} queries
   * @returns {Object[]} sortedDataSource
   */
  getFilteredSortedDataSource(o, l) {
    const u = this.filterDataSource(o, l.filter(
      (m) => {
        const g = m.filteredValue ? m.filteredValue : m.defaultFilteredValue;
        return lodashExports.isFunction(m.onFilter) && Array.isArray(g) && g.length;
      }
    ));
    return this.sortDataSource(u, l.filter((m) => m && lodashExports.isFunction(m.sorter)));
  }
  /**
   * get current page data
   *
   * @param {Array} dataSource
   * @param {object} pagination
   * @param {object} queries
   * @returns {{dataSource: RecordType[], groups: Map<string, Set<string>>, pagination: object, disabledRowKeys: string[], queries: BaseColumnProps[], allRowKeys: string[]}}
   */
  getCurrentPageData(o, l, u) {
    const c = this._adapter.getCachedFilteredSortedDataSource();
    o = o ?? [...c], l = l ?? (this.getState("pagination") && { ...this.getState("pagination") }), u = u ?? [...this.getState("queries")];
    let m;
    if (this.getProp("groupBy") != null) {
      const { groups: S, dataSource: E } = this.groupDataSource(o);
      o = E, m = S;
    }
    l = this.normalizePagination(l, o), o = this.limitPageDataSource(o, l);
    const g = this.getAllDisabledRowKeys(o), v = this.getAllRowKeys(o);
    return {
      dataSource: o,
      groups: m,
      pagination: l,
      disabledRowKeys: g,
      allRowKeys: v,
      queries: u
    };
  }
  /**
   * group dataSource, return grouped row keys
   *
   * @param {*[]} dataSource
   * @param {Function|string} groupBy
   */
  groupDataSource(o, l) {
    l = l ?? this.getProp("groupBy");
    const u = /* @__PURE__ */ new Map(), c = [];
    return l != null && lodashExports.each(o, (m, g) => {
      const v = typeof l == "function" ? l(m) : lodashExports.get(m, l);
      if (v != null && v !== "") {
        const b = this.getRecordKey(m);
        let S = u.get(v);
        lodashExports.isSet(S) ? S.add(b) : (S = /* @__PURE__ */ new Set([b]), u.set(v, S));
      }
    }), u && u.size ? u.forEach((m, g) => {
      lodashExports.isSet(m) && m.forEach((v) => {
        c.push(this._getRecord(v));
      });
    }) : c.push(...o), { groups: u, dataSource: c };
  }
  /**
   * sort data
   *
   * @param {Array} dataSource
   * @param {Array} sorters
   * @returns {Array}
   */
  sortDataSource(o, l) {
    return lodashExports.each(l, (u) => {
      const { sorter: c, sortOrder: m, defaultSortOrder: g, sortChildrenRecord: v } = u, b = this.isSortOrderValid(m) ? m : g;
      if (lodashExports.isFunction(c) && b && strings$2.SORT_DIRECTIONS.includes(b)) {
        if (v) {
          const S = this.getProp("childrenRecordName");
          o = o && o.map((E) => {
            const P = this._getRecordChildren(E);
            return Array.isArray(P) && P.length ? {
              ...E,
              [S]: this.sortDataSource(P, [u])
            } : E;
          });
        }
        return o.sort(withOrderSort(c, b)), !1;
      }
    }), o;
  }
  /**
   * filter data source
   *
   * @param {*[]} dataSource
   * @param {*[]} filters
   * @returns {*[]}
   */
  filterDataSource(o, l) {
    let u = null, c = !1;
    const m = this.getProp("childrenRecordName");
    return lodashExports.each(l, (g) => {
      const { onFilter: v, filteredValue: b, filterChildrenRecord: S, defaultFilteredValue: E } = g, P = Array.isArray(b) ? b : E;
      typeof v == "function" && Array.isArray(P) && P.length && (c = !0, u === null ? u = /* @__PURE__ */ new Map() : (o = Array.from(u && u.values()), u = /* @__PURE__ */ new Map()), lodashExports.each(o, (T) => {
        lodashExports.each(P, (N) => {
          const O = lodashExports.get(T, m), z = this.getRecordKey(T);
          let Q;
          if (Array.isArray(O) && O.length && S && (Q = this.filterDataSource(O, [g])), Array.isArray(Q) && Q.length) {
            if (z != null) {
              const W = lodashExports.get(u.get(z), m, []);
              u.set(z, {
                ...T,
                [m]: Q.reduce(
                  (ue, te) => (ue.find((K) => this.getRecordKey(K) === this.getRecordKey(te)) == null && ue.push(te), ue),
                  // @ts-ignore
                  [...W]
                )
              });
            }
          } else v(N, T) && u.set(z, T);
        });
      }));
    }), c && (o = Array.from(u && u.values())), o;
  }
  limitPageDataSource(o, l) {
    o = o ?? this.getProp("dataSource"), l = l ?? this.getState("pagination");
    let u = o;
    const c = lodashExports.get(l, "currentPage");
    if (this.getProp("pagination") !== !1 && c && o && l && !this._pagerIsControlled()) {
      const { pageSize: m = numbers$2.DEFAULT_PAGE_SIZE } = l, g = (c - 1) * m, v = c * m;
      u = lodashExports.slice(o, g, v);
    }
    return u;
  }
  normalizePagination(o, l) {
    o = o ?? this._getPagination(), l = l ?? this._getDataSource();
    const u = this.getProp("pagination");
    if (o && (o = typeof o == "object" ? { ...o } : {}, o = lodashExports.merge(
      {
        total: l && l.length || 0,
        pageSize: numbers$2.DEFAULT_PAGE_SIZE,
        currentPage: lodashExports.get(u, "defaultCurrentPage", 1),
        position: strings$2.PAGINATION_POSITIONS[0]
      },
      o
    ), !this._pagerIsControlled())) {
      const c = lodashExports.get(u, "total", l.length), { currentPage: m, pageSize: g } = o, v = Math.ceil(c / g);
      o.total = c, m > v && (o.currentPage = 1);
    }
    return o;
  }
  setAdapterPageData(o = {}) {
    const { pagination: l, dataSource: u, disabledRowKeys: c, allRowKeys: m, groups: g } = o;
    this._adapter.setDisabledRowKeys(c), this._adapter.setAllRowKeys(m), this._adapter.setPagination(l), this._adapter.setGroups(g), this._adapter.setDataSource(u);
  }
  destroy() {
  }
  setAllDisabledRowKeys(o) {
    this._adapter.setAllDisabledRowKeys(o);
  }
  handleClick(o) {
  }
  handleMouseEnter(o) {
  }
  handleMouseLeave(o) {
  }
  stopPropagation(o) {
    this._adapter.stopPropagation(o);
  }
  /**
   * Add non-repeating elements to the array itself
   */
  _addNoDuplicatedItemsToArr(o = [], ...l) {
    for (const u of l)
      if (Array.isArray(u))
        for (const c of u)
          o.includes(c) || o.push(c);
    return o;
  }
  _notifyChange(o, l, u, c) {
    o = o ?? this._getPagination(), l = l ?? this._getAllFilters(), u = u ?? this._getAllSorters()[0], lodashExports.get(this.getProp("scroll"), "scrollToFirstRowOnChange") && this._adapter.resetScrollY(), this._adapter.notifyChange({
      pagination: { ...o },
      filters: [...l],
      sorter: u,
      extra: { ...c }
    });
  }
  _rowExpansionIsControlled() {
    return Array.isArray(this.getProp("expandedRowKeys"));
  }
  _pagerIsControlled() {
    return lodashExports.get(this.getProp("pagination"), "currentPage") != null;
  }
  _selectionIsControlled() {
    return Array.isArray(lodashExports.get(this.getProp("rowSelection"), "selectedRowKeys"));
  }
  /**
   * Determine whether the column sorting is controlled
   * Controlled: the column passed the sortOrder prop
   * @param {String} dataIndex
   * @returns {Boolean}
   */
  _sorterIsControlled(o) {
    const l = o && this.getQuery(o, this.getState("flattenColumns"));
    return !!(l && l.sortOrder != null);
  }
  /**
   * Determine whether the column is filtered and controlled
   * Controlled: the column passed the filteredValue prop
   * @param {String} dataIndex
   * @returns {Boolean}
   */
  _filterIsControlled(o) {
    const l = o && this.getQuery(o, this.getState("flattenColumns"));
    return !!(l && Array.isArray(l.filteredValue));
  }
  _filterShowIsControlled(o) {
    const l = o && this.getQuery(o, this.getState("flattenColumns"));
    return !!(l && (l.filterDropdownVisible === !0 || l.filterDropdownVisible === !1));
  }
  _getSelectedRowKeys() {
    const o = this.getState("rowSelection");
    return [...lodashExports.get(o, "selectedRowKeys", [])];
  }
  _getSelectedRowKeysSet() {
    const o = this.getState("rowSelection");
    return lodashExports.get(o, "selectedRowKeysSet", /* @__PURE__ */ new Set());
  }
  _getDataSource() {
    return this.getProp("dataSource") || [];
  }
  _getRecord(o) {
    return lodashExports.find(
      this.getProp("dataSource"),
      (l) => o != null && o !== "" && this.getRecordKey(l) === o
    );
  }
  _getRecordChildren(o) {
    return lodashExports.get(o, this.getProp("childrenRecordName"));
  }
  _getPagination() {
    return this.getState("pagination") || {};
  }
  /**
   * Filters are considered valid if filteredValue exists
   */
  _getAllFilters(o) {
    o = o || this.getState("queries");
    const l = [];
    return lodashExports.each(o, (u) => {
      Array.isArray(u.filteredValue) && (u.filteredValue.length || this._filterIsControlled(u.dataIndex)) && l.push(u);
    }), l;
  }
  _getAllSorters(o) {
    return o = o || this.getState("queries"), lodashExports.filter(o, (l) => l.sorter && l.sortOrder);
  }
  _filterQueries(o, l, u = ["dataIndex"]) {
    l = l ?? this.getState("queries");
    const c = [], m = [];
    return lodashExports.each(l, (g, v) => {
      lodashExports.some(u, (S) => S && o[S] != null && o[S] === g[S]) && (c.push(g), m.push(v));
    }), { filteredQueries: c, filteredIndexes: m };
  }
  _mergeToQueries(o, l, u = ["dataIndex"]) {
    l = l ?? this.getState("queries"), l = [...l], o = { ...o };
    const { filteredQueries: c, filteredIndexes: m } = this._filterQueries(o, l, u);
    return lodashExports.each(c, (g, v) => {
      l[m[v]] = { ...o };
    }), l;
  }
  /**
   * get record real key
   * @param {RecordType} record
   * @returns {string}
   */
  getRecordKey(o) {
    if (!o)
      return;
    const l = this.getProp("rowKey");
    return typeof l == "function" ? l(o) : lodashExports.get(o, l);
  }
  isEmpty(o) {
    return o = o ?? this.getProp("dataSource"), !(Array.isArray(o) && o.length > 0);
  }
  handleSelectRow(o, l, u) {
    if (this.stopPropagation(u), typeof l == "boolean" && o != null) {
      const c = this._getSelectedRowKeys();
      let m = -1;
      const g = this.getSelectedRows(null, [o])[0];
      let v;
      (m = c.indexOf(o)) > -1 && l === !1 ? (c.splice(m, 1), v = this.getSelectedRows(null, c), this._selectionIsControlled() || this._adapter.setSelectedRowKeys(c), this._adapter.notifySelect(g, l, v, u), this._adapter.notifySelectionChange(c, v)) : c.indexOf(o) === -1 && l === !0 && (c.push(o), v = this.getSelectedRows(null, c), this._selectionIsControlled() || this._adapter.setSelectedRowKeys(c), this._adapter.notifySelect(g, l, v, u), this._adapter.notifySelectionChange(c, v));
    }
  }
  /**
   * select all rows
   * @param {*} selected The future state of the select all button
   * @param {*} e
   */
  handleSelectAllRow(o, l) {
    if (this.stopPropagation(l), typeof o == "boolean") {
      const u = this._getSelectedRowKeys();
      let c = [...u];
      const m = this._getSelectedRowKeysSet();
      let g = [...this._adapter.getCachedFilteredSortedRowKeys()];
      const v = this._adapter.getAllDisabledRowKeys(), b = this._adapter.getAllDisabledRowKeysSet();
      let S;
      if (o) {
        for (const T of g)
          !b.has(T) && !m.has(T) && c.push(T);
        g = pullAll(g, [...v, ...u]), S = [...g];
      } else
        c = pullAll(c, g), S = [...u];
      const E = this.getSelectedRows(null, S || []), P = this.getSelectedRows(null, c || []);
      this._selectionIsControlled() || this._adapter.setSelectedRowKeys(c), this._adapter.notifySelectAll(o, P, E, l), this._adapter.notifySelectionChange(c, P);
    }
  }
  /**
   * row keys => rows
   * @param {*} dataSource
   * @param {*} selectedRowKeys
   * @param {*} selectedRowKeysSet Recursive optimization
   */
  getSelectedRows(o, l, u) {
    o = o ?? this._getDataSource(), l = l ?? this._getSelectedRowKeys(), lodashExports.isSet(u) || (u = new Set(l));
    const c = this.getProp("childrenRecordName"), m = [];
    if (lodashExports.isSet(u) && u.size && Array.isArray(o) && o.length && (m.push(...o.filter((g) => u.has(this.getRecordKey(g)))), m.length < l.length))
      for (const g of o) {
        const v = lodashExports.get(g, c);
        if (Array.isArray(v) && v.length) {
          const b = this.getSelectedRows(v, l, u);
          m.push(...b);
        }
      }
    return m;
  }
  getAllDisabledRowKeys(o, l) {
    o = o ?? this._getDataSource(), l = l ?? lodashExports.get(this.getProp("rowSelection"), "getCheckboxProps");
    const u = this.getProp("childrenRecordName"), c = [];
    if (Array.isArray(o) && o.length && typeof l == "function")
      for (const m of o) {
        const g = l(m);
        g && g.disabled && c.push(this.getRecordKey(m));
        const v = lodashExports.get(m, u);
        if (Array.isArray(v) && v.length) {
          const b = this.getAllDisabledRowKeys(v, l);
          c.push(...b);
        }
      }
    return c;
  }
  getAllRowKeys(o) {
    o = o ?? this._getDataSource();
    const l = this.getProp("childrenRecordName"), u = [];
    if (Array.isArray(o) && o.length)
      for (const c of o) {
        const m = [], g = lodashExports.get(c, l);
        Array.isArray(g) && g.length && m.push(...this.getAllRowKeys(g)), u.push(this.getRecordKey(c), ...m);
      }
    return u;
  }
  /**
   * Check if the selected item is in allRowKeysSet
   * @param {Array} selectedRowKeys
   * @param {Set} allRowKeysSet
   */
  hasRowSelected(o, l) {
    return !!(Array.isArray(o) && o.length && lodashExports.isSet(l) && l.size && o.filter((u) => l.has(u)).length);
  }
  /**
   * expand processing function
   * @param {Boolean} expanded
   * @param {String} realKey
   * @param {Event} domEvent
   */
  handleRowExpanded(o, l, u) {
    this.stopPropagation(u);
    const c = [...this.getState("expandedRowKeys")], m = c.indexOf(l), g = typeof l == "string" || typeof l == "number";
    g && o && m === -1 ? c.push(l) : g && !o && m > -1 && c.splice(m, 1), this._rowExpansionIsControlled() || this._adapter.setExpandedRowKeys(c);
    const v = this.getSelectedRows(null, c);
    let b = this.getSelectedRows(null, [l])[0];
    const S = this._getGroups();
    if (S) {
      S.has(l) && (b = { groupKey: l });
      for (let E = 0, P = c.length; E < P; E++)
        S.has(l) && v.push({ groupKey: c[E] });
    }
    this._adapter.notifyExpand(o, b, u), this._adapter.notifyExpandedRowsChange(v);
  }
  /**
   * get state.groups
   * @returns {Map|Null}
   */
  _getGroups() {
    return this._adapter.getProp("groupBy") !== null ? this._adapter.getState("groups") : null;
  }
  /**
   * Determine whether you have selected all except for disabled
   * @param {Set} selectedRowKeysSet
   * @param {Set} disabledRowKeysSet
   * @param {Array} allKeys keys after sorted and filtered
   */
  allIsSelected(o, l, u) {
    const c = lodashExports.filter(u, (m) => m != null && !l.has(m));
    if (c && c.length) {
      for (const m of c)
        if (m != null && !o.has(m))
          return !1;
      return !0;
    } else
      return u.length && u.every((g) => o.has(g)) || !1;
  }
  /**
   * This function is not used yet
   * @param {*} selectedRowKeys
   * @param {*} allKeys
   */
  allIsNotSelected(o, l) {
    for (const u of l)
      if (u != null && Array.isArray(o) && o.includes(u))
        return !0;
    return !1;
  }
  formatPaginationInfo(o = {}, l = "") {
    let u = "";
    const c = lodashExports.get(this.getProp("pagination"), "formatPageText"), { total: m, pageSize: g, currentPage: v } = o, b = Math.min((v - 1) * g + 1, m), S = Math.min(v * g, m);
    return (c || c !== !1 && l && m > 0) && (u = typeof c == "function" ? c({ currentStart: b, currentEnd: S, total: m }) : l.replace("${currentStart}", b).replace("${currentEnd}", S).replace("${total}", m)), u;
  }
  toggleShowFilter(o, l) {
    let u = this.getQuery(o);
    const c = l;
    u = { ...u, filterDropdownVisible: c }, this._filterShowIsControlled(), this._adapter.notifyFilterDropdownVisibleChange(c, o);
  }
  /**
   * Called when the filter changes
   * @param {*} dataIndex
   * @param {*} data
   */
  handleFilterSelect(o, l = {}) {
    let u = this.getQuery(o), c = [...this._adapter.getState("queries")];
    const { filteredValue: m } = l;
    u = {
      ...u,
      filteredValue: m
    }, c = mergeQueries(u, c);
    const g = this._mergeToQueries(u, null), v = this._getAllFilters(g);
    this._filterIsControlled(o) || (this._adapter.setQueries(c), this.handleClickFilterOrSorter(c)), this._notifyChange(null, v);
  }
  /**
   * Click the sort button to call
   * @param {*} column
   * @param {*} e
   */
  handleSort(o = {}, l) {
    this.stopPropagation(l);
    const { dataIndex: u } = o;
    let c = this.getState("queries"), m = null;
    c = [...c], lodashExports.each(c, (g, v, b) => {
      if (g.sorter) {
        const S = { ...g }, E = lodashExports.get(S, "sortOrder"), P = lodashExports.get(S, "defaultSortOrder", !1);
        let T = this.isSortOrderValid(E) ? E : P;
        u && u === S.dataIndex ? T === strings$2.SORT_DIRECTIONS[0] ? T = strings$2.SORT_DIRECTIONS[1] : T === strings$2.SORT_DIRECTIONS[1] ? T = !1 : T = strings$2.SORT_DIRECTIONS[0] : T = !1, b[v] = { ...S, sortOrder: T }, u === S.dataIndex && (m = b[v]);
      }
    }), this._sorterIsControlled(u) || (this._adapter.setQueries(c), this.handleClickFilterOrSorter(c)), this._notifyChange(null, null, m, null);
  }
  /**
   * Recalculate the cached data after clicking filter or sorter
   * @param {*} queries
   */
  handleClickFilterOrSorter(o) {
    const l = [...this.getProp("dataSource")], u = this.getFilteredSortedDataSource(l, o), c = this.getAllDisabledRowKeys(u);
    this.setCachedFilteredSortedDataSource(u), this.setAllDisabledRowKeys(c);
    const m = this.getCurrentPageData(u);
    this.setAdapterPageData(m);
  }
  getQuery(o, l) {
    if (l = l || this.getState("queries"), o != null)
      return lodashExports.find(l, (u) => u.dataIndex === o);
  }
  getCellWidths(o, l, u) {
    return this._adapter.getCellWidths(o, l, u);
  }
  setHeadWidths(o, l) {
    return this._adapter.setHeadWidths(o, l);
  }
  getHeadWidths(o) {
    return this._adapter.getHeadWidths(o);
  }
  mergedRowExpandable(o) {
    return this._adapter.mergedRowExpandable(o);
  }
  setBodyHasScrollbar(o) {
    this._adapter.setBodyHasScrollbar(o);
  }
}
const ColumnShape = {
  align: String,
  className: string$3,
  colSpan: number$2,
  dataIndex: string$3,
  defaultSortOrder: String,
  filterChildrenRecord: bool,
  filterDropdownProps: object$1,
  filterDropdown: node$1,
  filterDropdownVisible: bool,
  filterIcon: [object$1, func],
  filterMultiple: bool,
  filteredValue: array$1,
  filters: array$1,
  fixed: String,
  onCell: func,
  onFilter: func,
  onFilterDropdownVisibleChange: func,
  onHeaderCell: func,
  //@ts-ignore
  onSorterChange: func,
  // TODO: future api
  render: func,
  renderFilterDropdownItem: func,
  sortChildrenRecord: bool,
  sortDirections: String,
  // TODO: future api
  sortOrder: oneOfType([bool, string$3]),
  sorter: oneOfType([bool, func]),
  title: oneOfType([func, node$1]),
  useFullRender: bool,
  width: oneOfType([number$2, string$3])
};
function getColumn() {
  const s = {
    ...ColumnShape
  }, o = vuePropsMake(s, {});
  return /* @__PURE__ */ defineComponent({
    props: {
      ...o
    },
    name: "Column",
    setup(u, {}) {
      return useSlots(), () => null;
    }
  });
}
const Column = getColumn();
function getColumns(s) {
  if (s && lodashExports.isArray(s)) {
    const o = [];
    return s.forEach((l) => {
      if (isVNode(l) && (l.type === Column || lodashExports.get(l, "type.name") === "Column")) {
        const u = lodashExports.omit(l.props, ["children"]);
        Array.isArray(l.props.children) && l.props.children.length && (u.children = getColumns(l.props.children)), o.push({
          key: l.key,
          ...u
        });
      }
    }), o;
  }
  return [];
}
const vuePropsType$T = {
  value: Object
}, Provider$6 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0,
    immediate: !0
  }), provide("TableContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$T
  },
  name: "TableContextProvider"
});
function useTableContext() {
  return {
    context: inject("TableContext", ref$1({
      headWidths: [],
      setHeadWidths: lodashExports.noop,
      handleRowExpanded: lodashExports.noop
    }))
  };
}
const vuePropsType$S = {
  name: String
}, Consumer$6 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useTableContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$S
  },
  name: "TableContextConsumer"
}), TableContext = {
  Provider: Provider$6,
  Consumer: Consumer$6
}, vuePropsType$R = {
  headWidths: array$1,
  setHeadWidths: func,
  handleRowExpanded: func,
  tableWidth: number$2,
  anyColumnFixed: bool,
  flattenedColumns: array$1,
  renderExpandIcon: func,
  renderSelection: func,
  getHeadWidths: func,
  getCellWidths: func,
  getVirtualizedListRef: [func, object$1],
  setBodyHasScrollbar: func,
  direction: string$3
}, TableContextProvider = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$R
  },
  name: "TableContextProvider",
  setup(s, {}) {
    const o = useSlots(), l = computed(() => ({
      anyColumnFixed: s.anyColumnFixed,
      flattenedColumns: s.flattenedColumns,
      renderExpandIcon: s.renderExpandIcon,
      renderSelection: s.renderSelection,
      setHeadWidths: s.setHeadWidths,
      getHeadWidths: s.getHeadWidths,
      getCellWidths: s.getCellWidths,
      headWidths: s.headWidths,
      tableWidth: s.tableWidth,
      handleRowExpanded: s.handleRowExpanded,
      getVirtualizedListRef: s.getVirtualizedListRef,
      setBodyHasScrollbar: s.setBodyHasScrollbar,
      direction: s.direction
    }));
    return () => createVNode(TableContext.Provider, {
      value: l.value
    }, {
      default: o.default
    });
  }
});
class TableSelectionCellFoundation extends BaseFoundation$1 {
  handleChange(o) {
    const l = o.target.checked;
    this._adapter.notifyChange(l, o);
  }
}
const propTypes$z = {
  columnTitle: string$3,
  getCheckboxProps: func,
  type: string$3,
  onChange: func,
  selected: bool,
  disabled: bool,
  indeterminate: bool,
  prefixCls: string$3,
  className: string$3,
  "aria-label": string$3
}, defaultProps$u = {
  disabled: !1,
  onChange: lodashExports.noop,
  prefixCls: cssClasses$a.PREFIX
}, vuePropsType$Q = vuePropsMake(propTypes$z, defaultProps$u), TableSelectionCell = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$Q
  },
  name: "TableSelectionCell",
  setup(s, {}) {
    useSlots();
    const o = reactive({}), {
      adapter: l
    } = useBaseComponent(s, o);
    function u() {
      return {
        ...l(),
        notifyChange: (...v) => s.onChange(...v)
      };
    }
    const c = u(), m = new TableSelectionCellFoundation(c), g = (v) => m.handleChange(v);
    return () => {
      const {
        selected: v,
        getCheckboxProps: b,
        indeterminate: S,
        disabled: E,
        prefixCls: P,
        className: T
      } = s, N = s["aria-label"];
      let O = {
        onChange: g,
        disabled: E,
        indeterminate: S,
        checked: v
      };
      typeof b == "function" && (O = {
        ...O,
        ...b()
      });
      const z = cls(`${P}-selection-wrap`, {
        [`${P}-selection-disabled`]: E
      }, T);
      return createVNode("span", {
        class: z
      }, [createVNode(Checkbox$1, mergeProps$1({
        "aria-label": N
      }, O), null)]);
    };
  }
}), propTypes$y = {
  style: object$1,
  prefixCls: string$3,
  pagination: object$1,
  info: oneOfType([string$3, node$1]),
  renderPagination: func
}, defaultProps$t = {
  prefixCls: cssClasses$a.PREFIX
}, vuePropsType$P = vuePropsMake(propTypes$y, defaultProps$t), TablePagination = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$P
  },
  name: "TablePagination",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        pagination: o,
        prefixCls: l,
        info: u,
        renderPagination: c
      } = s, m = lodashExports.get(o, "total"), g = c && lodashExports.isFunction(c) ? c(o) : null;
      return createVNode("div", {
        class: `${l}-pagination-outer`
      }, [isVNode(g) ? g : createVNode(Fragment, null, [createVNode("span", {
        class: `${l}-pagination-info`
      }, [u]), createVNode("span", {
        class: `${l}-pagination-wrapper`
      }, [m > 0 ? createVNode(Pagination$1, mergeProps$1(lodashExports.omit(o, "formatPageText"), {
        key: lodashExports.get(o, "pageSize", "pagination")
      }), null) : null])])]);
    };
  }
});
function _isSlot$b(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function renderDropdown(s, o = null, l = 0) {
  const {
    filterMultiple: u = !0,
    filters: c = [],
    filteredValue: m = [],
    filterDropdownVisible: g,
    onSelect: v = lodashExports.noop,
    onFilterDropdownVisibleChange: b = lodashExports.noop,
    trigger: S = "click",
    position: E = "bottom",
    renderFilterDropdown: P,
    renderFilterDropdownItem: T
  } = s ?? {}, N = lodashExports.pick(s, ["tempFilteredValue", "setTempFilteredValue", "confirm", "clear", "close", "filters"]), O = typeof P == "function" ? P(N) : createVNode(DropdownMenu$1, null, {
    default: () => [Array.isArray(c) && c.map((Q, W) => {
      const ue = (yt) => {
        const xt = yt;
        xt && (xt.stopImmediatePropagation(), xt.stopPropagation(), xt.preventDefault());
        let Kt = [...m];
        const tn = Kt.includes(Q.value), ln = Kt.indexOf(Q.value);
        return ln > -1 ? Kt.splice(ln, 1) : u ? Kt.push(Q.value) : Kt = [Q.value], v({
          value: Q.value,
          filteredValue: Kt,
          included: !tn,
          domEvent: xt
        });
      }, te = m.includes(Q.value), {
        text: K
      } = Q, {
        value: ve
      } = Q, ee = `${l}_${W}`, Re = typeof T == "function" ? T({
        onChange: ue,
        filterMultiple: u,
        value: ve,
        text: K,
        checked: te,
        filteredValue: m,
        level: l
      }) : null;
      let wt = Re && isVNode(Re) ? cloneVNode(Re, {
        key: ee
      }) : createVNode(DropdownItem$1, {
        key: ee,
        onClick: ue
      }, {
        default: () => [u ? createVNode(Checkbox$1, {
          checked: te
        }, _isSlot$b(K) ? K : {
          default: () => [K]
        }) : createVNode(Radio$1, {
          checked: te
        }, _isSlot$b(K) ? K : {
          default: () => [K]
        })]
      });
      if (Array.isArray(Q.children) && Q.children.length) {
        const yt = {
          ...s,
          filters: Q.children,
          trigger: "hover",
          position: "right"
        };
        delete yt.filterDropdownVisible, wt = renderDropdown(yt, wt, l + 1);
      }
      return wt;
    })]
  }), z = {
    ...lodashExports.pick(s, ...Object.keys(DropdownVuePropsType)),
    onVisibleChange: (Q) => b(Q),
    trigger: S,
    position: E,
    render: O
  };
  return g != null && (z.visible = g), createVNode(BaseDropdown, mergeProps$1(z, {
    key: `Dropdown_level_${l}`,
    className: `${cssClasses$a.PREFIX}-column-filter-dropdown`
  }), _isSlot$b(o) ? o : {
    default: () => [o]
  });
}
const propTypes$x = {
  ...DropdownVuePropsType,
  prefixCls: String,
  filteredValue: Array,
  filterIcon: [Boolean, Object, Function],
  filterDropdown: [Boolean, Object, Function],
  filterDropdownProps: Object,
  filters: Array,
  filterMultiple: Boolean,
  filterDropdownVisible: Boolean,
  onSelect: Function,
  onFilterDropdownVisibleChange: Function,
  renderFilterDropdown: Function,
  renderFilterDropdownItem: Function,
  title: String,
  dataIndex: [Number, String],
  width: [Number, String],
  fixed: [Boolean, String]
}, defaultProps$s = {}, ColumnFilterVueProps = vuePropsMake(propTypes$x, defaultProps$s), ColumnFilter = /* @__PURE__ */ defineComponent({
  props: ColumnFilterVueProps,
  name: "ColumnFilter",
  setup(s, {
    attrs: o
  }) {
    const {
      getProps: l
    } = useHasInProps(), u = typeof s.filterDropdownVisible < "u", c = typeof s.renderFilterDropdown == "function", g = !u && c ? !1 : s.filterDropdownVisible, v = ref$1(s.filteredValue), b = ref$1(g);
    watch(() => s.filterDropdownVisible, () => {
      typeof s.filterDropdownVisible < "u" && (b.value = s.filterDropdownVisible);
    }, {
      immediate: !0
    }), watch(() => s.filteredValue, () => {
      v.value = s.filteredValue;
    }, {
      immediate: !0
    });
    const S = (N = {}) => {
      const O = (N == null ? void 0 : N.filteredValue) || v;
      lodashExports.isEqual(O, s.filteredValue) || s.onSelect({
        filteredValue: O
      }), N.closeDropdown && (b.value = !1);
    }, E = (N = {}) => {
      v.value = [], s.onSelect({
        filteredValue: []
      }), N.closeDropdown && (b.value = !1);
    }, P = () => {
      b.value = !1;
    }, T = (N) => {
      const O = typeof s.filterDropdownVisible < "u", z = typeof s.renderFilterDropdown == "function";
      !O && z && (b.value = N), s.onFilterDropdownVisibleChange(N);
    };
    return () => {
      const {
        prefixCls: N = cssClasses$a.PREFIX,
        filteredValue: O,
        filterIcon: z = "filter",
        filterDropdownProps: Q,
        onSelect: W,
        filterDropdownVisible: ue,
        renderFilterDropdown: te,
        onFilterDropdownVisibleChange: K
      } = l(s);
      let {
        filterDropdown: ve = null
      } = s;
      const ee = typeof s.filterDropdownVisible < "u", Re = {
        tempFilteredValue: v.value,
        setTempFilteredValue: (Kt) => {
          v.value = Kt;
        },
        confirm: S,
        clear: E,
        close: P
      }, wt = cls(`${N}-column-filter`, {
        on: Array.isArray(O) && O.length
      });
      let yt;
      typeof z == "function" ? yt = z(Array.isArray(O) && O.length > 0) : isVNode(z) ? yt = z : yt = createVNode("div", {
        class: wt
      }, ["​", createVNode(IconComponent$m, {
        role: "button",
        "aria-label": "Filter data with this column",
        "aria-haspopup": "listbox",
        tabIndex: -1,
        size: "default"
      }, null)]);
      const xt = {
        ...l(s),
        ...Q,
        ...Re,
        filterDropdownVisible: ee ? ue : b.value,
        onFilterDropdownVisibleChange: T
      };
      return ve = isVNode(ve) ? ve : renderDropdown(xt, yt), ve;
    };
  }
}), propTypes$w = {
  className: string$3,
  style: object$1,
  onClick: func,
  prefixCls: string$3,
  sortOrder: oneOfType([string$3, bool]),
  sortIcon: func,
  title: any$1
}, defaultProps$r = {
  prefixCls: cssClasses$a.PREFIX,
  onClick: lodashExports.noop,
  sortOrder: !1
}, vuePropsType$O = vuePropsMake(propTypes$w, defaultProps$r), ColumnSorter = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$O
  },
  name: "ColumnSorter",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        prefixCls: o,
        onClick: l,
        sortOrder: u,
        style: c,
        title: m,
        sortIcon: g
      } = s, v = "default", b = cls(`${o}-column-sorter-up`, {
        on: u === strings$2.SORT_DIRECTIONS[0]
      }), S = cls(`${o}-column-sorter-down`, {
        on: u === strings$2.SORT_DIRECTIONS[1]
      }), E = {
        /**
         * Set 'aria-sort' to aria-columnheader is difficult, so set 'aria-label' about sort info to sorter
         * reference: https://developer.mozilla.org/en-US/docs/Web/API/Element/ariaSort
         */
        "aria-label": `Current sort order is ${u ? `${u}ing` : "none"}`,
        "aria-roledescription": "Sort data with this column"
      }, P = () => typeof g == "function" ? g({
        sortOrder: u
      }) : createVNode("div", {
        style: c,
        class: `${o}-column-sorter`
      }, [createVNode("span", {
        class: `${b}`
      }, [createVNode(IconComponent$D, {
        size: v
      }, null)]), createVNode("span", {
        class: `${S}`
      }, [createVNode(IconComponent$E, {
        size: v
      }, null)])]);
      return createVNode("div", mergeProps$1({
        role: "button"
      }, E, {
        tabindex: -1,
        class: `${o}-column-sorter-wrapper`,
        onClick: l,
        onKeypress: (T) => isEnterPress(T) && l(T)
      }), [m, P()]);
    };
  }
}), propTypes$v = {
  expanded: bool,
  componentType: String,
  onClick: func,
  onMouseEnter: func,
  onMouseLeave: func,
  expandIcon: oneOfType([node$1, func]),
  prefixCls: string$3,
  motion: bool
}, defaultProps$q = {
  componentType: "expand",
  onClick: lodashExports.noop,
  onMouseEnter: lodashExports.noop,
  onMouseLeave: lodashExports.noop,
  prefixCls: cssClasses$a.PREFIX
}, vuePropsType$N = vuePropsMake(propTypes$v, defaultProps$q), CustomExpandIcon = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$N
  },
  name: "CustomExpandIcon",
  setup(s, {}) {
    useSlots();
    const o = computed(() => (l) => {
      typeof s.onClick == "function" && s.onClick(!s.expanded, l);
    });
    return () => {
      const {
        expanded: l,
        componentType: u,
        onClick: c = lodashExports.noop,
        onMouseEnter: m = lodashExports.noop,
        onMouseLeave: g = lodashExports.noop,
        expandIcon: v,
        prefixCls: b = cssClasses$a.PREFIX,
        motion: S = !0
      } = s;
      let E;
      if (isVNode(v) ? E = v : typeof v == "function" ? E = v(l) : u === "tree" ? E = l && !S ? createVNode(IconComponent$4, {
        size: "small"
      }, null) : createVNode(IconComponent$3, {
        size: "small"
      }, null) : E = l && !S ? createVNode(IconComponent$A, null, null) : createVNode(IconComponent$y, null, null), S) {
        const P = E;
        E = createVNode(CSSAnimation, {
          animationState: l ? "enter" : "leave",
          startClassName: `${cssClasses$a.PREFIX}-expandedIcon-${l ? "show" : "hide"}`,
          children: ({
            animationClassName: T
          }) => {
            var N;
            return cloneVNode(P, {
              class: (((N = P.props) == null ? void 0 : N.class) || "") + " " + T
            });
          }
        }, null);
      }
      return createVNode("span", {
        role: "button",
        "aria-label": "Expand this row",
        tabindex: -1,
        onClick: o.value,
        onMouseenter: m,
        onMouseleave: g,
        class: `${b}-expand-icon`,
        onKeypress: (P) => isEnterPress(P) && o.value(P)
      }, [E]);
    };
  }
});
function _isSlot$a(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$u = {
  columns: array$1,
  prefixCls: string$3,
  className: string$3,
  style: object$1,
  components: object$1
}, defaultProps$p = {
  columns: [],
  prefixCls: cssClasses$a.PREFIX
}, vuePropsType$M = vuePropsMake(propTypes$u, defaultProps$p), ColGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$M
  },
  name: "ColGroup",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        columns: o,
        className: l,
        style: u,
        prefixCls: c,
        components: m
      } = s, g = lodashExports.get(m, "colgroup.wrapper", "colgroup"), v = lodashExports.get(m, "colgroup.col", "col"), b = flattenColumns(o).map((E, P) => {
        const T = {};
        return E.width && (T.width = typeof E.width == "string" ? E.width : E.width + "px", T.minWidth = typeof T.width == "string" ? T.width : T.width + "px"), createVNode(v, {
          className: cls(`${c}-col`, E.className),
          key: E.key || E.dataIndex || P,
          style: T
        }, null);
      }), S = cls(`${c}-colgroup`, l);
      return createVNode(g, {
        className: S,
        style: u
      }, _isSlot$a(b) ? b : {
        default: () => [b]
      });
    };
  }
});
function _isSlot$9(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$t = {
  components: object$1,
  row: array$1,
  prefixCls: string$3,
  onHeaderRow: func,
  index: oneOfType([string$3, number$2]),
  style: object$1,
  columns: array$1,
  fixed: oneOfType([bool, string$3]),
  selectedRowKeysSet: {
    type: object$1,
    required: !0
  }
}, defaultProps$o = {
  onHeaderRow: lodashExports.noop,
  prefixCls: cssClasses$a.PREFIX,
  columns: [],
  components: {
    header: {
      wrapper: "thead",
      row: "tr",
      cell: "th"
    }
  }
}, vuePropsType$L = vuePropsMake(propTypes$t, defaultProps$o), TableHeaderRow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$L
  },
  name: "TableHeaderRow",
  setup(s, {}) {
    useSlots();
    let o = null;
    const {
      context: l
    } = useTableContext(), u = reactive({}), {
      adapter: c
    } = useBaseComponent(s, u);
    c();
    const m = (g) => {
      if (o = g, g && l.value.setHeadWidths) {
        const {
          prefixCls: v,
          row: b,
          index: S
        } = s, E = `.${v}-row-head`, P = g && g.querySelectorAll && g.querySelectorAll(E);
        l.value.setHeadWidths(lodashExports.map(P, (T, N) => {
          let O = lodashExports.get(b, [N, "column", "width"]);
          const z = lodashExports.get(b, [N, "column", "key"]);
          return typeof O != "number" && (O = T && T.getBoundingClientRect().width || 0), {
            width: O,
            key: z
          };
        }), S);
      }
    };
    return watch(() => s.columns, (g, v, b) => {
      v !== s.columns && o && m(o);
    }), () => {
      const {
        components: g,
        row: v,
        prefixCls: b,
        onHeaderRow: S,
        index: E,
        style: P,
        columns: T
      } = s, {
        getCellWidths: N,
        direction: O
      } = l.value, z = O === "rtl", Q = sliceColumnsByLevel(T, E), W = (N == null ? void 0 : N(Q)) || [], ue = lodashExports.get(g, "header.row", "tr"), te = lodashExports.get(g, "header.cell", "th"), K = S(T, E) || {};
      lodashExports.set(K, "className", cls(lodashExports.get(K, "className"), `${b}-row`));
      const ve = lodashExports.map(v, (ee, Re) => {
        const {
          column: wt,
          ...yt
        } = ee, xt = typeof wt.onHeaderCell == "function" ? wt.onHeaderCell(wt, Re, E) : {};
        let Kt = {
          ...xt.style
        };
        if (wt.align) {
          const Et = getRTLAlign(wt.align, O);
          Kt = {
            ...Kt,
            textAlign: Et
          }, xt.className = cls(xt.className, wt.className, {
            [`${b}-align-${Et}`]: !!Et
          });
        }
        let tn, ln, rn, an;
        if (z ? (tn = isFixedRight(wt), ln = isFixedLeft(wt), rn = isFirstFixedRight(Q, wt), an = isLastLeftFixed(Q, wt)) : (tn = isFixedLeft(wt), ln = isFixedRight(wt), rn = isLastLeftFixed(Q, wt), an = isFirstFixedRight(Q, wt)), xt.className = cls(
          `${b}-row-head`,
          wt.className,
          xt.className,
          // `${prefixCls}-fixed-columns`,
          {
            [`${b}-cell-fixed-left`]: tn,
            [`${b}-cell-fixed-left-last`]: rn,
            [`${b}-cell-fixed-right`]: ln,
            [`${b}-cell-fixed-right-first`]: an,
            [`${b}-row-head-ellipsis`]: wt.ellipsis
          }
        ), W.length && Q.length) {
          const Et = lodashExports.findIndex(Q, (Qt) => Qt && Qt.key != null && Qt.key === wt.key);
          Et > -1 && (isFixedLeft(wt) ? Kt = {
            ...Kt,
            position: "sticky",
            [z ? "right" : "left"]: arrayAdd(W, 0, Et)
          } : isFixedRight(wt) && (Kt = {
            ...Kt,
            position: "sticky",
            [z ? "left" : "right"]: arrayAdd(W, Et + 1)
          }));
        }
        Object.assign(yt, {
          resize: wt.resize
        });
        const Gt = lodashExports.omit({
          ...yt,
          ...xt
        }, ["colStart", "colEnd", "hasSubColumns", "parents", "level"]), {
          rowSpan: nn,
          colSpan: vt
        } = Gt;
        return nn === 0 || vt === 0 ? null : (Kt.left && typeof Kt.left == "number" && (Kt.left = Kt.left + "px"), Kt.right && typeof Kt.right == "number" && (Kt.right = Kt.right + "px"), createVNode(te, mergeProps$1({
          role: "columnheader",
          "aria-colindex": Re + 1
        }, lodashExports.omit(Gt, "children"), {
          style: Kt,
          key: wt.key || wt.dataIndex || Re
        }), {
          default: () => [Gt.children]
        }));
      });
      return createVNode(ue, mergeProps$1({
        role: "row",
        "aria-rowindex": E + 1
      }, K, {
        style: P,
        ref: m
      }), _isSlot$9(ve) ? ve : {
        default: () => [ve]
      });
    };
  }
});
class TableBodyFoundation extends BaseFoundation$1 {
  init() {
    this.initVirtualizedData(), this.initExpandBtnShouldInRow();
  }
  destroy() {
    this.unobserveBodyResize();
  }
  initVirtualizedData(o) {
    this._adapter.setVirtualizedData(this.flattenData(this.getProp("dataSource")), o);
  }
  initExpandBtnShouldInRow(o) {
    const l = this.getProps(), u = expandBtnShouldInRow(l);
    this._adapter.setCachedExpandBtnShouldInRow(u), !lodashExports.isObject(o) && !o && (o = strings$2.EXPAND_RELATED_PROPS.map((m) => lodashExports.get(l, m, void 0))), this._adapter.setCachedExpandRelatedProps(o);
  }
  flattenData(o = [], l = 0, u = [], c = []) {
    const m = [], { rowKey: g, childrenRecordName: v, expandedRowRender: b, expandedRowKeys: S, groups: E } = this.getProps();
    return l === 0 && lodashExports.isMap(E) ? E.forEach((P, T) => {
      const N = o.findIndex((O) => P.has(getRecordKey(O, g)));
      if (N > -1) {
        const O = lodashExports.findLastIndex(o, (Q) => P.has(getRecordKey(Q, g))), z = lodashExports.includes(S, T);
        m.push({
          key: T,
          level: l,
          sectionRow: !0,
          group: P,
          groupKey: T,
          expanded: z
        }), z && m.push(
          ...this.flattenData(
            o.slice(N, O + 1),
            l + 1,
            [...u],
            [...c]
          )
        );
      }
    }) : o.forEach((P, T) => {
      const N = getRecordKey(P, g), O = getRecordChildren(P, v);
      l && c.push(N);
      const z = {
        key: N,
        record: P,
        level: l,
        parentKeys: [...u],
        childrenKeys: [...c]
      };
      m.push(z);
      const Q = [];
      lodashExports.includes(S, N) && (Array.isArray(O) && O.length ? Q.push(
        ...this.flattenData(O, l + 1, [...z.parentKeys], [...z.childrenKeys])
      ) : b && Q.push({
        key: genExpandedRowKey(N),
        level: l,
        expandedRow: !0,
        record: P
      }), m.push(...Q));
    }), m;
  }
  /**
   * Use ResizeObserver to monitor changes in the size of the body content area, and notify Table to recalculate if it changes. columns #1219
   * (Only monitor the scroll.y scene, other scenes are not monitored, because the header of the scroll.y scene is a separate table, and a scrollbar column will be inserted)
   */
  observeBodyResize(o) {
    const { scroll: l } = this.getProps();
    if (lodashExports.get(l, "y"))
      return this._adapter.observeBodyResize(o);
  }
  unobserveBodyResize() {
    return this._adapter.unobserveBodyResize();
  }
}
let scrollbarVerticalSize, scrollbarHorizontalSize;
const scrollbarMeasure = {
  position: "absolute",
  top: "-9999px",
  width: "50px",
  height: "50px"
};
function measureScrollbar(s = "vertical") {
  if (typeof document > "u" || typeof window > "u")
    return 0;
  const o = s === "vertical";
  if (o && scrollbarVerticalSize)
    return scrollbarVerticalSize;
  if (!o && scrollbarHorizontalSize)
    return scrollbarHorizontalSize;
  const l = document.createElement("div");
  Object.keys(scrollbarMeasure).forEach((c) => {
    l.style[c] = scrollbarMeasure[c];
  }), o ? l.style.overflowY = "scroll" : l.style.overflowX = "scroll", document.body.appendChild(l);
  let u = 0;
  return o ? (u = l.offsetWidth - l.clientWidth, scrollbarVerticalSize = u) : (u = l.offsetHeight - l.clientHeight, scrollbarHorizontalSize = u), document.body.removeChild(l), u;
}
function amendTableWidth(s) {
  return typeof s == "number" ? s - numbers$2.DEFAULT_CELL_PADDING_LEFT - numbers$2.DEFAULT_CELL_PADDING_RIGHT - numbers$2.DEFAULT_CELL_BORDER_WIDTH_LEFT - numbers$2.DEFAULT_CELL_BORDER_WIDTH_RIGHT - measureScrollbar("vertical") : void 0;
}
function mergeComponents(s, o) {
  return lodashExports.merge(
    {},
    {
      table: "table",
      header: {
        outer: "table",
        wrapper: "thead",
        row: "tr",
        cell: "th"
      },
      body: o ? {
        outer: "div",
        wrapper: "div",
        row: "div",
        cell: "div",
        colgroup: {
          wrapper: "div",
          col: "div"
        }
      } : {
        outer: "table",
        wrapper: "tbody",
        row: "tr",
        cell: "td",
        colgroup: {
          wrapper: "colgroup",
          col: "col"
        }
      },
      footer: {
        wrapper: "tfoot",
        row: "tr",
        cell: "td"
      }
    },
    s
  );
}
const logger = new Logger("[@kousum/semi-ui-vue Table]");
function mergeColumns(s = [], o = [], l = null, u = !0) {
  const c = [], m = u ? cloneDeep$1 : lodashExports.clone;
  return lodashExports.map(o, (g) => {
    g = { ...g };
    const v = getColumnKey(g, l), b = v != null && lodashExports.find(s, (S) => getColumnKey(S, l) === v);
    b ? c.push(
      m({
        ...b,
        ...g
      })
    ) : c.push(m(g));
  }), c;
}
class TableRowFoundation extends BaseFoundation$1 {
  handleClick(o) {
    const { expanded: l, rowKey: u } = this.getProps();
    this._adapter.notifyClick(u, o, l);
  }
  handleDoubleClick(o) {
    this._adapter.notifyDoubleClick(this.getProp("record"), o);
  }
  handleMouseEnter(o) {
    const l = this.getProp("record");
    this._adapter.notifyMouseEnter(l, o);
  }
  handleMouseLeave(o) {
    const l = this.getProp("record");
    this._adapter.notifyMouseLeave(l, o);
  }
}
class TableCellFoundation extends BaseFoundation$1 {
  handleClick(o) {
    this._adapter.notifyClick(this.getProp("record"), o);
  }
}
function _isSlot$8(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function isInvalidRenderCellText(s) {
  return s && !isVNode(s) && Object.prototype.toString.call(s) === "[object Object]";
}
const propTypes$s = {
  record: object$1,
  prefixCls: string$3,
  index: number$2,
  fixedLeft: oneOfType([bool, number$2]),
  lastFixedLeft: bool,
  fixedRight: oneOfType([bool, number$2]),
  firstFixedRight: bool,
  indent: number$2,
  indentSize: number$2,
  column: object$1,
  expandIcon: any$1,
  renderExpandIcon: func,
  hideExpandedColumn: bool,
  component: any$1,
  onClick: func,
  onDidUpdate: func,
  isSection: bool,
  width: oneOfType([string$3, number$2]),
  height: oneOfType([string$3, number$2]),
  selected: bool,
  expanded: bool,
  colIndex: number$2,
  disabled: bool,
  style: object$1,
  className: string$3
}, defaultProps$n = {
  indent: 0,
  indentSize: numbers$2.DEFAULT_INDENT_WIDTH,
  onClick: lodashExports.noop,
  prefixCls: cssClasses$a.PREFIX,
  component: "td",
  onDidUpdate: lodashExports.noop,
  column: {}
}, vuePropsType$K = vuePropsMake(propTypes$s, defaultProps$n), TableCell = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$K
  },
  name: "TableCell",
  setup(s, {}) {
    useSlots();
    let {
      context: o
    } = useTableContext();
    const l = ref$1(), u = reactive({}), {
      adapter: c
    } = useBaseComponent(s, u);
    function m() {
      return {
        ...c(),
        notifyClick: (...N) => {
          const {
            onClick: O
          } = s;
          typeof O == "function" && O(...N);
        }
      };
    }
    const g = m(), v = new TableCellFoundation(g);
    watch([() => s, u], () => {
      s.onDidUpdate(l.value);
    });
    const b = (N) => {
      v.handleClick(N);
      const O = g.getCache("customCellProps");
      O && typeof O.onClick == "function" && O.onClick(N);
    };
    function S() {
      var xt, Kt, tn, ln;
      const {
        record: N,
        index: O,
        column: z = {},
        fixedLeft: Q,
        fixedRight: W,
        width: ue,
        height: te
      } = s;
      let K = {}, ve = {};
      const {
        direction: ee
      } = o.value, Re = ee === "rtl";
      if (Q || typeof Q == "number" ? lodashExports.set(K, Re ? "style.right" : "style.left", typeof Q == "number" ? Q : 0) : (W || typeof W == "number") && lodashExports.set(K, Re ? "style.left" : "style.right", typeof W == "number" ? W : 0), ue != null && lodashExports.set(K, "style.width", ue + "px"), te != null && lodashExports.set(K, "style.height", te + "px"), (xt = K.style) != null && xt.left && typeof ((Kt = K.style) == null ? void 0 : Kt.left) == "number" && (K.style.left = K.style.left + "px"), (tn = K.style) != null && tn.right && typeof ((ln = K.style) == null ? void 0 : ln.right) == "number" && (K.style.right = K.style.right + "px"), z.onCell) {
        ve = z.onCell(N, O), g.setCache("customCellProps", {
          ...ve
        }), K = {
          ...K,
          ...lodashExports.omit(ve, ["style", "className", "onClick"])
        };
        const rn = lodashExports.get(ve, "style") || {};
        K.style = {
          ...K.style,
          ...rn
        };
      }
      if (z.align) {
        const rn = getRTLAlign(z.align, ee), an = getRTLFlexAlign(z.align, ee);
        K.style = {
          ...K.style,
          textAlign: rn,
          justifyContent: an
        };
      }
      return {
        tdProps: K,
        customCellProps: ve
      };
    }
    function E(N) {
      const {
        record: O,
        indentSize: z,
        prefixCls: Q,
        indent: W,
        index: ue,
        expandIcon: te,
        renderExpandIcon: K,
        column: ve = {}
      } = s, {
        dataIndex: ee,
        render: Re,
        useFullRender: wt
      } = ve;
      let yt, xt, Kt;
      typeof ee == "number" ? yt = lodashExports.get(O, ee) : !ee || ee.length === 0 ? yt = O : yt = lodashExports.get(O, ee);
      const tn = W && z ? createVNode("span", {
        style: {
          paddingLeft: `${z * W}px`
        },
        class: `${Q}-row-indent indent-level-${W}`
      }, null) : null, ln = typeof K == "function" ? K(O) : te;
      if (Re) {
        const rn = {
          expandIcon: ln
        };
        if (wt) {
          const {
            renderSelection: an
          } = o.value, Gt = typeof an == "function" ? an(O) : null;
          Object.assign(rn, {
            selection: Gt,
            indentText: tn
          });
        }
        yt = Re(yt, O, ue, rn), isInvalidRenderCellText(yt) && (N = yt.props ? lodashExports.merge(N, yt.props) : N, xt = N.colSpan, Kt = N.rowSpan, yt = yt.children);
      }
      return {
        text: yt,
        indentText: tn,
        rowSpan: Kt,
        colSpan: xt,
        realExpandIcon: ln,
        tdProps: N
      };
    }
    function P(N, O, z) {
      const {
        prefixCls: Q,
        isSection: W,
        expandIcon: ue,
        column: te = {}
      } = s, {
        tableWidth: K,
        anyColumnFixed: ve
      } = o.value, {
        useFullRender: ee
      } = te;
      let Re = null;
      return ee ? Re = N : Re = [createVNode(Fragment, {
        key: "indentText"
      }, [O]), createVNode(Fragment, {
        key: "expandIcon"
      }, [ue ? z : null]), createVNode(Fragment, {
        key: "text"
      }, [N])], W && (Re = createVNode("div", {
        class: cls(`${Q}-section-inner`),
        style: {
          width: ve ? styleNum(amendTableWidth(K)) : void 0
        }
      }, [Re])), Re;
    }
    const T = (N) => l.value = N;
    return () => {
      const {
        prefixCls: N,
        column: O = {},
        component: z,
        fixedLeft: Q,
        fixedRight: W,
        lastFixedLeft: ue,
        firstFixedRight: te,
        colIndex: K
      } = s, {
        direction: ve
      } = o.value, ee = ve === "rtl", {
        className: Re,
        ellipsis: wt
      } = O, yt = Q || typeof Q == "number", xt = W || typeof W == "number", {
        tdProps: Kt,
        customCellProps: tn
      } = S(), ln = E(Kt);
      let {
        text: rn
      } = ln;
      const {
        indentText: an,
        rowSpan: Gt,
        colSpan: nn,
        realExpandIcon: vt,
        tdProps: Et
      } = ln;
      let Qt;
      if (shouldShowEllipsisTitle(wt) && typeof rn == "string" && (Qt = rn), Gt === 0 || nn === 0)
        return null;
      isInvalidRenderCellText(rn) && (rn = null);
      const gn = P(rn, an, vt);
      let dn, yn, vn, Pn;
      ee ? (dn = xt, yn = te, vn = yt, Pn = ue) : (dn = yt, yn = ue, vn = xt, Pn = te);
      const On = cls(Re, `${N}-row-cell`, lodashExports.get(tn, "className"), {
        [`${N}-cell-fixed-left`]: dn,
        [`${N}-cell-fixed-left-last`]: yn,
        [`${N}-cell-fixed-right`]: vn,
        [`${N}-cell-fixed-right-first`]: Pn,
        [`${N}-row-cell-ellipsis`]: wt
      });
      return createVNode(z, mergeProps$1({
        role: "gridcell",
        "aria-colindex": K + 1,
        className: On,
        onClick: b,
        title: Qt
      }, Et, {
        ref: T
      }), _isSlot$8(gn) ? gn : {
        default: () => [gn]
      });
    };
  }
});
function _isSlot$7(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$r = {
  anyColumnFixed: bool,
  cellWidths: array$1,
  className: string$3,
  columns: {
    type: array$1,
    required: !0
  },
  components: object$1,
  disabled: bool,
  expandIcon: oneOfType([bool, func, node$1]),
  expandableRow: bool,
  expanded: bool,
  displayNone: bool,
  expandedRow: bool,
  fixed: oneOfType([string$3, bool]),
  height: oneOfType([string$3, number$2]),
  hideExpandedColumn: bool,
  hovered: bool,
  indent: number$2,
  indentSize: number$2,
  index: number$2,
  isSection: bool,
  level: number$2,
  onDidUpdate: func,
  onHover: func,
  onRow: func,
  onRowClick: func,
  onRowContextMenu: func,
  onRowDoubleClick: func,
  onRowMouseEnter: func,
  onRowMouseLeave: func,
  prefixCls: string$3,
  record: object$1,
  renderExpandIcon: func,
  replaceClassName: string$3,
  rowExpandable: func,
  rowKey: oneOfType([string$3, number$2]),
  // real key of the row
  selected: bool,
  store: object$1,
  style: object$1,
  virtualized: oneOfType([object$1, bool]),
  visible: bool
  // data: [Array] as PropType<BaseRowProps['data']>,
}, defaultProps$m = {
  columns: [],
  rowExpandable: lodashExports.stubTrue,
  components: {
    body: {
      row: "tr",
      cell: "td"
    }
  },
  prefixCls: cssClasses$a.PREFIX,
  onRow: lodashExports.noop,
  onRowClick: lodashExports.noop,
  onRowDoubleClick: lodashExports.noop,
  onRowMouseEnter: lodashExports.noop,
  onRowMouseLeave: lodashExports.noop,
  onHover: lodashExports.noop,
  onDidUpdate: lodashExports.noop,
  visible: !0,
  hovered: !1,
  selected: !1,
  disabled: !1
}, vuePropsType$J = vuePropsMake(propTypes$r, defaultProps$m), TableRow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$J
  },
  name: "TableRow",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const {
      adapter: l
    } = useBaseComponent(s, {});
    function u() {
      return {
        ...l(),
        notifyClick: (...P) => s.onRowClick(...P),
        notifyDoubleClick: (...P) => s.onRowDoubleClick(...P),
        notifyMouseLeave: (...P) => {
          s.onHover(!1, s.rowKey), s.onRowMouseEnter(...P);
        },
        notifyMouseEnter: (...P) => {
          s.onHover(!0, s.rowKey), s.onRowMouseEnter(...P);
        }
      };
    }
    const c = u(), m = new TableRowFoundation(c);
    getCurrentInstance();
    const g = (P) => {
      const {
        renderExpandIcon: T
      } = s;
      return T(P, !0);
    };
    function v() {
      const {
        columns: P,
        record: T,
        index: N,
        prefixCls: O,
        fixed: z,
        components: Q,
        expandableRow: W,
        level: ue,
        expandIcon: te,
        rowExpandable: K,
        isSection: ve,
        expandedRow: ee,
        virtualized: Re,
        indentSize: wt,
        hideExpandedColumn: yt,
        cellWidths: xt,
        selected: Kt,
        expanded: tn,
        disabled: ln,
        onDidUpdate: rn
      } = s, an = lodashExports.get(Q, "body.cell", strings$2.DEFAULT_COMPONENTS.body.cell), Gt = [], nn = K(T);
      let vt = 0;
      return lodashExports.each(P, (Et, Qt) => {
        const un = lodashExports.get(Et, "key"), gn = {};
        if (z !== "right" && (isInnerColumnKey(un) && vt++, W && Qt === vt && (gn.renderExpandIcon = g, (yt || ve) && (gn.expandIcon = te ?? !0)), ue != null && Qt === vt && (gn.indent = ue, !W && yt && (gn.indent = ue + 1))), isExpandedColumn(Et) && !nn)
          Gt.push(createVNode(TableCell, {
            key: Qt,
            colIndex: Qt,
            isSection: ve
          }, null));
        else if (!isScrollbarColumn(Et)) {
          const dn = {};
          an !== strings$2.DEFAULT_COMPONENTS.body.cell && Re && !ee && (dn.width = lodashExports.get(xt, Qt)), Gt.push(createVNode(TableCell, mergeProps$1({
            colIndex: Qt
          }, {
            ...gn,
            ...dn
          }, {
            hideExpandedColumn: yt,
            indentSize: wt,
            isSection: ve,
            prefixCls: `${O}`,
            column: Et,
            key: Qt,
            index: N,
            record: T,
            component: an,
            fixedLeft: isFixedLeft(Et) && arrayAdd(xt, 0, Qt),
            lastFixedLeft: isLastLeftFixed(P, Et),
            fixedRight: isFixedRight(Et) && arrayAdd(xt, Qt + 1),
            firstFixedRight: isFirstFixedRight(P, Et),
            selected: Kt,
            expanded: tn,
            disabled: ln,
            onDidUpdate: rn
          }), null));
        }
      }), Gt;
    }
    const b = (P) => {
      m.handleMouseEnter(P);
      const T = c.getCache("customRowProps");
      typeof (T == null ? void 0 : T.onMouseEnter) == "function" && T.onMouseEnter(P);
    }, S = (P) => {
      m.handleMouseLeave(P);
      const T = c.getCache("customRowProps");
      typeof (T == null ? void 0 : T.onMouseLeave) == "function" && T.onMouseLeave(P);
    }, E = (P) => {
      m.handleClick(P);
      const T = c.getCache("customRowProps");
      T && typeof T.onClick == "function" && T.onClick(P);
    };
    return () => {
      let P;
      const {
        style: T
      } = s, {
        components: N,
        prefixCls: O,
        selected: z,
        onRow: Q,
        index: W,
        className: ue,
        replaceClassName: te,
        record: K,
        hovered: ve,
        expanded: ee,
        displayNone: Re,
        expandableRow: wt,
        level: yt,
        expandedRow: xt,
        isSection: Kt,
        rowKey: tn
      } = s, ln = N.body.row, {
        className: rn,
        style: an,
        ...Gt
      } = Q(K, W) || {};
      c.setCache("customRowProps", {
        ...Gt
      });
      const nn = {
        ...T,
        ...an
      }, vt = typeof te == "string" && te.length ? cls(te, rn) : cls(ue, `${O}-row`, {
        [`${O}-row-selected`]: z,
        [`${O}-row-expanded`]: ee,
        [`${O}-row-hovered`]: ve,
        [`${O}-row-hidden`]: Re
      }, rn), Et = {};
      return typeof W == "number" && (Et["aria-rowindex"] = W + 1), wt && (Et["aria-expanded"] = ee), (ee || xt) && (Et["aria-level"] = 2), typeof yt == "number" && (Et["aria-level"] = yt + 1), Kt && (Et["aria-level"] = 1), createVNode(ln, mergeProps$1({
        role: "row"
      }, Et, {
        ...Gt,
        onMouseenter: b,
        onMouseleave: S,
        onClick: E
      }, {
        style: nn,
        className: vt,
        "data-row-key": tn
      }), _isSlot$7(P = v()) ? P : {
        default: () => [P]
      });
    };
  }
}), propTypes$q = {
  cellWidths: {
    type: array$1,
    required: !0
  },
  className: string$3,
  columns: array$1,
  components: object$1,
  defaultExpandAllRows: bool,
  defaultExpandedRowKeys: array$1,
  expandIcon: oneOfType([object$1, node$1, func]),
  expandRowByClick: bool,
  expanded: bool,
  expandedRowKeys: array$1,
  expandedRowRender: func,
  indentSize: number$2,
  index: oneOfType([string$3, number$2]),
  onExpand: func,
  onExpandedRowsChange: func,
  prefixCls: string$3,
  record: object$1,
  renderExpandIcon: func,
  store: object$1,
  style: object$1,
  virtualized: oneOfType([bool, object$1]),
  displayNone: bool
}, defaultProps$l = {
  record: {},
  prefixCls: cssClasses$a.PREFIX
}, vuePropsType$I = vuePropsMake(propTypes$q, defaultProps$l), TableExpandedRow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$I
  },
  name: "TableExpandedRow",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useTableContext();
    return () => {
      const {
        record: l,
        columns: u = [],
        prefixCls: c,
        className: m,
        expanded: g,
        expandedRowRender: v,
        renderExpandIcon: b,
        index: S,
        store: E,
        components: P,
        style: T,
        virtualized: N,
        indentSize: O,
        cellWidths: z,
        displayNone: Q
      } = s, {
        tableWidth: W,
        anyColumnFixed: ue,
        getCellWidths: te
      } = o.value, K = v(l, S, g);
      let ve = null;
      const ee = {};
      let Re = {};
      if (lodashExports.isNull(K))
        return null;
      if (isVNode(K))
        ve = K;
      else if (K && Object.prototype.toString.call(K) === "[object Object]") {
        const {
          children: Kt,
          fixed: tn,
          ...ln
        } = K;
        ve = Kt, Re = {
          ...ln
        };
      }
      lodashExports.get(P, "body.cell") !== strings$2.DEFAULT_COMPONENTS.body.cell ? (N && lodashExports.set(ee, "style.height", "100%"), lodashExports.set(ee, "style.display", "block"), lodashExports.set(ee, "style.width", arrayAdd(z, 0, u.length))) : ee.colSpan = filterColumns(u).length;
      const wt = [{
        render: () => ({
          props: ee,
          children: createVNode("div", {
            class: cls(`${c}-expand-inner`),
            style: {
              width: ue ? styleNum(amendTableWidth(W)) : void 0
            }
          }, [ve])
        }),
        ...Re
      }], yt = cls(m, `${c}-row-expand`), xt = te(wt);
      return createVNode(TableRow, {
        style: T,
        components: P,
        className: yt,
        expandedRow: !0,
        renderExpandIcon: b,
        rowKey: `${l.key}-expanded-row`,
        columns: wt,
        store: E,
        virtualized: N,
        indentSize: O,
        cellWidths: xt,
        displayNone: Q
      }, null);
    };
  }
}), propTypes$p = {
  record: object$1,
  index: number$2,
  columns: array$1,
  group: object$1,
  groupKey: {
    type: oneOfType([string$3, number$2]),
    required: !0
  },
  data: array$1,
  renderGroupSection: func,
  // render group title
  onGroupedRow: func,
  clickGroupedRowToExpand: bool,
  components: object$1,
  expanded: bool,
  prefixCls: string$3,
  onExpand: func,
  virtualized: oneOfType([bool, object$1]),
  style: object$1,
  renderExpandIcon: func,
  // passing to baseRow
  className: string$3,
  store: object$1,
  rowKey: oneOfType([string$3, number$2, func])
}, defaultProps$k = {
  prefixCls: cssClasses$a.PREFIX,
  components: {
    body: {
      row: "tr",
      cell: "td"
    }
  }
}, vuePropsType$H = vuePropsMake(propTypes$p, defaultProps$k), SectionRow = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$H
  },
  name: "SectionRow",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = useTableContext(), l = (...c) => {
      const {
        onGroupedRow: m,
        clickGroupedRowToExpand: g,
        onExpand: v,
        groupKey: b,
        expanded: S
      } = s, E = {};
      return typeof m == "function" && Object.assign(E, m(...c)), {
        ...E,
        onClick: (P) => {
          typeof v == "function" && g && v(!S, b, P), typeof E.onClick == "function" && E.onClick(P);
        }
      };
    }, u = (c) => {
      const {
        renderExpandIcon: m,
        groupKey: g
      } = s;
      return typeof m == "function" ? m(c, !1, g) : null;
    };
    return () => {
      const {
        record: c,
        columns: m = [],
        prefixCls: g,
        className: v,
        expanded: b,
        renderGroupSection: S,
        components: E,
        index: P,
        store: T,
        group: N,
        groupKey: O,
        virtualized: z,
        style: Q
      } = s, W = {};
      let ue = {}, te = null;
      const K = typeof S == "function" ? S(O, [...N]) : null;
      if (isVNode(K))
        te = K;
      else if (K && Object.prototype.toString.call(K) === "[object Object]") {
        const {
          children: yt,
          ...xt
        } = K;
        te = yt, ue = {
          ...xt
        };
      }
      W.colSpan = filterColumns(m).length;
      const ve = [{
        render: () => ({
          props: W,
          children: te
        }),
        ...ue
      }], ee = cls(v, `${g}-row-section`, {
        on: b
      }), {
        getCellWidths: Re
      } = o.value, wt = Re(ve, null, !0);
      return createVNode(TableRow, {
        components: E,
        virtualized: z,
        index: P,
        onRow: l,
        expanded: b,
        expandIcon: !0,
        isSection: !0,
        record: c,
        replaceClassName: ee,
        expandableRow: !0,
        renderExpandIcon: u,
        rowKey: O,
        columns: ve,
        store: T,
        style: Q,
        cellWidths: wt
      }, null);
    };
  }
}), propTypes$o = {
  anyColumnFixed: bool,
  childrenRecordName: string$3,
  columns: array$1,
  components: object$1,
  dataSource: array$1,
  disabledRowKeysSet: {
    type: object$1,
    required: !0
  },
  emptySlot: node$1,
  expandRowByClick: bool,
  expandedRowKeys: array$1,
  expandedRowRender: func,
  fixed: oneOfType([string$3, bool]),
  forwardedRef: oneOfType([object$1, func]),
  groups: object$1,
  handleBodyScroll: func,
  handleWheel: func,
  headerRef: oneOfType([object$1, func]),
  includeHeader: bool,
  onScroll: func,
  prefixCls: string$3,
  renderExpandIcon: {
    type: func,
    required: !0
  },
  rowExpandable: func,
  rowKey: oneOfType([string$3, bool, func]),
  scroll: object$1,
  selectedRowKeysSet: {
    type: object$1,
    required: !0
  },
  showHeader: bool,
  size: string$3,
  store: {
    type: object$1,
    required: !0
  },
  virtualized: oneOfType([bool, object$1]),
  tableWidth: number$2,
  tableLayout: any$1,
  expandIcon: any$1,
  expandCellFixed: any$1,
  title: any$1,
  indentSize: any$1,
  defaultExpandAllRows: any$1,
  expandAllRows: any$1,
  defaultExpandAllGroupRows: any$1,
  expandAllGroupRows: any$1,
  defaultExpandedRowKeys: any$1,
  footer: any$1,
  empty: any$1,
  groupBy: any$1,
  renderGroupSection: any$1,
  clickGroupedRowToExpand: any$1,
  dropdownPrefixCls: any$1,
  cachedColumns: any$1,
  cachedChildren: any$1,
  flattenColumns: any$1,
  queries: any$1,
  flattenData: any$1,
  pagination: any$1,
  allRowKeys: any$1,
  disabledRowKeys: any$1,
  bodyHasScrollBar: any$1,
  prePropRowSelection: any$1,
  prePagination: any$1,
  hideExpandedColumn: any$1,
  filteredColumns: any$1,
  useFixedHeader: any$1,
  bodyRef: any$1,
  onExpandedRowsChange: func,
  onExpand: func,
  onChange: func,
  onRow: func,
  bodyWrapperRef: [func, object$1],
  onGroupedRow: func,
  keepDOM: bool,
  style: object$1,
  className: string$3
}, vuePropsType$G = vuePropsMake(propTypes$o, {}), Body = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$G
  },
  name: "Body",
  setup(s, {}) {
    useSlots();
    const o = ref$1(), l = ref$1();
    let u, c, m;
    const {
      context: g
    } = useTableContext(), v = reactive({
      virtualizedData: [],
      cache: {
        virtualizedScrollTop: null,
        virtualizedScrollLeft: null
      },
      cachedExpandBtnShouldInRow: null,
      cachedExpandRelatedProps: []
    });
    let b;
    b = watch(() => g.value.getVirtualizedListRef, (Gt) => {
      var nn, vt;
      m = g.value.flattenedColumns, c = (vt = (nn = g.value).getCellWidths) == null ? void 0 : vt.call(nn, m), b == null || b();
    }, {
      immediate: !0
    }), u = null;
    const {
      adapter: S
    } = useBaseComponent(s, {});
    function E() {
      return {
        ...S(),
        setVirtualizedData: (Gt, nn) => {
          v.virtualizedData = Gt, nextTick(nn);
        },
        setCachedExpandBtnShouldInRow: (Gt) => v.cachedExpandBtnShouldInRow = Gt,
        setCachedExpandRelatedProps: (Gt) => v.cachedExpandRelatedProps = Gt,
        observeBodyResize: (Gt) => {
          const {
            setBodyHasScrollbar: nn
          } = g.value, vt = () => {
            const Et = () => {
              const {
                offsetWidth: un,
                clientWidth: gn
              } = Gt, dn = gn < un;
              nn(dn);
            };
            (window.requestAnimationFrame || window.setTimeout)(Et);
          };
          Gt && (lodashExports.get(window, "ResizeObserver") ? (u && (u.unobserve(Gt), u = null), u = new ResizeObserver(vt), u.observe(Gt)) : logger.warn("The current browser does not support ResizeObserver,and the table may be misaligned after plugging and unplugging the mouse and keyboard.You can try to refresh it."));
        },
        unobserveBodyResize: () => {
          const Gt = o.value;
          u && (u.unobserve(Gt), u = null);
        }
      };
    }
    const P = E(), T = new TableBodyFoundation(P);
    watch([() => s.virtualized, () => s.dataSource, () => s.expandedRowKeys, () => s.columns, () => s.scroll, () => v.cachedExpandRelatedProps], (Gt, [nn, vt, Et, Qt, un, gn]) => {
      const {
        virtualized: dn,
        dataSource: yn,
        expandedRowKeys: vn,
        columns: Pn,
        scroll: On
      } = s;
      dn && (vt !== yn || Et !== vn || Qt !== Pn) && T.initVirtualizedData();
      const Nn = strings$2.EXPAND_RELATED_PROPS.map((zn) => lodashExports.get(s, zn, void 0));
      gn && !lodashExports.isEqual(Nn, gn) && T.initExpandBtnShouldInRow(Nn);
      const Un = lodashExports.get(On, "y"), Xn = o.value;
      Un && Un !== (un == null ? void 0 : un.y) && T.observeBodyResize(Xn);
    }, {
      immediate: !0
    });
    const N = (Gt) => {
      const {
        forwardedRef: nn
      } = s;
      o.value = Gt, T.observeBodyResize(Gt), typeof nn == "function" ? nn(Gt) : nn && typeof nn == "object" && (nn.value = Gt);
    }, O = (Gt) => {
      l.value = Gt;
      const {
        getVirtualizedListRef: nn
      } = g.value;
      nn && (s.virtualized ? nn(l.value) : console.warn("getVirtualizedListRef only works with virtualized. See https://semi.design/en-US/show/table for more information."));
    }, z = (Gt) => {
      const {
        virtualized: nn,
        size: vt
      } = s, {
        virtualizedData: Et
      } = v, Qt = lodashExports.get(Et, Gt), un = getDefaultVirtualizedRowConfig(vt, Qt.sectionRow), gn = lodashExports.get(nn, "itemSize", un.height);
      let dn = gn;
      return typeof gn == "function" && (dn = gn(Gt, {
        expandedRow: lodashExports.get(Qt, "expandedRow", !1),
        sectionRow: lodashExports.get(Qt, "sectionRow", !1)
      })), dn < un.minHeight && logger.warn(`The computed real \`itemSize\` cannot be less than ${un.minHeight}`), dn;
    }, Q = (Gt, nn) => lodashExports.get(nn, [Gt, "key"], Gt), W = (Gt, nn, vt) => {
      const {
        handleRowExpanded: Et
      } = g.value;
      Et(!vt, Gt, nn);
    }, ue = (Gt = {}) => {
      const nn = lodashExports.get(s.virtualized, "onScroll");
      typeof nn == "function" && nn(Gt);
    }, te = (Gt) => {
      const {
        handleBodyScroll: nn
      } = s, vt = lodashExports.get(Gt, "nativeEvent.target.scrollLeft"), Et = lodashExports.get(Gt, "nativeEvent.target.scrollTop");
      Et === v.cache.virtualizedScrollTop && ue({
        horizontalScrolling: !0
      }), v.cache.virtualizedScrollLeft = vt, v.cache.virtualizedScrollTop = Et, typeof nn == "function" && nn(Gt);
    }, K = () => {
      const {
        getCellWidths: Gt
      } = g.value, {
        columns: nn
      } = s, vt = Gt(nn);
      return arrayAdd(vt, 0, lodashExports.size(nn));
    }, ve = (Gt) => {
      const {
        index: nn,
        style: vt
      } = Gt, {
        virtualizedData: Et,
        cachedExpandBtnShouldInRow: Qt
      } = v, {
        flattenedColumns: un
      } = g.value, gn = lodashExports.get(Et, [nn], {}), {
        key: dn,
        parentKeys: yn,
        expandedRow: vn,
        sectionRow: Pn,
        ...On
      } = gn, _n = K(), Nn = Qt, Un = {
        ...s,
        style: {
          ...vt,
          width: _n + "px"
        },
        ...On,
        columns: un,
        index: nn,
        expandBtnShouldInRow: Nn
      };
      return Pn ? xt(Un) : vn ? Kt(Un) : tn(Un);
    }, ee = (Gt, {
      slots: nn
    }) => {
      var vt;
      return createVNode("div", mergeProps$1(Gt, {
        onScroll: (...Et) => {
          Gt.onScroll && Gt.onScroll(...Et);
        },
        class: cls(Gt.className, `${s.prefixCls}-tbody`),
        style: {
          ...Gt.style
        },
        ref: ref$1
      }), [(vt = nn == null ? void 0 : nn.default) == null ? void 0 : vt.call(nn)]);
    }, Re = (Gt, {
      slots: nn
    }) => {
      var vn;
      const {
        ...vt
      } = Gt, {
        handleWheel: Et,
        prefixCls: Qt,
        emptySlot: un,
        dataSource: gn
      } = s, dn = K(), yn = cls(`${Qt}`, `${Qt}-fixed`);
      return createVNode("div", mergeProps$1(vt, {
        ref: ref$1,
        onWheel: (...Pn) => {
          Et && Et(...Pn), vt.onWheel && vt.onWheel(...Pn);
        },
        onScroll: (...Pn) => {
          te(...Pn), vt.onScroll && vt.onScroll(...Pn);
        }
      }), [createVNode("div", {
        style: {
          width: dn + "px"
        },
        class: yn
      }, [(vn = nn.default) == null ? void 0 : vn.call(nn)]), lodashExports.size(gn) === 0 && un]);
    }, wt = (Gt) => {
      v.cache.virtualizedScrollLeft && o.value && (o.value.scrollLeft = v.cache.virtualizedScrollLeft);
    }, yt = (Gt) => {
      const {
        scroll: nn,
        prefixCls: vt,
        virtualized: Et,
        columns: Qt
      } = s, {
        virtualizedData: un
      } = v, {
        getCellWidths: gn
      } = g.value, dn = gn(Qt);
      if (!lodashExports.size(dn))
        return null;
      const yn = lodashExports.get(nn, "y"), vn = typeof yn == "number", Pn = vn ? yn : 600;
      vn || logger.warn('You have to specific "scroll.y" which must be a number for table virtualization!');
      const On = {
        width: "100%",
        height: un != null && un.length ? Pn + "px" : null,
        overflowX: "auto",
        overflowY: "auto"
      }, _n = cls(`${vt}-body`);
      return createVNode(Pt, mergeProps$1(typeof Et == "object" ? Et : {}, {
        initialScrollOffset: v.cache.virtualizedScrollTop,
        onScroll: ue,
        onItemsRendered: wt,
        ref: O,
        className: _n,
        outerRef: N,
        height: un != null && un.length ? Pn : 0,
        width: On.width,
        itemData: un,
        itemSize: z,
        itemCount: un.length,
        itemKey: Q,
        innerElementType: ee,
        outerElementType: Re,
        style: {
          ...On,
          direction: Gt
        },
        direction: Gt
      }), {
        default: ve
      });
    }, xt = (Gt = {
      groupKey: void 0
    }) => {
      const {
        dataSource: nn,
        rowKey: vt,
        group: Et,
        groupKey: Qt,
        index: un
      } = Gt, gn = Object.keys(propTypes$p), dn = lodashExports.pick(Gt, gn), {
        handleRowExpanded: yn
      } = g.value;
      return createVNode(SectionRow, mergeProps$1({
        ...dn,
        onExpand: yn,
        record: {
          groupKey: Qt,
          records: [...Et].map((vn) => getRecord(nn, vn, vt))
        },
        index: un,
        data: nn
      }, {
        key: Qt || un
      }), null);
    }, Kt = (Gt = {
      renderExpandIcon: () => null
    }) => {
      const {
        style: nn,
        components: vt,
        renderExpandIcon: Et,
        expandedRowRender: Qt,
        record: un,
        columns: gn,
        expanded: dn,
        index: yn,
        rowKey: vn,
        virtualized: Pn,
        displayNone: On
      } = Gt;
      let _n = getRecordKey(un, vn);
      _n == null && (_n = yn);
      const {
        getCellWidths: Nn
      } = g.value;
      return m !== g.value.flattenedColumns && (m = g.value.flattenedColumns, c = Nn(m)), createVNode(TableExpandedRow, {
        style: nn,
        components: vt,
        renderExpandIcon: Et,
        expandedRowRender: Qt,
        record: un,
        columns: gn,
        expanded: dn,
        index: yn,
        virtualized: Pn,
        key: genExpandedRowKey(_n),
        cellWidths: c,
        displayNone: On
      }, null);
    };
    function tn(Gt = {}) {
      const {
        rowKey: nn,
        columns: vt,
        expandedRowKeys: Et,
        rowExpandable: Qt,
        record: un,
        index: gn,
        level: dn,
        expandBtnShouldInRow: yn,
        // effect the display of the indent span
        selectedRowKeysSet: vn,
        disabledRowKeysSet: Pn,
        expandRowByClick: On
      } = Gt, _n = Object.keys(propTypes$r), Nn = lodashExports.pick(Gt, _n);
      let Un = getRecordKey(un, nn);
      Un == null && (Un = gn);
      const Xn = isExpanded(Et, Un), zn = Qt && Qt(un), jn = {
        level: void 0,
        expanded: Xn
      };
      (zn || yn) && (jn.level = dn, jn.expandableRow = zn, On && (jn.onRowClick = W));
      const kn = {
        selected: isSelected(vn, Un),
        disabled: isDisabled(Pn, Un)
      }, {
        getCellWidths: Yn
      } = g.value, Zn = Yn(vt, null, !0);
      return (
        // 这里必须加Fragment，不然BaseRow会传入一个默认的props，来历不明？
        createVNode(Fragment, null, [createVNode(TableRow, {
          ...Nn,
          ...jn,
          ...kn,
          key: Un,
          rowKey: Un,
          cellWidths: Zn
        }, null)])
      );
    }
    const ln = () => {
      const {
        groups: Gt,
        dataSource: nn,
        rowKey: vt,
        expandedRowKeys: Et,
        keepDOM: Qt
      } = s, {
        flattenedColumns: un
      } = g.value, gn = /* @__PURE__ */ new Map(), dn = [];
      Gt != null && Array.isArray(nn) && nn.length && nn.forEach((vn) => {
        const Pn = getRecordKey(vn, vt);
        Gt.forEach((On, _n) => {
          if (On.has(Pn))
            return gn.has(_n) || gn.set(_n, /* @__PURE__ */ new Set([])), gn.get(_n).add(Pn), !1;
        });
      });
      let yn = -1;
      return gn.forEach((vn, Pn) => {
        const On = isExpanded(Et, Pn);
        if (dn.push(xt({
          ...s,
          columns: un,
          index: ++yn,
          group: vn,
          groupKey: Pn,
          expanded: On
        })), On || Qt) {
          const _n = [];
          vn.forEach((Nn) => {
            const Un = getRecord(nn, Nn, vt);
            Un != null && _n.push(Un);
          }), dn.push(rn(_n, void 0, [], !On));
        }
      }), dn;
    };
    function rn(Gt = [], nn = 0, vt = [], Et = !1) {
      const {
        rowKey: Qt,
        expandedRowRender: un,
        expandedRowKeys: gn,
        childrenRecordName: dn,
        rowExpandable: yn,
        keepDOM: vn
      } = s, Pn = typeof un == "function", On = v.cachedExpandBtnShouldInRow, {
        flattenedColumns: _n
      } = g.value;
      return lodashExports.each(Gt, (Nn, Un) => {
        let Xn = getRecordKey(Nn, Qt);
        Xn == null && (Xn = Un);
        const zn = lodashExports.get(Nn, dn), jn = !!(Array.isArray(zn) && zn.length);
        vt.push(tn({
          ...s,
          columns: _n,
          expandBtnShouldInRow: On,
          displayNone: Et,
          record: Nn,
          key: Xn,
          level: nn,
          index: Un
        }));
        const kn = isExpanded(gn, Xn), Yn = kn || vn;
        if (Pn && yn && yn(Nn) && Yn) {
          const Zn = Kt({
            ...s,
            columns: _n,
            level: nn,
            index: Un,
            record: Nn,
            expanded: kn,
            displayNone: Et || !kn
          });
          lodashExports.isNull(Zn) || vt.push(Zn);
        }
        if (jn && Yn) {
          const Zn = rn(zn, nn + 1);
          vt.push(...Zn);
        }
      }), vt;
    }
    const an = (Gt) => {
      const {
        scroll: nn,
        prefixCls: vt,
        columns: Et,
        components: Qt,
        fixed: un,
        handleWheel: gn,
        headerRef: dn,
        handleBodyScroll: yn,
        anyColumnFixed: vn,
        showHeader: Pn,
        emptySlot: On,
        includeHeader: _n,
        dataSource: Nn,
        onScroll: Un,
        groups: Xn,
        expandedRowRender: zn,
        tableLayout: jn
      } = s, kn = lodashExports.get(nn, "x"), Yn = lodashExports.get(nn, "y"), Zn = {}, er = {}, bn = lodashExports.get(Qt, "body.outer", "table"), Ln = lodashExports.get(Qt, "body.wrapper") || "tbody";
      Yn && (Zn.maxHeight = typeof Yn == "string" ? Yn : Yn + "px"), kn && (er.width = typeof kn == "string" ? kn : kn + "px"), vn && lodashExports.size(Nn) && (Zn.overflow = "auto", Zn.WebkitTransform = "translate3d (0, 0, 0)");
      const Kn = createVNode(ColGroup, {
        components: lodashExports.get(Qt, "body"),
        columns: Et,
        prefixCls: vt
      }, null), Bn = `${vt}-body`, Fn = createVNode("div", {
        key: "bodyTable",
        class: Bn,
        style: Zn,
        ref: N,
        onWheel: gn,
        onScroll: yn
      }, [createVNode(bn, {
        role: lodashExports.isMap(Xn) || lodashExports.isFunction(zn) || isTreeTable({
          dataSource: Nn
        }) ? "treegrid" : "grid",
        "aria-rowcount": Nn && Nn.length,
        "aria-colcount": Et && Et.length,
        style: er,
        className: cls(vt, {
          [`${vt}-fixed`]: jn === "fixed"
        })
      }, {
        default: () => [Kn, _n && Pn ? createVNode(TableHeader, mergeProps$1(s, {
          ref: dn,
          components: Qt,
          columns: Et
        }), null) : null, createVNode(Ln, {
          ref: s.bodyWrapperRef,
          className: `${vt}-tbody`,
          onScroll: Un
        }, {
          default: () => [lodashExports.isMap(Xn) ? ln() : rn(Nn)]
        })]
      }), On]);
      return un && Et.length ? createVNode("div", {
        key: "bodyTable",
        class: `${vt}-body-outer`
      }, [Fn]) : Fn;
    };
    return () => {
      const {
        virtualized: Gt
      } = s, {
        direction: nn
      } = g.value;
      return Gt ? yt(nn) : an();
    };
  }
});
function _isSlot$6(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
function parseHeaderRows(s) {
  const o = [];
  function l(c, m, g = [], v = 0, b = 0) {
    o[v] = o[v] || [];
    let S = m;
    return c.map((P) => {
      const T = {
        key: P.key,
        className: P.className || "",
        children: lodashExports.isFunction(P.title) ? P.title() : P.title,
        column: P,
        colStart: S,
        level: b,
        parents: g
      };
      let N = 1;
      const O = P.children;
      O && O.length > 0 && (N = l(O, S, [...g, T], v + 1, b + 1).reduce((W, ue) => W + ue, 0), T.hasSubColumns = !0), "colSpan" in P && ({
        colSpan: N
      } = P), "rowSpan" in P && (T.rowSpan = P.rowSpan), P.key === strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR && (T["x-type"] = strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR), T.colSpan = N, T.colEnd = T.colStart + N - 1, o[v].push(T), S += N;
      const z = P == null ? void 0 : P.ellipsis;
      return shouldShowEllipsisTitle(z) && typeof T.children == "string" && (T.title = T.children), N;
    });
  }
  l(s, 0);
  const u = o.length;
  for (let c = 0; c < u; c += 1)
    o[c].forEach((m) => {
      !("rowSpan" in m) && !m.hasSubColumns && (m.rowSpan = u - c);
    });
  return o;
}
const propTypes$n = {
  ...propTypes$o,
  components: any$1,
  columns: array$1,
  columnManager: object$1,
  prefixCls: string$3,
  onHeaderRow: func,
  onDidUpdate: func,
  fixed: oneOfType([bool, string$3]),
  selectedRowKeysSet: {
    type: object$1,
    required: !0
  },
  forwardedRef: [func, object$1],
  style: object$1,
  className: string$3
}, defaultProps$j = {
  columns: [],
  prefixCls: cssClasses$a.PREFIX,
  onHeaderRow: lodashExports.noop,
  onDidUpdate: lodashExports.noop,
  components: {
    header: {
      wrapper: "thead",
      row: "tr",
      cell: "th"
    }
  }
}, vuePropsType$F = vuePropsMake(propTypes$n, defaultProps$j), TableHeader = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$F
  },
  name: "TableHeader",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    const l = reactive({}), {
      adapter: u
    } = useBaseComponent(s, l);
    return u(), () => {
      let c;
      const {
        components: m,
        columns: g,
        prefixCls: v,
        fixed: b,
        onHeaderRow: S,
        forwardedRef: E,
        selectedRowKeysSet: P
      } = o(s), T = parseHeaderRows(g), N = m.header.wrapper;
      return createVNode(N, {
        className: `${v}-thead`,
        ref: E
      }, _isSlot$6(c = T.map((O, z) => createVNode(TableHeaderRow, {
        prefixCls: v,
        key: z,
        index: z,
        fixed: b,
        columns: g,
        row: O,
        components: m,
        onHeaderRow: S,
        selectedRowKeysSet: P
      }, null))) ? c : {
        default: () => [c]
      });
    };
  }
}), propTypes$m = {
  tableLayout: string$3,
  bodyHasScrollBar: bool,
  columns: array$1,
  components: object$1,
  dataSource: array$1,
  fixed: oneOfType([bool, string$3]),
  handleBodyScroll: func,
  prefixCls: string$3,
  forwardedRef: oneOfType([object$1, func]),
  scroll: object$1,
  selectedRowKeysSet: {
    type: object$1,
    required: !0
  },
  // Useful when update is selected
  showHeader: bool,
  onDidUpdate: func,
  onHeaderRow: func,
  anyColumnFixed: bool,
  sticky: [bool, object$1]
}, defaultProps$i = {
  handleBodyScroll: lodashExports.noop
}, vuePropsType$E = vuePropsMake(propTypes$m, defaultProps$i), HeadTable = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$E
  },
  name: "HeadTable",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    return useSlots(), () => {
      const {
        scroll: l,
        prefixCls: u,
        fixed: c,
        forwardedRef: m,
        handleBodyScroll: g,
        columns: v,
        components: b,
        onDidUpdate: S,
        showHeader: E,
        tableLayout: P,
        anyColumnFixed: T,
        bodyHasScrollBar: N,
        sticky: O
      } = o(s), z = lodashExports.get(b, "header.outer", "table"), Q = lodashExports.get(l, "x"), W = {}, ue = {};
      Q && !c && (ue.width = Q + "px"), N && (W.overflowY = "scroll");
      const te = createVNode(ColGroup, {
        columns: v,
        prefixCls: u
      }, null), K = createVNode(TableHeader, mergeProps$1(o(s), {
        columns: v,
        components: b,
        onDidUpdate: S
      }), null), ve = cls(`${u}-header`, {
        [`${u}-header-sticky`]: O,
        [`${u}-header-hidden`]: !E
      }), ee = lodashExports.get(O, "top", 0);
      return typeof ee == "number" && (W.top = ee), createVNode("div", {
        key: "headTable",
        style: W,
        class: ve,
        ref: m,
        onScroll: g
      }, [createVNode(z, {
        style: ue,
        className: cls(u, {
          [`${u}-fixed`]: P === "fixed"
        })
      }, {
        default: () => [te, K]
      })]);
    };
  }
}), propTypes$l = {
  children: any$1,
  className: string$3,
  style: object$1,
  prefixCls: string$3,
  components: any$1,
  bordered: bool,
  loading: bool,
  size: string$3,
  // @ts-ignore
  tableLayout: string$3,
  columns: array$1,
  hideExpandedColumn: bool,
  id: string$3,
  expandIcon: oneOfType([bool, func, node$1]),
  expandCellFixed: bool,
  title: oneOfType([string$3, node$1, func]),
  onHeaderRow: func,
  showHeader: bool,
  indentSize: number$2,
  rowKey: oneOfType([func, string$3, number$2]),
  onRow: func,
  onExpandedRowsChange: func,
  onExpand: func,
  rowExpandable: func,
  expandedRowRender: func,
  expandedRowKeys: array$1,
  defaultExpandAllRows: bool,
  expandAllRows: bool,
  defaultExpandAllGroupRows: bool,
  expandAllGroupRows: bool,
  defaultExpandedRowKeys: array$1,
  pagination: oneOfType([object$1, bool]),
  renderPagination: func,
  footer: oneOfType([func, string$3, node$1]),
  empty: node$1,
  dataSource: array$1,
  childrenRecordName: string$3,
  // children data property name
  rowSelection: oneOfType([object$1, bool]),
  onChange: func,
  scroll: object$1,
  groupBy: oneOfType([string$3, number$2, func]),
  renderGroupSection: oneOfType([func]),
  onGroupedRow: func,
  clickGroupedRowToExpand: bool,
  virtualized: oneOfType([object$1, bool]),
  dropdownPrefixCls: string$3,
  // TODO: future api
  expandRowByClick: bool,
  // TODO: future api
  getVirtualizedListRef: func,
  // TODO: future api
  bodyWrapperRef: [func, object$1],
  direction: string$3
}, defaultProps$h = {
  // rowExpandable: stubTrue,
  tableLayout: "",
  dataSource: [],
  prefixCls: cssClasses$a.PREFIX,
  rowSelection: null,
  className: "",
  childrenRecordName: "children",
  size: "default",
  loading: !1,
  bordered: !1,
  expandCellFixed: !1,
  hideExpandedColumn: !0,
  showHeader: !0,
  indentSize: numbers$2.DEFAULT_INDENT_WIDTH,
  onChange: lodashExports.noop,
  pagination: !0,
  rowKey: "key",
  defaultExpandedRowKeys: [],
  defaultExpandAllRows: !1,
  defaultExpandAllGroupRows: !1,
  expandAllRows: !1,
  expandAllGroupRows: !1,
  onFilterDropdownVisibleChange: lodashExports.noop,
  onExpand: lodashExports.noop,
  onExpandedRowsChange: lodashExports.noop,
  expandRowByClick: !1
};
function Table$3() {
  const s = vuePropsMake(propTypes$l, defaultProps$h);
  return /* @__PURE__ */ defineComponent({
    props: {
      ...s
    },
    name: "Table",
    setup(l, {
      expose: u
    }) {
      const {
        getProps: c
      } = useHasInProps();
      useSlots();
      let m, g, v, b, {
        context: S
      } = useTableContext(), E = [], P = [], T = /* @__PURE__ */ new Set();
      const N = un(l.columns, l.children), O = flattenColumns(N), z = TableFoundation.initColumnsFilteredValueAndSorterOrder(cloneDeep$1(O)), Q = ref$1(), W = ref$1(), ue = ref$1(), te = ref$1(), K = reactive({
        /**
         * Cached props
         */
        cachedColumns: N,
        // update cachedColumns after columns or children change
        cachedChildren: l.children,
        flattenColumns: O,
        components: mergeComponents(l.components, l.virtualized),
        // cached components
        /**
         * State calculated based on prop
         */
        queries: z,
        // flatten columns, update when sorting or filtering
        dataSource: [],
        // data after paging
        flattenData: [],
        expandedRowKeys: [...l.expandedRowKeys || [], ...l.defaultExpandedRowKeys || []],
        // cached expandedRowKeys
        rowSelection: l.rowSelection ? lodashExports.isObject(l.rowSelection) ? {
          ...l.rowSelection
        } : {} : null,
        pagination: l.pagination && typeof l.pagination == "object" ? {
          ...l.pagination
        } : l.pagination || !1,
        /**
         * Internal state
         */
        groups: null,
        allRowKeys: [],
        // row keys after paging
        disabledRowKeys: [],
        // disabled row keys after paging
        disabledRowKeysSet: /* @__PURE__ */ new Set(),
        allDisabledRowKeys: [],
        allDisabledRowKeysSet: /* @__PURE__ */ new Set(),
        headWidths: [],
        // header cell width
        bodyHasScrollBar: !1,
        prePropRowSelection: void 0,
        prePagination: void 0
      }), {
        adapter: ve,
        getDataAttr: ee
      } = useBaseComponent(l, K);
      function Re() {
        return {
          ...ve(),
          resetScrollY: () => {
            ue.value && (ue.value.scrollTop = 0);
          },
          setSelectedRowKeys: (An) => {
            K.rowSelection = {
              ...K.rowSelection,
              selectedRowKeys: [...An],
              selectedRowKeysSet: new Set(An)
            };
          },
          setDisabledRowKeys: (An) => {
            K.disabledRowKeys = An, K.disabledRowKeysSet = new Set(An);
          },
          setCurrentPage: (An) => {
            const {
              pagination: Hn
            } = K;
            typeof Hn == "object" ? K.pagination = {
              ...Hn,
              currentPage: An
            } : K.pagination = {
              currentPage: An
            };
          },
          setPagination: (An) => {
            K.pagination = An;
          },
          setGroups: (An) => {
            K.groups = An;
          },
          setDataSource: (An) => {
            K.dataSource = An;
          },
          setExpandedRowKeys: (An) => {
            K.expandedRowKeys = [...An];
          },
          setQuery: (An = {}) => {
            let Hn = [...K.queries];
            Hn = mergeQueries(An, Hn), K.queries = Hn;
          },
          // Update queries when filtering or sorting
          setQueries: (An) => K.queries = An,
          setFlattenData: (An) => K.flattenData = An,
          setAllRowKeys: (An) => K.allRowKeys = An,
          setHoveredRowKey: (An) => {
            ln.setState({
              hoveredRowKey: An
            });
          },
          setCachedFilteredSortedDataSource: (An) => {
            E = An;
          },
          setCachedFilteredSortedRowKeys: (An) => {
            P = An, T = new Set(An);
          },
          setAllDisabledRowKeys: (An) => {
            const Hn = new Set(An);
            K.allDisabledRowKeys = An, K.allDisabledRowKeysSet = Hn;
          },
          getCurrentPage: () => lodashExports.get(K, "pagination.currentPage", 1),
          getCurrentPageSize: () => lodashExports.get(K, "pagination.pageSize", numbers$2.DEFAULT_PAGE_SIZE),
          getCachedFilteredSortedDataSource: () => E,
          getCachedFilteredSortedRowKeys: () => P,
          getCachedFilteredSortedRowKeysSet: () => T,
          getAllDisabledRowKeys: () => K.allDisabledRowKeys,
          getAllDisabledRowKeysSet: () => K.allDisabledRowKeysSet,
          notifyFilterDropdownVisibleChange: (An, Hn) => vt(Hn, "onFilterDropdownVisibleChange", An),
          notifyChange: (...An) => l.onChange(...An),
          notifyExpand: (...An) => l.onExpand(...An),
          notifyExpandedRowsChange: (...An) => l.onExpandedRowsChange(...An),
          notifySelect: (...An) => nn("onSelect", ...An),
          notifySelectAll: (...An) => nn("onSelectAll", ...An),
          notifySelectInvert: (...An) => nn("onSelectInvert", ...An),
          notifySelectionChange: (...An) => nn("onChange", ...An),
          isAnyColumnFixed: (An) => lodashExports.some(un(An || l.columns, l.children), (Hn) => !!Hn.fixed),
          useFixedHeader: () => {
            const {
              scroll: An,
              sticky: Hn
            } = l;
            return !!(lodashExports.get(An, "y") || Hn);
          },
          getTableLayout: () => {
            let An = !1;
            const {
              flattenColumns: Hn
            } = K;
            return Array.isArray(Hn) && (An = Hn.some((ir) => !!ir.ellipsis || !!ir.fixed)), wt.useFixedHeader() && (An = !0), An ? "fixed" : "auto";
          },
          setHeadWidths: (An, Hn = 0) => {
            if (!equalWith(K.headWidths[Hn], An)) {
              const ir = [...K.headWidths];
              ir[Hn] = [...An], K.headWidths = ir;
            }
          },
          getHeadWidths: (An = 0) => K.headWidths.length && typeof An == "number" ? (K.headWidths[An] || []).map((ir) => ir.width) : [],
          // This method is called by row rendering function
          getCellWidths: (An, Hn = null, ir = !1) => Array.isArray(An) && An.length && (Hn = Hn == null && K.headWidths.length ? lodashExports.flattenDeep(K.headWidths) : [], Array.isArray(Hn) && Hn.length) ? An.reduce((dr, ar) => {
            const Or = ar.key === strings$2.DEFAULT_KEY_COLUMN_SCROLLBAR && ir ? null : lodashExports.find(Hn, (Sr) => Sr && Sr.key != null && Sr.key === ar.key);
            return Or && dr.push(Or.width), dr;
          }, []) : [],
          mergedRowExpandable: (An) => {
            const {
              expandedRowRender: Hn,
              childrenRecordName: ir,
              rowExpandable: dr
            } = l, ar = lodashExports.get(An, ir), Or = typeof Hn == "function", Sr = typeof dr == "function", kr = Array.isArray(ar) && ar.length, Nr = Sr && dr(An);
            return (Or || kr) && (!Sr || Nr) || !(Or || kr) && Nr;
          },
          isAnyColumnUseFullRender: (An) => lodashExports.some(An, (Hn) => {
            Hn.useFullRender;
          }),
          //TODO 类型没对上
          getNormalizeColumns: () => Cr,
          getHandleColumns: () => tr,
          getMergePagination: () => Fr,
          setBodyHasScrollbar: (An) => {
            An !== K.bodyHasScrollBar && (K.bodyHasScrollBar = An);
          },
          stopPropagation(An) {
            An && typeof An == "object" && (typeof An.stopPropagation == "function" && An.stopPropagation(), An.nativeEvent && typeof An.nativeEvent.stopPropagation == "function" ? An.nativeEvent.stopPropagation() : typeof An.stopImmediatePropagation == "function" && An.stopImmediatePropagation());
          }
        };
      }
      const wt = Re(), yt = new TableFoundation(wt), xt = yt.getFilteredSortedDataSource(l.dataSource, z), Kt = lodashExports.isPlainObject(l.pagination) ? l.pagination : {}, tn = yt.getCurrentPageData(xt, Kt, z);
      K.dataSource = tn.dataSource, K.pagination = tn.pagination;
      const ln = new Store({
        hoveredRowKey: null
      });
      let rn = lodashExports.debounce(Nn, 150);
      function an(An) {
        const Hn = {}, {
          rowSelection: ir,
          dataSource: dr,
          childrenRecordName: ar,
          rowKey: Or,
          pagination: Sr
        } = An;
        if (An.columns && An.children && logger.warn("columns should not given by object and children at the same time"), An.columns && An.columns !== K.cachedColumns) {
          const kr = flattenColumns(An.columns);
          Hn.flattenColumns = kr, Hn.queries = mergeColumns(K.queries, kr, null, !1), Hn.cachedColumns = An.columns, Hn.cachedChildren = null;
        } else if (An.children && An.children !== K.cachedChildren) {
          const kr = getColumns(An.children), Nr = flattenColumns(kr), Ur = mergeColumns(K.queries, Nr, null, !1);
          Hn.flattenColumns = Nr, Hn.queries = [...Ur], Hn.cachedColumns = [...kr], Hn.cachedChildren = An.children;
        }
        if (ir !== K.prePropRowSelection) {
          let kr = {};
          lodashExports.isObject(K.rowSelection) && (kr = {
            ...kr,
            ...K.rowSelection
          }), lodashExports.isObject(ir) && (kr = {
            ...kr,
            ...ir
          });
          const Nr = lodashExports.get(ir, "selectedRowKeys"), Ur = lodashExports.get(ir, "getCheckboxProps");
          if (Nr && Array.isArray(Nr) && (kr.selectedRowKeysSet = new Set(Nr)), lodashExports.isFunction(Ur)) {
            const _r = getAllDisabledRowKeys({
              dataSource: dr,
              getCheckboxProps: Ur,
              childrenRecordName: ar,
              rowKey: Or
            }), Zr = new Set(_r);
            Hn.disabledRowKeys = _r, Hn.disabledRowKeysSet = Zr, Hn.allDisabledRowKeys = _r, Hn.allDisabledRowKeysSet = Zr;
          }
          Hn.rowSelection = kr, Hn.prePropRowSelection = ir;
        }
        if (Sr !== K.prePagination) {
          let kr = {};
          lodashExports.isObject(K.pagination) && (kr = {
            ...kr,
            ...K.pagination
          }), lodashExports.isObject(Sr) && (kr = {
            ...kr,
            ...Sr
          }), Hn.pagination = kr, Hn.prePagination = Sr;
        }
        return Hn;
      }
      watch(() => l, () => {
        const An = an({
          ...l
        });
        An && Object.keys(An).forEach((Hn) => {
          K[Hn] = An[Hn];
        });
      }, {
        deep: !0,
        immediate: !0
      }), onMounted(() => {
        zn("left"), (wt.isAnyColumnFixed() || l.showHeader && wt.useFixedHeader()) && (Nn(), window.addEventListener("resize", rn));
      }), watch([() => l.expandedRowKeys, () => l.components, () => l.virtualized, () => l.expandAllRows, () => l.expandAllGroupRows, () => l.dataSource, () => K.cachedColumns, () => K.cachedChildren], (An, [Hn, ir, dr, ar, Or, Sr, kr, Nr]) => {
        const {
          dataSource: Ur,
          expandedRowKeys: _r,
          expandAllRows: Zr,
          expandAllGroupRows: Jr,
          virtualized: ii,
          components: Ti,
          pagination: Mi
        } = l, {
          pagination: ui,
          queries: Ii,
          cachedColumns: bs,
          // @ts-ignore
          cachedChildren: Oi,
          groups: Vs
        } = K, _s = {};
        if (Gt(), Array.isArray(_r) && _r !== Hn && (K.expandedRowKeys = _r), (Ti !== ir || ii !== dr) && (K.components = mergeComponents(Ti, ii)), (Zr !== ar || Jr !== Or) && yt.initExpandedRowKeys({
          groups: Vs
        }), Ur !== Sr || bs !== kr || Oi !== Nr) {
          const Is = [...Ur], Fa = yt.getFilteredSortedDataSource(Is, Ii), io = yt.getAllDisabledRowKeys(Fa);
          yt.setCachedFilteredSortedDataSource(Fa), yt.setAllDisabledRowKeys(io), _s.dataSource = Fa, l.groupBy && (_s.groups = null);
        }
        if (Ur !== Sr && (_s.pagination = typeof ui != "boolean" ? {
          ...ui,
          currentPage: (
            //@ts-ignore
            lodashExports.isObject(Mi) && Mi.currentPage ? Mi.currentPage : 1
          )
        } : ui), Object.keys(_s).length) {
          const {
            // eslint-disable-next-line @typescript-eslint/no-shadow
            pagination: Is = null,
            queries: Fa = null,
            dataSource: io = null
          } = _s, Da = yt.getCurrentPageData(io, Is, Fa);
          wt.setAllRowKeys(Da.allRowKeys), wt.setDisabledRowKeys(Da.disabledRowKeys), "dataSource" in _s && ((l.defaultExpandAllRows && Da.groups && Da.groups.size || l.expandAllRows || l.expandAllGroupRows) && yt.initExpandedRowKeys(Da), _s.pagination = Da.pagination);
          const oo = Object.keys(_s);
          for (const Xs of oo)
            K[Xs] = Da[Xs];
        }
        (wt.isAnyColumnFixed() || l.showHeader && wt.useFixedHeader()) && (rn || window.addEventListener("resize", rn));
      }, {
        immediate: !0
      }), onBeforeUnmount(() => {
        rn && (window.removeEventListener("resize", rn), rn.cancel(), rn = null);
      });
      function Gt() {
        (l.rowSelection || l.expandedRowRender) && lodashExports.some(l.dataSource, (An) => yt.getRecordKey(An) == null) && logger.error('You must specify a key for each element in the dataSource or use "rowKey" to specify an attribute name as the primary key!');
      }
      const nn = (An, ...Hn) => {
        const ir = lodashExports.get(K, ["rowSelection", An]);
        typeof ir == "function" && ir(...Hn);
      }, vt = (An, Hn, ...ir) => {
        if (An && Hn) {
          const dr = yt.getQuery(An), ar = lodashExports.get(dr, Hn, null);
          typeof ar == "function" && ar(...ir);
        }
      }, Et = (An) => {
        te.value = An;
      }, Qt = () => {
        const An = yt.getCurrentPageData(), Hn = ["dataSource", "groups"].reduce((ir, dr) => (An[dr] && (ir[dr] = An[dr]), ir), {});
        return cloneDeep$1(Hn);
      };
      function un(An, Hn) {
        return !Array.isArray(An) || !An || !An.length ? getColumns(Hn) : An;
      }
      const gn = (...An) => yt.getCellWidths(...An), dn = (...An) => yt.setHeadWidths(...An), yn = (...An) => yt.getHeadWidths(...An), vn = (...An) => yt.mergedRowExpandable(...An), Pn = (...An) => yt.setBodyHasScrollbar(...An), On = (An) => {
        var ir;
        const {
          scroll: Hn = {}
        } = l;
        if ((ir = window.navigator) != null && ir.userAgent.match(/Trident\/7\./) && Hn.y) {
          An.preventDefault();
          const dr = An.deltaY, {
            target: ar
          } = An, Or = ue.value;
          let Sr = 0;
          m ? Sr = m + dr : Sr = dr, Or && ar !== Or && (Or.scrollTop = Sr);
        }
      }, _n = (An) => {
        var ar;
        if (An.currentTarget !== An.target)
          return;
        const {
          target: Hn
        } = An, ir = (ar = te.value) == null ? void 0 : ar.$el, dr = ue.value;
        Hn.scrollLeft !== g && (Hn === dr && ir ? ir.scrollLeft = Hn.scrollLeft : Hn === ir && dr && (dr.scrollLeft = Hn.scrollLeft), jn()), g = Hn.scrollLeft;
      };
      function Nn() {
        kn(), jn();
      }
      const Un = (An) => {
        const {
          target: Hn
        } = An;
        if (An.currentTarget !== Hn)
          return;
        const {
          scroll: ir = {}
        } = l, dr = te.value, ar = ue.value;
        if (Hn.scrollTop !== m && ir.y && Hn !== dr) {
          const {
            scrollTop: Or
          } = Hn;
          ar && Hn !== ar && (ar.scrollTop = Or);
        }
        m = Hn.scrollTop;
      }, Xn = (An) => {
        _n(An), Un(An);
      }, zn = (An) => {
        const {
          prefixCls: Hn
        } = l, ir = [`${Hn}-scroll-position-both`, `${Hn}-scroll-position-middle`, `${Hn}-scroll-position-left`, `${Hn}-scroll-position-right`];
        v = An;
        const dr = W.value;
        if (dr && dr.nodeType)
          if (An === "both") {
            const ar = [`${Hn}-scroll-position-left`, `${Hn}-scroll-position-right`];
            dr.classList.remove(...lodashExports.difference(ir, ar)), dr.classList.add(...ar);
          } else {
            const ar = [`${Hn}-scroll-position-${An}`];
            dr.classList.remove(...lodashExports.difference(ir, ar)), dr.classList.add(...ar);
          }
      }, jn = () => {
        const An = ue.value;
        if (An && An.children && An.children.length) {
          const Hn = An.scrollLeft === 0, ir = Math.abs(An.scrollLeft) + 1 >= An.children[0].getBoundingClientRect().width - An.getBoundingClientRect().width;
          Hn && ir ? zn("both") : Hn ? zn("left") : ir ? zn("right") : v !== "middle" && zn("middle");
        }
      }, kn = () => {
        Q && Q.value && (K.tableWidth = Q.value.getBoundingClientRect().width);
      }, Yn = (An = {}, Hn = !1, ir) => {
        const {
          rowSelection: dr,
          allDisabledRowKeysSet: ar
        } = K;
        if (dr && typeof dr == "object") {
          const {
            selectedRowKeys: Or = [],
            selectedRowKeysSet: Sr = /* @__PURE__ */ new Set(),
            getCheckboxProps: kr,
            disabled: Nr,
            renderCell: Ur
          } = dr, _r = P, Zr = T, Jr = yt.allIsSelected(Sr, ar, _r), Ti = yt.hasRowSelected(Or, Zr) && !Jr;
          if (Hn) {
            const Mi = lodashExports.get(dr, "key", strings$2.DEFAULT_KEY_COLUMN_SELECTION), ui = createVNode(TableSelectionCell, {
              "aria-label": `${Jr ? "Deselect" : "Select"} all rows`,
              disabled: Nr,
              key: Mi,
              selected: Jr,
              indeterminate: Ti,
              onChange: (bs, Oi) => {
                Wn(bs, Oi);
              }
            }, null), Ii = (bs, Oi) => Wn(bs, Oi);
            return lodashExports.isFunction(Ur) ? Ur({
              selected: Jr,
              record: An,
              originNode: ui,
              inHeader: Hn,
              disabled: Nr,
              indeterminate: Ti,
              selectAll: Ii
            }) : ui;
          } else {
            const Mi = yt.getRecordKey(An), ui = Sr.has(Mi), bs = createVNode(TableSelectionCell, {
              "aria-label": `${ui ? "Deselect" : "Select"} this row`,
              getCheckboxProps: () => typeof kr == "function" ? kr(An) : {},
              selected: ui,
              onChange: (Vs, _s) => Gn(Vs, Mi, _s)
            }, null), Oi = (Vs, _s) => Gn(Vs, Mi, _s);
            return lodashExports.isFunction(Ur) ? Ur({
              selected: ui,
              record: An,
              index: ir,
              originNode: bs,
              inHeader: !1,
              disabled: Nr,
              indeterminate: Ti,
              selectRow: Oi
            }) : bs;
          }
        }
        return null;
      }, Zn = (An, Hn = {}, ir) => Yn(Hn, !1, ir), er = () => Yn(void 0, !0), bn = (An = {}) => {
        const {
          rowSelection: Hn,
          prefixCls: ir
        } = An;
        let dr = {};
        if (Hn) {
          const ar = ["selectedRowKeys", "selectedRowKeysSet"];
          dr = {
            key: strings$2.DEFAULT_KEY_COLUMN_SELECTION
          }, lodashExports.isObject(Hn) && (dr = {
            ...dr,
            ...lodashExports.omit(Hn, ar)
          }), dr.className = cls(dr.className, `${ir}-column-selection`), dr.title = er, dr.render = Zn;
        }
        return dr;
      }, Ln = (An = {}, Hn = !1, ir = null) => {
        const {
          expandedRowKeys: dr
        } = K, {
          expandIcon: ar
        } = l, Or = typeof ir == "string" || typeof ir == "number" ? ir : yt.getRecordKey(An);
        return createVNode(CustomExpandIcon, {
          key: Or,
          componentType: Hn ? "tree" : "expand",
          expanded: lodashExports.includes(dr, Or),
          expandIcon: ar,
          onClick: (Sr, kr) => Kn(Sr, Or, kr)
        }, null);
      }, Kn = (...An) => yt.handleRowExpanded(...An), Bn = (An = {}) => {
        let Hn = null;
        const {
          prefixCls: ir,
          expandCellFixed: dr,
          expandIcon: ar
        } = An;
        return Hn = {
          fixed: dr,
          key: strings$2.DEFAULT_KEY_COLUMN_EXPAND
        }, Hn.className = cls(Hn.className, `${ir}-column-expand`), Hn.render = ar !== !1 ? (Or = "", Sr, kr) => wt.mergedRowExpandable(Sr) ? Ln(Sr) : null : () => null, Hn;
      }, Fn = (An = {}) => {
        const {
          prefixCls: Hn
        } = l;
        if (An && (An.sorter || An.filters || An.onFilter || An.useFullRender)) {
          let ir = !1;
          const {
            dataIndex: dr,
            title: ar,
            useFullRender: Or
          } = An, Sr = yt.getQuery(dr), kr = {}, Nr = [];
          Or && (kr.selection = Yn(null, !0));
          const Ur = lodashExports.get(Sr, "sortOrder"), _r = lodashExports.get(Sr, "defaultSortOrder", !1), Zr = yt.isSortOrderValid(Ur) ? Ur : _r, Jr = shouldShowEllipsisTitle(An.ellipsis), ii = typeof ar != "function" && createVNode("span", {
            class: `${Hn}-row-head-title`,
            key: strings$2.DEFAULT_KEY_COLUMN_TITLE,
            title: Jr && typeof ar == "string" ? ar : void 0
          }, [ar]);
          if (typeof An.sorter == "function" || An.sorter === !0) {
            const bs = createVNode(ColumnSorter, {
              key: strings$2.DEFAULT_KEY_COLUMN_SORTER,
              sortOrder: Zr,
              sortIcon: An.sortIcon,
              onClick: (Oi) => yt.handleSort(An, Oi),
              title: ii
            }, null);
            Or && (kr.sorter = bs), ir = !0, Nr.push(bs);
          } else
            Nr.push(ii);
          const Ti = lodashExports.get(Sr, "filteredValue"), Mi = lodashExports.get(Sr, "defaultFilteredValue"), ui = Ti || Mi;
          if (Array.isArray(An.filters) && An.filters.length || isVNode(An.filterDropdown) || typeof An.renderFilterDropdown == "function") {
            const bs = createVNode(ColumnFilter, mergeProps$1({
              key: strings$2.DEFAULT_KEY_COLUMN_FILTER
            }, Sr, {
              filteredValue: ui,
              onFilterDropdownVisibleChange: (Oi) => yt.toggleShowFilter(dr, Oi),
              onSelect: (Oi) => {
                yt.handleFilterSelect(dr, Oi);
              }
            }), null);
            Or && (kr.filter = bs), ir = !0, Nr.push(bs);
          }
          const Ii = typeof ar == "function" ? () => ar(kr) : ir ? createVNode("div", {
            class: `${Hn}-operate-wrapper`
          }, [Nr]) : Nr;
          An = {
            ...An,
            title: Ii
          };
        }
        return An;
      }, Gn = (An, Hn, ir) => {
        yt.handleSelectRow(Hn, An, ir);
      }, Wn = (An, Hn) => {
        yt.handleSelectAllRow(An, Hn);
      }, Mn = (An, Hn) => {
        if (!An)
          return null;
        const ir = yt.memoizedPagination(An);
        return createVNode(LocaleConsumer$6, {
          componentName: "Table"
        }, {
          default: (dr) => {
            const ar = yt.formatPaginationInfo(ir, dr.pageText);
            return createVNode(TablePagination, {
              info: ar,
              pagination: ir,
              renderPagination: Hn
            }, null);
          }
        });
      }, Tn = (An = {}) => {
        let {
          title: Hn
        } = An;
        const {
          prefixCls: ir,
          dataSource: dr
        } = An;
        return typeof Hn == "function" && (Hn = Hn(dr)), isVNode(Hn) || typeof Hn == "string" ? createVNode("div", {
          class: `${ir}-title`,
          "x-semi-prop": "title"
        }, [Hn]) : null;
      }, Rn = (An = {}) => {
        const {
          prefixCls: Hn,
          empty: ir,
          dataSource: dr
        } = An, ar = `${Hn}-placeholder`;
        return yt.isEmpty(dr) ? createVNode(LocaleConsumer$6, {
          componentName: "Table",
          key: "emptyText"
        }, {
          default: (Sr, kr) => createVNode("div", {
            class: ar
          }, [createVNode("div", {
            class: `${Hn}-empty`,
            "x-semi-prop": "empty"
          }, [ir || Sr.emptyText])])
        }) : null;
      }, hn = (An = {}) => {
        let {
          footer: Hn
        } = An;
        const {
          prefixCls: ir,
          dataSource: dr
        } = An;
        return typeof Hn == "function" && (Hn = Hn(dr)), isVNode(Hn) || typeof Hn == "string" ? createVNode("div", {
          class: `${ir}-footer`,
          key: "footer",
          "x-semi-prop": "footer"
        }, [Hn]) : null;
      }, Qn = (An) => {
        const Hn = wt.useFixedHeader(), ir = Rn(An);
        return [rr({
          ...An,
          fixed: !1,
          useFixedHeader: Hn,
          headerRef: Et,
          bodyRef: ue,
          includeHeader: !Hn,
          emptySlot: ir
        }), hn(An)];
      }, rr = (An) => {
        const {
          columns: Hn,
          filteredColumns: ir,
          fixed: dr,
          useFixedHeader: ar,
          scroll: Or,
          prefixCls: Sr,
          anyColumnFixed: kr,
          includeHeader: Nr,
          showHeader: Ur,
          components: _r,
          headerRef: Zr,
          bodyRef: Jr,
          onHeaderRow: ii,
          rowSelection: Ti,
          dataSource: Mi,
          bodyHasScrollBar: ui,
          disabledRowKeysSet: Ii,
          sticky: bs
        } = An, Oi = lodashExports.get(Ti, "selectedRowKeysSet", /* @__PURE__ */ new Set()), Vs = wt.getTableLayout(), _s = dr || ar ? createVNode(HeadTable, {
          key: "head",
          tableLayout: Vs,
          ref: Zr,
          columns: ir,
          prefixCls: Sr,
          fixed: dr,
          handleBodyScroll: _n,
          components: _r,
          scroll: Or,
          showHeader: Ur,
          selectedRowKeysSet: Oi,
          onHeaderRow: ii,
          dataSource: Mi,
          bodyHasScrollBar: ui,
          sticky: bs
        }, null) : null, Is = createVNode(Body, mergeProps$1(lodashExports.omit(An, ["rowSelection", "headWidths", "allDisabledRowKeys", "allDisabledRowKeysSet"]), {
          key: "body",
          forwardedRef: Jr,
          columns: ir,
          fixed: dr,
          prefixCls: Sr,
          handleWheel: On,
          handleBodyScroll: Xn,
          anyColumnFixed: kr,
          tableLayout: Vs,
          includeHeader: Nr,
          showHeader: Ur,
          scroll: Or,
          components: _r,
          store: ln,
          selectedRowKeysSet: Oi,
          disabledRowKeysSet: Ii
        }), null);
        return [_s, Is];
      };
      function tr(An, Hn) {
        const {
          hideExpandedColumn: ir,
          scroll: dr,
          prefixCls: ar,
          expandCellFixed: Or,
          expandIcon: Sr,
          rowSelection: kr
        } = l, Nr = "children";
        let Ur = cloneDeep$1(Hn);
        const _r = (Zr = []) => {
          Array.isArray(Zr) && Zr.length && lodashExports.each(Zr, (Jr, ii, Ti) => {
            const Mi = Fn(Jr), ui = Jr[Nr];
            if (Array.isArray(ui) && ui.length) {
              const Ii = [...ui];
              _r(Ii), Mi[Nr] = Ii;
            }
            Ti[ii] = Mi;
          });
        };
        if (_r(Ur), !ir) {
          const Zr = Bn({
            prefixCls: ar,
            expandCellFixed: Or,
            expandIcon: Sr
          }), Jr = lodashExports.findIndex(Ur, (ii) => ii.key === strings$2.DEFAULT_KEY_COLUMN_EXPAND);
          Zr && (Jr > -1 ? Ur[Jr] = {
            ...Zr,
            ...Ur[Jr]
          } : Zr.fixed === "right" ? Ur = [...Ur, Zr] : Ur = [Zr, ...Ur]);
        }
        if (kr && !lodashExports.get(kr, "hidden")) {
          const Zr = lodashExports.findIndex(Ur, (ii) => ii.key === strings$2.DEFAULT_KEY_COLUMN_SELECTION), Jr = bn({
            rowSelection: kr,
            prefixCls: ar
          });
          Zr > -1 ? Ur[Zr] = {
            ...Jr,
            ...Ur[Zr]
          } : Jr.fixed === "right" ? Ur = [...Ur, Jr] : Ur = [Jr, ...Ur];
        }
        return assignColumnKeys(Ur), Ur;
      }
      const Cr = (An, Hn) => (console.error("TODO"), cloneDeep$1(un(An, Hn)));
      function Fr(An) {
        return {
          onChange: yt.setPage,
          ...An
        };
      }
      return u({
        getCurrentPageData: Qt
      }), () => {
        let {
          scroll: An,
          prefixCls: Hn,
          className: ir,
          style: dr = {},
          bordered: ar,
          id: Or,
          pagination: Sr,
          virtualized: kr,
          size: Nr,
          renderPagination: Ur,
          getVirtualizedListRef: _r,
          loading: Zr,
          hideExpandedColumn: Jr,
          rowSelection: ii,
          children: Ti,
          ...Mi
        } = c(l);
        const ui = {
          ...l.style
        };
        let Ii;
        if (wt.isAnyColumnUseFullRender(K.queries))
          Ii = tr(K.queries, K.cachedColumns);
        else {
          const kl = ii && !lodashExports.get(ii, "hidden");
          Ii = yt.memoizedWithFnsColumns(
            K.queries,
            K.cachedColumns,
            kl,
            Jr,
            // Update the columns after the body scrollbar changes to ensure that the head and body are aligned
            K.bodyHasScrollBar
          );
        }
        const bs = yt.memoizedFilterColumns(Ii), Oi = yt.memoizedFlattenFnsColumns(Ii), Vs = wt.isAnyColumnFixed(Ii), _s = {
          ...toRaw(K)
        }, Is = {
          ...Mi,
          ..._s,
          // props not in rest
          virtualized: kr,
          scroll: An,
          prefixCls: Hn,
          size: Nr,
          hideExpandedColumn: Jr,
          // renamed state
          columns: Ii,
          // calculated value
          anyColumnFixed: Vs,
          rowExpandable: vn,
          pagination: K.pagination,
          dataSource: K.dataSource,
          rowSelection: K.rowSelection,
          expandedRowKeys: K.expandedRowKeys,
          renderExpandIcon: Ln,
          filteredColumns: bs
        }, Fa = lodashExports.get(An, "x"), io = lodashExports.get(An, "y");
        kr && (isNaN(parseInt("" + ui.width)) ? ui.width = Fa + "px" : ui.width = typeof ui.width == "string" ? ui.width : ui.width + "px");
        const Da = cls({
          [`${Hn}-${strings$2.SIZE_SMALL}`]: Nr === strings$2.SIZE_SMALL,
          [`${Hn}-${strings$2.SIZE_MIDDLE}`]: Nr === strings$2.SIZE_MIDDLE,
          [`${Hn}-virtualized`]: !!kr,
          [`${Hn}-bordered`]: ar,
          [`${Hn}-fixed-header`]: !!io,
          [`${Hn}-scroll-position-left`]: ["both", "left"].includes(b),
          [`${Hn}-scroll-position-right`]: ["both", "right"].includes(b)
        }), oo = K.pagination && Sr ? Mn(K.pagination, Ur) : null, Xs = lodashExports.get(Sr, "position", "bottom"), so = {
          ...S.value,
          headWidths: K.headWidths,
          tableWidth: K.tableWidth,
          anyColumnFixed: Vs,
          flattenedColumns: Oi,
          renderExpandIcon: Ln,
          renderSelection: Yn,
          setHeadWidths: dn,
          getHeadWidths: yn,
          getCellWidths: gn,
          handleRowExpanded: Kn,
          getVirtualizedListRef: _r,
          setBodyHasScrollbar: Pn
        };
        l.direction && (so.direction = l.direction);
        const Ol = ee();
        return createVNode("div", mergeProps$1({
          ref: Q,
          class: cls(ir, `${Hn}-wrapper`, `${Hn}-wrapper-${l.direction}`),
          "data-column-fixed": Vs,
          style: ui,
          id: Or
        }, Ol), [createVNode(TableContextProvider, so, {
          default: () => [createVNode(Spin, {
            spinning: Zr,
            size: "large"
          }, {
            default: () => [createVNode("div", {
              ref: W,
              class: Da
            }, [createVNode(Fragment, {
              key: "pagination-top"
            }, [["top", "both"].includes(Xs) ? oo : null]), " ", Tn({
              title: l.title,
              dataSource: l.dataSource,
              prefixCls: l.prefixCls
            }), createVNode("div", {
              class: `${Hn}-container`
            }, [Qn({
              ...Is
            })]), createVNode(Fragment, {
              key: "pagination-bottom"
            }, [["bottom", "both"].includes(Xs) ? oo : null])])]
          })]
        })]);
      };
    }
  });
}
function addClass(s, ...o) {
  const l = lodashExports.split(s, /\s+/), u = lodashExports.filter(o, (c) => !l.includes(c));
  return cls(s, ...u);
}
function removeClass(s, ...o) {
  const l = lodashExports.split(s, /\s+/);
  return lodashExports.map(o, (u) => {
    const c = l.indexOf(u);
    c > -1 && l.splice(c, 1);
  }), cls(...l);
}
const Ce = [Array, Object, String, Number, Boolean, Function], L = Array, De = Boolean, A = Function, I = Number, ke = Object, se = String, Ee = [Array, Object, String, Number], Ne = [Array, Object, String, Number];
function Me(s) {
  let o = [];
  return s.map((l) => {
    Array.isArray(l) ? o = [...o, ...l] : o.push(l);
  }), o;
}
function fe(s, o) {
  const l = {};
  return Object.keys(s).forEach((u) => {
    if (o.hasOwnProperty(u))
      if (s[u].hasOwnProperty("type"))
        l[u] = {
          // @ts-ignore
          type: s[u].type,
          default: o[u]
        };
      else {
        const c = typeof o[u] == "object" ? () => o[u] : o[u];
        l[u] = {
          type: s[u],
          default: c
        };
      }
    else
      l[u] = {
        // eslint-disable-next-line no-prototype-builtins
        type: s[u].hasOwnProperty("type") ? (
          // @ts-ignore
          s[u].type
        ) : s[u],
        default: void 0
      };
  }), l;
}
const ge = {
  /*
   * Restricts resizing to a particular axis (default: 'both')
   * 'both' - allows resizing by width or height
   * 'x' - only allows the width to be changed
   * 'y' - only allows the height to be changed
   * 'none' - disables resizing altogether
   * */
  axis: se,
  className: se,
  /*
   * Require that one and only one child be present.
   * */
  children: Ce,
  /*
   * These will be passed wholesale to react-draggable's DraggableCore
   * */
  draggableOpts: ke,
  /*
   * Initial height
   * */
  height: I,
  /*
   * Customize cursor resize handle
   * */
  handle: Me([Ee, A]),
  /*
   * If you change this, be sure to update your css
   * */
  handleSize: L,
  lockAspectRatio: De,
  /*
   * Max X & Y measure
   * */
  maxConstraints: L,
  /*
   * Min X & Y measure
   * */
  minConstraints: L,
  /*
   * Called on stop resize event
   * */
  onResizeStop: A,
  /*
   * Called on start resize event
   * */
  onResizeStart: A,
  /*
   * Called on resize event
   * */
  onResize: A,
  /*
   * Defines which resize handles should be rendered (default: 'se')
   * 's' - South handle (bottom-center)
   * 'w' - West handle (left-center)
   * 'e' - East handle (right-center)
   * 'n' - North handle (top-center)
   * 'sw' - Southwest handle (bottom-left)
   * 'nw' - Northwest handle (top-left)
   * 'se' - Southeast handle (bottom-right)
   * 'ne' - Northeast handle (top-center)
   * */
  resizeHandles: L,
  /*
   * If `transform: scale(n)` is set on the parent, this should be set to `n`.
   * */
  transformScale: I,
  /*
   * Initial width
   */
  width: I
};
function Te(s, o) {
  return o.style && s.props && s.props.style && (o.style = { ...s.props.style, ...o.style }), o.class && s.props && s.props.class && (o.class = `${s.props.class} ${o.class}`), cloneVNode(s, o);
}
const he = [Array, Object, String, Number, Boolean, Function], He = Array, U = Boolean, H = Function, $e = Number, D = Object, k = String;
function pe(s, o) {
  const l = {};
  return Object.keys(s).forEach((u) => {
    if (o.hasOwnProperty(u))
      if (s[u].hasOwnProperty("type"))
        l[u] = {
          // @ts-ignore
          type: s[u].type,
          default: o[u]
        };
      else {
        const c = typeof o[u] == "object" ? () => o[u] : o[u];
        l[u] = {
          type: s[u],
          default: c
        };
      }
    else
      l[u] = {
        // eslint-disable-next-line no-prototype-builtins
        type: s[u].hasOwnProperty("type") ? (
          // @ts-ignore
          s[u].type
        ) : s[u],
        default: void 0
      };
  }), l;
}
function Z(s, o) {
  for (let l = 0, u = s.length; l < u; l++)
    if (o.apply(o, [s[l], l, s]))
      return s[l];
}
function ae(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Function]";
}
function $(s) {
  return typeof s == "number" && !isNaN(s);
}
function x(s) {
  return parseInt(s, 10);
}
const F = ["Moz", "Webkit", "O", "ms"];
function Pe(s = "transform") {
  var o, l;
  if (typeof window > "u")
    return "";
  const u = (l = (o = window.document) == null ? void 0 : o.documentElement) == null ? void 0 : l.style;
  if (!u || s in u)
    return "";
  for (let c = 0; c < F.length; c++)
    if (me(s, F[c]) in u)
      return F[c];
  return "";
}
function me(s, o) {
  return o ? `${o}${Xe(s)}` : s;
}
function Xe(s) {
  let o = "", l = !0;
  for (let u = 0; u < s.length; u++)
    l ? (o += s[u].toUpperCase(), l = !1) : s[u] === "-" ? l = !0 : o += s[u];
  return o;
}
const Ye = Pe();
let B = "";
function Oe(s, o) {
  return B || (B = Z(
    [
      "matches",
      "webkitMatchesSelector",
      "mozMatchesSelector",
      "msMatchesSelector",
      "oMatchesSelector"
    ],
    function(l) {
      return ae(s[l]);
    }
  )), ae(s[B]) ? s[B](o) : !1;
}
function ie(s, o, l) {
  let u = s;
  do {
    if (Oe(u, o))
      return !0;
    if (u === l)
      return !1;
    u = u.parentNode;
  } while (u);
  return !1;
}
function G(s, o, l, u) {
  if (!s)
    return;
  const c = { capture: !0, ...u };
  s.addEventListener ? s.addEventListener(o, l, c) : s.attachEvent ? s.attachEvent("on" + o, l) : s["on" + o] = l;
}
function M(s, o, l, u) {
  if (!s)
    return;
  const c = { capture: !0, ...u };
  s.removeEventListener ? s.removeEventListener(o, l, c) : s.detachEvent ? s.detachEvent("on" + o, l) : s["on" + o] = null;
}
function Le(s) {
  let o = s.clientHeight;
  const l = s.ownerDocument.defaultView.getComputedStyle(s);
  return o += x(l.borderTopWidth), o += x(l.borderBottomWidth), o;
}
function Ae(s) {
  let o = s.clientWidth;
  const l = s.ownerDocument.defaultView.getComputedStyle(s);
  return o += x(l.borderLeftWidth), o += x(l.borderRightWidth), o;
}
function Be(s) {
  let o = s.clientHeight;
  const l = s.ownerDocument.defaultView.getComputedStyle(s);
  return o -= x(l.paddingTop), o -= x(l.paddingBottom), o;
}
function Ve(s) {
  let o = s.clientWidth;
  const l = s.ownerDocument.defaultView.getComputedStyle(s);
  return o -= x(l.paddingLeft), o -= x(l.paddingRight), o;
}
function je(s, o, l) {
  const u = o === o.ownerDocument.body ? { left: 0, top: 0 } : o.getBoundingClientRect(), c = (s.clientX + o.scrollLeft - u.left) / l, m = (s.clientY + o.scrollTop - u.top) / l;
  return { x: c, y: m };
}
function We(s, o) {
  const l = ye(s, o, "px");
  return console.log(s), { [me("transform", Ye)]: l };
}
function Ie(s, o) {
  return ye(s, o, "");
}
function ye({ x: s, y: o }, l, u) {
  let c = `translate(${s}${u},${o}${u})`;
  if (l) {
    const m = `${typeof l.x == "string" ? l.x : l.x + u}`, g = `${typeof l.y == "string" ? l.y : l.y + u}`;
    c = `translate(${m}, ${g})` + c;
  }
  return c;
}
function Ue(s, o) {
  return s.targetTouches && Z(s.targetTouches, (l) => o === l.identifier) || s.changedTouches && Z(s.changedTouches, (l) => o === l.identifier);
}
function Fe(s) {
  if (s.targetTouches && s.targetTouches[0])
    return s.targetTouches[0].identifier;
  if (s.changedTouches && s.changedTouches[0])
    return s.changedTouches[0].identifier;
}
function Ge(s) {
  if (!s)
    return;
  let o = s.getElementById("react-draggable-style-el");
  o || (o = s.createElement("style"), o.type = "text/css", o.id = "react-draggable-style-el", o.innerHTML = `.react-draggable-transparent-selection *::-moz-selection {all: inherit;}
`, o.innerHTML += `.react-draggable-transparent-selection *::selection {all: inherit;}
`, s.getElementsByTagName("head")[0].appendChild(o)), s.body && qe(s.body, "react-draggable-transparent-selection");
}
function le(s) {
  if (s)
    try {
      if (s.body && _e(s.body, "react-draggable-transparent-selection"), s.selection)
        s.selection.empty();
      else {
        const o = (s.defaultView || window).getSelection();
        o && o.type !== "Caret" && o.removeAllRanges();
      }
    } catch {
    }
}
function qe(s, o) {
  s.classList ? s.classList.add(o) : s.class.match(new RegExp(`(?:^|\\s)${o}(?!\\S)`)) || (s.class += ` ${o}`);
}
function _e(s, o) {
  s.classList ? s.classList.remove(o) : s.class = s.class.replace(
    new RegExp(`(?:^|\\s)${o}(?!\\S)`, "g"),
    ""
  );
}
function Je(s, o, l) {
  if (!s.props.bounds)
    return [o, l];
  let { bounds: u } = s.props;
  u = typeof u == "string" ? u : Ke(u);
  const c = ne(s);
  if (typeof u == "string") {
    const { ownerDocument: m } = c, g = m.defaultView;
    let v;
    if (u === "parent" ? v = c.parentNode : v = m.querySelector(u), !(v instanceof g.HTMLElement))
      throw new Error(
        'Bounds selector "' + u + '" could not find an element.'
      );
    const b = v, S = g.getComputedStyle(c), E = g.getComputedStyle(b);
    u = {
      left: -c.offsetLeft + x(E.paddingLeft) + x(S.marginLeft),
      top: -c.offsetTop + x(E.paddingTop) + x(S.marginTop),
      right: Ve(b) - Ae(c) - c.offsetLeft + x(E.paddingRight) - x(S.marginRight),
      bottom: Be(b) - Le(c) - c.offsetTop + x(E.paddingBottom) - x(S.marginBottom)
    };
  }
  return $(u.right) && (o = Math.min(o, u.right)), $(u.bottom) && (l = Math.min(l, u.bottom)), $(u.left) && (o = Math.max(o, u.left)), $(u.top) && (l = Math.max(l, u.top)), [o, l];
}
function ce(s, o, l) {
  const u = Math.round(o / s[0]) * s[0], c = Math.round(l / s[1]) * s[1];
  return [u, c];
}
function Qe(s) {
  return s.props.axis === "both" || s.props.axis === "x";
}
function Ze(s) {
  return s.props.axis === "both" || s.props.axis === "y";
}
function q(s, o, l) {
  const u = typeof o == "number" ? Ue(s, o) : null;
  if (typeof o == "number" && !u)
    return null;
  const c = ne(l), m = l.props.offsetParent || c.offsetParent || c.ownerDocument.body;
  return je(
    u || s,
    // @ts-ignore
    m,
    l.props.scale
  );
}
function _(s, o, l) {
  const u = s.exposed.state, c = !$(u.lastX), m = ne(s);
  return c ? {
    node: m,
    deltaX: 0,
    deltaY: 0,
    lastX: o,
    lastY: l,
    x: o,
    y: l
  } : {
    node: m,
    deltaX: o - u.lastX,
    deltaY: l - u.lastY,
    lastX: u.lastX,
    lastY: u.lastY,
    x: o,
    y: l
  };
}
function J(s, o) {
  const l = s.props.scale;
  return {
    node: o.node,
    x: s.exposed.state.x + o.deltaX / l,
    y: s.exposed.state.y + o.deltaY / l,
    deltaX: o.deltaX / l,
    deltaY: o.deltaY / l,
    lastX: s.exposed.state.x,
    lastY: s.exposed.state.y
  };
}
function Ke(s) {
  return {
    left: s.left,
    top: s.top,
    right: s.right,
    bottom: s.bottom
  };
}
function ne(s) {
  var o;
  const l = (o = s == null ? void 0 : s.ctx) == null ? void 0 : o.$el;
  if (!l)
    throw new Error("<DraggableCore>: Unmounted during event!");
  return l;
}
function et(...s) {
}
const R = {
  touch: {
    start: "touchstart",
    move: "touchmove",
    stop: "touchend"
  },
  mouse: {
    start: "mousedown",
    move: "mousemove",
    stop: "mouseup"
  }
};
let C = R.mouse;
const tt = {
  children: he,
  /**
   * `allowAnyClick` allows dragging using any mouse button.
   * By default, we only accept the left button.
   *
   * Defaults to `false`.
   */
  allowAnyClick: U,
  /**
   * `disabled`, if true, stops the <Draggable> from dragging. All handlers,
   * with the exception of `onMouseDown`, will not fire.
   */
  disabled: U,
  /**
   * By default, we add 'user-select:none' attributes to the document body
   * to prevent ugly text selection during drag. If this is causing problems
   * for your app, set this to `false`.
   */
  enableUserSelectHack: U,
  /**
   * `offsetParent`, if set, uses the passed DOM node to compute drag offsets
   * instead of using the parent node.
   */
  offsetParent: H,
  /**
   * `grid` specifies the x and y that dragging should snap to.
   */
  grid: He,
  /**
   * `handle` specifies a selector to be used as the handle that initiates drag.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable handle=".handle">
   *              <div>
   *                  <div className="handle">Click me to drag</div>
   *                  <div>This is some other content</div>
   *              </div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  handle: k,
  /**
   * `cancel` specifies a selector to be used to prevent drag initialization.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *           return(
   *               <Draggable cancel=".cancel">
   *                   <div>
   *                     <div className="cancel">You can't drag from here</div>
   *                     <div>Dragging here works fine</div>
   *                   </div>
   *               </Draggable>
   *           );
   *       }
   *   });
   * ```
   */
  cancel: k,
  /* If running in React Strict mode, ReactDOM.findDOMNode() is deprecated.
   * Unfortunately, in order for <Draggable> to work properly, we need raw access
   * to the underlying DOM node. If you want to avoid the warning, pass a `nodeRef`
   * as in this example:
   *
   * function MyComponent() {
   *   const nodeRef = React.useRef(null);
   *   return (
   *     <Draggable nodeRef={nodeRef}>
   *       <div ref={nodeRef}>Example Target</div>
   *     </Draggable>
   *   );
   * }
   *
   * This can be used for arbitrarily nested components, so long as the ref ends up
   * pointing to the actual child DOM node and not a custom component.
   */
  nodeRef: D,
  /**
   * Called when dragging starts.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onStart: H,
  /**
   * Called while dragging.
   * If this function returns the boolean false, dragging will be canceled.
   */
  onDrag: H,
  /**
   * Called when dragging stops.
   * If this function returns the boolean false, the drag will remain active.
   */
  onStop: H,
  /**
   * A workaround option which can be passed if onMouseDown needs to be accessed,
   * since it'll always be blocked (as there is internal use of onMouseDown)
   */
  onMouseDown: H,
  /**
   * `scale`, if set, applies scaling while dragging an element
   */
  scale: $e,
  /**
   * These properties should be defined on the child, not here.
   */
  className: k,
  style: D,
  transform: D
}, be = {
  allowAnyClick: !1,
  // by default only accept left click
  disabled: !1,
  enableUserSelectHack: !0,
  onStart: function() {
  },
  onDrag: function() {
  },
  onStop: function() {
  },
  onMouseDown: function() {
  },
  scale: 1
}, Se = pe(tt, be), X = /* @__PURE__ */ defineComponent((s, {
  expose: o
}) => {
  useSlots();
  const l = reactive({
    dragging: !1,
    // Used while dragging to determine deltas.
    lastX: NaN,
    lastY: NaN,
    touchIdentifier: void 0
  });
  let u = !1;
  const c = getCurrentInstance();
  onMounted(() => {
    var N;
    u = !0;
    const O = (N = c == null ? void 0 : c.ctx) == null ? void 0 : N.$el;
    O && G(O, R.touch.start, P, {
      passive: !1
    });
  }), onBeforeUnmount(() => {
    u = !1;
    const N = m();
    if (N) {
      const {
        ownerDocument: O
      } = N;
      M(O, R.mouse.move, v), M(O, R.touch.move, v), M(O, R.mouse.stop, b), M(O, R.touch.stop, b), M(N, R.touch.start, P, {
        passive: !1
      }), s.enableUserSelectHack && le(O);
    }
  });
  function m() {
    var N;
    return ((N = s == null ? void 0 : s.nodeRef) == null ? void 0 : N.value) || // @ts-ignore
    c.ctx.$el;
  }
  const g = (N) => {
    if (s.onMouseDown(N), !s.allowAnyClick && typeof N.button == "number" && N.button !== 0)
      return !1;
    const O = m();
    if (!O || !O.ownerDocument || !O.ownerDocument.body)
      throw new Error("<DraggableCore> not mounted on DragStart!");
    const {
      ownerDocument: z
    } = O;
    if (s.disabled || !(N.target instanceof z.defaultView.Node) || s.handle && !ie(N.target, s.handle, O) || s.cancel && ie(N.target, s.cancel, O))
      return;
    N.type === "touchstart" && N.preventDefault();
    const Q = Fe(N);
    l.touchIdentifier = Q;
    const W = q(N, Q, c);
    if (W == null)
      return;
    const {
      x: ue,
      y: te
    } = W, K = _(c, ue, te);
    et("calling", s.onStart), !(s.onStart(N, K) === !1 || u === !1) && (s.enableUserSelectHack && Ge(z), l.dragging = !0, l.lastX = ue, l.lastY = te, G(z, C.move, v), G(z, C.stop, b));
  }, v = (N) => {
    const O = q(N, l.touchIdentifier, c);
    if (O == null)
      return;
    let {
      x: z,
      y: Q
    } = O;
    if (Array.isArray(s.grid)) {
      let ue = z - l.lastX, te = Q - l.lastY;
      if ([ue, te] = ce(s.grid, ue, te), !ue && !te)
        return;
      z = l.lastX + ue, Q = l.lastY + te;
    }
    const W = _(c, z, Q);
    if (s.onDrag(N, W) === !1 || u === !1) {
      try {
        b(new MouseEvent("mouseup"));
      } catch {
        const ue = document.createEvent("MouseEvents");
        ue.initMouseEvent("mouseup", !0, !0, window, 0, 0, 0, 0, 0, !1, !1, !1, !1, 0, null), b(ue);
      }
      return;
    }
    l.lastX = z, l.lastY = Q;
  }, b = (N) => {
    if (!l.dragging)
      return;
    const O = q(N, l.touchIdentifier, c);
    if (O == null)
      return;
    let {
      x: z,
      y: Q
    } = O;
    if (Array.isArray(s.grid)) {
      let te = z - l.lastX || 0, K = Q - l.lastY || 0;
      [te, K] = ce(s.grid, te, K), z = l.lastX + te, Q = l.lastY + K;
    }
    const W = _(c, z, Q);
    if (s.onStop(N, W) === !1 || u === !1)
      return !1;
    const ue = m();
    ue && s.enableUserSelectHack && le(ue.ownerDocument), l.dragging = !1, l.lastX = NaN, l.lastY = NaN, ue && (M(ue.ownerDocument, C.move, v), M(ue.ownerDocument, C.stop, b));
  }, S = (N) => (C = R.mouse, g(N)), E = (N) => (C = R.mouse, b(N)), P = (N) => (C = R.touch, g(N)), T = (N) => (C = R.touch, b(N));
  return o({
    state: l
  }), () => cloneVNode(s.children, {
    // Note: mouseMove handler is attached to document so it will still function
    // when the user drags quickly and leaves the bounds of the element.
    onMousedown: S,
    onMouseup: E,
    // onTouchStart is added on `componentDidMount` so they can be added with
    // {passive: false}, which allows it to cancel. See
    // https://developers.google.com/web/updates/2017/01/scrolling-intervention
    onTouchend: T
  });
});
X.props = Se;
X.name = "DraggableCore";
X.displayName = "DraggableCore";
function we(s) {
  var o, l, u = "";
  if (typeof s == "string" || typeof s == "number")
    u += s;
  else if (typeof s == "object")
    if (Array.isArray(s))
      for (o = 0; o < s.length; o++)
        s[o] && (l = we(s[o])) && (u && (u += " "), u += l);
    else
      for (o in s)
        s[o] && (u && (u += " "), u += o);
  return u;
}
function nt() {
  for (var s, o, l = 0, u = ""; l < arguments.length; )
    (s = arguments[l++]) && (o = we(s)) && (u && (u += " "), u += o);
  return u;
}
const ot = {
  // Accepts all props <DraggableCore> accepts.
  ...Se,
  /**
   * `axis` determines which axis the draggable can move.
   *
   *  Note that all callbacks will still return data as normal. This only
   *  controls flushing to the DOM.
   *
   * 'both' allows movement horizontally and vertically.
   * 'x' limits movement to horizontal axis.
   * 'y' limits movement to vertical axis.
   * 'none' limits all movement.
   *
   * Defaults to 'both'.
   */
  axis: k,
  /**
   * `bounds` determines the range of movement available to the element.
   * Available values are:
   *
   * 'parent' restricts movement within the Draggable's parent node.
   *
   * Alternatively, pass an object with the following properties, all of which are optional:
   *
   * {left: LEFT_BOUND, right: RIGHT_BOUND, bottom: BOTTOM_BOUND, top: TOP_BOUND}
   *
   * All values are in px.
   *
   * Example:
   *
   * ```jsx
   *   let App = React.createClass({
   *       render: function () {
   *         return (
   *            <Draggable bounds={{right: 300, bottom: 300}}>
   *              <div>Content</div>
   *           </Draggable>
   *         );
   *       }
   *   });
   * ```
   */
  bounds: he,
  defaultClassName: k,
  defaultClassNameDragging: k,
  defaultClassNameDragged: k,
  /**
   * `defaultPosition` specifies the x and y that the dragged item should start at
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable defaultPosition={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  defaultPosition: D,
  positionOffset: D,
  /**
   * `position`, if present, defines the current position of the element.
   *
   *  This is similar to how form elements in React work - if no `position` is supplied, the component
   *  is uncontrolled.
   *
   * Example:
   *
   * ```jsx
   *      let App = React.createClass({
   *          render: function () {
   *              return (
   *                  <Draggable position={{x: 25, y: 25}}>
   *                      <div>I start with transformX: 25px and transformY: 25px;</div>
   *                  </Draggable>
   *              );
   *          }
   *      });
   * ```
   */
  position: D,
  /**
   * These properties should be defined on the child, not here.
   */
  className: k,
  style: D,
  transform: D
}, rt = {
  ...be,
  axis: "both",
  bounds: !1,
  defaultClassName: "react-draggable",
  defaultClassNameDragging: "react-draggable-dragging",
  defaultClassNameDragged: "react-draggable-dragged",
  defaultPosition: {
    x: 0,
    y: 0
  },
  scale: 1
}, st = pe(ot, rt), oe = /* @__PURE__ */ defineComponent((s, {
  expose: o
}) => {
  useSlots();
  const l = getCurrentInstance(), u = reactive({
    // Whether or not we are currently dragging.
    dragging: !1,
    // Whether or not we have been dragged before.
    dragged: !1,
    // Current transform x and y.
    x: s.position ? s.position.x : s.defaultPosition.x,
    y: s.position ? s.position.y : s.defaultPosition.y,
    prevPropsPosition: {
      ...s.position
    },
    // Used for compensating for out-of-bounds drags
    slackX: 0,
    slackY: 0,
    // Can only determine if SVG after mounting
    isElementSVG: !1
  });
  watch([], () => {
    s.position && !(s.onDrag || s.onStop) && console.warn("A `position` was applied to this <Draggable>, without drag handlers. This will make this component effectively undraggable. Please attach `onDrag` or `onStop` handlers so you can adjust the `position` of this element.");
  });
  function c({
    position: S
  }, {
    prevPropsPosition: E
  }) {
    return S && (!E || S.x !== E.x || S.y !== E.y) ? {
      x: S.x,
      y: S.y,
      prevPropsPosition: {
        ...S
      }
    } : null;
  }
  watch(() => s, () => {
    const S = c(s, u);
    S && Object.keys(S).forEach((E) => {
      u[E] = S[E];
    });
  }, {
    deep: !0
  }), onMounted(() => {
    typeof window.SVGElement < "u" && m() instanceof window.SVGElement && (u.isElementSVG = !0);
  }), onBeforeUnmount(() => {
    u.isElementSVG = !1;
  });
  function m() {
    var S;
    return ((S = s == null ? void 0 : s.nodeRef) == null ? void 0 : S.value) || // @ts-ignore
    l.ctx.$el;
  }
  const g = (S, E) => {
    if (s.onStart(S, J(l, E)) === !1)
      return !1;
    u.dragging = !0, u.dragged = !0;
  }, v = (S, E) => {
    if (!u.dragging)
      return !1;
    const P = J(l, E), T = {
      x: P.x,
      y: P.y
    };
    if (s.bounds) {
      const {
        x: N,
        y: O
      } = T;
      T.x += u.slackX, T.y += u.slackY;
      const [z, Q] = Je(l, T.x, T.y);
      T.x = z, T.y = Q, T.slackX = u.slackX + (N - T.x), T.slackY = u.slackY + (O - T.y), P.x = T.x, P.y = T.y, P.deltaX = T.x - u.x, P.deltaY = T.y - u.y;
    }
    if (s.onDrag(S, P) === !1)
      return !1;
    T && Object.keys(T).forEach((N) => {
      u[N] = T[N];
    });
  }, b = (S, E) => {
    if (!u.dragging || s.onStop(S, J(l, E)) === !1)
      return !1;
    const P = {
      dragging: !1,
      slackX: 0,
      slackY: 0
    };
    if (s.position) {
      const {
        x: T,
        y: N
      } = s.position;
      P.x = T, P.y = N;
    }
    P && Object.keys(P).forEach((T) => {
      u[T] = P[T];
    });
  };
  return o({
    state: u
  }), () => {
    var S, E;
    const {
      axis: P,
      bounds: T,
      children: N,
      defaultPosition: O,
      defaultClassName: z,
      defaultClassNameDragging: Q,
      defaultClassNameDragged: W,
      position: ue,
      positionOffset: te,
      scale: K,
      ...ve
    } = s;
    let ee = {}, Re = null;
    const wt = !ue || u.dragging, yt = ue || O, xt = {
      // Set left if horizontal drag is enabled
      x: Qe(l) && wt ? u.x : yt.x,
      // Set top if vertical drag is enabled
      y: Ze(l) && wt ? u.y : yt.y
    };
    u.isElementSVG ? Re = Ie(xt, te) : ee = We(xt, te);
    const Kt = nt(((S = N.props) == null ? void 0 : S.class) || "", z, {
      [Q]: u.dragging,
      [W]: u.dragged
    });
    return createVNode(X, mergeProps$1({
      ...ve,
      scale: K,
      onStart: g,
      onDrag: v,
      onStop: b
    }, {
      children: cloneVNode(N, {
        className: Kt,
        style: {
          ...(E = N.props) == null ? void 0 : E.style,
          ...ee
        },
        transform: Re
      })
    }), null);
  };
});
oe.props = st;
oe.name = "Draggable";
oe.v = "Draggable";
const at = ge, it = {
  axis: "both",
  handleSize: [20, 20],
  lockAspectRatio: !1,
  minConstraints: [20, 20],
  maxConstraints: [1 / 0, 1 / 0],
  resizeHandles: ["se"],
  transformScale: 1
}, lt = fe(at, it), re$1 = /* @__PURE__ */ defineComponent((s, {
  expose: o
}) => {
  useSlots();
  const l = {};
  let u = null, c = null;
  onMounted(() => {
    m();
  });
  function m() {
    u = c = null;
  }
  function g(S, E) {
    const {
      minConstraints: P,
      maxConstraints: T,
      lockAspectRatio: N
    } = s;
    if (!P && !T && !N)
      return [S, E];
    if (N) {
      const ue = s.width / s.height, te = S - s.width, K = E - s.height;
      Math.abs(te) > Math.abs(K * ue) ? E = S / ue : S = E * ue;
    }
    const [O, z] = [S, E], [Q, W] = c || [0, 0];
    return S += Q, E += W, P && (S = Math.max(P[0], S), E = Math.max(P[1], E)), T && (S = Math.min(T[0], S), E = Math.min(T[1], E)), c = [Q + (O - S), W + (z - E)], [S, E];
  }
  function v(S, E) {
    return (P, {
      node: T,
      deltaX: N,
      deltaY: O
    }) => {
      var z;
      S === "onResizeStart" && m();
      const Q = (s.axis === "both" || s.axis === "x") && E !== "n" && E !== "s", W = (s.axis === "both" || s.axis === "y") && E !== "e" && E !== "w";
      if (!Q && !W)
        return;
      const ue = E[0], te = E[E.length - 1], K = T.getBoundingClientRect();
      if (u != null) {
        if (te === "w") {
          const yt = K.left - u.left;
          N += yt;
        }
        if (ue === "n") {
          const yt = K.top - u.top;
          O += yt;
        }
      }
      u = K, te === "w" && (N = -N), ue === "n" && (O = -O);
      let ve = s.width + (Q ? N / s.transformScale : 0), ee = s.height + (W ? O / s.transformScale : 0);
      [ve, ee] = g(ve, ee);
      const Re = ve !== s.width || ee !== s.height, wt = typeof s[S] == "function" ? s[S] : null;
      wt && !(S === "onResize" && !Re) && ((z = P.persist) == null || z.call(P), wt(P, {
        node: T,
        size: {
          width: ve,
          height: ee
        },
        handle: E
      })), S === "onResizeStop" && m();
    };
  }
  function b(S, E) {
    const {
      handle: P
    } = s;
    if (!P)
      return createVNode("span", {
        class: `react-resizable-handle react-resizable-handle-${S}`,
        ref: E
      }, null);
    if (typeof P == "function")
      return P(S, E);
    const T = typeof P.type == "string", N = {
      ref: E,
      // Add `handleAxis` prop iff this is not a DOM element,
      // otherwise we'll get an unknown property warning
      ...T ? {} : {
        handleAxis: S
      }
    };
    return cloneVNode(P, N);
  }
  return () => {
    const {
      children: S,
      className: E,
      draggableOpts: P,
      width: T,
      height: N,
      handle: O,
      handleSize: z,
      lockAspectRatio: Q,
      axis: W,
      minConstraints: ue,
      maxConstraints: te,
      onResize: K,
      onResizeStop: ve,
      onResizeStart: ee,
      resizeHandles: Re,
      transformScale: wt,
      ...yt
    } = s;
    return h(Te(S, {
      ...yt,
      class: `${E ? `${E} ` : ""}react-resizable`
    }), [...S.children || [], ...Re.map((xt) => {
      const Kt = l[xt] ?? (l[xt] = ref$1());
      return createVNode(X, mergeProps$1({
        ...P,
        nodeRef: Kt,
        key: `resizableHandle-${xt}`,
        onStop: v("onResizeStop", xt),
        onStart: v("onResizeStart", xt),
        onDrag: v("onResize", xt)
      }, {
        children: b(xt, Kt)
      }), null);
    })]);
  };
});
re$1.props = lt;
re$1.name = "Resizable";
const ct = {
  ...ge,
  children: Ne
}, ut = fe(ct, {}), xe = /* @__PURE__ */ defineComponent((s, {
  expose: o
}) => {
  useSlots();
  const l = reactive({
    width: s.width,
    height: s.height,
    propsWidth: s.width,
    propsHeight: s.height
  });
  function u(m, g) {
    return g.propsWidth !== m.width || g.propsHeight !== m.height ? {
      width: m.width,
      height: m.height,
      propsWidth: m.width,
      propsHeight: m.height
    } : null;
  }
  watch(() => s, () => {
    const m = u(s, l);
    m && Object.keys(m).forEach((g) => {
      l[g] = m[g];
    });
  }, {
    deep: !0
  });
  const c = (m, g) => {
    var v;
    const {
      size: b
    } = g;
    s.onResize ? ((v = m.persist) == null || v.call(m), b && Object.keys(b).forEach((S) => {
      l[S] = b[S];
    }), nextTick(() => {
      s.onResize && s.onResize(m, g);
    })) : b && Object.keys(b).forEach((S) => {
      l[S] = b[S];
    });
  };
  return () => {
    const {
      handle: m,
      handleSize: g,
      onResize: v,
      onResizeStart: b,
      onResizeStop: S,
      draggableOpts: E,
      minConstraints: P,
      maxConstraints: T,
      lockAspectRatio: N,
      axis: O,
      width: z,
      height: Q,
      resizeHandles: W,
      style: ue,
      transformScale: te,
      children: K,
      ...ve
    } = s;
    return createVNode(re$1, {
      axis: O,
      draggableOpts: E,
      handle: m,
      handleSize: g,
      height: l.height,
      lockAspectRatio: N,
      maxConstraints: T,
      minConstraints: P,
      onResizeStart: b,
      onResize: c,
      onResizeStop: S,
      resizeHandles: W,
      transformScale: te,
      width: l.width,
      children: createVNode("div", mergeProps$1(ve, {
        style: {
          ...ue,
          width: l.width + "px",
          height: l.height + "px"
        }
      }), [K])
    }, null);
  };
});
xe.props = ut;
xe.name = "ResizableBox";
const vuePropsType$D = {
  onResize: Function,
  onResizeStart: Function,
  onResizeStop: Function,
  width: [Number, String],
  resize: Boolean
}, ResizableHeaderCell = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$D
  },
  name: "ResizableHeaderCell",
  setup(s, {
    attrs: o
  }) {
    const l = useSlots();
    return () => {
      var P;
      const {
        onResize: u,
        onResizeStart: c,
        onResizeStop: m,
        width: g,
        resize: v,
        ...b
      } = s, S = lodashExports.omit(o, "onResize", "onResizeStart", "onResizeStop", "width");
      if (typeof g != "number" || v === !1)
        return createVNode("th", S, null);
      let E = (P = l.default) == null ? void 0 : P.call(l);
      return E = E.map((T, N) => createVNode(Fragment, {
        key: N
      }, [T])), // @ts-ignore
      createVNode(re$1, {
        width: g,
        height: 0,
        onResize: u,
        onResizeStart: c,
        onResizeStop: m,
        draggableOpts: {
          enableUserSelectHack: !1
        },
        children: createVNode("th", S, [E]),
        axis: "x"
      }, null);
    };
  }
}), Table$2 = Table$3(), vuePropsType$C = {
  bordered: bool,
  children: element$2,
  childrenRecordName: string$3,
  className: string$3,
  clickGroupedRowToExpand: bool,
  columns: array$1,
  components: element$2,
  dataSource: array$1,
  defaultExpandAllGroupRows: bool,
  defaultExpandAllRows: bool,
  defaultExpandedRowKeys: array$1,
  empty: element$2,
  expandAllGroupRows: bool,
  expandAllRows: bool,
  expandCellFixed: bool,
  expandIcon: element$2,
  expandedRowKeys: array$1,
  expandedRowRender: func,
  expandRowByClick: bool,
  footer: element$2,
  getVirtualizedListRef: element$2,
  groupBy: element$2,
  hideExpandedColumn: bool,
  id: string$3,
  indentSize: number$2,
  loading: bool,
  pagination: object$1,
  prefixCls: string$3,
  renderGroupSection: element$2,
  renderPagination: element$2,
  resizable: [bool, object$1],
  rowExpandable: any$1,
  rowKey: string$3,
  rowSelection: element$2,
  scroll: any$1,
  showHeader: bool,
  size: object$1,
  style: object$1,
  title: element$2,
  virtualized: bool,
  onChange: func,
  onExpand: func,
  onExpandedRowsChange: func,
  onGroupedRow: func,
  onHeaderRow: func,
  onRow: func,
  sticky: element$2,
  direction: string$3,
  bodyWrapperRef: [func, object$1],
  keepDOM: bool
}, ResizableTable = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$C
  },
  name: "ResizableTable",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    const l = "children", u = ref$1([]);
    watch([() => s.columns, () => s.expandedRowRender, () => s.hideExpandedColumn, () => s.rowSelection], () => {
      const {
        components: P,
        columns: T,
        resizable: N,
        ...O
      } = o(s), z = Array.isArray(T) && T.length ? T : getColumns(s.children), Q = assignColumnKeys(cloneDeep$1(z), l), W = assignColumnKeys(cloneDeep$1(z), l);
      typeof s.expandedRowRender == "function" && !s.hideExpandedColumn && !lodashExports.find(Q, (K) => K.key === strings$2.DEFAULT_KEY_COLUMN_EXPAND) && W.unshift({
        key: strings$2.DEFAULT_KEY_COLUMN_EXPAND,
        width: numbers$2.DEFAULT_WIDTH_COLUMN_EXPAND
      }), s.rowSelection && !lodashExports.get(s.rowSelection, "hidden") && !lodashExports.find(Q, (K) => K.key === strings$2.DEFAULT_KEY_COLUMN_SELECTION) && W.unshift({
        width: lodashExports.get(s, "rowSelection.width", numbers$2.DEFAULT_WIDTH_COLUMN_SELECTION),
        key: strings$2.DEFAULT_KEY_COLUMN_SELECTION
      });
      const ue = Array.from(u.value), te = withResizeWidth(ue, W);
      u.value = mergeColumns(ue, te);
    }, {
      deep: !0,
      immediate: !0
    });
    const c = computed(() => lodashExports.merge({
      header: {
        cell: ResizableHeaderCell
      }
    }, s.components)), m = (P) => (T, {
      size: N
    }) => {
      const O = lodashExports.get(s.resizable, "onResize", lodashExports.noop), z = cloneDeep$1(u.value), Q = findColumn(z, P, l);
      let W = {
        ...Q,
        width: N.width
      };
      const ue = O(W) || {};
      W = {
        ...W,
        ...ue
      }, Object.assign(Q, W), u.value = z;
    }, g = (P) => (T) => {
      const N = lodashExports.get(s.resizable, "onResizeStart", lodashExports.noop), O = lodashExports.get(s.resizable, "handlerClassName", "resizing"), z = cloneDeep$1(u.value), Q = findColumn(z, P, l);
      let W = {
        ...Q,
        className: addClass(Q.className, O)
      };
      const ue = N(W) || {};
      W = {
        ...W,
        ...ue
      }, Object.assign(Q, W), u.value = z;
    }, v = (P) => (T) => {
      const N = lodashExports.get(s.resizable, "onResizeStop", lodashExports.noop), O = lodashExports.get(s.resizable, "handlerClassName", "resizing"), z = cloneDeep$1(u.value), Q = findColumn(z, P, l);
      let W = {
        ...Q,
        className: removeClass(Q.className, O)
      };
      const ue = N(W) || {};
      W = {
        ...W,
        ...ue
      }, Object.assign(Q, W), u.value = z;
    }, b = (P, T, N = 0, O) => ({
      ...P,
      onHeaderCell: (z) => ({
        ...O,
        width: z.width,
        onResize: m(z),
        onResizeStart: g(z),
        onResizeStop: v(z)
      })
    }), S = (P = [], T = 0) => Array.isArray(P) && P.length ? P.map((N, O) => {
      var W;
      const z = ((W = N.onHeaderCell) == null ? void 0 : W.call(N, N, O, T)) ?? {};
      Object.assign(N, b(N, O, T, z));
      const Q = N[l];
      return Array.isArray(Q) && Q.length && (N[l] = S(Q, T + 1)), N;
    }) : [], E = ref$1([]);
    return watch(u, () => {
      E.value = S(u.value);
    }, {
      immediate: !0
    }), () => {
      const {
        components: P,
        columns: T,
        resizable: N,
        ...O
      } = o(s);
      return createVNode(Table$2, mergeProps$1(O, {
        columns: E.value,
        components: c.value
      }), null);
    };
  }
}), propTypes$k = {
  ...propTypes$l,
  resizable: [bool, object$1]
}, defaultProps$g = {
  hideExpandedColumn: !0
};
function Table() {
  const s = Table$3(), o = vuePropsMake(propTypes$k, defaultProps$g);
  return /* @__PURE__ */ defineComponent({
    props: {
      ...o
    },
    name: "TableIndex",
    setup(u, {
      expose: c
    }) {
      const {
        getProps: m
      } = useHasInProps(), g = useSlots(), v = ref$1(), {
        context: b
      } = useConfigContext();
      return c({
        getCurrentPageData: () => v.value && v.value.getCurrentPageData()
      }), () => {
        const E = u.direction ?? b.value.direction, P = getFragmentChildren(g);
        return u.resizable ? createVNode(ResizableTable, mergeProps$1(m(u), {
          children: P,
          ref: v,
          direction: E
        }), null) : createVNode(s, mergeProps$1(m(u), {
          children: P,
          ref: v,
          direction: E
        }), null);
      };
    }
  });
}
const Table_ = Table(), Table$1 = Table_, cssClasses$9 = {
  TABS: `${BASE_CLASS_PREFIX$1}-tabs`,
  TABS_BAR: `${BASE_CLASS_PREFIX$1}-tabs-bar`,
  TABS_BAR_LINE: `${BASE_CLASS_PREFIX$1}-tabs-bar-line`,
  TABS_BAR_CARD: `${BASE_CLASS_PREFIX$1}-tabs-bar-card`,
  TABS_BAR_BUTTON: `${BASE_CLASS_PREFIX$1}-tabs-bar-button`,
  TABS_BAR_EXTRA: `${BASE_CLASS_PREFIX$1}-tabs-bar-extra`,
  TABS_TAB: `${BASE_CLASS_PREFIX$1}-tabs-tab`,
  TABS_TAB_ACTIVE: `${BASE_CLASS_PREFIX$1}-tabs-tab-active`,
  TABS_TAB_DISABLED: `${BASE_CLASS_PREFIX$1}-tabs-tab-disabled`,
  TABS_CONTENT: `${BASE_CLASS_PREFIX$1}-tabs-content`,
  TABS_CONTENT_ANIMATED: `${BASE_CLASS_PREFIX$1}-tabs-content-animated`,
  TABS_CONTENT_NO_ANIMATED: `${BASE_CLASS_PREFIX$1}-tabs-content-no-animated`,
  TABS_PANE: `${BASE_CLASS_PREFIX$1}-tabs-pane`,
  TABS_PANE_INACTIVE: `${BASE_CLASS_PREFIX$1}-tabs-pane-inactive`,
  TABS_PANE_ACTIVE: `${BASE_CLASS_PREFIX$1}-tabs-pane-active`,
  TABS_PANE_MOTION_OVERLAY: `${BASE_CLASS_PREFIX$1}-tabs-pane-motion-overlay`,
  TABS_PANE_ANIMATING: `${BASE_CLASS_PREFIX$1}-tabs-pane-animating`,
  TABS_PANE_ANIMATE_LEFT_SHOW: `${BASE_CLASS_PREFIX$1}-tabs-pane-animate-leftShow`,
  TABS_PANE_ANIMATE_RIGHT_SHOW: `${BASE_CLASS_PREFIX$1}-tabs-pane-animate-rightShow`,
  TABS_PANE_ANIMATE_TOP_SHOW: `${BASE_CLASS_PREFIX$1}-tabs-pane-animate-topShow`,
  TABS_PANE_ANIMATE_BOTTOM_SHOW: `${BASE_CLASS_PREFIX$1}-tabs-pane-animate-bottomShow`
};
class TabsFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.destroy = lodashExports.noop, this.handlePrevent = (l) => {
      l.stopPropagation(), l.preventDefault();
    }, this.handleKeyDown = (l, u, c) => {
      const { preventScroll: m } = this.getProps(), g = [...l.target.parentNode.childNodes].filter((v) => lodashExports.get(v, "attributes.data-tabkey.value", "").includes("semiTab") && lodashExports.get(v, "attributes.aria-disabled.value", "") !== "true");
      switch (l.key) {
        case "ArrowLeft":
        case "ArrowRight":
        case "ArrowUp":
        case "ArrowDown":
          this.determineOrientation(l, g);
          break;
        case "Backspace":
        case "Delete":
          this.handleDeleteKeyDown(l, g, u, c);
          break;
        case "Enter":
        case " ":
          this.handleTabClick(u, l), this.handlePrevent(l);
          break;
        case "Home":
          g[0].focus({ preventScroll: m }), this.handlePrevent(l);
          break;
        case "End":
          g[g.length - 1].focus({ preventScroll: m }), this.handlePrevent(l);
          break;
      }
    };
  }
  init() {
    this._adapter.collectPane();
  }
  _notifyChange(o) {
    const { activeKey: l } = this.getStates();
    l !== o && this._adapter.notifyChange(o);
  }
  handleTabClick(o, l) {
    this._isInProps("activeKey") ? this._notifyChange(o) : (this._notifyChange(o), this.handleNewActiveKey(o)), this._adapter.notifyTabClick(o, l);
  }
  handleNewActiveKey(o) {
    const { activeKey: l } = this.getStates();
    l !== o && this._adapter.setNewActiveKey(o);
  }
  getDefaultActiveKey() {
    let o;
    const l = this.getProps();
    return "activeKey" in l ? o = l.activeKey : "defaultActiveKey" in l ? o = l.defaultActiveKey : o = this._adapter.getDefaultActiveKeyFromChildren(), o;
  }
  handleTabListChange() {
    this._adapter.collectPane();
  }
  handleTabPanesChange() {
    this._adapter.collectPane(), this._adapter.collectActiveKey();
  }
  handleTabDelete(o) {
    this._adapter.notifyTabDelete(o);
  }
  determineOrientation(o, l) {
    const { tabPosition: u } = this.getProps();
    u === "left" ? (o.key === "ArrowUp" || o.key === "ArrowDown") && (this.switchTabOnArrowPress(o, l), this.handlePrevent(o)) : (o.key === "ArrowLeft" || o.key === "ArrowRight") && (this.switchTabOnArrowPress(o, l), this.handlePrevent(o));
  }
  handleDeleteKeyDown(o, l, u, c) {
    const { preventScroll: m } = this.getProps();
    if (c) {
      this.handleTabDelete(u);
      const g = l.indexOf(o.target);
      l.length !== 1 && l[g + 1 >= l.length ? g - 1 : g + 1].focus({ preventScroll: m });
    }
  }
  switchTabOnArrowPress(o, l) {
    const { preventScroll: u } = this.getProps(), c = l.indexOf(o.target), m = {
      ArrowLeft: -1,
      ArrowUp: -1,
      ArrowRight: 1,
      ArrowDown: 1
    };
    m[o.key] && c !== void 0 && (l[c + m[o.key]] ? l[c + m[o.key]].focus({ preventScroll: u }) : o.key === "ArrowLeft" || o.key === "ArrowUp" ? l[l.length - 1].focus({ preventScroll: u }) : (o.key === "ArrowRight" || o.key == "ArrowDown") && l[0].focus({ preventScroll: u }));
  }
}
const propTypes$j = {
  tab: node$1,
  icon: node$1,
  size: string$3,
  type: string$3,
  tabPosition: string$3,
  selected: bool,
  closable: bool,
  disabled: bool,
  itemKey: string$3,
  handleKeyDown: func,
  deleteTabItem: func,
  onClick: func,
  forwardRef: [object$1, func]
}, vuePropsType$B = vuePropsMake(propTypes$j, {}), TabItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$B
  },
  name: "Tabs.TabItem",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = computed(() => s.type === "card" && s.closable ? createVNode(IconComponent$u, {
      "aria-label": "Close",
      role: "button",
      className: `${cssClasses$9.TABS_TAB}-icon-close`,
      onClick: (g) => s.deleteTabItem(s.itemKey, g)
    }, null) : null), u = (g) => createVNode("span", null, [g]), c = (g) => {
      s.handleKeyDown && s.handleKeyDown(g, s.itemKey, s.closable);
    }, m = (g) => {
      !s.disabled && s.onClick && s.onClick(s.itemKey, g);
    };
    return () => {
      const {
        tab: g,
        size: v,
        type: b,
        icon: S,
        selected: E,
        closable: P,
        disabled: T,
        itemKey: N,
        deleteTabItem: O,
        tabPosition: z,
        handleKeyDown: Q,
        onClick: W,
        ...ue
      } = s, te = S ? u(S) : null, K = cls(cssClasses$9.TABS_TAB, `${cssClasses$9.TABS_TAB}-${b}`, `${cssClasses$9.TABS_TAB}-${z}`, `${cssClasses$9.TABS_TAB}-single`, {
        [cssClasses$9.TABS_TAB_ACTIVE]: E,
        [cssClasses$9.TABS_TAB_DISABLED]: T,
        [`${cssClasses$9.TABS_TAB}-small`]: v === "small",
        [`${cssClasses$9.TABS_TAB}-medium`]: v === "medium"
      });
      return createVNode("div", mergeProps$1({
        role: "tab",
        id: `semiTab${N}`,
        "data-tabkey": `semiTab${N}`,
        "aria-controls": `semiTabPanel${N}`,
        "aria-disabled": T ? "true" : "false",
        "aria-selected": E ? "true" : "false",
        tabindex: E ? 0 : -1,
        onKeydown: c,
        onClick: m,
        class: K
      }, ue, {
        ref: s.forwardRef
      }), [te, g, l.value]);
    };
  }
});
function _isSlot$5(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const propTypes$i = {
  activeKey: string$3,
  className: string$3,
  collapsible: bool,
  list: array$1,
  onTabClick: func,
  size: string$3,
  style: object$1,
  tabBarExtraContent: node$1,
  tabPosition: string$3,
  type: string$3,
  closable: bool,
  deleteTabItem: func,
  more: oneOfType([number$2, object$1]),
  handleKeyDown: func,
  showRestInDropdown: bool,
  dropdownClassName: string$3,
  dropdownStyle: object$1,
  onVisibleTabsChange: func,
  visibleTabsStyle: object$1,
  arrowPosition: string$3,
  renderArrow: func
}, vuePropsType$A = vuePropsMake(propTypes$i, {}), TabBar = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$A
  },
  name: "TabBar",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = reactive({
      endInd: s.list.length,
      rePosKey: 0,
      startInd: 0,
      uuid: "",
      currentVisibleItems: []
    });
    onMounted(() => {
      l.uuid = getUuidv4();
    }), watch(() => s.activeKey, () => {
      s.collapsible && S();
    });
    function u(K) {
      return createVNode("span", null, [K]);
    }
    function c() {
      const {
        tabBarExtraContent: K,
        type: ve,
        size: ee
      } = s, Re = {
        float: "right"
      }, wt = K && K.props ? K.props.style : {}, yt = cls(cssClasses$9.TABS_BAR_EXTRA, {
        [`${cssClasses$9.TABS_BAR}-${ve}-extra`]: ve,
        [`${cssClasses$9.TABS_BAR}-${ve}-extra-${ee}`]: ee
      });
      if (K) {
        const xt = {
          ...Re,
          ...wt
        };
        return createVNode("div", {
          class: yt,
          style: xt,
          "x-semi-prop": "tabBarExtraContent"
        }, [K]);
      }
      return null;
    }
    const m = (K, ve) => {
      s.onTabClick(K, ve);
    }, g = (K) => {
      const {
        size: ve,
        type: ee,
        deleteTabItem: Re,
        handleKeyDown: wt,
        tabPosition: yt
      } = s, xt = z(K.itemKey);
      return createVNode(TabItem, mergeProps$1(lodashExports.pick(K, ["disabled", "icon", "itemKey", "tab", "closable"]), {
        key: Q(K.itemKey),
        selected: xt,
        size: ve,
        type: ee,
        tabPosition: yt,
        handleKeyDown: wt,
        deleteTabItem: Re,
        onClick: m
      }), null);
    }, v = ref$1(), b = (K, ve = "nearest") => {
      const ee = v.value.querySelector(`[data-uuid="${l.uuid}"] .${cssClasses$9.TABS_TAB}[data-scrollkey=${JSON.stringify(K)}]`);
      ee == null || ee.scrollIntoView({
        behavior: "smooth",
        block: ve,
        inline: ve
      });
    }, S = (K) => {
      const ve = Q(s.activeKey);
      b(ve, K);
    }, E = (K) => K.map((ve) => g(ve)), P = (K, ve) => {
      const ee = ve === "start" ? K.pop() : K.shift();
      if (!ee)
        return;
      const Re = Q(ee.itemKey);
      b(Re);
    }, T = (K, ve, ee) => {
      let Re;
      const wt = cls({
        [`${cssClasses$9.TABS_BAR}-arrow-${ee}`]: ee,
        [`${cssClasses$9.TABS_BAR}-arrow`]: !0
      });
      if (lodashExports.isEmpty(K))
        return createVNode("div", {
          role: "presentation",
          class: wt
        }, [createVNode(Button$2, {
          disabled: !0,
          icon: ve,
          theme: "borderless"
        }, null)]);
      const {
        dropdownClassName: yt,
        dropdownStyle: xt,
        showRestInDropdown: Kt
      } = s, {
        rePosKey: tn
      } = l, ln = !K.length, rn = createVNode(DropdownMenu$1, null, _isSlot$5(Re = K.map((nn) => {
        const {
          icon: vt,
          tab: Et,
          itemKey: Qt
        } = nn, un = vt ? u(nn.icon) : null;
        return createVNode(DropdownItem$1, {
          key: Qt,
          onClick: (gn) => m(Qt, gn),
          active: z(Qt)
        }, {
          default: () => [un, Et]
        });
      })) ? Re : {
        default: () => [Re]
      }), an = createVNode("div", {
        role: "presentation",
        class: wt,
        onClick: (nn) => P(K, ee)
      }, [createVNode(Button$2, {
        disabled: ln,
        icon: ve,
        theme: "borderless"
      }, null)]), Gt = cls(yt, {
        [`${cssClasses$9.TABS_BAR}-dropdown`]: !0
      });
      return createVNode(Fragment, null, [Kt ? createVNode(BaseDropdown, {
        className: Gt,
        clickToHide: !0,
        clickTriggerToHide: !0,
        key: `${tn}-${ee}`,
        position: ee === "start" ? "bottomLeft" : "bottomRight",
        render: ln ? null : rn,
        showTick: !0,
        style: xt,
        trigger: "hover",
        disableFocusListener: !0
      }, _isSlot$5(an) ? an : {
        default: () => [an]
      }) : an]);
    }, N = (K) => K.map((ve, ee) => {
      const Re = ee === 0 ? "start" : "end";
      if (s.renderArrow)
        return s.renderArrow(ve, Re, () => P(ve, Re));
      const wt = ee === 0 ? createVNode(IconComponent$z, null, null) : createVNode(IconComponent$y, null, null);
      return T(ve, wt, Re);
    }), O = () => {
      const {
        list: K
      } = s, ve = K.map((ee) => {
        const {
          itemKey: Re
        } = ee;
        return {
          key: Q(Re),
          active: z(Re),
          ...ee
        };
      });
      return createVNode(OverflowList$1, {
        items: ve,
        overflowRenderDirection: s.arrowPosition,
        wrapperStyle: s.visibleTabsStyle,
        overflowRenderer: N,
        renderMode: "scroll",
        className: `${cssClasses$9.TABS_BAR}-overflow-list`,
        visibleItemRenderer: g,
        onVisibleStateChange: (ee) => {
          var wt;
          const Re = /* @__PURE__ */ new Map();
          ee.forEach((yt, xt) => {
            Re.set(W(xt), yt);
          }), (wt = s.onVisibleTabsChange) == null || wt.call(s, Re);
        }
      }, null);
    }, z = (K) => K === s.activeKey, Q = (K) => `${K}-bar`, W = (K) => K.replace(/-bar$/, ""), ue = () => {
      const {
        list: K,
        more: ve
      } = s;
      let ee = [], Re = createVNode("div", {
        class: cls({
          [`${cssClasses$9.TABS_BAR}-more-trigger`]: !0,
          [`${cssClasses$9.TABS_BAR}-more-trigger-${s.type}`]: !0
        })
      }, [createVNode(LocaleConsumer$6, {
        componentName: "Tabs"
      }, {
        default: (yt, xt) => createVNode("div", {
          class: `${cssClasses$9.TABS_BAR}-more-trigger-content`
        }, [createVNode("div", null, [yt.more]), createVNode(IconComponent$A, {
          className: `${cssClasses$9.TABS_BAR}-more-trigger-content-icon`
        }, null)])
      })]), wt;
      if (typeof ve == "number")
        wt = K.length - Math.min(ve, K.length), ee = K.slice(0, wt).map((yt) => g(yt));
      else if (typeof ve == "object")
        wt = K.length - Math.min(ve.count, K.length), ee = K.slice(0, wt).map((yt) => g(yt)), ve.render && (Re = ve.render());
      else if (ve !== void 0)
        throw new Error("[Semi Tabs]: invalid tab props format: more");
      return createVNode(Fragment, null, [ee, te(K.slice(wt), ve == null ? void 0 : ve.dropdownProps, Re)]);
    }, te = (K, ve, ee) => createVNode(BaseDropdown, mergeProps$1({
      trigger: "hover",
      showTick: !0,
      position: "bottomLeft",
      className: `${cssClasses$9.TABS_BAR}-more-dropdown-${s.type}`,
      clickToHide: !0,
      menu: K.map((Re) => ({
        node: "item",
        name: Re.tab,
        icon: Re.icon,
        onClick: (wt) => s.onTabClick(Re.itemKey, wt),
        active: s.activeKey === Re.itemKey
      }))
    }, ve), _isSlot$5(ee) ? ee : {
      default: () => [ee]
    });
    return () => {
      const {
        type: K,
        style: ve,
        className: ee,
        list: Re,
        tabPosition: wt,
        more: yt,
        collapsible: xt,
        handleKeyDown: Kt,
        ...tn
      } = s, ln = cls(ee, {
        [cssClasses$9.TABS_BAR]: !0,
        [cssClasses$9.TABS_BAR_LINE]: K === "line",
        [cssClasses$9.TABS_BAR_CARD]: K === "card",
        [cssClasses$9.TABS_BAR_BUTTON]: K === "button",
        [`${cssClasses$9.TABS_BAR}-${wt}`]: wt,
        [`${cssClasses$9.TABS_BAR}-collapse`]: xt
      }), rn = c(), an = xt ? O() : yt ? ue() : E(Re);
      return createVNode("div", mergeProps$1({
        role: "tablist",
        ref: v,
        "aria-orientation": wt === "left" ? "vertical" : "horizontal",
        class: ln,
        style: ve
      }, getDataAttr(tn), {
        "data-uuid": l.uuid
      }), [an, rn]);
    };
  }
});
function useTabsContext() {
  return {
    context: inject("TabsContext", ref$1({}))
  };
}
const vuePropsType$z = {
  name: String
}, Consumer$5 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useTabsContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$z
  },
  name: "TabsContextConsumer"
}), propTypes$h = {
  className: string$3,
  style: object$1,
  children: node$1,
  disabled: bool,
  itemKey: string$3,
  tab: node$1,
  icon: node$1,
  closable: bool,
  tabIndex: number$2
}, vuePropsType$y = vuePropsMake(propTypes$h, {}), TabPane = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$y
  },
  name: "TabPane",
  isTabPane: !0,
  setup(s, {}) {
    const o = useSlots(), {
      context: l
    } = useTabsContext();
    let u;
    const c = (g, v, b, S) => {
      if (v !== null && g !== null && Array.isArray(b) && b.length) {
        const E = b.findIndex((N) => N.itemKey === g), P = b.findIndex((N) => N.itemKey === v), T = b.findIndex((N) => N.itemKey === S);
        return E === P ? T > E : P < E;
      }
      return !1;
    }, m = () => {
      const {
        itemKey: g
      } = s, {
        activeKey: v,
        lazyRender: b
      } = l.value;
      return u = u || v === g, b ? u : !0;
    };
    return () => {
      var ve;
      const g = (ve = o.default) == null ? void 0 : ve.call(o), {
        tabPaneMotion: v,
        tabPosition: b,
        prevActiveKey: S
      } = l.value, {
        className: E,
        style: P,
        itemKey: T,
        tabIndex: N,
        ...O
      } = s, z = l.value.activeKey === T, Q = cls(E, {
        [cssClasses$9.TABS_PANE_INACTIVE]: !z,
        [cssClasses$9.TABS_PANE_ACTIVE]: z,
        [cssClasses$9.TABS_PANE]: !0
      }), W = m(), ue = (() => {
        const ee = c(l.value.activeKey, T, l.value.panes, S);
        return b === "top" ? ee ? cssClasses$9.TABS_PANE_ANIMATE_RIGHT_SHOW : cssClasses$9.TABS_PANE_ANIMATE_LEFT_SHOW : ee ? cssClasses$9.TABS_PANE_ANIMATE_BOTTOM_SHOW : cssClasses$9.TABS_PANE_ANIMATE_TOP_SHOW;
      })(), te = !l.value.panes.find((ee) => ee.itemKey === S), K = v && z && !te && !l.value.forceDisableMotion;
      return createVNode("div", mergeProps$1({
        role: "tabpanel",
        id: `semiTabPanel${T}`,
        key: `semiTabPanel${T}`,
        "aria-labelledby": `semiTab${T}`,
        class: Q,
        style: P,
        "aria-hidden": z ? "false" : "true",
        tabindex: N || 0
      }, getDataAttr(O), {
        "x-semi-prop": "children"
      }), [createVNode(CSSAnimation, {
        motion: K,
        animationState: z ? "enter" : "leave",
        startClassName: ue,
        children: ({
          animationClassName: ee,
          animationEventsNeedBind: Re
        }) => createVNode("div", mergeProps$1({
          class: cls(cssClasses$9.TABS_PANE_MOTION_OVERLAY, ee),
          "x-semi-prop": "children"
        }, Re), [W ? g : null])
      }, null)]);
    };
  }
}), TabPane$1 = TabPane, vuePropsType$x = {
  value: Object
}, Provider$5 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0,
    immediate: !0
  }), provide("TabsContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$x
  },
  name: "TabsContextProvider"
}), TabsContext = {
  Provider: Provider$5,
  Consumer: Consumer$5
}, panePickKeys = ["className", "style", "disabled", "itemKey", "tab", "icon"], propTypes$g = {
  activeKey: string$3,
  className: string$3,
  collapsible: bool,
  contentStyle: oneOfType([object$1]),
  defaultActiveKey: string$3,
  keepDOM: bool,
  lazyRender: bool,
  onChange: func,
  onTabClick: func,
  renderTabBar: func,
  showRestInDropdown: bool,
  size: string$3,
  style: object$1,
  tabBarClassName: string$3,
  tabBarExtraContent: node$1,
  tabBarStyle: object$1,
  tabList: array$1,
  tabPaneMotion: bool,
  tabPosition: string$3,
  type: string$3,
  onTabClose: func,
  preventScroll: bool,
  more: oneOfType([number$2, object$1]),
  arrowPosition: string$3,
  renderArrow: func,
  onVisibleTabsChange: func,
  visibleTabsStyle: object$1
}, defaultProps$f = {
  // children: [],
  collapsible: !1,
  keepDOM: !0,
  lazyRender: !1,
  onChange: () => {
  },
  onTabClick: () => {
  },
  size: "large",
  tabPaneMotion: !0,
  tabPosition: "top",
  type: "line",
  onTabClose: () => {
  },
  showRestInDropdown: !0,
  arrowPosition: "both"
}, vuePropsType$w = vuePropsMake(propTypes$g, defaultProps$f), Tabs = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$w
  },
  name: "Tabs",
  setup(s, {}) {
    const o = useSlots(), l = ref$1(), u = shallowRef([]), c = reactive({
      activeKey: "",
      panes: P(),
      prevActiveKey: null,
      forceDisableMotion: !1
    }), {
      adapter: m
    } = useBaseComponent(s, c);
    function g() {
      return {
        ...m(),
        collectPane: () => {
          const z = P();
          c.panes = z;
        },
        collectActiveKey: () => {
          const {
            tabList: z,
            activeKey: Q
          } = s;
          if (typeof Q < "u")
            return;
          const {
            activeKey: W
          } = c, ue = P();
          ue.findIndex((te) => te.itemKey === W) === -1 && (ue.length > 0 ? c.activeKey = ue[0].itemKey : c.activeKey = "");
        },
        notifyTabClick: (z, Q) => {
          s.onTabClick(z, Q);
        },
        notifyChange: (z) => {
          s.onChange(z);
        },
        setNewActiveKey: (z) => {
          c.activeKey = z;
        },
        getDefaultActiveKeyFromChildren: () => {
          const {
            tabList: z
          } = s;
          let Q = "";
          return (z || u.value.map((ue) => isVNode(ue) ? ue.props : null)).forEach((ue) => {
            ue && !Q && !ue.disabled && (Q = ue.itemKey);
          }), Q;
        },
        notifyTabDelete: (z) => {
          s.onTabClose && s.onTabClose(z);
        }
      };
    }
    const v = g(), b = new TabsFoundation(v);
    c.activeKey = b.getDefaultActiveKey();
    function S(z) {
      const Q = {};
      return !isNullOrUndefined(z.activeKey) && z.activeKey !== c.activeKey && (c.prevActiveKey = c.activeKey, Q.activeKey = z.activeKey), Q;
    }
    watch([() => s.activeKey, () => c.activeKey], () => {
      const z = S({
        ...s
      });
      z && Object.keys(z).forEach((Q) => {
        c[Q] = z[Q];
      });
    }), watch([() => u.value, () => s.tabList, () => s.activeKey, () => c.activeKey], (z, [Q, W, ue, te]) => {
      const K = (Q || []).map((Re) => lodashExports.pick(isVNode(Re) ? Re.props : null, panePickKeys)), ve = (u.value || []).map((Re) => lodashExports.pick(isVNode(Re) ? Re.props : null, panePickKeys)), ee = s.tabList || W;
      if (lodashExports.isEqual(s.tabList, W) || b.handleTabListChange(), te !== c.activeKey && te !== c.prevActiveKey && (c.prevActiveKey = te), ue !== s.activeKey) {
        const Re = (() => {
          const wt = new Set(K.map((yt) => yt.itemKey));
          return ve.map((yt) => yt.itemKey).filter((yt) => !wt.has(yt));
        })();
        c.forceDisableMotion = Re.includes(s.activeKey);
      }
      !lodashExports.isEqual(K, ve) && !ee && b.handleTabPanesChange();
    });
    const E = (z) => {
      l.value = z;
    };
    function P() {
      const {
        tabList: z
      } = s;
      return Array.isArray(z) && z.length ? z : u.value.filter((Q) => {
        var W;
        return typeof Q.type != "symbol" && ((W = Q.type) == null ? void 0 : W.name) === "TabPane";
      }).map((Q) => {
        if (Q) {
          const {
            tab: W,
            icon: ue,
            disabled: te,
            itemKey: K,
            closable: ve
          } = Q.props;
          return {
            tab: W,
            icon: ue,
            disabled: te,
            itemKey: K,
            closable: ve
          };
        }
      });
    }
    const T = (z, Q) => {
      b.handleTabClick(z, Q);
    }, N = () => {
      const {
        activeKey: z
      } = c, {
        tabList: Q
      } = s;
      return Q || !Array.isArray(u.value) ? u.value : u.value.filter((W) => isVNode(W) && W.type && W.type.isTabPane ? W.props.itemKey === z : !0);
    }, O = (z, Q) => {
      Q.stopPropagation(), b.handleTabDelete(z);
    };
    return () => {
      var Nn;
      const z = (Nn = o.default) == null ? void 0 : Nn.call(o), Q = getFragmentChildren(o);
      (Q.length !== u.value.length || !lodashExports.isEqual(Q.map((Un) => Un.props), u.value.map((Un) => Un.props))) && (u.value = Q);
      const {
        className: W,
        collapsible: ue,
        contentStyle: te,
        keepDOM: K,
        lazyRender: ve,
        renderTabBar: ee,
        showRestInDropdown: Re,
        size: wt,
        style: yt,
        tabBarClassName: xt,
        tabBarExtraContent: Kt,
        tabBarStyle: tn,
        tabPaneMotion: ln,
        tabPosition: rn,
        type: an,
        more: Gt,
        onVisibleTabsChange: nn,
        visibleTabsStyle: vt,
        arrowPosition: Et,
        renderArrow: Qt,
        ...un
      } = s, {
        panes: gn,
        activeKey: dn
      } = c, yn = cls(W, {
        [cssClasses$9.TABS]: !0,
        [`${cssClasses$9.TABS}-${rn}`]: rn
      }), vn = cls({
        [cssClasses$9.TABS_CONTENT]: !0,
        [`${cssClasses$9.TABS_CONTENT}-${rn}`]: rn
      }), Pn = {
        activeKey: dn,
        className: xt,
        collapsible: ue,
        list: gn,
        onTabClick: T,
        showRestInDropdown: Re,
        size: wt,
        style: tn,
        tabBarExtraContent: Kt,
        tabPosition: rn,
        type: an,
        deleteTabItem: O,
        handleKeyDown: b.handleKeyDown,
        more: Gt,
        onVisibleTabsChange: nn,
        visibleTabsStyle: vt,
        arrowPosition: Et,
        renderArrow: Qt
      }, On = ee ? ee(Pn, TabBar) : createVNode(TabBar, Pn, null), _n = K ? z : N();
      return createVNode("div", mergeProps$1({
        class: yn,
        style: yt
      }, getDataAttr(un)), [On, createVNode(TabsContext.Provider, {
        value: {
          activeKey: dn,
          lazyRender: ve,
          panes: gn,
          tabPaneMotion: ln,
          tabPosition: rn,
          prevActiveKey: c.prevActiveKey,
          forceDisableMotion: c.forceDisableMotion
        }
      }, {
        default: () => [createVNode("div", {
          ref: E,
          class: vn,
          style: {
            ...te
          }
        }, [_n])]
      })]);
    };
  }
}), Tabs$1 = Tabs, cssClasses$8 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-timeline`,
  ITEM: `${BASE_CLASS_PREFIX$1}-timeline-item`
}, prefixCls$9 = cssClasses$8.ITEM, propTypes$f = {
  color: string$3,
  time: node$1,
  type: string$3,
  dot: node$1,
  extra: node$1,
  position: string$3,
  className: string$3,
  style: object$1,
  onClick: func
}, defaultProps$e = {
  type: "default",
  time: "",
  onClick: lodashExports.noop
}, vuePropsType$v = vuePropsMake(propTypes$f, defaultProps$e), TimelineItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$v
  },
  name: "TimelineItem",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs();
    return () => {
      var Q;
      const u = (Q = o.default) == null ? void 0 : Q.call(o), {
        className: c,
        color: m,
        dot: g,
        type: v,
        style: b,
        time: S,
        extra: E,
        onClick: P,
        ...T
      } = s, N = cls(prefixCls$9, c), O = cls({
        [`${prefixCls$9}-head`]: !0,
        [`${prefixCls$9}-head-custom`]: g,
        [`${prefixCls$9}-head-${v}`]: v
      }), z = m ? {
        style: {
          backgroundColor: m
        }
      } : null;
      return createVNode("li", mergeProps$1({
        class: N,
        style: b,
        onClick: P
      }, getDataAttr({
        ...T,
        ...l
      })), [createVNode("div", {
        class: `${prefixCls$9}-tail`,
        "aria-hidden": !0
      }, null), createVNode("div", mergeProps$1({
        class: O,
        "aria-hidden": !0
      }, z), [g]), createVNode("div", {
        class: `${prefixCls$9}-content`
      }, [u, E && createVNode("div", {
        class: `${prefixCls$9}-content-extra`
      }, [E]), S && createVNode("div", {
        class: `${prefixCls$9}-content-time`
      }, [S])])]);
    };
  }
}), Item = TimelineItem, prefixCls$8 = cssClasses$8.PREFIX, propTypes$e = {
  mode: string$3,
  className: string$3,
  style: object$1,
  dataSource: array$1,
  "aria-label": string$3
}, defaultProps$d = {
  mode: "left"
}, vuePropsType$u = vuePropsMake(propTypes$e, defaultProps$d), Timeline = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$u
  },
  name: "Timeline",
  setup(s, {}) {
    const o = useSlots(), l = useAttrs(), u = (m, g) => {
      const {
        mode: v
      } = s;
      return v === "alternate" ? m.props.position ? `${prefixCls$8}-item-${m.props.position}` : g % 2 === 0 ? `${prefixCls$8}-item-left` : `${prefixCls$8}-item-right` : v === "center" ? m.props.position ? `${prefixCls$8}-item-${m.props.position}` : `${prefixCls$8}-item-left` : v === "left" || v === "right" ? `${prefixCls$8}-item-${v}` : m.props.position ? `${prefixCls$8}-item-${m.props.position}` : "";
    }, c = (m) => m.map((g, v) => isVNode(g) ? cloneVNode(g, {
      // @ts-ignore
      className: cls(g.props.class, u(g, v))
    }) : g);
    return () => {
      var O;
      const m = (O = o.default) == null ? void 0 : O.call(o), {
        className: g,
        style: v,
        mode: b,
        dataSource: S,
        ...E
      } = s, P = cls(prefixCls$8, g, {
        [`${prefixCls$8}-${b}`]: b
      });
      let T;
      if (S && S.length) {
        const z = S.map((Q, W) => createVNode(Item, mergeProps$1({
          key: `timeline-item-${W}`
        }, Q), {
          default: () => [Q.content]
        }));
        T = c(z);
      }
      const N = T || c(m);
      return createVNode("ul", mergeProps$1({
        "aria-label": s["aria-label"],
        style: v,
        class: P
      }, getDataAttr({
        ...E,
        ...l
      })), [N]);
    };
  }
}), BaseTimeline = Timeline;
BaseTimeline.Item = Item;
const BaseTimeline$1 = BaseTimeline;
class ToastListFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...ToastListFoundation.defaultAdapter, ...o }), this.handleMouseInSideChange = (l) => {
      this._adapter.handleMouseInSideChange(l);
    }, this.getInputWrapperRect = () => this._adapter.getInputWrapperRect();
  }
  hasToast(o) {
    return this._adapter.getState("list").map(({ id: u }) => u).includes(o);
  }
  addToast(o) {
    const l = this._adapter.getState("list");
    l.push(o), this._adapter.updateToast(l, [], []);
  }
  updateToast(o, l) {
    let u = this._adapter.getState("list");
    u = u.map((m) => m.id === o ? { ...m, ...l } : m);
    const c = u.filter((m) => m.id === o);
    this._adapter.updateToast(u, [], c);
  }
  removeToast(o) {
    let l = this._adapter.getState("list");
    const u = [];
    l = l.filter((c) => c.id === o ? (u.push(c), !1) : !0), this._adapter.updateToast(l, u, []);
  }
  destroyAll() {
    const o = this._adapter.getState("list");
    o.length > 0 && this._adapter.updateToast([], o, []);
  }
}
const PREFIX = `${BASE_CLASS_PREFIX$1}-toast`, cssClasses$7 = {
  PREFIX,
  WRAPPER: `${PREFIX}-wrapper`,
  LIST: `${PREFIX}-list`
}, strings$1 = {
  types: ["warning", "success", "info", "error", "default"],
  themes: ["normal", "light"],
  directions: ["ltr", "rtl"]
}, numbers$1 = {
  duration: 3
  // default close time, unit: s
};
class ToastFoundation extends BaseFoundation$1 {
  // cache id
  constructor(o) {
    super({ ...ToastFoundation.defaultAdapter, ...o }), this._timer = null, this._id = null;
  }
  init() {
    this.startCloseTimer_(), this._id = this._adapter.getProp("id");
  }
  destroy() {
    this.clearCloseTimer_();
  }
  startCloseTimer_() {
    const o = this._adapter.getProp("duration");
    o && lodashExports.isNumber(o) && (this._timer = setTimeout(() => {
      this.close();
    }, o * 1e3));
  }
  close(o) {
    o && o.stopPropagation(), this._adapter.notifyWrapperToRemove(this._id), this._adapter.notifyClose();
  }
  clearCloseTimer_() {
    this._timer && (clearTimeout(this._timer), this._timer = null);
  }
  restartCloseTimer() {
    this.clearCloseTimer_(), this.startCloseTimer_();
  }
}
const prefixCls$7 = cssClasses$7.PREFIX, propTypes$d = {
  onClose: func,
  content: {
    type: node$1,
    required: !0
  },
  close: func,
  duration: number$2,
  theme: String,
  type: String,
  textMaxWidth: oneOfType([string$3, number$2]),
  style: object$1,
  className: string$3,
  showClose: bool,
  stack: bool,
  stackExpanded: bool,
  onAnimationEnd: func,
  onAnimationStart: func,
  positionInList: object$1,
  icon: node$1,
  direction: String,
  id: String,
  top: [string$3, number$2],
  bottom: [string$3, number$2],
  left: [string$3, number$2],
  right: [string$3, number$2],
  zIndex: number$2,
  getPopupContainer: func
}, defaultProps$c = {
  onClose: lodashExports.noop,
  content: "",
  close: lodashExports.noop,
  duration: numbers$1.duration,
  textMaxWidth: 450,
  showClose: !0,
  stack: !1,
  stackExpanded: !1,
  theme: "normal"
}, vuePropsType$t = vuePropsMake(propTypes$d, defaultProps$c), Toast = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$t
  },
  name: "Toast",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const {
      context: l
    } = useConfigContext(), u = reactive({});
    let c = ref$1();
    const {
      adapter: m
    } = useBaseComponent(s, u);
    function g() {
      return {
        ...m(),
        notifyWrapperToRemove: (N) => {
          s.close(N);
        },
        notifyClose: () => {
          s.onClose();
        }
      };
    }
    const v = g(), b = new ToastFoundation(v);
    onMounted(() => {
      b.init();
    }), onBeforeUnmount(() => {
      b.destroy();
    });
    function S(N) {
      b.close(N);
    }
    const E = () => {
      b.clearCloseTimer_();
    }, P = () => {
      b.startCloseTimer_();
    };
    function T() {
      const {
        type: N,
        icon: O
      } = s, Q = {
        warning: createVNode(IconComponent$J, null, null),
        success: createVNode(IconComponent$5, null, null),
        info: createVNode(IconComponent$h, null, null),
        error: createVNode(IconComponent$K, null, null)
      }[N], W = "large", ue = cls(`${prefixCls$7}-icon`, `${prefixCls$7}-icon-${N}`);
      return O ? isSemiIcon(O) ? cloneVNode(O, {
        size: W,
        class: `${prefixCls$7}-icon`
      }) : O : N && Q ? cloneVNode(Q, {
        size: W,
        class: ue
      }) : null;
    }
    return o({
      foundation: b,
      close: S
    }), () => {
      const {
        content: N,
        type: O,
        theme: z,
        showClose: Q,
        textMaxWidth: W,
        className: ue,
        style: te
      } = s, K = s.direction || l.value.direction, ve = cls(prefixCls$7, ue, {
        [`${prefixCls$7}-${O}`]: !0,
        [`${prefixCls$7}-${z}`]: z === "light",
        [`${prefixCls$7}-rtl`]: K === "rtl"
      }), ee = {};
      ee.maxWidth = W;
      const Re = "borderless", wt = "small", yt = s.positionInList ? s.positionInList.length - s.positionInList.index - 1 : 0, xt = createVNode("div", {
        ref: c,
        role: "alert",
        "aria-label": `${O || "default"} type`,
        class: ve,
        style: {
          ...te,
          transform: `translate3d(0,0,${yt * -10}px)`
        },
        onMouseenter: E,
        onMouseleave: P,
        onAnimationstart: s.onAnimationStart,
        onAnimationend: s.onAnimationEnd
      }, [createVNode("div", {
        class: `${prefixCls$7}-content`
      }, [T(), createVNode("span", {
        class: `${prefixCls$7}-content-text`,
        style: ee,
        "x-semi-prop": "content"
      }, [N]), Q && createVNode("div", {
        class: `${prefixCls$7}-close-button`
      }, [createVNode(Button$3, {
        onClick: (Kt) => S(Kt),
        type: "tertiary",
        icon: createVNode(IconComponent$u, {
          "x-semi-prop": "icon"
        }, null),
        theme: Re,
        size: wt
      }, null)])])]);
      if (s.stack) {
        const Kt = s.stackExpanded && c.value && getComputedStyle(c.value).height || 0;
        return createVNode("div", {
          class: `${prefixCls$7}-zero-height-wrapper`,
          style: {
            height: Kt
          }
        }, [xt]);
      } else
        return xt;
    };
  }
}), vuePropsType$s = {
  ...propTypes$d,
  content: void 0,
  id: String,
  motion: Boolean,
  afterClose: {
    type: Function,
    required: !0
  }
}, HookToast = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$s
  },
  name: "HookToast",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = o, u = ref$1(), c = () => {
      u.value = !1;
    };
    return watch(u, () => {
      u.value || s.afterClose(l.id);
    }), () => u ? createVNode(Toast, mergeProps$1(l, {
      close: c
    }), null) : null;
  }
}), defaultOpts = {
  motion: !0,
  zIndex: 1010,
  duration: 3
};
function usePatchElement() {
  const s = ref$1([]);
  function o(u) {
    s.value = u;
  }
  function l(u, c) {
    return o((m) => [{
      element: u,
      config: c
    }, ...m]), (m) => {
      o((g) => g.filter(({
        config: v
      }) => v.id !== m));
    };
  }
  return [s, l];
}
function useToast() {
  const [s, o] = usePatchElement(), l = shallowRef(/* @__PURE__ */ new Map()), u = (g) => {
    const v = getUuid("semi_toast_"), b = {
      ...g,
      id: v
    };
    let S;
    const E = createVNode(HookToast, mergeProps$1(b, {
      key: v,
      afterClose: (P) => S(P),
      ref: (P) => {
        l.value.set(v, {
          close: (P == null ? void 0 : P.close) ?? lodashExports.noop
        });
      }
    }), null);
    return S = o(E, {
      ...b
    }), v;
  }, c = (g) => {
    const v = l.value.get(g);
    v && v.close();
  }, m = ref$1();
  return watch(() => s.value, (g) => {
    m.value = createVNode(Fragment, null, [Array.isArray(s.value) && s.value.length ? createVNode(Fragment, null, [s.value.map((v) => v.element)]) : null]);
  }), [{
    success: (g) => u({
      ...defaultOpts,
      ...g,
      type: "success"
    }),
    info: (g) => u({
      ...defaultOpts,
      ...g,
      type: "info"
    }),
    error: (g) => u({
      ...defaultOpts,
      ...g,
      type: "error"
    }),
    warning: (g) => u({
      ...defaultOpts,
      ...g,
      type: "warning"
    }),
    open: (g) => u({
      ...defaultOpts,
      ...g,
      type: "default"
    }),
    close: (g) => c(g)
  }, m];
}
const ToastList = /* @__PURE__ */ defineComponent({
  props: {
    content: node$1,
    duration: number$2,
    onClose: func,
    icon: node$1,
    direction: String,
    stack: bool
    // ref: [Function, Object],
  },
  name: "ToastList",
  setup(s, {
    expose: o
  }) {
    useSlots();
    const l = shallowRef(!1);
    function u(ue) {
      l.value = ue;
    }
    function c() {
      return l.value;
    }
    getCurrentInstance();
    let m = ref$1();
    const g = reactive({
      list: [],
      removedItems: [],
      updatedItems: [],
      mouseInSide: !1
    }), {
      adapter: v
    } = useBaseComponent(s, g);
    function b() {
      return {
        ...v(),
        updateToast: (ue, te, K) => {
          g.list = ue, g.removedItems = te, g.updatedItems = K;
        },
        handleMouseInSideChange: (ue) => {
          g.mouseInSide = ue;
        },
        getInputWrapperRect: () => {
          var ue;
          return (ue = m.value) == null ? void 0 : ue.getBoundingClientRect();
        }
      };
    }
    const S = (ue) => {
      l.value && T.handleMouseInSideChange(!0);
    }, E = (ue) => {
      var te;
      l.value && ((te = T.getInputWrapperRect()) != null && te.height) && T.handleMouseInSideChange(!1);
    }, P = b(), T = new ToastListFoundation(P);
    function N(ue) {
      return T.hasToast(ue);
    }
    function O(ue) {
      return T.addToast(ue);
    }
    function z(ue, te) {
      return T.updateToast(ue, te);
    }
    function Q(ue) {
      return T.removeToast(ue);
    }
    function W() {
      return T.destroyAll();
    }
    return o({
      has: N,
      add: O,
      update: z,
      remove: Q,
      destroyAll: W,
      setStack: u,
      getStack: c
    }), () => {
      let {
        list: ue
      } = g;
      const {
        removedItems: te,
        updatedItems: K
      } = g;
      ue = Array.from(/* @__PURE__ */ new Set([...ue, ...te]));
      const ve = K.map(({
        id: Re
      }) => Re), ee = (Re) => {
        var wt;
        (wt = Re == null ? void 0 : Re.foundation) != null && wt._id && ve.includes(Re.foundation._id) && Re.foundation.restartCloseTimer();
      };
      return createVNode(Fragment, null, [createVNode("div", {
        class: cls({
          [`${cssClasses$7.PREFIX}-innerWrapper`]: !0,
          [`${cssClasses$7.PREFIX}-innerWrapper-hover`]: g.mouseInSide
        }),
        ref: m,
        onMouseenter: S,
        onMouseleave: E
      }, [ue.map((Re, wt) => {
        const yt = te.find((xt) => xt.id === Re.id) !== void 0;
        return createVNode(CSSAnimation, {
          key: Re.id,
          motion: Re.motion,
          animationState: yt ? "leave" : "enter",
          startClassName: yt ? `${cssClasses$7.PREFIX}-animation-hide` : `${cssClasses$7.PREFIX}-animation-show`,
          children: ({
            animationClassName: xt,
            animationEventsNeedBind: Kt,
            isAnimating: tn
          }) => yt && !tn ? null : createVNode(Toast, mergeProps$1(Re, {
            stack: l.value,
            stackExpanded: g.mouseInSide,
            positionInList: {
              length: ue.length,
              index: wt
            },
            className: cls({
              [Re.className]: !!Re.className,
              [xt]: !0
            })
          }, Kt, {
            style: {
              ...Re.style
            },
            close: (ln) => Q(ln),
            ref: ee
          }), null)
        }, null);
      })])]);
    };
  }
});
function useToastHook(s) {
  let o, l;
  const u = {
    motion: !0,
    zIndex: 1010,
    content: ""
  };
  let c;
  s && N(s);
  function m(O) {
    const z = O.id ?? getUuid("toast");
    if (l) {
      const Q = document.querySelector(`#${c}`);
      ["top", "left", "bottom", "right"].map((W) => {
        W in O && (Q.style[W] = typeof O[W] == "number" ? `${O[W]}px` : O[W]);
      }), !!O.stack !== l.getStack() && l.setStack(!!O.stack), l.has(z) ? l.update(z, {
        ...O,
        id: z
      }) : l.add({
        ...O,
        id: z
      });
    } else {
      const Q = document.createElement("div");
      c || (c = getUuid("toast-wrapper").slice(0, 26)), Q.className = cssClasses$7.WRAPPER, Q.id = c, Q.style.zIndex = String(typeof O.zIndex == "number" ? O.zIndex : u.zIndex), ["top", "left", "bottom", "right"].map((W) => {
        if (W in u || W in O) {
          const ue = O[W] ? O[W] : u[W];
          Q.style[W] = typeof ue == "number" ? `${ue}px` : ue;
        }
      }), u.getPopupContainer ? u.getPopupContainer().appendChild(Q) : document.body.appendChild(Q), o = createApp(() => createVNode(ToastList, {
        ref: (W) => {
          l || (W.add({
            ...O,
            id: z
          }), W.setStack(!!O.stack)), l = W;
        }
      })), o.mount(Q);
    }
    return z;
  }
  function g(O) {
    l && l.remove(O);
  }
  function v() {
    if (l) {
      l.destroyAll();
      const O = document.querySelector(`#${c}`);
      o.unmount(), O && O.parentNode.removeChild(O), l = null, c = null;
    }
  }
  function b() {
    return c;
  }
  function S(O) {
    return typeof O == "string" && (O = {
      content: O
    }), m({
      ...u,
      ...O,
      type: "info"
    });
  }
  function E(O) {
    return typeof O == "string" && (O = {
      content: O
    }), m({
      ...u,
      ...O,
      type: "warning"
    });
  }
  function P(O) {
    return typeof O == "string" && (O = {
      content: O
    }), m({
      ...u,
      ...O,
      type: "error"
    });
  }
  function T(O) {
    return typeof O == "string" && (O = {
      content: O
    }), m({
      ...u,
      ...O,
      type: "success"
    });
  }
  function N(O) {
    ["top", "left", "bottom", "right"].forEach((z) => {
      z in O && (u[z] = O[z]);
    }), typeof O.theme == "string" && strings$1.themes.includes(O.theme) && (u.theme = O.theme), typeof O.zIndex == "number" && (u.zIndex = O.zIndex), typeof O.duration == "number" && (u.duration = O.duration), typeof O.getPopupContainer == "function" && (u.getPopupContainer = O.getPopupContainer);
  }
  return {
    create: m,
    close: g,
    destroyAll: v,
    getWrapperId: b,
    info: S,
    warning: E,
    error: P,
    success: T,
    config: N,
    useToast
  };
}
class ToastFactory {
  static create(o) {
    return useToastHook(o);
  }
}
const index$6 = ToastFactory.create(), cssClasses$6 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-transfer`
}, strings = {
  TYPE_GROUP_LIST: "groupList",
  TYPE_LIST: "list",
  TYPE_TREE_TO_LIST: "treeList"
};
function _generateGroupedData(s) {
  const o = [];
  for (const l of s)
    l.children.forEach((u) => {
      const { children: c, ...m } = l;
      o.push({ ...u, _parent: m });
    });
  return o;
}
function _generateTreeData(s) {
  const o = [], l = [...s].reverse();
  for (; l.length; ) {
    const u = l.pop();
    if (u.path = u.path || [lodashExports.omit(u, ["children"])], u.children && Array.isArray(u.children)) {
      const c = u.children;
      for (let m = c.length - 1; m >= 0; m--) {
        const g = { ...c[m] };
        g.path = [].concat(u.path).concat(lodashExports.omit(g, ["children"])), l.push(g);
      }
    } else
      u.isLeaf = !0;
    o.push(lodashExports.omit(u, ["children"]));
  }
  return o;
}
function _generateDataByType(s, o) {
  const l = s.slice() || [];
  return o === strings.TYPE_GROUP_LIST ? _generateGroupedData(l) : o === strings.TYPE_TREE_TO_LIST ? _generateTreeData(l) : l;
}
function _generateSelectedItems(s, o) {
  const l = /* @__PURE__ */ new Map();
  return s.forEach((u) => {
    const c = o.findIndex((m) => m.value === u);
    if (c !== -1) {
      const m = o[c];
      l.set(m.key, m);
    }
  }), l;
}
class TransferFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
  }
  _generateGroupedData(o) {
    return _generateGroupedData(o);
  }
  _generateTreeData(o) {
    return _generateTreeData(o);
  }
  _generatePath(o) {
    const { path: l = [] } = o;
    return l.map((u) => u.label).join(" > ");
  }
  handleInputChange(o, l) {
    const { data: u } = this.getStates(), { filter: c, type: m } = this.getProps();
    if (m === strings.TYPE_TREE_TO_LIST) {
      const S = new Set(u.map((E) => E.key));
      this._adapter.searchTree(o), l && this._adapter.notifySearch(o), this._adapter.updateInput(o), this._adapter.updateSearchResult(S);
      return;
    }
    const g = typeof c == "function" ? (S) => c(o, S) : (S) => typeof S.label == "string" && S.label.includes(o), v = u.filter(g), b = new Set(v.map((S) => S.key));
    l && this._adapter.notifySearch(o), this._adapter.updateInput(o), this._adapter.updateSearchResult(b);
  }
  // Select or cancel all unhidden items
  handleAll(o) {
    const { disabled: l, type: u } = this.getProps(), { selectedItems: c, data: m, searchResult: g, inputValue: v } = this.getStates();
    if (l)
      return;
    const b = v !== "";
    let S = [];
    S = b ? m.filter((P) => g.has(P.key)) : m, S = u === strings.TYPE_TREE_TO_LIST ? m : S;
    let E = /* @__PURE__ */ new Map();
    switch (!0) {
      case !o:
        E = new Map(c), S.forEach((P) => {
          P.disabled || E.delete(P.key);
        });
        break;
      case o:
        E = new Map(c), S.forEach((P) => {
          if (P.disabled) {
            c.has(P.key) && E.set(P.key, P);
            return;
          }
          E.set(P.key, P);
        });
        break;
    }
    this._isControlledComponent() || this._adapter.updateSelected(E), this._notifyChange(E);
  }
  handleClear() {
    const { disabled: o } = this.getProps(), { selectedItems: l, data: u } = this.getStates();
    if (o)
      return;
    const c = new Map(l);
    u.forEach((m) => {
      m.disabled || c.delete(m.key);
    }), this._isControlledComponent() || this._adapter.updateSelected(c), this._notifyChange(c);
  }
  handleSelectOrRemove(o) {
    const { disabled: l } = this.getProps(), u = this._adapter.getSelected();
    l || o.disabled || (u.has(o.key) ? (u.delete(o.key), this._adapter.notifyDeselect(o)) : (u.set(o.key, o), this._adapter.notifySelect(o)), this._isControlledComponent() || this._adapter.updateSelected(u), this._notifyChange(u));
  }
  handleSelect(o) {
    const { disabled: l } = this.getProps(), u = this._adapter.getSelected(), { data: c } = this.getStates(), m = c.map((b) => [b.value, b]), g = new Map(m), v = /* @__PURE__ */ new Map();
    l || (o.forEach((b) => {
      const S = g.get(b);
      if (u.has(S.key)) {
        v.set(S.key, S);
        return;
      }
      S.disabled || v.set(S.key, S);
    }), this._isControlledComponent() || this._adapter.updateSelected(v), this._notifyChange(v));
  }
  getValuesAndItemsFromMap(o) {
    const { type: l } = this.getProps(), u = [], c = [];
    for (const m of o) {
      const g = l === strings.TYPE_GROUP_LIST ? lodashExports.omit(m[1], "_parent") : m[1];
      u.push(g), c.push(g.value);
    }
    return { items: u, values: c };
  }
  _notifyChange(o) {
    const { items: l, values: u } = this.getValuesAndItemsFromMap(o);
    this._adapter.notifyChange(u, l);
  }
  handleSortEnd(o) {
    const { oldIndex: l, newIndex: u } = o;
    let m = [...this._adapter.getSelected().values()];
    m = arrayMove(m, l, u);
    let g = /* @__PURE__ */ new Map();
    m.forEach((v) => {
      g = g.set(v.key, v);
    }), this._adapter.updateSelected(g), this._notifyChange(g);
  }
}
const vuePropsType$r = {
  id: {
    type: [String, Number],
    required: !0
  },
  item: {
    type: Function,
    required: !0
  }
}, SortableItem = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$r
  },
  name: "SortableItem",
  setup(s, {}) {
    useSlots();
    const o = {
      id: computed(() => s.id)
    }, {
      attributes: l,
      listeners: u,
      setNodeRef: c,
      transform: m,
      transition: g,
      isDragging: v
    } = z0(o);
    return () => {
      const b = {
        transform: d.Transform.toString(m.value),
        // @ts-ignore
        transition: g.value
      };
      return s.item({
        setNodeRef: c,
        style: b,
        attributes: l == null ? void 0 : l.value,
        listeners: u == null ? void 0 : u.value
      });
    };
  }
}), vuePropsType$q = {
  items: {
    type: Array,
    required: !0
  },
  onSortEnd: {
    type: Function,
    required: !0
  },
  useDragHandle: {
    type: [Boolean],
    required: !0
  },
  helperClass: {
    type: String,
    required: !0
  },
  axis: String
}, SortableList = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$q
  },
  name: "SortableList",
  setup(s, {}) {
    useSlots();
    const o = z_(U_(os, {
      activationConstraint: {
        // distance: 5,
        delay: 100,
        tolerance: 100
      }
    }), U_(ls, {
      coordinateGetter: M0
    })), l = ref$1("");
    function u(c) {
      var m;
      l.value = (m = c.active) == null ? void 0 : m.id;
    }
    return () => createVNode(K_, {
      sensors: o.value,
      collisionDetection: $_,
      onDragStart: u,
      onDragEnd: s.onSortEnd
    }, {
      default: () => [createVNode(O0, {
        items: s.items,
        strategy: k0
      }, {
        default: () => [createVNode("div", {
          class: `${prefixCls$6}-right-list`,
          role: "list",
          "aria-label": "Selected list"
        }, [s.items.map((c, m) => (
          // @ts-ignore skip SortableItem type check
          createVNode(SortableItem, {
            key: c.key,
            index: m,
            id: c.id,
            item: c.node
          }, null)
        ))])]
      })]
    });
  }
});
function _isSlot$4(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefixCls$6 = cssClasses$6.PREFIX, propTypes$c = {
  style: object$1,
  className: string$3,
  disabled: bool,
  dataSource: array$1,
  filter: oneOfType([func, bool]),
  onSearch: func,
  inputProps: object$1,
  value: array$1,
  defaultValue: array$1,
  onChange: func,
  onSelect: func,
  onDeselect: func,
  renderSourceItem: func,
  renderSelectedItem: func,
  loading: bool,
  type: string$3,
  treeProps: object$1,
  showPath: bool,
  emptyContent: object$1,
  renderSourcePanel: func,
  renderSelectedPanel: func,
  draggable: bool,
  renderSourceHeader: func,
  renderSelectedHeader: func
}, defaultProps$b = {
  type: strings.TYPE_LIST,
  dataSource: [],
  onSearch: lodashExports.noop,
  onChange: lodashExports.noop,
  onSelect: lodashExports.noop,
  onDeselect: lodashExports.noop,
  onClear: lodashExports.noop,
  defaultValue: [],
  emptyContent: {},
  showPath: !1
}, vuePropsType$p = vuePropsMake(propTypes$c, defaultProps$b), Transfer = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$p
  },
  name: "Transfer",
  setup(s, {}) {
    useSlots();
    const o = ref$1(), {
      defaultValue: l = [],
      dataSource: u,
      type: c
    } = s, m = reactive({
      data: [],
      selectedItems: /* @__PURE__ */ new Map(),
      searchResult: /* @__PURE__ */ new Set(),
      inputValue: ""
    });
    u && lodashExports.isArray(u) && (m.data = _generateDataByType(u, c)), l && lodashExports.isArray(l) && (m.selectedItems = _generateSelectedItems(l, m.data));
    function g(xt) {
      const {
        value: Kt,
        dataSource: tn,
        type: ln,
        filter: rn
      } = xt, an = {};
      let Gt = m.data, nn = m.selectedItems;
      if (tn && Array.isArray(tn) && (Gt = _generateDataByType(tn, ln), an.data = Gt), Kt && Array.isArray(Kt) && (nn = _generateSelectedItems(Kt, Gt), an.selectedItems = nn), !lodashExports.isEqual(m.data, Gt) && typeof m.inputValue == "string" && m.inputValue !== "") {
        const vt = typeof rn == "function" ? (un) => rn(m.inputValue, un) : (un) => typeof un.label == "string" && un.label.includes(m.inputValue), Et = Gt.filter(vt), Qt = new Set(Et.map((un) => un.key));
        an.searchResult = Qt;
      }
      return lodashExports.isEmpty(an) ? null : an;
    }
    watch([() => m.selectedItems, () => m.data, () => m.inputValue, () => s.value, () => s.dataSource, () => s.type, () => s.filter], (xt, Kt, tn) => {
      if (!lodashExports.isEqual(xt, Kt)) {
        const ln = g({
          ...s
        });
        ln && Object.keys(ln).forEach((rn) => {
          m[rn] = ln[rn];
        });
      }
    }, {
      immediate: !0
    });
    const {
      adapter: v,
      getDataAttr: b
    } = useBaseComponent(s, m);
    function S() {
      return {
        ...v(),
        getSelected: () => new Map(m.selectedItems),
        updateSelected: (xt) => {
          m.selectedItems = xt;
        },
        notifyChange: (xt, Kt) => {
          s.onChange(xt, Kt);
        },
        notifySearch: (xt) => {
          s.onSearch(xt);
        },
        notifySelect: (xt) => {
          s.onSelect(xt);
        },
        notifyDeselect: (xt) => {
          s.onDeselect(xt);
        },
        updateInput: (xt) => {
          m.inputValue = xt;
        },
        updateSearchResult: (xt) => {
          m.searchResult = xt;
        },
        searchTree: (xt) => {
          o.value && o.value.search(xt);
        }
      };
    }
    const E = S(), P = new TransferFoundation(E);
    function T(xt) {
      P.handleInputChange(xt, !0);
    }
    function N(xt) {
      P.handleSelectOrRemove(xt);
    }
    function O(xt, Kt) {
      if (xt) {
        const {
          active: tn,
          over: ln
        } = xt;
        let an = [...E.getSelected().values()].map((Gt) => Gt.key);
        if (!tn || !ln)
          return;
        if (tn.id !== ln.id) {
          const Gt = an.indexOf(tn.id), nn = an.indexOf(ln.id);
          P.handleSortEnd({
            oldIndex: Gt,
            newIndex: nn
          });
        }
      }
      Kt && P.handleSortEnd(Kt);
    }
    function z(xt) {
      const {
        inputProps: Kt,
        filter: tn,
        disabled: ln
      } = s;
      return typeof tn == "boolean" && !tn ? null : createVNode("div", {
        role: "search",
        "aria-label": "Transfer filter",
        class: `${prefixCls$6}-filter`
      }, [createVNode(Input$1, mergeProps$1({
        prefix: createVNode(IconComponent$9, null, null),
        placeholder: xt.placeholder,
        showClear: !0,
        value: m.inputValue,
        disabled: ln,
        onChange: T
      }, Kt), null)]);
    }
    function Q(xt) {
      const {
        disabled: Kt,
        renderSourceHeader: tn,
        renderSelectedHeader: ln
      } = s, {
        totalContent: rn,
        allContent: an,
        onAllClick: Gt,
        type: nn,
        showButton: vt
      } = xt, Et = cls({
        [`${prefixCls$6}-header`]: !0,
        [`${prefixCls$6}-right-header`]: nn === "right",
        [`${prefixCls$6}-left-header`]: nn === "left"
      });
      if (nn === "left" && typeof tn == "function") {
        const {
          num: Qt,
          showButton: un,
          allChecked: gn,
          onAllClick: dn
        } = xt;
        return tn({
          num: Qt,
          showButton: un,
          allChecked: gn,
          onAllClick: dn
        });
      }
      if (nn === "right" && typeof ln == "function") {
        const {
          num: Qt,
          showButton: un,
          onAllClick: gn
        } = xt;
        return ln({
          num: Qt,
          showButton: un,
          onClear: gn
        });
      }
      return createVNode("div", {
        class: Et
      }, [createVNode("span", {
        class: `${prefixCls$6}-header-total`
      }, [rn]), vt ? createVNode(Button$2, {
        theme: "borderless",
        disabled: Kt,
        type: "tertiary",
        size: "small",
        className: `${prefixCls$6}-header-all`,
        onClick: Gt
      }, _isSlot$4(an) ? an : {
        default: () => [an]
      }) : null]);
    }
    function W(xt, Kt) {
      const {
        renderSourceItem: tn,
        disabled: ln
      } = s, {
        selectedItems: rn
      } = m, an = rn.has(xt.key);
      if (tn)
        return tn({
          ...xt,
          checked: an,
          onChange: () => N(xt)
        });
      const Gt = cls({
        [`${prefixCls$6}-item`]: !0,
        [`${prefixCls$6}-item-disabled`]: xt.disabled
      });
      return createVNode(Checkbox$1, {
        key: Kt,
        disabled: xt.disabled || ln,
        className: Gt,
        checked: an,
        role: "listitem",
        onChange: () => N(xt),
        "x-semi-children-alias": `dataSource[${Kt}].label`
      }, {
        default: () => [xt.label]
      });
    }
    function ue(xt) {
      const {
        data: Kt,
        selectedItems: tn,
        inputValue: ln,
        searchResult: rn
      } = m, {
        loading: an,
        type: Gt,
        emptyContent: nn,
        renderSourcePanel: vt,
        dataSource: Et
      } = s, Qt = xt.total, un = ln !== "", gn = un ? rn.size : Kt.length, dn = un ? Kt.filter((bn) => rn.has(bn.key)) : Kt, yn = !!dn.find((bn) => !tn.has(bn.key)), Pn = {
        totalContent: Qt.replace("${total}", `${gn}`),
        allContent: yn ? xt.selectAll : xt.clearSelectAll,
        onAllClick: () => P.handleAll(yn),
        type: "left",
        showButton: Gt !== strings.TYPE_TREE_TO_LIST,
        num: gn,
        allChecked: !yn
      }, On = z(xt), _n = Q(Pn), Nn = un && rn.size === 0, Un = nn.search ? nn.search : xt.emptySearch, Xn = nn.left ? nn.left : xt.emptyLeft, zn = Re("left", Xn), jn = Re("left", Un), kn = createVNode(Spin, null, null);
      let Yn = null;
      switch (!0) {
        case an:
          Yn = kn;
          break;
        case Nn:
          Yn = jn;
          break;
        case Kt.length === 0:
          Yn = zn;
          break;
        case Gt === strings.TYPE_TREE_TO_LIST:
          Yn = createVNode(Fragment, null, [_n, K()]);
          break;
        case (!Nn && (Gt === strings.TYPE_LIST || Gt === strings.TYPE_GROUP_LIST)):
          Yn = createVNode(Fragment, null, [_n, ve(dn)]);
          break;
        default:
          Yn = null;
          break;
      }
      const {
        values: Zn
      } = P.getValuesAndItemsFromMap(tn), er = {
        loading: an,
        noMatch: Nn,
        filterData: dn,
        sourceData: Kt,
        propsDataSource: Et,
        allChecked: !yn,
        showNumber: gn,
        inputValue: ln,
        selectedItems: tn,
        value: Zn,
        onSelect: P.handleSelect.bind(P),
        onAllClick: () => P.handleAll(yn),
        onSearch: T,
        onSelectOrRemove: (bn) => N(bn)
      };
      return vt ? vt(er) : createVNode("section", {
        class: `${prefixCls$6}-left`
      }, [On, Yn]);
    }
    function te(xt, Kt) {
      const tn = cls(`${prefixCls$6}-group-title`);
      return createVNode("div", {
        class: tn,
        key: `title-${Kt}`
      }, [xt.title]);
    }
    function K() {
      const {
        selectedItems: xt
      } = m, {
        disabled: Kt,
        dataSource: tn,
        treeProps: ln
      } = s, {
        values: rn
      } = P.getValuesAndItemsFromMap(xt), an = (nn) => {
        P.handleSelect(nn);
      }, Gt = lodashExports.omit(ln, ["value", "ref", "onChange"]);
      return createVNode(Tree$1, mergeProps$1({
        disabled: Kt,
        treeData: tn,
        multiple: !0,
        disableStrictly: !0,
        value: rn,
        defaultExpandAll: !0,
        leafOnly: !0,
        ref: o,
        filterTreeNode: !0,
        searchRender: !1,
        searchStyle: {
          padding: 0
        },
        style: {
          flex: 1,
          overflow: "overlay"
        },
        onChange: an
      }, Gt), null);
    }
    function ve(xt) {
      const Kt = [], tn = /* @__PURE__ */ new Map();
      return xt.forEach((ln, rn) => {
        const an = ln._parent, Gt = W(ln, rn);
        if (an && tn.has(an.title))
          Kt.push(Gt);
        else if (an) {
          const nn = te(an, rn);
          tn.set(an.title, !0), Kt.push(nn), Kt.push(Gt);
        } else
          Kt.push(Gt);
      }), createVNode("div", {
        class: `${prefixCls$6}-left-list`,
        role: "list",
        "aria-label": "Option list"
      }, [Kt]);
    }
    function ee(xt) {
      const {
        renderSelectedItem: Kt,
        draggable: tn,
        type: ln,
        showPath: rn
      } = s, an = () => P.handleSelectOrRemove(xt), Gt = cls({
        [`${prefixCls$6}-item`]: !0,
        [`${prefixCls$6}-right-item`]: !0,
        [`${prefixCls$6}-right-item-draggable`]: tn
      }), vt = ln === strings.TYPE_TREE_TO_LIST && rn === !0 ? P._generatePath(xt) : xt.label;
      return Kt ? (Et) => Kt({
        ...xt,
        onRemove: an,
        sortableHandle: () => {
        }
      }, Et) : (Et) => (
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
        createVNode("div", mergeProps$1({
          role: "listitem",
          ref: Et.setNodeRef,
          class: Gt,
          key: xt.key
        }, Et.attributes, {
          style: Et.style
        }), [tn ? createVNode(IconComponent$j, mergeProps$1(Et.listeners, {
          role: "button",
          "aria-label": "Drag and sort",
          className: `${prefixCls$6}-right-item-drag-handler`
        }), null) : null, createVNode("div", {
          class: `${prefixCls$6}-right-item-text`
        }, [vt]), createVNode(IconComponent$u, {
          onClick: an,
          "aria-disabled": xt.disabled,
          className: cls(`${prefixCls$6}-item-close-icon`, {
            [`${prefixCls$6}-item-close-icon-disabled`]: xt.disabled
          })
        }, null)])
      );
    }
    function Re(xt, Kt) {
      const tn = cls({
        [`${prefixCls$6}-empty`]: !0,
        [`${prefixCls$6}-right-empty`]: xt === "right",
        [`${prefixCls$6}-left-empty`]: xt === "left"
      });
      return createVNode("div", {
        "aria-label": "empty",
        class: tn
      }, [Kt]);
    }
    function wt(xt) {
      const Kt = xt.map((ln) => ({
        ...ln,
        id: ln.key,
        node: ee(ln)
      }));
      return createVNode(SortableList, {
        useDragHandle: !0,
        helperClass: `${prefixCls$6}-right-item-drag-item-move`,
        onSortEnd: O,
        items: Kt
      }, null);
    }
    function yt(xt) {
      const {
        selectedItems: Kt
      } = m, {
        emptyContent: tn,
        renderSelectedPanel: ln,
        draggable: rn
      } = s, an = [...Kt.values()], Gt = {
        length: an.length,
        selectedData: an,
        onClear: () => P.handleClear(),
        onRemove: (yn) => P.handleSelectOrRemove(yn),
        onSortEnd: (yn) => O(null, yn)
      };
      if (ln)
        return ln(Gt);
      const Et = {
        totalContent: xt.selected.replace("${total}", `${an.length}`),
        allContent: xt.clear,
        onAllClick: () => P.handleClear(),
        type: "right",
        showButton: !!an.length,
        num: an.length
      }, Qt = Q(Et), un = Re("right", tn.right ? tn.right : xt.emptyRight), gn = `${prefixCls$6}-right`;
      let dn = null;
      switch (!0) {
        case !an.length:
          dn = un;
          break;
        case (an.length && !rn):
          dn = createVNode("div", {
            class: `${prefixCls$6}-right-list`,
            role: "list",
            "aria-label": "Selected list"
          }, [an.map((vn) => ee({
            ...vn
          })({}))]);
          break;
        case (an.length && rn):
          dn = wt(an);
          break;
      }
      return createVNode("section", {
        class: gn
      }, [Qt, dn]);
    }
    return () => {
      const {
        className: xt,
        style: Kt,
        disabled: tn,
        renderSelectedPanel: ln,
        renderSourcePanel: rn
      } = s, an = cls(prefixCls$6, xt, {
        [`${prefixCls$6}-disabled`]: tn,
        [`${prefixCls$6}-custom-panel`]: ln && rn
      });
      return createVNode(LocaleConsumer$6, {
        componentName: "Transfer"
      }, {
        default: (Gt) => createVNode("div", mergeProps$1({
          class: an,
          style: Kt
        }, b()), [ue(Gt), yt(Gt)])
      });
    };
  }
}), Transfer$1 = Transfer, cssClasses$5 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-highlight`
}, prefixCls$5 = cssClasses$5.PREFIX, propTypes$b = {
  // style: PropTypes.object,
  // className: PropTypes.string,
  autoEscape: bool,
  caseSensitive: bool,
  sourceString: string$3,
  searchWords: array$1,
  highlightStyle: object$1,
  highlightClassName: string$3,
  component: string$3
}, defaultProps$a = {
  component: "mark",
  autoEscape: !0,
  caseSensitive: !1,
  sourceString: ""
}, vuePropsType$o = vuePropsMake(propTypes$b, defaultProps$a), Highlight = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$o
  },
  name: "Highlight",
  setup(s, {}) {
    return useSlots(), () => {
      const {
        searchWords: o,
        sourceString: l,
        component: u,
        highlightClassName: c,
        highlightStyle: m,
        caseSensitive: g,
        autoEscape: v
      } = s, b = cls({
        [`${prefixCls$5}-tag`]: !0
      }, c);
      return getHighLightTextHTML({
        sourceString: l,
        searchWords: o,
        option: {
          highlightTag: u,
          highlightClassName: b,
          highlightStyle: m,
          caseSensitive: g,
          autoEscape: v
        }
      });
    };
  }
}), Highlight$1 = Highlight, pathToArrayElem = (s) => {
  const o = lodashExports.toPath(s);
  return lodashExports.isNumber(s) && o.length === 1 ? !1 : Number.isInteger(+o[o.length - 1]);
};
function isEmptyObject(s) {
  if (lodashExports.isObject(s)) {
    const o = lodashExports.values(s);
    return o.length ? o.every((l) => typeof l > "u") : !0;
  } else
    return !1;
}
function cleanup(s, o, l = !0) {
  if (o.length === 0)
    return;
  const u = lodashExports.get(s, o);
  (Array.isArray(u) && u.every((c) => c == null) || isEmptyObject(u)) && lodashExports.unset(s, o), cleanup(s, o.slice(0, o.length - 1), l);
}
function empty$4(s) {
  return lodashExports.values(s).length === 0;
}
function get(s, o) {
  return lodashExports.get(s, o);
}
function remove(s, o) {
  lodashExports.unset(s, o);
  let l = lodashExports.toPath(o);
  l = l.slice(0, l.length - 1), cleanup(s, l, !1);
}
function set(s, o, l, u) {
  if (u || l !== void 0)
    return lodashExports.set(s, o, l);
  if (pathToArrayElem(o) && get(s, o) !== void 0) {
    lodashExports.set(s, o, void 0);
    let c = lodashExports.toPath(o);
    c = c.slice(0, c.length - 1), cleanup(s, c, !1);
  } else !pathToArrayElem(o) && get(s, o) !== void 0 && remove(s, o);
}
function _extends() {
  return _extends = Object.assign || function(s) {
    for (var o = 1; o < arguments.length; o++) {
      var l = arguments[o];
      for (var u in l)
        Object.prototype.hasOwnProperty.call(l, u) && (s[u] = l[u]);
    }
    return s;
  }, _extends.apply(this, arguments);
}
function _inheritsLoose(s, o) {
  s.prototype = Object.create(o.prototype), s.prototype.constructor = s, _setPrototypeOf(s, o);
}
function _getPrototypeOf(s) {
  return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function(l) {
    return l.__proto__ || Object.getPrototypeOf(l);
  }, _getPrototypeOf(s);
}
function _setPrototypeOf(s, o) {
  return _setPrototypeOf = Object.setPrototypeOf || function(u, c) {
    return u.__proto__ = c, u;
  }, _setPrototypeOf(s, o);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham) return !1;
  if (typeof Proxy == "function") return !0;
  try {
    return Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    })), !0;
  } catch {
    return !1;
  }
}
function _construct(s, o, l) {
  return _isNativeReflectConstruct() ? _construct = Reflect.construct : _construct = function(c, m, g) {
    var v = [null];
    v.push.apply(v, m);
    var b = Function.bind.apply(c, v), S = new b();
    return g && _setPrototypeOf(S, g.prototype), S;
  }, _construct.apply(null, arguments);
}
function _isNativeFunction(s) {
  return Function.toString.call(s).indexOf("[native code]") !== -1;
}
function _wrapNativeSuper(s) {
  var o = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
  return _wrapNativeSuper = function(u) {
    if (u === null || !_isNativeFunction(u)) return u;
    if (typeof u != "function")
      throw new TypeError("Super expression must either be null or a function");
    if (typeof o < "u") {
      if (o.has(u)) return o.get(u);
      o.set(u, c);
    }
    function c() {
      return _construct(u, arguments, _getPrototypeOf(this).constructor);
    }
    return c.prototype = Object.create(u.prototype, {
      constructor: {
        value: c,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }), _setPrototypeOf(c, u);
  }, _wrapNativeSuper(s);
}
var formatRegExp = /%[sdj%]/g, warning = function() {
};
typeof process < "u" && process.env && process.env.NODE_ENV !== "production" && typeof window < "u" && typeof document < "u" && (warning = function(o, l) {
  typeof console < "u" && console.warn && l.every(function(u) {
    return typeof u == "string";
  }) && console.warn(o, l);
});
function convertFieldsError(s) {
  if (!s || !s.length) return null;
  var o = {};
  return s.forEach(function(l) {
    var u = l.field;
    o[u] = o[u] || [], o[u].push(l);
  }), o;
}
function format() {
  for (var s = arguments.length, o = new Array(s), l = 0; l < s; l++)
    o[l] = arguments[l];
  var u = 1, c = o[0], m = o.length;
  if (typeof c == "function")
    return c.apply(null, o.slice(1));
  if (typeof c == "string") {
    var g = String(c).replace(formatRegExp, function(v) {
      if (v === "%%")
        return "%";
      if (u >= m)
        return v;
      switch (v) {
        case "%s":
          return String(o[u++]);
        case "%d":
          return Number(o[u++]);
        case "%j":
          try {
            return JSON.stringify(o[u++]);
          } catch {
            return "[Circular]";
          }
          break;
        default:
          return v;
      }
    });
    return g;
  }
  return c;
}
function isNativeStringType(s) {
  return s === "string" || s === "url" || s === "hex" || s === "email" || s === "date" || s === "pattern";
}
function isEmptyValue(s, o) {
  return !!(s == null || o === "array" && Array.isArray(s) && !s.length || isNativeStringType(o) && typeof s == "string" && !s);
}
function asyncParallelArray(s, o, l) {
  var u = [], c = 0, m = s.length;
  function g(v) {
    u.push.apply(u, v), c++, c === m && l(u);
  }
  s.forEach(function(v) {
    o(v, g);
  });
}
function asyncSerialArray(s, o, l) {
  var u = 0, c = s.length;
  function m(g) {
    if (g && g.length) {
      l(g);
      return;
    }
    var v = u;
    u = u + 1, v < c ? o(s[v], m) : l([]);
  }
  m([]);
}
function flattenObjArr(s) {
  var o = [];
  return Object.keys(s).forEach(function(l) {
    o.push.apply(o, s[l]);
  }), o;
}
var AsyncValidationError = /* @__PURE__ */ function(s) {
  _inheritsLoose(o, s);
  function o(l, u) {
    var c;
    return c = s.call(this, "Async Validation Error") || this, c.errors = l, c.fields = u, c;
  }
  return o;
}(/* @__PURE__ */ _wrapNativeSuper(Error));
function asyncMap(s, o, l, u) {
  if (o.first) {
    var c = new Promise(function(P, T) {
      var N = function(Q) {
        return u(Q), Q.length ? T(new AsyncValidationError(Q, convertFieldsError(Q))) : P();
      }, O = flattenObjArr(s);
      asyncSerialArray(O, l, N);
    });
    return c.catch(function(P) {
      return P;
    }), c;
  }
  var m = o.firstFields || [];
  m === !0 && (m = Object.keys(s));
  var g = Object.keys(s), v = g.length, b = 0, S = [], E = new Promise(function(P, T) {
    var N = function(z) {
      if (S.push.apply(S, z), b++, b === v)
        return u(S), S.length ? T(new AsyncValidationError(S, convertFieldsError(S))) : P();
    };
    g.length || (u(S), P()), g.forEach(function(O) {
      var z = s[O];
      m.indexOf(O) !== -1 ? asyncSerialArray(z, l, N) : asyncParallelArray(z, l, N);
    });
  });
  return E.catch(function(P) {
    return P;
  }), E;
}
function complementError(s) {
  return function(o) {
    return o && o.message ? (o.field = o.field || s.fullField, o) : {
      message: typeof o == "function" ? o() : o,
      field: o.field || s.fullField
    };
  };
}
function deepMerge(s, o) {
  if (o) {
    for (var l in o)
      if (o.hasOwnProperty(l)) {
        var u = o[l];
        typeof u == "object" && typeof s[l] == "object" ? s[l] = _extends({}, s[l], u) : s[l] = u;
      }
  }
  return s;
}
function required(s, o, l, u, c, m) {
  s.required && (!l.hasOwnProperty(s.field) || isEmptyValue(o, m || s.type)) && u.push(format(c.messages.required, s.fullField));
}
function whitespace$1(s, o, l, u, c) {
  (/^\s+$/.test(o) || o === "") && u.push(format(c.messages.whitespace, s.fullField));
}
var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", "i"),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
}, types$3 = {
  integer: function(o) {
    return types$3.number(o) && parseInt(o, 10) === o;
  },
  float: function(o) {
    return types$3.number(o) && !types$3.integer(o);
  },
  array: function(o) {
    return Array.isArray(o);
  },
  regexp: function(o) {
    if (o instanceof RegExp)
      return !0;
    try {
      return !!new RegExp(o);
    } catch {
      return !1;
    }
  },
  date: function(o) {
    return typeof o.getTime == "function" && typeof o.getMonth == "function" && typeof o.getYear == "function" && !isNaN(o.getTime());
  },
  number: function(o) {
    return isNaN(o) ? !1 : typeof o == "number";
  },
  object: function(o) {
    return typeof o == "object" && !types$3.array(o);
  },
  method: function(o) {
    return typeof o == "function";
  },
  email: function(o) {
    return typeof o == "string" && !!o.match(pattern.email) && o.length < 255;
  },
  url: function(o) {
    return typeof o == "string" && !!o.match(pattern.url);
  },
  hex: function(o) {
    return typeof o == "string" && !!o.match(pattern.hex);
  }
};
function type(s, o, l, u, c) {
  if (s.required && o === void 0) {
    required(s, o, l, u, c);
    return;
  }
  var m = ["integer", "float", "array", "regexp", "object", "method", "email", "number", "date", "url", "hex"], g = s.type;
  m.indexOf(g) > -1 ? types$3[g](o) || u.push(format(c.messages.types[g], s.fullField, s.type)) : g && typeof o !== s.type && u.push(format(c.messages.types[g], s.fullField, s.type));
}
function range(s, o, l, u, c) {
  var m = typeof s.len == "number", g = typeof s.min == "number", v = typeof s.max == "number", b = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, S = o, E = null, P = typeof o == "number", T = typeof o == "string", N = Array.isArray(o);
  if (P ? E = "number" : T ? E = "string" : N && (E = "array"), !E)
    return !1;
  N && (S = o.length), T && (S = o.replace(b, "_").length), m ? S !== s.len && u.push(format(c.messages[E].len, s.fullField, s.len)) : g && !v && S < s.min ? u.push(format(c.messages[E].min, s.fullField, s.min)) : v && !g && S > s.max ? u.push(format(c.messages[E].max, s.fullField, s.max)) : g && v && (S < s.min || S > s.max) && u.push(format(c.messages[E].range, s.fullField, s.min, s.max));
}
var ENUM = "enum";
function enumerable(s, o, l, u, c) {
  s[ENUM] = Array.isArray(s[ENUM]) ? s[ENUM] : [], s[ENUM].indexOf(o) === -1 && u.push(format(c.messages[ENUM], s.fullField, s[ENUM].join(", ")));
}
function pattern$1(s, o, l, u, c) {
  if (s.pattern) {
    if (s.pattern instanceof RegExp)
      s.pattern.lastIndex = 0, s.pattern.test(o) || u.push(format(c.messages.pattern.mismatch, s.fullField, o, s.pattern));
    else if (typeof s.pattern == "string") {
      var m = new RegExp(s.pattern);
      m.test(o) || u.push(format(c.messages.pattern.mismatch, s.fullField, o, s.pattern));
    }
  }
}
var rules = {
  required,
  whitespace: whitespace$1,
  type,
  range,
  enum: enumerable,
  pattern: pattern$1
};
function string$2(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o, "string") && !s.required)
      return l();
    rules.required(s, o, u, m, c, "string"), isEmptyValue(o, "string") || (rules.type(s, o, u, m, c), rules.range(s, o, u, m, c), rules.pattern(s, o, u, m, c), s.whitespace === !0 && rules.whitespace(s, o, u, m, c));
  }
  l(m);
}
function method(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && rules.type(s, o, u, m, c);
  }
  l(m);
}
function number$1(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (o === "" && (o = void 0), isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && (rules.type(s, o, u, m, c), rules.range(s, o, u, m, c));
  }
  l(m);
}
function _boolean(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && rules.type(s, o, u, m, c);
  }
  l(m);
}
function regexp(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), isEmptyValue(o) || rules.type(s, o, u, m, c);
  }
  l(m);
}
function integer(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && (rules.type(s, o, u, m, c), rules.range(s, o, u, m, c));
  }
  l(m);
}
function floatFn(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && (rules.type(s, o, u, m, c), rules.range(s, o, u, m, c));
  }
  l(m);
}
function array(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (o == null && !s.required)
      return l();
    rules.required(s, o, u, m, c, "array"), o != null && (rules.type(s, o, u, m, c), rules.range(s, o, u, m, c));
  }
  l(m);
}
function object(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && rules.type(s, o, u, m, c);
  }
  l(m);
}
var ENUM$1 = "enum";
function enumerable$1(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c), o !== void 0 && rules[ENUM$1](s, o, u, m, c);
  }
  l(m);
}
function pattern$2(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o, "string") && !s.required)
      return l();
    rules.required(s, o, u, m, c), isEmptyValue(o, "string") || rules.pattern(s, o, u, m, c);
  }
  l(m);
}
function date(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o, "date") && !s.required)
      return l();
    if (rules.required(s, o, u, m, c), !isEmptyValue(o, "date")) {
      var v;
      o instanceof Date ? v = o : v = new Date(o), rules.type(s, v, u, m, c), v && rules.range(s, v.getTime(), u, m, c);
    }
  }
  l(m);
}
function required$1(s, o, l, u, c) {
  var m = [], g = Array.isArray(o) ? "array" : typeof o;
  rules.required(s, o, u, m, c, g), l(m);
}
function type$1(s, o, l, u, c) {
  var m = s.type, g = [], v = s.required || !s.required && u.hasOwnProperty(s.field);
  if (v) {
    if (isEmptyValue(o, m) && !s.required)
      return l();
    rules.required(s, o, u, g, c, m), isEmptyValue(o, m) || rules.type(s, o, u, g, c);
  }
  l(g);
}
function any(s, o, l, u, c) {
  var m = [], g = s.required || !s.required && u.hasOwnProperty(s.field);
  if (g) {
    if (isEmptyValue(o) && !s.required)
      return l();
    rules.required(s, o, u, m, c);
  }
  l(m);
}
var validators = {
  string: string$2,
  method,
  number: number$1,
  boolean: _boolean,
  regexp,
  integer,
  float: floatFn,
  array,
  object,
  enum: enumerable$1,
  pattern: pattern$2,
  date,
  url: type$1,
  hex: type$1,
  email: type$1,
  required: required$1,
  any
};
function newMessages() {
  return {
    default: "Validation error on field %s",
    required: "%s is required",
    enum: "%s must be one of %s",
    whitespace: "%s cannot be empty",
    date: {
      format: "%s date %s is invalid for format %s",
      parse: "%s date could not be parsed, %s is invalid ",
      invalid: "%s date %s is invalid"
    },
    types: {
      string: "%s is not a %s",
      method: "%s is not a %s (function)",
      array: "%s is not an %s",
      object: "%s is not an %s",
      number: "%s is not a %s",
      date: "%s is not a %s",
      boolean: "%s is not a %s",
      integer: "%s is not an %s",
      float: "%s is not a %s",
      regexp: "%s is not a valid %s",
      email: "%s is not a valid %s",
      url: "%s is not a valid %s",
      hex: "%s is not a valid %s"
    },
    string: {
      len: "%s must be exactly %s characters",
      min: "%s must be at least %s characters",
      max: "%s cannot be longer than %s characters",
      range: "%s must be between %s and %s characters"
    },
    number: {
      len: "%s must equal %s",
      min: "%s cannot be less than %s",
      max: "%s cannot be greater than %s",
      range: "%s must be between %s and %s"
    },
    array: {
      len: "%s must be exactly %s in length",
      min: "%s cannot be less than %s in length",
      max: "%s cannot be greater than %s in length",
      range: "%s must be between %s and %s in length"
    },
    pattern: {
      mismatch: "%s value %s does not match pattern %s"
    },
    clone: function() {
      var o = JSON.parse(JSON.stringify(this));
      return o.clone = this.clone, o;
    }
  };
}
var messages$1 = newMessages();
function Schema$1(s) {
  this.rules = null, this._messages = messages$1, this.define(s);
}
Schema$1.prototype = {
  messages: function(o) {
    return o && (this._messages = deepMerge(newMessages(), o)), this._messages;
  },
  define: function(o) {
    if (!o)
      throw new Error("Cannot configure a schema with no rules");
    if (typeof o != "object" || Array.isArray(o))
      throw new Error("Rules must be an object");
    this.rules = {};
    var l, u;
    for (l in o)
      o.hasOwnProperty(l) && (u = o[l], this.rules[l] = Array.isArray(u) ? u : [u]);
  },
  validate: function(o, l, u) {
    var c = this;
    l === void 0 && (l = {}), u === void 0 && (u = function() {
    });
    var m = o, g = l, v = u;
    if (typeof g == "function" && (v = g, g = {}), !this.rules || Object.keys(this.rules).length === 0)
      return v && v(), Promise.resolve();
    function b(z) {
      var Q, W = [], ue = {};
      function te(K) {
        if (Array.isArray(K)) {
          var ve;
          W = (ve = W).concat.apply(ve, K);
        } else
          W.push(K);
      }
      for (Q = 0; Q < z.length; Q++)
        te(z[Q]);
      W.length ? ue = convertFieldsError(W) : (W = null, ue = null), v(W, ue);
    }
    if (g.messages) {
      var S = this.messages();
      S === messages$1 && (S = newMessages()), deepMerge(S, g.messages), g.messages = S;
    } else
      g.messages = this.messages();
    var E, P, T = {}, N = g.keys || Object.keys(this.rules);
    N.forEach(function(z) {
      E = c.rules[z], P = m[z], E.forEach(function(Q) {
        var W = Q;
        typeof W.transform == "function" && (m === o && (m = _extends({}, m)), P = m[z] = W.transform(P)), typeof W == "function" ? W = {
          validator: W
        } : W = _extends({}, W), W.validator = c.getValidationMethod(W), W.field = z, W.fullField = W.fullField || z, W.type = c.getType(W), W.validator && (T[z] = T[z] || [], T[z].push({
          rule: W,
          value: P,
          source: m,
          field: z
        }));
      });
    });
    var O = {};
    return asyncMap(T, g, function(z, Q) {
      var W = z.rule, ue = (W.type === "object" || W.type === "array") && (typeof W.fields == "object" || typeof W.defaultField == "object");
      ue = ue && (W.required || !W.required && z.value), W.field = z.field;
      function te(ee, Re) {
        return _extends({}, Re, {
          fullField: W.fullField + "." + ee
        });
      }
      function K(ee) {
        ee === void 0 && (ee = []);
        var Re = ee;
        if (Array.isArray(Re) || (Re = [Re]), !g.suppressWarning && Re.length && Schema$1.warning("async-validator:", Re), Re.length && W.message !== void 0 && (Re = [].concat(W.message)), Re = Re.map(complementError(W)), g.first && Re.length)
          return O[W.field] = 1, Q(Re);
        if (!ue)
          Q(Re);
        else {
          if (W.required && !z.value)
            return W.message !== void 0 ? Re = [].concat(W.message).map(complementError(W)) : g.error && (Re = [g.error(W, format(g.messages.required, W.field))]), Q(Re);
          var wt = {};
          if (W.defaultField)
            for (var yt in z.value)
              z.value.hasOwnProperty(yt) && (wt[yt] = W.defaultField);
          wt = _extends({}, wt, z.rule.fields);
          for (var xt in wt)
            if (wt.hasOwnProperty(xt)) {
              var Kt = Array.isArray(wt[xt]) ? wt[xt] : [wt[xt]];
              wt[xt] = Kt.map(te.bind(null, xt));
            }
          var tn = new Schema$1(wt);
          tn.messages(g.messages), z.rule.options && (z.rule.options.messages = g.messages, z.rule.options.error = g.error), tn.validate(z.value, z.rule.options || g, function(ln) {
            var rn = [];
            Re && Re.length && rn.push.apply(rn, Re), ln && ln.length && rn.push.apply(rn, ln), Q(rn.length ? rn : null);
          });
        }
      }
      var ve;
      W.asyncValidator ? ve = W.asyncValidator(W, z.value, K, z.source, g) : W.validator && (ve = W.validator(W, z.value, K, z.source, g), ve === !0 ? K() : ve === !1 ? K(W.message || W.field + " fails") : ve instanceof Array ? K(ve) : ve instanceof Error && K(ve.message)), ve && ve.then && ve.then(function() {
        return K();
      }, function(ee) {
        return K(ee);
      });
    }, function(z) {
      b(z);
    });
  },
  getType: function(o) {
    if (o.type === void 0 && o.pattern instanceof RegExp && (o.type = "pattern"), typeof o.validator != "function" && o.type && !validators.hasOwnProperty(o.type))
      throw new Error(format("Unknown rule type %s", o.type));
    return o.type || "string";
  },
  getValidationMethod: function(o) {
    if (typeof o.validator == "function")
      return o.validator;
    var l = Object.keys(o), u = l.indexOf("message");
    return u !== -1 && l.splice(u, 1), l.length === 1 && l[0] === "required" ? validators.required : validators[this.getType(o)] || !1;
  }
};
Schema$1.register = function(o, l) {
  if (typeof l != "function")
    throw new Error("Cannot register a validator by type, validator is not a function");
  validators[o] = l;
};
Schema$1.warning = warning;
Schema$1.messages = messages$1;
Schema$1.validators = validators;
function generateValidatesFromRules(s, o = []) {
  const l = {};
  return l[s] = o, new Schema$1(l);
}
function isRequired(s = []) {
  let o = !1;
  return typeof s == "object" && "required" in s ? o = s.required : Array.isArray(s) && s.length && s.forEach((l) => {
    l.required && (o = !0);
  }), o;
}
function isValid$1(s) {
  let o = !0;
  return typeof s == "string" && s.length ? o = !1 : Array.isArray(s) && s.length ? o = s.every((l) => isValid$1(l)) : typeof s == "boolean" ? o = s : s && typeof s.$$typeof == "symbol" && s.$$typeof.toString() === "Symbol(react.element)" && (o = !1), o;
}
function transformTrigger(s, o) {
  let l = [], u = [];
  return lodashExports.isUndefined(s) ? lodashExports.isUndefined(o) ? l = strings$6.DEFAULT_TRIGGER : l = o : l = s, Array.isArray(l) && (u = l), typeof l == "string" && (u[0] = l), u;
}
function transformDefaultBooleanAPI(s, o, l = !1) {
  return lodashExports.isUndefined(s) ? lodashExports.isUndefined(o) ? l : o : s;
}
function mergeOptions(s, o) {
  const u = { ...{
    valueKey: "value",
    onKeyChangeFnName: "onChange",
    valuePath: "",
    maintainCursor: !1,
    shouldInject: !0,
    shouldMemo: !0
  }, ...s }, c = "field" in o ? !0 : u.shouldInject;
  return { options: u, shouldInject: c };
}
function mergeProps(s) {
  const o = {
    // validateStatus: 'default',
    allowEmptyString: !1,
    allowEmpty: !1,
    emptyValue: "",
    noLabel: !1,
    noErrorMessage: !1,
    isInInputGroup: !1
  };
  let {
    field: l,
    label: u,
    labelPosition: c,
    labelWidth: m,
    labelAlign: g,
    labelCol: v,
    wrapperCol: b,
    initValue: S,
    validate: E,
    /**
     * error、warning、default、success
     */
    validateStatus: P,
    /**
     * change、blur、custom、mount
     */
    trigger: T,
    allowEmptyString: N,
    allowEmpty: O,
    emptyValue: z,
    rules: Q,
    onChange: W,
    keepState: ue,
    // Conversion before validation
    transform: te,
    name: K,
    fieldClassName: ve,
    fieldStyle: ee,
    noLabel: Re,
    noErrorMessage: wt,
    isInInputGroup: yt,
    stopValidateWithError: xt,
    convert: Kt,
    showValidateIcon: tn,
    helpText: ln,
    extraText: rn,
    extraTextPosition: an,
    pure: Gt,
    id: nn,
    ...vt
  } = { ...o, ...s };
  delete vt.defaultChecked, delete vt.defaultValue, delete vt.checked, typeof S < "u" && (S = index$b(S));
  const Et = isRequired(Q);
  return z = typeof z < "u" ? z : "", {
    field: l,
    label: u,
    labelPosition: c,
    labelWidth: m,
    labelAlign: g,
    labelCol: v,
    wrapperCol: b,
    noLabel: Re,
    noErrorMessage: wt,
    isInInputGroup: yt,
    initValue: S,
    validate: E,
    validateStatus: P,
    trigger: T,
    allowEmptyString: N,
    allowEmpty: O,
    emptyValue: z,
    rules: Q,
    required: Et,
    keepState: ue,
    transform: te,
    name: K,
    fieldClassName: ve,
    fieldStyle: ee,
    convert: Kt,
    stopValidateWithError: xt,
    showValidateIcon: tn,
    helpText: ln,
    extraText: rn,
    extraTextPosition: an,
    pure: Gt,
    rest: vt,
    id: nn
  };
}
class FormFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o });
    let { initValues: l } = this._adapter.getProps();
    l = this._adapter.cloneDeep(l), this.data = {
      values: l || {},
      errors: {},
      touched: {}
      // invalid: false,
      // dirty: false,
    }, this.fields = /* @__PURE__ */ new Map(), this.registered = {}, this.registeredArrayField = /* @__PURE__ */ new Map(), this.register = this.register.bind(this), this.unRegister = this.unRegister.bind(this), this.registerArrayField = this.registerArrayField.bind(this), this.unRegisterArrayField = this.unRegisterArrayField.bind(this), this.getArrayField = this.getArrayField.bind(this), this.updateArrayField = this.updateArrayField.bind(this), this.getField = this.getField.bind(this), this.setValues = this.setValues.bind(this), this.updateStateValue = this.updateStateValue.bind(this), this.updateStateError = this.updateStateError.bind(this), this.updateStateTouched = this.updateStateTouched.bind(this), this.getFormState = this.getFormState.bind(this), this.getValue = this.getValue.bind(this), this.getError = this.getError.bind(this), this.getTouched = this.getTouched.bind(this), this.getInitValues = this.getInitValues.bind(this), this.getInitValue = this.getInitValue.bind(this), this.getFormProps = this.getFormProps.bind(this), this.getFieldExist = this.getFieldExist.bind(this), this.scrollToField = this.scrollToField.bind(this), this.scrollToError = this.scrollToError.bind(this);
  }
  init() {
    this._adapter.initFormId();
  }
  getField(o) {
    return this.fields.get(o);
  }
  register(o, l, u) {
    if (this.registered[o], this.registered[o] = !0, this.fields.set(o, u), !u.keepState) {
      const c = u.allowEmpty || !1, m = {
        notNotify: !0,
        notUpdate: !1,
        allowEmpty: c
      };
      let g = l.value;
      !c && g === "" && (g = void 0), this.updateStateValue(o, g, m), l.error && this.updateStateError(o, l.error, m);
    }
  }
  unRegister(o) {
    const l = this.fields.get(o);
    try {
      l.keepState || (remove(this.data.values, o), remove(this.data.errors, o), remove(this.data.touched, o));
    } catch {
      console.error(`some thing wrong when unregister field:${o}`);
    }
    this.fields.delete(o), this._adapter.notifyChange(this.data), this._adapter.forceUpdate();
  }
  // in order to solve bytedance internal issue-289
  registerArrayField(o, l) {
    this.updateArrayField(o, {
      updateKey: (/* @__PURE__ */ new Date()).valueOf(),
      initValue: l
    });
  }
  unRegisterArrayField(o) {
    this.registeredArrayField.delete(o);
  }
  getArrayField(o) {
    return this.registeredArrayField.get(o);
  }
  updateArrayField(o, l) {
    const u = { ...this.registeredArrayField.get(o), ...l };
    this.registeredArrayField.set(o, u);
  }
  validate(o) {
    const { validateFields: l } = this.getProps();
    return l && lodashExports.isFunction(l) ? this._formValidate() : this._fieldsValidate(o);
  }
  // form level validate
  _formValidate() {
    const { values: o } = this.data, { validateFields: l } = this.getProps();
    return new Promise((u, c) => {
      let m;
      try {
        m = l(o);
      } catch (g) {
        m = g;
      }
      if (m)
        isPromise(m) ? m.then(
          (g) => {
            if (g)
              this.data.errors = g, this._adapter.notifyChange(this.data), this.injectErrorToField(g), this._adapter.forceUpdate(), this._autoScroll(100), c(g);
            else {
              const v = this._adapter.cloneDeep(o);
              u(v), this.injectErrorToField({});
            }
          },
          (g) => {
            this._autoScroll(100), c(g);
          }
        ) : (this.data.errors = m, this.injectErrorToField(m), this._adapter.notifyChange(this.data), this._adapter.forceUpdate(), this._autoScroll(100), c(m));
      else {
        const g = this._adapter.cloneDeep(o);
        u(g), this.injectErrorToField({});
      }
    });
  }
  // field level validate
  _fieldsValidate(o) {
    const { values: l } = this.data;
    return new Promise((u, c) => {
      let m = [];
      const g = this._getOperateFieldMap(o);
      g.forEach((v, b) => {
        const S = this.getValue(b), E = {
          notNotify: !0,
          notUpdate: !0
        }, P = v.fieldApi.validate(S, E);
        m.push(P), v.fieldApi.setTouched(!0, E);
      }), Promise.all(m).then(() => {
        this._adapter.notifyChange(this.data), this._adapter.forceUpdate();
        const v = this.getError();
        if (this._isValid(g)) {
          const b = this._adapter.cloneDeep(l);
          u(b);
        } else
          this._autoScroll(), c(v);
      });
    });
  }
  submit(o) {
    const { values: l } = this.data;
    this.validate().then((u) => {
      const c = this._adapter.cloneDeep(u);
      this._adapter.notifySubmit(c, o);
    }).catch((u) => {
      const c = this._adapter.cloneDeep(u), m = this._adapter.cloneDeep(l);
      this._adapter.notifySubmitFail(c, m, o);
    });
  }
  /**
   * Case A：
   *      All fields: a[0]、a[1]、b.type、b.name[2]、b.name[0]
   *      input => output:
   *           a  => a[0]、a[1]
   *           b  => b.type、b.name[0]、b.name[2]
   *
   * Case B：
   *      All fields: activity.a[0]、activity.a[1]、activity.c、activity.d、other
   *      input => output:
   *           activity.a => activity.a[0]、activity.a[1]
   *
   */
  _getNestedField(o) {
    const l = this.fields, u = [...l].map((m) => m[0]);
    let c = /* @__PURE__ */ new Map();
    return u.forEach((m) => {
      let g = lodashExports.toPath(m), v = lodashExports.toPath(o);
      if (v.every((b, S) => v[S] === g[S])) {
        const b = l.get(m);
        c.set(m, b);
      }
    }), c;
  }
  // get all operate fields, called by validate() / reset()
  _getOperateFieldMap(o) {
    let l = /* @__PURE__ */ new Map();
    return lodashExports.isUndefined(o) ? l = this.fields : o.forEach((u) => {
      const c = this.fields.get(u);
      if (lodashExports.isUndefined(c)) {
        const m = this._getNestedField(u);
        l = new Map([...l, ...m]);
      } else
        l.set(u, c);
    }), l;
  }
  // Reset the entire form, reset all fields and remove validation results
  reset(o) {
    this._getOperateFieldMap(o).forEach((u) => {
      u.fieldApi.reset();
    }), this.registeredArrayField.size && this._resetArrayField(), this._adapter.notifyChange(this.data), this._adapter.forceUpdate(), this._adapter.notifyReset();
  }
  _resetArrayField() {
    [...this.registeredArrayField.keys()].forEach((l) => {
      const c = this.registeredArrayField.get(l).initValue;
      this.updateStateValue(l, c, { notNotify: !0, notUpdate: !0 }), this.updateArrayField(l, { updateKey: (/* @__PURE__ */ new Date()).valueOf() });
    });
  }
  // After calling the form's custom validateFields function, reject the returned error to the corresponding field
  // 调用了Form的自定义validateFields函数后，将返回的错误展示到对应的field中
  injectErrorToField(o) {
    this.fields.forEach((l) => {
      const u = get(o, l.field), c = {
        notNotify: !0,
        notUpdate: !0
      };
      l.fieldApi.setError(u, c);
    });
  }
  getValue(o, l) {
    const u = typeof o > "u", c = l && l.needClone;
    let m, g;
    switch (!0) {
      case (!u && !c):
        m = get(this.data.values, o);
        break;
      case (!u && c):
        g = get(this.data.values, o), m = this._adapter.cloneDeep(g);
        break;
      case (u && !c):
        m = { ...this.data.values };
        break;
      case (u && c):
        m = this._adapter.cloneDeep(this.data.values);
        break;
    }
    return m;
  }
  setValues(o, { isOverride: l = !1 }) {
    const u = this._adapter.cloneDeep(o);
    this.fields.forEach((c) => {
      const m = get(u, c.field), g = {
        notNotify: !0,
        notUpdate: !0
      };
      c.fieldApi.setValue(m, g);
    }), this.registeredArrayField.size && [...this.registeredArrayField.keys()].forEach((m) => {
      this.updateArrayField(m, { updateKey: (/* @__PURE__ */ new Date()).valueOf() });
    }), l && (this.data.values = u), this._adapter.notifyChange(this.data), this._adapter.notifyValueChange(this.data.values, { ...o }), this._adapter.forceUpdate();
  }
  // update formState value
  updateStateValue(o, l, u, c) {
    const m = u && u.notNotify, g = u && u.notUpdate, v = u && u.fieldAllowEmpty, b = this.getProp("allowEmpty"), S = v || b;
    set(this.data.values, o, l, S), m || (this._adapter.notifyChange(this.data), this._adapter.notifyValueChange(this.data.values, { [o]: l })), g || this._adapter.forceUpdate(c);
  }
  // get touched from formState
  getTouched(o) {
    return typeof o > "u" ? this.data.touched : get(this.data.touched, o);
  }
  // update formState touched
  updateStateTouched(o, l, u, c) {
    const m = u && u.notNotify, g = u && u.notUpdate;
    set(this.data.touched, o, l), m || this._adapter.notifyChange(this.data), g || this._adapter.forceUpdate(c);
  }
  // get error from formState
  getError(o) {
    return typeof o > "u" ? this.data.errors : get(this.data.errors, o);
  }
  // update formState error
  updateStateError(o, l, u, c) {
    const m = u && u.notNotify, g = u && u.notUpdate;
    set(this.data.errors, o, l), m || this._adapter.notifyChange(this.data), g || this._adapter.forceUpdate(c);
  }
  // For internal use in the FormApi Operating Field
  getFieldSetterApi() {
    return {
      setValue: (c, m, g) => {
        const v = this.fields.get(c) ? this.fields.get(c).fieldApi : void 0, b = this._adapter.cloneDeep(m);
        v ? v.setValue(b, g) : (this.updateStateValue(c, b, g, () => {
          let S = this._getNestedField(c);
          S.size && S.forEach((E) => {
            let P = E.field, T = get(this.data.values, P), N = { notNotify: !0, notUpdate: !0 };
            E.fieldApi.setValue(T, N);
          });
        }), this.getArrayField(c) && this.updateArrayField(c, { updateKey: (/* @__PURE__ */ new Date()).valueOf() }));
      },
      setError: (c, m, g) => {
        const v = this.fields.get(c) ? this.fields.get(c).fieldApi : void 0, b = this._adapter.cloneDeep(m);
        v ? v.setError(b, g) : (this.updateStateError(c, b, g, () => {
          let S = this._getNestedField(c);
          S.size && S.forEach((E) => {
            let P = E.field, T = get(this.data.errors, P), N = { notNotify: !0, notUpdate: !0 };
            E.fieldApi.setError(T, N);
          });
        }), this.getArrayField(c) && this.updateArrayField(c, { updateKey: (/* @__PURE__ */ new Date()).valueOf() }));
      },
      setTouched: (c, m, g) => {
        const v = this.fields.get(c) ? this.fields.get(c).fieldApi : void 0;
        v ? v.setTouched(m, g) : (this.updateStateTouched(c, m, g, () => {
          let b = this._getNestedField(c);
          b.size && b.forEach((S) => {
            let E = S.field, P = get(this.data.touched, E), T = { notNotify: !0, notUpdate: !0 };
            S.fieldApi.setTouched(P, T);
          });
        }), this.getArrayField(c) && this.updateArrayField(c, { updateKey: (/* @__PURE__ */ new Date()).valueOf() }));
      }
    };
  }
  // For Field and ArrayField to read and modify FormState
  getModifyFormStateApi() {
    return {
      register: this.register,
      unRegister: this.unRegister,
      updateStateValue: this.updateStateValue,
      updateStateError: this.updateStateError,
      updateStateTouched: this.updateStateTouched,
      getValue: this.getValue,
      getError: this.getError,
      getTouched: this.getTouched,
      getInitValues: this.getInitValues,
      getInitValue: this.getInitValue,
      getFormProps: this.getFormProps,
      getField: this.getField,
      registerArrayField: this.registerArrayField,
      unRegisterArrayField: this.unRegisterArrayField,
      getArrayField: this.getArrayField,
      updateArrayField: this.updateArrayField
    };
  }
  // Form APIs for external use, exposed to the user
  getFormApi() {
    return {
      ...this.getFieldSetterApi(),
      reset: (l) => this.reset(l),
      validate: (l) => this.validate(l),
      getValue: (l) => this.getValue(l, { needClone: !0 }),
      getValues: () => this.getValue(void 0, { needClone: !0 }),
      getFormState: () => this.getFormState(!0),
      getFormProps: (l) => this.getFormProps(l),
      getInitValue: (l) => this.getInitValue(l),
      getInitValues: () => this.getInitValues(),
      getTouched: (l) => this.getTouched(l),
      getError: (l) => this.getError(l),
      setValues: (l, u) => this.setValues(l, u || { isOverride: !1 }),
      submitForm: () => this.submit(),
      getFieldExist: (l) => this.getFieldExist(l),
      scrollToField: (l, u) => this.scrollToField(l, u),
      scrollToError: (l) => this.scrollToError(l)
    };
  }
  getFormState(o = !1) {
    return o ? this._adapter.cloneDeep(this.data) : {
      ...this.data
    };
  }
  _isValid(o) {
    let l = !0;
    return o ? [...o.keys()].forEach((c) => {
      const m = get(this.data.errors, c);
      isValid$1(m) || (l = !1);
    }) : l = !!empty$4(this.data.errors), l;
  }
  // get form.props.initValues
  getInitValues() {
    return this._adapter.getInitValues();
  }
  getInitValue(o) {
    return typeof o > "u" ? this._adapter.getInitValues() : get(this._adapter.getInitValues(), o);
  }
  getFormProps(o) {
    return this._adapter.getFormProps(o);
  }
  getFieldExist(o) {
    return !!this.fields.has(o);
  }
  _autoScroll(o) {
    const { autoScrollToError: l } = this.getFormProps();
    if (!l)
      return;
    let u = { behavior: "smooth", block: "start" };
    typeof l == "object" && (u = l), o ? setTimeout(() => this._getErrorFieldAndScroll(u), 100) : this._getErrorFieldAndScroll(u);
  }
  _getErrorFieldAndScroll(o) {
    const l = this._adapter.getAllErrorDOM();
    if (l && l.length)
      try {
        const u = l[0].parentNode.parentNode;
        scrollIntoView(u, o);
      } catch {
      }
  }
  scrollToField(o, l = { behavior: "smooth", block: "start" }) {
    if (this.getFieldExist(o)) {
      const u = this._adapter.getFieldDOM(o);
      scrollIntoView(u, l);
    }
  }
  scrollToError(o) {
    let l = o && o.scrollOpts ? o.scrollOpts : { behavior: "smooth", block: "start" }, u = o && o.field, c = o && o.index, m, g;
    if (typeof c == "number") {
      let b = this._adapter.getAllErrorDOM()[c];
      b && (m = b.parentNode.parentNode);
    } else if (u)
      g = this._adapter.getFieldErrorDOM(u), g && (m = g.parentNode.parentNode);
    else if (typeof u > "u") {
      let v = this._adapter.getAllErrorDOM();
      v && v.length && (m = v[0].parentNode.parentNode);
    }
    m && scrollIntoView(m, l);
  }
}
const vuePropsType$n = {
  value: Object
}, Provider$4 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = shallowRef();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    immediate: !0,
    deep: !0
  }), provide("FormStateContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$n
  },
  name: "FormStateContextProvider"
});
function useFormStateContext() {
  return {
    context: inject("FormStateContext", shallowRef({}))
  };
}
const vuePropsType$m = {
  name: String
}, Consumer$4 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useFormStateContext();
  return () => s.default ? s.default(o) : null;
});
Consumer$4.props = vuePropsType$m;
const vuePropsType$l = {
  value: Object
}, Provider$3 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = shallowRef();
  return provide("BaseFormApiContext", l), watch(() => s.value, () => {
    l.value = s.value;
  }, {
    immediate: !0,
    deep: !0
  }), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$l
  },
  name: "FormApiContextProvider"
});
function useBaseFormApiContext() {
  return {
    context: inject("BaseFormApiContext", shallowRef({}))
  };
}
const vuePropsType$k = {}, Consumer$3 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useBaseFormApiContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$k
  },
  name: "BaseFormApiContextConsumer"
}), vuePropsType$j = {
  value: Object
}, Provider$2 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = shallowRef();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    immediate: !0,
    deep: !0
  }), provide("FormUpdaterContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$j
  },
  name: "FormUpdaterContextProvider"
});
function useFormUpdaterContext() {
  return {
    context: inject("FormUpdaterContext", shallowRef({}))
  };
}
const vuePropsType$i = {
  name: String
}, Consumer$2 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useFormUpdaterContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$i
  },
  name: "FormUpdaterContextConsumer"
}), vuePropsType$h = {
  value: Object
}, Provider$1 = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = shallowRef();
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    immediate: !0,
    deep: !0
  }), provide("ArrayFieldContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$h
  },
  name: "ArrayFieldContextProvider"
});
function useArrayFieldContext() {
  return {
    context: inject("ArrayFieldContext", shallowRef({
      shouldUseInitValue: !0
    }))
  };
}
const vuePropsType$g = {
  name: String
}, Consumer$1 = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = useArrayFieldContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$g
  },
  name: "ArrayFieldContextConsumer"
}), FormStateContext = {
  Provider: Provider$4,
  Consumer: Consumer$4,
  displayName: "FormState"
}, FormApiContext = {
  Provider: Provider$3,
  Consumer: Consumer$3,
  displayName: "FormApi"
}, FormUpdaterContext = {
  Provider: Provider$2,
  Consumer: Consumer$2,
  displayName: "FormUpdater"
}, ArrayFieldContext = {
  Provider: Provider$1,
  Consumer: Consumer$1
};
function _isSlot$3(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefix$4 = cssClasses$h.PREFIX, propTypes$a = {
  "aria-label": string$3,
  onSubmit: func,
  onSubmitFail: func,
  /* Triggered from update, including field mount/unmount/value change/blur/verification status change/error prompt change, input parameter is formState, currentField */
  onChange: func,
  onReset: func,
  // Triggered when the value of the form is updated, only when the value of the subfield changes. The entry parameter is formState.values
  onValueChange: func,
  autoScrollToError: oneOfType([bool, object$1]),
  allowEmpty: bool,
  className: string$3,
  component: oneOfType([node$1, func]),
  disabled: bool,
  extraTextPosition: string$3,
  getFormApi: func,
  initValues: object$1,
  validateFields: func,
  layout: string$3,
  labelPosition: string$3,
  labelWidth: oneOfType([number$2, string$3]),
  labelAlign: string$3,
  labelCol: object$1,
  // Control labelCol {span: number, offset: number} for all field child nodes
  render: func,
  style: object$1,
  showValidateIcon: bool,
  stopValidateWithError: bool,
  id: string$3,
  wrapperCol: object$1,
  // Control wrapperCol {span: number, offset: number} for all field child nodes
  trigger: [String, Array]
}, defaultProps$9 = {
  onChange: lodashExports.noop,
  onSubmitFail: lodashExports.noop,
  onSubmit: lodashExports.noop,
  onReset: lodashExports.noop,
  onValueChange: lodashExports.noop,
  layout: "vertical",
  labelPosition: "top",
  allowEmpty: !1,
  autoScrollToError: !1,
  showValidateIcon: !0
}, vuePropsType$f = vuePropsMake(propTypes$a, defaultProps$9), Form = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$f
  },
  name: "Form",
  setup(s, {}) {
    const o = useSlots();
    let l = getCurrentInstance();
    const u = reactive({
      formId: ""
    });
    warning$1(!!(s.component && s.render), "[Semi Form] You should not use <Form component> and <Form render> in ths same time; <Form render> will be ignored"), warning$1(s.component && o.default && !isEmptyChildren(o.default()), "[Semi Form] You should not use <Form component> and <Form>{children}</Form> in ths same time; <Form>{slots.default()}</Form> will be ignored"), warning$1(s.render && o.default && !isEmptyChildren(o.default()), "[Semi Form] You should not use <Form render> and <Form>{children}</Form> in ths same time; <Form>{slots.default()}</Form> will be ignored");
    const {
      adapter: c
    } = useBaseComponent(s, u);
    function m() {
      return {
        ...c(),
        cloneDeep: cloneDeep$1,
        notifySubmit: (T, N) => {
          s.onSubmit(T, N);
        },
        notifySubmitFail: (T, N, O) => {
          s.onSubmitFail(T, N, O);
        },
        forceUpdate: (T) => {
          nextTick(() => {
            l.proxy.$forceUpdate(), nextTick(() => {
              T == null || T();
            });
          });
        },
        notifyChange: (T) => {
          s.onChange(T);
        },
        notifyValueChange: (T, N) => {
          s.onValueChange(T, N);
        },
        notifyReset: () => {
          s.onReset();
        },
        initFormId: () => {
          u.formId = getUuidv4();
        },
        getInitValues: () => s.initValues,
        getFormProps: (T) => {
          if (typeof T > "u")
            return s;
          if (typeof T == "string")
            return s[T];
          {
            const N = {};
            return T.forEach((O) => {
              N[O] = s[O];
            }), N;
          }
        },
        getAllErrorDOM: () => {
          const {
            formId: T
          } = u, {
            id: N
          } = s, O = N || T;
          return document.querySelectorAll(`form[x-form-id="${O}"] .${cssClasses$h.PREFIX}-field-error-message`);
        },
        getFieldDOM: (T) => document.querySelector(`.${cssClasses$h.PREFIX}-field[x-field-id="${T}"]`),
        getFieldErrorDOM: (T) => {
          const {
            formId: N
          } = u, {
            id: O
          } = s;
          let Q = `form[x-form-id="${O || N}"] .${cssClasses$h.PREFIX}-field[x-field-id="${T}"] .${cssClasses$h.PREFIX}-field-error-message`;
          return document.querySelector(Q);
        }
      };
    }
    const g = m(), v = new FormFoundation(g);
    let b = v.getFormApi();
    s.getFormApi && s.getFormApi(b), onMounted(() => {
      v.init();
    }), onUnmounted(() => {
      v.destroy();
    });
    function S() {
      var Q;
      const {
        component: T,
        render: N
      } = s, O = v.getFormState(), z = {
        formState: O,
        formApi: v.getFormApi(),
        values: O.values
      };
      return T ? createVNode(T, z) : N ? N(z) : (Q = o.default) == null ? void 0 : Q.call(o, z);
    }
    function E(T) {
      T.preventDefault(), v.submit(T);
    }
    function P(T) {
      T.preventDefault(), v.reset();
    }
    return () => {
      const N = v.getFormState(!1), O = v.getModifyFormStateApi(), {
        formId: z
      } = u, {
        getFormApi: Q,
        onChange: W,
        onSubmit: ue,
        onSubmitFail: te,
        onValueChange: K,
        component: ve,
        render: ee,
        validateFields: Re,
        initValues: wt,
        layout: yt,
        style: xt,
        className: Kt,
        labelPosition: tn,
        labelWidth: ln,
        labelAlign: rn,
        labelCol: an,
        wrapperCol: Gt,
        allowEmpty: nn,
        autoScrollToError: vt,
        showValidateIcon: Et,
        stopValidateWithError: Qt,
        extraTextPosition: un,
        id: gn,
        trigger: dn,
        ...yn
      } = s, vn = cls(prefix$4, Kt, {
        [prefix$4 + "-vertical"]: yt === "vertical",
        [prefix$4 + "-horizontal"]: yt === "horizontal"
      }), Pn = Gt && an, On = createVNode("form", mergeProps$1({
        style: xt
      }, yn, {
        onReset: P,
        onSubmit: E,
        class: vn,
        id: gn || z,
        "x-form-id": gn || z
      }), [S()]), _n = createVNode(Row$1, null, _isSlot$3(On) ? On : {
        default: () => [On]
      });
      return createVNode(FormUpdaterContext.Provider, {
        value: O
      }, {
        default: () => [createVNode(FormApiContext.Provider, {
          value: b
        }, {
          default: () => [createVNode(FormStateContext.Provider, {
            value: N
          }, {
            default: () => [Pn ? _n : On]
          })]
        })]
      });
    };
  }
}), filterArrayByIndex = (s, o) => s.filter((l, u) => u !== o), getUuidByArray = (s) => s.map(() => getUuidv4()), getUpdateKey = (s) => {
  if (s && s && s.updateKey)
    return s.updateKey;
}, initValueAdapter = (s) => {
  const o = [];
  return Array.isArray(s) ? s : (warning$1(!lodashExports.isUndefined(s), "[Semi Form ArrayField] initValue of ArrayField must be an array. Please check the type of your props"), o);
}, generateKeys = (s, o) => {
  const l = initValueAdapter(s);
  return getUuidByArray(l).map((m, g) => o && o[g] ? o[g] : m);
}, vuePropsType$e = {
  initValue: Array,
  field: String
}, ArrayFieldComponent = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$e
  },
  name: "ArrayFieldComponent",
  setup(s, {}) {
    const o = useSlots();
    let l, u;
    const {
      context: c
    } = useFormUpdaterContext(), m = s.initValue, g = c.value.getValue(s.field), v = m || g, b = reactive({
      keys: generateKeys(v)
    });
    l = !c.value.getArrayField(s.field);
    const S = lodashExports.cloneDeep(v), E = lodashExports.cloneDeep(v);
    c.value.registerArrayField(s.field, E), c.value.updateStateValue(s.field, S, {
      notNotify: !0,
      notUpdate: !0
    }), onBeforeUnmount(() => {
      const O = c.value, {
        field: z
      } = s;
      O.unRegisterArrayField(z);
    }), watch([() => s.field, () => b.keys], () => {
      const {
        field: O
      } = s, {
        keys: z
      } = b, Q = c.value.getValue(O), W = getUpdateKey(c.value.getArrayField(O));
      if (W !== u) {
        const ue = generateKeys(Q, z);
        b.keys = ue, u = W, u !== null && (l = !1);
      }
    });
    function P() {
      const {
        keys: O
      } = b;
      O.push(getUuidv4()), l = !0, b.keys = O;
    }
    function T(O) {
      const z = c, {
        field: Q
      } = s, W = z.value.getValue(Q) ? z.value.getValue(Q).slice() : [];
      W.push(O), z.value.updateStateValue(Q, W, {}), z.value.updateArrayField(Q, {
        updateKey: (/* @__PURE__ */ new Date()).valueOf()
      });
    }
    function N(O) {
      const z = c, {
        keys: Q
      } = b, {
        field: W
      } = s, ue = filterArrayByIndex(Q, O);
      let te = z.value.getError(W);
      const K = {
        notNotify: !0,
        notUpdate: !0
      };
      Array.isArray(te) && (te = te.slice(), te.splice(O, 1), z.value.updateStateError(W, te, K));
      let ve = z.value.getValue(W);
      Array.isArray(ve) && (ve = ve.slice(), ve.splice(O, 1), z.value.updateStateValue(W, ve)), b.keys = ue;
    }
    return () => {
      const {
        field: O
      } = s, {
        keys: z
      } = b, Q = z.map((ue, te) => ({
        // key: i,
        key: ue,
        field: `${O}[${te}]`,
        remove: () => N(te)
      })), W = {
        shouldUseInitValue: l
      };
      return createVNode(ArrayFieldContext.Provider, {
        value: W
      }, {
        default: () => {
          var ue;
          return [(ue = o.default) == null ? void 0 : ue.call(o, {
            arrayFields: Q,
            add: P,
            addWithInitValue: T
          })];
        }
      });
    };
  }
}), ArrayFieldComponent$1 = ArrayFieldComponent;
function useFormApi() {
  return useBaseFormApiContext();
}
function useFormState() {
  const {
    context: s
  } = useFormStateContext();
  return s;
}
const buildFieldState = (s, o) => ({
  value: get(s.value.values, o),
  error: get(s.value.errors, o),
  touched: get(s.value.touched, o)
});
function useFieldState(s) {
  const o = useFormState();
  return buildFieldState(o, s);
}
const buildFieldApi = (s, o) => ({
  getError: () => s.value.getError(o),
  setError: (l) => s.value.setError(o, l),
  getTouched: () => s.value.getTouched(o),
  setTouched: (l) => s.value.setTouched(o, l),
  getValue: () => s.value.getValue(o),
  setValue: (l) => s.value.setValue(o, l)
});
function useFieldApi(s) {
  const {
    context: o
  } = useFormApi();
  return buildFieldApi(o, s);
}
function useStateWithGetter(s) {
  const o = shallowRef(), l = ref$1(s);
  function u(g) {
    l.value = g;
  }
  return o.value = l.value, [l, (g) => {
    o.value = g, u(g);
  }, () => o.value];
}
function useArrayFieldState() {
  return useArrayFieldContext();
}
function isValid(s) {
  let o = !0;
  return typeof s == "string" && s.length ? o = !1 : Array.isArray(s) && s.length ? o = s.every((l) => isValid(l)) : typeof s == "boolean" ? o = s : isVNode(s) && (o = !1), o;
}
const prefix$3 = cssClasses$h.PREFIX, propTypes$9 = {
  error: oneOfType([bool, string$3, array$1, node$1]),
  className: string$3,
  style: object$1,
  validateStatus: string$3,
  showValidateIcon: bool,
  helpText: node$1,
  isInInputGroup: bool,
  // internal props
  errorMessageId: string$3,
  helpTextId: string$3
}, vuePropsType$d = vuePropsMake(propTypes$9, {}), ErrorMessage = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$d
  },
  name: "ErrorMessage",
  setup(s, {}) {
    useSlots();
    function o(l) {
      const {
        helpTextId: u,
        errorMessageId: c
      } = s, m = s.error;
      let g = c;
      if (m || (g = u), typeof l == "string")
        return createVNode("span", {
          id: g
        }, [l]);
      if (Array.isArray(l)) {
        const v = l.filter((b) => b);
        return v.length ? createVNode("span", {
          id: g
        }, [v.join(", ")]) : null;
      } else if (isVNode(l))
        return l;
      return null;
    }
    return () => {
      const {
        error: l,
        className: u,
        style: c,
        validateStatus: m,
        helpText: g,
        showValidateIcon: v,
        isInInputGroup: b
      } = s, S = cls({
        [prefix$3 + "-field-error-message"]: !!l,
        [prefix$3 + "-field-help-text"]: !!g
      }, u);
      if (!l && !g)
        return null;
      const E = {
        warning: createVNode(IconComponent$J, null, null),
        error: createVNode(IconComponent$K, null, null)
      }, P = o(l || g), T = `${prefix$3}-field-validate-status-icon`;
      let N = null;
      return b ? N = createVNode(IconComponent$K, {
        className: T
      }, null) : E[m] && (N = cloneVNode(E[m], {
        class: T
      })), createVNode("div", {
        class: S,
        style: c
      }, [v && P ? N : null, P]);
    };
  }
});
function _isSlot$2(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefix$2 = cssClasses$h.PREFIX, useIsomorphicEffect = typeof window < "u" ? onBeforeMount : onMounted;
function withField(s, o, l) {
  const u = s.props || {}, c = {};
  Object.keys(u).forEach((v) => {
    c[v] = {
      ...u[v],
      default: void 0
    }, delete c[v].default;
  });
  const m = {
    ...lodashExports.omit(
      {
        ...c,
        ...l || {}
      },
      // 'style',
      "class"
    ),
    label: [...node$1, func],
    id: [String],
    field: {
      type: String,
      required: !0
    },
    className: String,
    prefix: String,
    labelPosition: String,
    labelAlign: String,
    labelWidth: [String, Number],
    noLabel: Boolean,
    noErrorMessage: Boolean,
    name: String,
    fieldClassName: String,
    fieldStyle: Object,
    initValue: any$1,
    validate: node$1,
    /** Check rules, check library based on async-validator */
    rules: array$1,
    /** Check trigger timing */
    trigger: [string$3, array$1],
    // onChange: (fieldValue: any) => void;
    /** Converts form control values before validation */
    transform: func,
    /** Make a second change to the component's value before the UI update */
    convert: func,
    allowEmptyString: bool,
    /** When true, use rules verification, after encountering the first rule that fails the test, the verification of subsequent rules will no longer be triggered */
    stopValidateWithError: bool,
    /* Custom prompt information is displayed in the same block as the verification information. When both have values, the verification information is displayed first */
    helpText: node$1,
    /* Extra message, you can use this when you need an error message and the prompt text to appear at the same time, after helpText/errorMessage */
    extraText: node$1,
    extraTextPosition: string$3,
    /** These declaration just hack for Subtract, not valid props in CommonFieldProps */
    defaultValue: any$1,
    /** Whether to take over only the data stream, when true, it will not automatically insert modules such as ErrorMessage, Label, extraText, etc. The style and DOM structure are consistent with the original component */
    pure: bool
  };
  return /* @__PURE__ */ defineComponent({
    props: {
      ...m
    },
    name: "Form" + s.name,
    //@ts-ignore
    setup(v, {
      attrs: b
    }) {
      const S = useSlots(), {
        getProps: E,
        hasInProps: P
      } = useHasInProps();
      function T() {
        return E({
          ...b,
          ...v
        });
      }
      const {
        context: N
      } = useFormUpdaterContext();
      let {
        context: O
      } = useArrayFieldState(), z = typeof mergeProps(T()).field < "u" ? N.value.getValue(mergeProps(T()).field) : void 0, Q = typeof mergeProps(T()).initValue < "u" ? mergeProps(T()).initValue : z;
      try {
        O.value && (Q = O.value.shouldUseInitValue && typeof mergeProps(T()).initValue < "u" ? mergeProps(T()).initValue : z);
      } catch {
      }
      const [W, ue, te] = useStateWithGetter(typeof Q !== void 0 ? Q : null), K = shallowRef(!1), ve = ref$1(mergeProps(T()).rules), ee = ref$1(v.validate), Re = shallowRef(null), wt = (_n, Nn) => {
        let {
          field: Un
        } = mergeProps(T());
        gn(_n), N.value.updateStateTouched(Un, _n, Nn);
      }, yt = (_n, Nn) => {
        if (K.value)
          return;
        let {
          field: Un
        } = mergeProps(T());
        _n !== Qt() && (Et(_n), N.value.updateStateError(Un, _n, Nn), isValid(_n) ? On("success") : On("error"));
      };
      function xt(_n) {
        return _n || N.value.getFormProps().allowEmpty;
      }
      const Kt = (_n, Nn) => {
        let {
          field: Un,
          allowEmpty: Xn
        } = mergeProps(T());
        Xn = xt(Xn), ue(_n);
        let zn = {
          ...Nn,
          allowEmpty: Xn
        };
        N.value.updateStateValue(Un, _n, zn);
      }, tn = () => {
        let _n = {
          notNotify: !0,
          notUpdate: !0
        };
        Kt(Q !== null ? Q : void 0, _n), yt(void 0, _n), wt(void 0, _n), On("default");
      }, ln = (_n, Nn) => {
        let Un = ve.value || [];
        const Xn = generateValidatesFromRules(mergeProps(T()).field, Un), zn = {
          [mergeProps(T()).field]: _n
        };
        let {
          stopValidateWithError: jn
        } = mergeProps(T()), kn = N.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]), Yn = transformDefaultBooleanAPI(jn, kn.stopValidateWithError, !1);
        const Zn = new Promise((er, bn) => {
          Xn.validate(
            zn,
            {
              first: Yn
            },
            // eslint-disable-next-line @typescript-eslint/no-empty-function
            (Ln, Kn) => {
            }
          ).then((Ln) => {
            K.value || Re.value !== Zn || (On("success"), yt(void 0, Nn), er({}));
          }).catch((Ln) => {
            if (K.value || Re.value !== Zn)
              return;
            let {
              errors: Kn,
              fields: Bn
            } = Ln;
            if (Kn && Bn) {
              let Fn = Kn.map((Gn) => Gn.message);
              Fn.length === 1 && (Fn = Fn[0]), yt(Fn, Nn), isValid(Fn) || (On("error"), er(Kn));
            } else
              throw On("error"), yt(Ln.message, Nn), er(Ln.message), Ln;
          });
        });
        return Re.value = Zn, Zn;
      }, rn = (_n, Nn, Un) => {
        const Xn = new Promise((zn) => {
          let jn;
          try {
            jn = ee.value(_n, Nn);
          } catch (kn) {
            jn = kn;
          }
          jn === void 0 ? (zn({}), yt(void 0, Un)) : isPromise(jn) ? jn.then((kn) => {
            K.value || Re.value !== Xn || (isValid(kn) ? (yt(void 0, Un), zn(null)) : (yt(kn, Un), zn(kn)));
          }) : isValid(jn) ? (yt(void 0, Un), zn(null)) : (yt(jn, Un), zn(jn));
        });
        return Re.value = Xn, Xn;
      }, an = (_n, Nn) => {
        let Un = _n, Xn = ve.value;
        return mergeProps(T()).transform && (Un = mergeProps(T()).transform(_n)), ee.value ? rn(Un, N.value.getValue(), Nn) : Xn ? ln(Un, Nn) : null;
      }, Gt = (_n, Nn, ...Un) => {
        if (_n && _n[Symbol.toStringTag] && _n[Symbol.toStringTag] === "Event") {
          console.trace("不明来源事件触发过滤", _n);
          return;
        }
        let {
          trigger: Xn,
          emptyValue: zn
        } = mergeProps(T()), {
          allowEmptyString: jn,
          allowEmpty: kn
        } = mergeProps(T());
        kn = xt(kn);
        let {
          options: Yn,
          shouldInject: Zn
        } = mergeOptions(o, b), er = Yn.onKeyChangeFnName;
        P(er) && typeof b[Yn.onKeyChangeFnName] == "function" && b[Yn.onKeyChangeFnName](_n, Nn, ...Un);
        let bn;
        Yn.valuePath ? bn = get(_n, Yn.valuePath) : bn = _n, typeof mergeProps(T()).convert == "function" && (bn = mergeProps(T()).convert(bn)), jn || kn || bn === zn && (bn = void 0);
        try {
          Nn && Nn.target && Nn.target.selectionStart && yn(Nn.target.selectionStart);
        } catch {
        }
        wt(!0, {
          notNotify: !0,
          notUpdate: !0
        }), Kt(bn);
        let Ln = N.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]);
        transformTrigger(Xn, Ln.trigger).includes("change") && an(bn);
      }, nn = (_n) => {
        let {
          trigger: Nn
        } = mergeProps(T()), Un = N.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]), Xn = transformTrigger(Nn, Un.trigger);
        if (b.onBlur && b.onBlur(_n), un.value || wt(!0), Xn.includes("blur")) {
          let zn = te();
          an(zn);
        }
      };
      useFormState();
      const [vt, Et, Qt] = useStateWithGetter(), un = ref$1();
      function gn(_n) {
        un.value = _n;
      }
      const [dn, yn, vn] = useStateWithGetter(0), Pn = ref$1(mergeProps(T()).validateStatus);
      function On(_n) {
        Pn.value = _n;
      }
      return watch([() => v.rules, () => v.validate], () => {
        ve.value = mergeProps(T()).rules, ee.value = v.validate;
      }, {
        immediate: !0
      }), useIsomorphicEffect(() => {
        let {
          trigger: _n
        } = mergeProps(T()), Nn = N.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition", "stopValidateWithError", "trigger"]);
        const Xn = transformTrigger(_n, Nn.trigger).includes("mount");
        K.value = !1, Xn && an(W);
      }), onBeforeUnmount(() => {
        K.value = !0;
      }), watch(() => v.field, (_n, Nn, Un) => {
        let {
          // condition,
          field: Xn,
          allowEmptyString: zn,
          allowEmpty: jn,
          keepState: kn
        } = mergeProps(T());
        jn = xt(jn);
        const Yn = {
          setValue: Kt,
          setTouched: wt,
          setError: yt,
          reset: tn,
          validate: an
        };
        if (typeof Xn > "u")
          return () => {
          };
        const Zn = te();
        N.value.register(Xn, {
          value: Zn,
          error: vt.value,
          touched: un,
          status: Pn.value
        }, {
          field: Xn,
          fieldApi: Yn,
          keepState: kn,
          allowEmpty: jn || zn
        }), Un(() => {
          N.value.unRegister(mergeProps(T()).field);
        });
      }, {
        immediate: !0
      }), (_n, Nn) => {
        const Un = v.label, Xn = v.id;
        let {
          // condition,
          field: zn,
          labelPosition: jn,
          labelWidth: kn,
          labelAlign: Yn,
          labelCol: Zn,
          wrapperCol: er,
          noLabel: bn,
          noErrorMessage: Ln,
          isInInputGroup: Kn,
          initValue: Bn,
          validate: Fn,
          validateStatus: Gn,
          trigger: Wn,
          allowEmptyString: Mn,
          allowEmpty: Tn,
          emptyValue: Rn,
          rules: hn,
          required: Qn,
          keepState: rr,
          transform: tr,
          name: Cr,
          fieldClassName: Fr,
          fieldStyle: An,
          convert: Hn,
          stopValidateWithError: ir,
          helpText: dr,
          extraText: ar,
          extraTextPosition: Or,
          pure: Sr,
          rest: kr
        } = mergeProps(T());
        const Nr = v.prefix ? {
          ...kr,
          prefix: v.prefix
        } : kr;
        let {
          options: Ur,
          shouldInject: _r
        } = mergeOptions(o, b);
        if (warning$1(typeof zn > "u" && Ur.shouldInject, "[Semi Form]: 'field' is required, please check your props of Field Component"), !_r)
          return createVNode(s, Nr, {
            default: S.default
          });
        if (!N.value.getFormProps)
          return warning$1(!0, "[Semi Form]: Field Component must be use inside the Form, please check your dom declaration"), null;
        const Zr = {
          value: W.value,
          error: vt.value,
          touched: un.value,
          status: Pn.value
        };
        let Jr = N.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "labelCol", "wrapperCol", "disabled", "showValidateIcon", "extraTextPosition"]), ii = jn || Jr.labelPosition, Ti = kn || Jr.labelWidth, Mi = Yn || Jr.labelAlign, ui = Zn || Jr.labelCol, Ii = er || Jr.wrapperCol, bs = Or || Jr.extraTextPosition || "bottom";
        const Oi = Xn || zn, Vs = `${Oi}-label`, _s = `${Oi}-helpText`, Is = `${Oi}-extraText`, Fa = `${Oi}-errormessage`;
        let io = Gn || Pn.value;
        const Da = cls(`${prefix$2}-field-extra`, {
          [`${prefix$2}-field-extra-string`]: typeof ar == "string",
          [`${prefix$2}-field-extra-middle`]: bs === "middle",
          [`${prefix$2}-field-extra-botttom`]: bs === "bottom"
        }), oo = ar ? createVNode("div", {
          class: Da,
          id: Is,
          "x-semi-prop": "extraText"
        }, [ar]) : null;
        let Xs = {
          id: Oi,
          disabled: Jr.disabled,
          ...Nr,
          onBlur: nn,
          [Ur.onKeyChangeFnName]: Gt,
          // value 为Ref 对象
          [Ur.valueKey]: unref(W),
          validateStatus: io,
          "aria-required": Qn,
          "aria-labelledby": Vs
        };
        dr && (Xs["aria-describedby"] = ar ? `${_s} ${Is}` : _s), ar && (Xs["aria-describedby"] = dr ? `${_s} ${Is}` : Is), Pn.value === "error" && (Xs["aria-errormessage"] = Fa, Xs["aria-invalid"] = !0);
        const so = cls({
          [`${prefix$2}-field`]: !0,
          [`${prefix$2}-field-${Cr}`]: !!Cr,
          [Fr]: !!Fr
        }), Ol = cls({
          [`${prefix$2}-field-main`]: !0
        });
        ii === "inset" && !bn && (Xs.insetLabel = Un || zn, Xs.insetLabelId = Vs, typeof Un == "object" && !isElement(Un) && (Xs.insetLabel = Un.text, Xs.insetLabelId = Vs));
        const kl = createVNode(s, Xs, {
          default: S.default
        });
        if (Kn)
          return kl;
        if (Sr) {
          let va = cls(Nr.className, {
            [`${prefix$2}-field-pure`]: !0,
            [`${prefix$2}-field-${Cr}`]: !!Cr,
            [Fr]: !!Fr
          });
          return Xs.className = va, createVNode(s, Xs, {
            default: S.default
          });
        }
        let uc = ui && Ii;
        const Vl = Mi ? `${prefix$2}-col-${Mi}` : "";
        let Ma = null;
        if (!bn && ii !== "inset") {
          let va = typeof Un == "object" && !isElement(Un) ? Un : {};
          Ma = // @ts-ignore
          createVNode(Label, mergeProps$1({
            text: Un || zn,
            id: Vs,
            required: Qn,
            name: Oi || Cr || zn,
            width: Ti,
            align: Mi
          }, va), null);
        }
        const Ll = createVNode("div", {
          class: Ol
        }, [bs === "middle" ? oo : null, kl, Ln ? null : createVNode(ErrorMessage, {
          error: vt.value,
          validateStatus: io,
          helpText: dr,
          helpTextId: _s,
          errorMessageId: Fa,
          showValidateIcon: Jr.showValidateIcon
        }, null), bs === "bottom" ? oo : null]), Oa = createVNode(Fragment, null, [ii === "top" ? createVNode("div", {
          style: {
            overflow: "hidden"
          }
        }, [createVNode(Col$1, mergeProps$1(ui, {
          className: Vl
        }), _isSlot$2(Ma) ? Ma : {
          default: () => [Ma]
        })]) : createVNode(Col$1, mergeProps$1(ui, {
          className: Vl
        }), _isSlot$2(Ma) ? Ma : {
          default: () => [Ma]
        }), createVNode(Col$1, Ii, _isSlot$2(Ll) ? Ll : {
          default: () => [Ll]
        })]), cc = [...Object.values(Zr), ...Object.values(b), ...Object.values(v), zn, ii, Mi, Jr.disabled];
        return withMemo(cc, () => createVNode("div", {
          class: so,
          style: An,
          "x-label-pos": ii,
          "x-field-id": zn,
          "x-extra-pos": bs
        }, [uc ? Oa : createVNode(Fragment, null, [Ma, Ll])]), Nn, 0);
      };
    }
  });
}
const withFormState = (s) => (o) => createVNode(FormStateContext.Consumer, null, {
  default: (l) => createVNode(s, mergeProps$1({
    formState: l
  }, o), null)
}), withFormState$1 = withFormState, withFormApi = (s) => (o) => createVNode(FormApiContext.Consumer, null, {
  default: (l) => createVNode(s, mergeProps$1({
    formApi: l.value
  }, o), null)
}), withFormApi$1 = withFormApi, FormInput = withField(Input$1, {
  maintainCursor: !0
}), FormInputNumber = withField(InputNumber$1, {
  maintainCursor: !0
}), FormTextArea = withField(TextArea$1, {
  maintainCursor: !0
}), FormSelect = withField(Select, void 0), FormSelectOption = Option$1;
FormSelect.Option = FormSelectOption;
const FormSelectBase = FormSelect, FormSelectOptionGroup = OptionGroup, FormCheckboxGroup = withField(CheckboxGroup$1, void 0), FormCheckbox = withField(Checkbox$1, {
  valueKey: "checked",
  valuePath: "target.checked",
  shouldInject: !1
}), FormRadioGroup = withField(RadioGroup$1, {
  valuePath: "target.value"
}), FormRadio = withField(Radio$1, {
  valueKey: "checked",
  valuePath: "target.checked",
  shouldInject: !1
}), FormDatePicker = withField(DatePicker, void 0), FormSwitch = withField(Switch$1, {
  valueKey: "checked"
}), FormSlider = withField(Slider$1, void 0), FormTimePicker = withField(TimePicker, void 0), FormTreeSelect = withField(TreeSelect$1, void 0), FormCascader = withField(Cascader, void 0), FormRating = withField(Rating$1, void 0), FormAutoComplete = withField(AutoComplete, {
  valueKey: "value",
  onKeyChangeFnName: "onChange"
}), FormUpload = withField(Upload$1, {
  valueKey: "fileList",
  valuePath: "fileList",
  onKeyChangeFnName: "onChange"
}), FormTagInput = withField(TagInput, void 0);
function _isSlot$1(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const prefix$1 = cssClasses$h.PREFIX, GroupError = (s) => {
  const {
    fieldSet: o
  } = s, l = useFormState(), u = o.map((c) => get(l.value.errors, c));
  return isValid$1(u) ? null : createVNode(ErrorMessage, {
    error: u,
    showValidateIcon: s.showValidateIcon,
    isInInputGroup: s.isInInputGroup
  }, null);
}, vuePropsType$c = {
  className: {
    type: String,
    default: ""
  },
  size: {
    type: String,
    default: "default"
  },
  style: [String, Object],
  onBlur: {
    type: Function,
    default: noop$1
  },
  onFocus: {
    type: Function,
    default: noop$1
  },
  label: Object,
  labelPosition: String,
  disabled: Boolean,
  extraText: node$1,
  extraTextPosition: String
}, FormInputGroup = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$c
  },
  name: "FormInputGroup",
  setup(s, {}) {
    const o = useSlots(), {
      context: l
    } = useFormUpdaterContext();
    function u(c, m) {
      return c ? lodashExports.isString(c) ? createVNode(Label, {
        width: m.labelWidth,
        text: c
      }, null) : createVNode(Label, mergeProps$1({
        width: m.labelWidth
      }, c), null) : null;
    }
    return () => {
      var xt;
      const c = (xt = o.default) == null ? void 0 : xt.call(o), {
        label: m,
        extraText: g,
        extraTextPosition: v,
        ...b
      } = s, E = l.value.getFormProps(["labelPosition", "labelWidth", "labelAlign", "showValidateIcon", "wrapperCol", "labelCol", "disabled"]), P = s.labelPosition || E.labelPosition, T = [], N = c.map((Kt) => Kt && Kt.props && Kt.props.field ? (T.push(Kt.props.field), cloneVNode(Kt, {
        isInInputGroup: !0
        // noErrorMessage: true,
        // noLabel: true
      })) : null), O = cls({
        [`${prefix$1}-field-group`]: !0
      }), z = E.labelCol, Q = E.wrapperCol, W = E.labelAlign, ue = z && Q, te = z ? `${prefix$1}-col-${W}` : "", K = u(m, E), ve = createVNode(InputGroup$2, mergeProps$1({
        disabled: E.disabled
      }, b), _isSlot$1(N) ? N : {
        default: () => [N]
      }), ee = createVNode(GroupError, {
        fieldSet: T,
        showValidateIcon: E.showValidateIcon,
        isInInputGroup: !0
      }, null), Re = cls(`${prefix$1}-field-extra`, {
        [`${prefix$1}-field-extra-string`]: typeof g == "string",
        [`${prefix$1}-field-extra-middle`]: v === "middle",
        [`${prefix$1}-field-extra-bottom`]: v === "bottom"
      }), wt = g ? createVNode("div", {
        class: Re,
        "x-semi-prop": "extraText"
      }, [g]) : null;
      let yt;
      switch (!0) {
        case !ue:
          yt = createVNode(Fragment, null, [K, createVNode("div", null, [v === "middle" ? wt : null, ve, v === "bottom" ? wt : null, ee])]);
          break;
        case (ue && P === "top"):
          yt = createVNode(Fragment, null, [createVNode("div", {
            style: {
              overflow: "hidden"
            }
          }, [createVNode(Col$1, mergeProps$1(z, {
            className: te
          }), _isSlot$1(K) ? K : {
            default: () => [K]
          })]), createVNode(Col$1, Q, {
            default: () => [v === "middle" ? wt : null, ve, v === "bottom" ? wt : null, ee]
          })]);
          break;
        case (ue && P !== "top"):
          yt = createVNode(Fragment, null, [createVNode(Col$1, mergeProps$1(z, {
            className: te
          }), _isSlot$1(K) ? K : {
            default: () => [K]
          }), createVNode(Col$1, Q, {
            default: () => [v === "middle" ? wt : null, ve, v === "bottom" ? wt : null, ee]
          })]);
          break;
      }
      return createVNode("div", {
        "x-label-pos": P,
        class: O
      }, [yt]);
    };
  }
}), prefix = cssClasses$h.PREFIX, vuePropsType$b = {
  text: node$1,
  className: string$3,
  style: object$1
}, Section = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$b
  },
  name: "Section",
  setup(s, {}) {
    const o = useSlots();
    return () => {
      var v;
      const {
        text: l,
        className: u,
        style: c
      } = s, m = cls({
        [prefix + "-section"]: !0
      }, u), g = prefix + "-section-text";
      return createVNode("section", {
        class: m,
        style: c
      }, [createVNode("h5", {
        class: g
      }, [l]), (v = o.default) == null ? void 0 : v.call(o)]);
    };
  }
}), InputGroup = FormInputGroup, BaseForm = Form;
BaseForm.TextArea = FormTextArea;
BaseForm.InputNumber = FormInputNumber;
BaseForm.Select = FormSelectBase;
BaseForm.Input = FormInput;
BaseForm.SelectOption = FormSelectOption;
BaseForm.SelectOptionGroup = FormSelectOptionGroup;
BaseForm.AutoComplete = FormAutoComplete;
BaseForm.Cascader = FormCascader;
BaseForm.Checkbox = FormCheckbox;
BaseForm.CheckboxGroup = FormCheckboxGroup;
BaseForm.DatePicker = FormDatePicker;
BaseForm.Radio = FormRadio;
BaseForm.RadioGroup = FormRadioGroup;
BaseForm.Rating = FormRating;
BaseForm.Slider = FormSlider;
BaseForm.Switch = FormSwitch;
BaseForm.TagInput = FormTagInput;
BaseForm.TimePicker = FormTimePicker;
BaseForm.TreeSelect = FormTreeSelect;
BaseForm.Upload = FormUpload;
BaseForm.ErrorMessage = ErrorMessage;
BaseForm.InputGroup = InputGroup;
BaseForm.Label = Label;
BaseForm.Section = Section;
const BaseForm$1 = BaseForm, cssClasses$4 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-image`
}, numbers = {
  DEFAULT_Z_INDEX: 1070
}, vuePropsType$a = {
  value: Object
}, Provider = /* @__PURE__ */ defineComponent((s, {
  slots: o
}) => {
  const l = ref$1(s.value);
  return watch(() => s.value, () => {
    l.value = s.value;
  }, {
    deep: !0
  }), provide("PreviewContext", l), () => o.default ? o.default(l.value) : null;
}, {
  props: {
    ...vuePropsType$a
  },
  name: "PreviewContextProvider"
});
function usePreviewContext() {
  return {
    context: inject("PreviewContext", ref$1({}))
  };
}
const vuePropsType$9 = {}, Consumer = /* @__PURE__ */ defineComponent(() => {
  const s = useSlots(), {
    context: o
  } = usePreviewContext();
  return () => s.default ? s.default(o) : null;
}, {
  props: {
    ...vuePropsType$9
  },
  name: "PreviewContextConsumer"
}), PreviewContext = {
  Provider,
  Consumer
}, prefixCls$4 = `${cssClasses$4.PREFIX}-preview-header`, Header = ({
  onClose: s,
  titleStyle: o,
  className: l,
  renderHeader: u,
  closable: c,
  forwardRef: m
}) => createVNode(PreviewContext.Consumer, null, {
  default: ({
    currentIndex: g,
    titles: v
  }) => {
    let b;
    return v && typeof g == "number" && (b = v[g]), createVNode("section", {
      ref: m,
      class: cls(prefixCls$4, l)
    }, [createVNode("section", {
      class: `${prefixCls$4}-title`,
      style: o
    }, [u ? u(b) : b]), c && createVNode("section", {
      class: `${prefixCls$4}-close`,
      onMouseup: s
    }, [createVNode(IconComponent$u, null, null)])]);
  }
});
Header.props = {
  closable: Boolean,
  forwardRef: [Object],
  renderHeader: Function,
  title: String,
  titleStyle: Object,
  className: String,
  onClose: Function
};
class PreviewFooterFoundation extends BaseFoundation$1 {
  constructor() {
    super(...arguments), this.changeSliderValue = (o) => {
      const { zoom: l, step: u, min: c, max: m } = this.getProps();
      let g = o === "plus" ? l + u : l - u;
      g > m ? g = m : g < c && (g = c), this.handleValueChange(g);
    }, this.handleValueChange = (o) => {
      const { onZoomIn: l, onZoomOut: u, zoom: c } = this.getProps();
      o > c ? l(Number((o / 100).toFixed(2))) : u(Number((o / 100).toFixed(2)));
    }, this.handleRatioClick = () => {
      const { ratio: o, onAdjustRatio: l } = this.getProps();
      l(o === "adaptation" ? "realSize" : "adaptation");
    }, this.handleRotate = (o) => {
      const { onRotate: l } = this.getProps();
      l && l(o);
    };
  }
}
function _isSlot(s) {
  return typeof s == "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const footerPrefixCls = `${cssClasses$4.PREFIX}-preview-footer`, LocaleConsumer = LocaleConsumerFunc(), propTypes$8 = {
  curPage: number$2,
  totalNum: number$2,
  disabledPrev: bool,
  disabledNext: bool,
  disableDownload: bool,
  className: string$3,
  zoom: number$2,
  ratio: string$3,
  prevTip: string$3,
  nextTip: string$3,
  zoomInTip: string$3,
  zoomOutTip: string$3,
  rotateTip: string$3,
  downloadTip: string$3,
  adaptiveTip: string$3,
  originTip: string$3,
  showTooltip: bool,
  onZoomIn: func,
  onZoomOut: func,
  onPrev: func,
  onNext: func,
  onAdjustRatio: func,
  // onRotateLeft: PropTypes.func,
  onDownload: func,
  min: number$2,
  max: number$2,
  step: number$2,
  onRotate: func,
  renderPreviewMenu: func,
  forwardRef: object$1,
  zIndex: number$2
}, defaultProps$8 = {
  min: 10,
  max: 500,
  step: 10,
  showTooltip: !1,
  disableDownload: !1
}, vuePropsType$8 = vuePropsMake(propTypes$8, defaultProps$8), Footer = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$8
  },
  name: "Footer",
  setup(s, {}) {
    useSlots();
    const {
      adapter: o
    } = useBaseComponent(s, {});
    function l() {
      return {
        ...o()
      };
    }
    const u = l(), c = new PreviewFooterFoundation(u), m = (xt) => {
      c.changeSliderValue(xt);
    }, g = () => {
      m("minus");
    }, v = () => {
      m("plus");
    }, b = () => {
      c.handleRotate("left");
    }, S = () => {
      c.handleRotate("right");
    }, E = lodashExports.throttle((xt) => {
      c.handleValueChange(xt);
    }, 50), P = () => {
      c.handleRatioClick();
    }, T = () => {
      const {
        min: xt,
        max: Kt,
        step: tn,
        curPage: ln,
        totalNum: rn,
        ratio: an,
        zoom: Gt,
        disabledPrev: nn,
        disabledNext: vt,
        disableDownload: Et,
        onNext: Qt,
        onPrev: un,
        onDownload: gn,
        renderPreviewMenu: dn
      } = s, yn = {
        min: xt,
        max: Kt,
        step: tn,
        curPage: ln,
        totalNum: rn,
        ratio: an,
        zoom: Gt,
        disabledPrev: nn,
        disabledNext: vt,
        disableDownload: Et,
        onNext: Qt,
        onPrev: un,
        onDownload: gn,
        onRotateLeft: b,
        onRotateRight: S,
        disabledZoomIn: Gt === Kt,
        disabledZoomOut: Gt === xt,
        onRatioClick: P,
        onZoomIn: v,
        onZoomOut: g,
        menuItems: wt()
      };
      return dn(yn);
    }, N = (xt, Kt, tn) => {
      const {
        showTooltip: ln,
        zIndex: rn
      } = s;
      return ln ? createVNode(Tooltip$1, {
        content: Kt,
        key: `tooltip-${tn}`,
        zIndex: rn + 1
      }, _isSlot(xt) ? xt : {
        default: () => [xt]
      }) : xt;
    }, O = (xt) => createVNode(LocaleConsumer, {
      componentName: "Image"
    }, {
      default: (Kt) => Kt[xt]
    }), z = () => {
      const {
        disabledPrev: xt,
        onPrev: Kt,
        prevTip: tn
      } = s, ln = createVNode(IconComponent$z, {
        key: "chevron-left",
        role: "prev_bt",
        size: "large",
        className: xt ? `${footerPrefixCls}-disabled` : "",
        onClick: xt ? void 0 : Kt
      }, null), rn = tn ?? O("prevTip");
      return N(ln, rn, "chevron-left");
    }, Q = () => {
      const {
        disabledNext: xt,
        onNext: Kt,
        nextTip: tn
      } = s, ln = createVNode(IconComponent$y, {
        key: "chevron-right",
        role: "next_bt",
        size: "large",
        className: xt ? `${footerPrefixCls}-disabled` : "",
        onClick: xt ? void 0 : Kt
      }, null), rn = tn ?? O("nextTip");
      return N(ln, rn, "chevron-right");
    }, W = () => {
      const {
        zoomOutTip: xt,
        zoom: Kt,
        min: tn
      } = s, ln = Kt === tn, rn = createVNode(IconComponent$g, {
        key: "minus",
        role: "minus_bt",
        size: "large",
        onClick: ln ? void 0 : g,
        className: ln ? `${footerPrefixCls}-disabled` : ""
      }, null), an = xt ?? O("zoomOutTip");
      return N(rn, an, "minus");
    }, ue = () => {
      const {
        zoomInTip: xt,
        zoom: Kt,
        max: tn
      } = s, ln = Kt === tn, rn = createVNode(IconComponent$e, {
        key: "plus",
        role: "plus_bt",
        size: "large",
        onClick: ln ? void 0 : v,
        className: ln ? `${footerPrefixCls}-disabled` : ""
      }, null), an = xt ?? O("zoomInTip");
      return N(rn, an, "plus");
    }, te = () => {
      const {
        ratio: xt,
        originTip: Kt,
        adaptiveTip: tn
      } = s, ln = {
        key: "ratio",
        size: "large",
        className: cls(`${footerPrefixCls}-gap`),
        onClick: P
      }, rn = xt === "adaptation" ? createVNode(IconComponent$c, ln, null) : createVNode(IconComponent, ln, null);
      let an;
      return xt === "adaptation" ? an = Kt ?? O("originTip") : an = tn ?? O("adaptiveTip"), N(rn, an, "ratio");
    }, K = () => {
      const {
        rotateTip: xt
      } = s, Kt = createVNode(IconComponent$a, {
        key: "rotate",
        role: "rotate_bt",
        size: "large",
        onClick: b
      }, null), tn = xt ?? O("rotateTip");
      return N(Kt, tn, "rotate");
    }, ve = () => {
      const {
        downloadTip: xt,
        onDownload: Kt,
        disableDownload: tn
      } = s, ln = createVNode(IconComponent$q, {
        key: "download",
        role: "download_bt",
        size: "large",
        onClick: tn ? void 0 : Kt,
        className: cls(`${footerPrefixCls}-gap`, {
          [`${footerPrefixCls}-disabled`]: tn
        })
      }, null), rn = xt ?? O("downloadTip");
      return N(ln, rn, "download");
    }, ee = () => {
      const {
        curPage: xt,
        totalNum: Kt
      } = s;
      return createVNode("div", {
        class: `${footerPrefixCls}-page`,
        key: "info"
      }, [xt, createTextVNode("/"), Kt]);
    }, Re = () => {
      const {
        zoom: xt,
        min: Kt,
        max: tn,
        step: ln,
        showTooltip: rn
      } = s;
      return createVNode(Slider$1, {
        key: "slider",
        value: xt,
        min: Kt,
        max: tn,
        step: ln,
        tipFormatter: (an) => `${an}%`,
        tooltipVisible: rn ? void 0 : !1,
        onChange: E
      }, null);
    }, wt = () => [z(), ee(), Q(), W(), Re(), ue(), te(), K(), ve()], yt = () => {
      const xt = wt();
      return xt.splice(3, 0, createVNode(Divider$1, {
        layout: "vertical",
        key: "divider-first"
      }, null)), xt.splice(8, 0, createVNode(Divider$1, {
        layout: "vertical",
        key: "divider-second"
      }, null)), xt;
    };
    return () => {
      const {
        className: xt,
        renderPreviewMenu: Kt,
        forwardRef: tn
      } = s, ln = cls(footerPrefixCls, `${footerPrefixCls}-wrapper`, xt, {
        [`${footerPrefixCls}-content`]: !Kt
      });
      return createVNode("section", {
        class: ln,
        ref: tn
      }, [Kt ? T() : yt()]);
    };
  }
}), DefaultDOMRect = {
  bottom: 0,
  height: 0,
  left: 0,
  right: 0,
  top: 0,
  width: 0,
  x: 0,
  y: 0,
  toJSON: () => ({})
};
class PreviewImageFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.startMouseOffset = { x: 0, y: 0 }, this.originImageWidth = null, this.originImageHeight = null, this._isImageVertical = () => this.getProp("rotation") % 180 !== 0, this._getImageBounds = () => {
      const l = this._adapter.getImage();
      return l ? l.getBoundingClientRect() : DefaultDOMRect;
    }, this._getContainerBounds = () => {
      const l = this._adapter.getContainer();
      return l ? l.getBoundingClientRect() : DefaultDOMRect;
    }, this._getOffset = (l) => {
      const { left: u, top: c } = this._getImageBounds();
      return {
        x: l.clientX - u,
        y: l.clientY - c
      };
    }, this.setLoading = (l) => {
      this._adapter.setLoading(l);
    }, this.handleWindowResize = () => {
      this.originImageWidth && this.originImageHeight && this.handleResizeImage();
    }, this.handleLoad = (l) => {
      if (l.target) {
        const { naturalWidth: m, naturalHeight: g } = l.target;
        this.originImageHeight = g, this.originImageWidth = m, this.setState({
          loading: !1
        }), this.handleResizeImage(!1);
      }
      const { src: u, onLoad: c } = this.getProps();
      c && c(u);
    }, this.handleError = (l) => {
      const { onError: u, src: c } = this.getProps();
      this.setState({
        loading: !1
      }), u && u(c);
    }, this.handleResizeImage = (l = !0) => {
      const u = !this._isImageVertical(), { currZoom: c } = this.getStates(), m = u ? this.originImageWidth : this.originImageHeight, g = u ? this.originImageHeight : this.originImageWidth, { onZoom: v, setRatio: b, ratio: S } = this.getProps();
      if (this._adapter.getContainer()) {
        const { width: P, height: T } = this._getContainerBounds(), N = P - 80, O = T - 80;
        let z = 1;
        (m > N || g > O) && (z = Number(
          Math.min(N / m, O / g).toFixed(2)
        )), c === z ? this.calculatePreviewImage(z, null) : v(z, l);
      }
    }, this.handleRatioChange = () => {
      if (this.originImageWidth && this.originImageHeight) {
        const { currZoom: l } = this.getStates(), { ratio: u, onZoom: c } = this.getProps();
        let m;
        if (u === "adaptation") {
          const g = !this._isImageVertical(), v = g ? this.originImageWidth : this.originImageHeight, b = g ? this.originImageHeight : this.originImageWidth, { width: S, height: E } = this._getContainerBounds(), P = S - 80, T = E - 80;
          m = Number(
            Math.min(P / v, T / b).toFixed(2)
          );
        } else
          m = 1;
        l !== m && c(m);
      }
    }, this.handleRightClickImage = (l) => {
      const { disableDownload: u } = this.getProps();
      return u ? (l.preventDefault(), l.stopPropagation(), !1) : !0;
    }, this.calcCanDragDirection = () => {
      const { width: l, height: u } = this.getStates();
      this.getProps();
      const { width: c, height: m } = this._getContainerBounds();
      let g = l > c, v = u > m;
      return this._isImageVertical() && (g = u > c, v = l > m), {
        canDragVertical: v,
        canDragHorizontal: g
      };
    }, this.calculatePreviewImage = (l, u) => {
      const c = this._adapter.getImage(), { canDragVertical: m, canDragHorizontal: g } = this.calcCanDragDirection(), v = m || g, { width: b, height: S } = this._getContainerBounds(), E = Math.floor(this.originImageWidth * l), P = Math.floor(this.originImageHeight * l);
      let T;
      const N = !this._isImageVertical();
      let O = 0, z = 0;
      N ? (T = {
        x: 0.5 * (b - E),
        y: 0.5 * (S - P)
      }, z = T.x, O = T.y) : (T = {
        x: 0.5 * (b - P),
        y: 0.5 * (S - E)
      }, z = T.x - (E - P) / 2, O = T.y + (E - P) / 2), this.setState({
        width: E,
        height: P,
        offset: T,
        left: z,
        top: O,
        currZoom: l
      }), c && this._adapter.setImageCursor(v);
    }, this.calcExtremeBounds = () => {
      const { width: l, height: u } = this.getStates(), { width: c, height: m } = this._getContainerBounds();
      let g = c - l, v = m - u;
      return this._isImageVertical() && (g = c - u, v = m - l), {
        left: g,
        top: v
      };
    }, this.handleMoveImage = (l) => {
      const { offset: u, width: c, height: m } = this.getStates(), { canDragVertical: g, canDragHorizontal: v } = this.calcCanDragDirection();
      if (l.buttons === 1 && (g || v)) {
        const { clientX: S, clientY: E } = l, { left: P, top: T } = this._getContainerBounds(), { left: N, top: O } = this.calcExtremeBounds();
        let z = v ? S - P - this.startMouseOffset.x : u.x, Q = g ? E - T - this.startMouseOffset.y : u.y;
        v && (z = z > 0 ? 0 : z < N ? N : z), g && (Q = Q > 0 ? 0 : Q < O ? O : Q);
        const W = {
          x: z,
          y: Q
        };
        this.setState({
          offset: W,
          left: this._isImageVertical() ? W.x - (c - m) / 2 : W.x,
          top: this._isImageVertical() ? W.y + (c - m) / 2 : W.y
        });
      }
    }, this.handleImageMouseDown = (l) => {
      this.startMouseOffset = this._getOffset(l);
    };
  }
}
const prefixCls$3 = cssClasses$4.PREFIX, preViewImgPrefixCls = `${prefixCls$3}-preview-image`, propTypes$7 = {
  src: string$3,
  rotation: number$2,
  style: object$1,
  // maxZoom: PropTypes.number,
  // minZoom: PropTypes.number,
  // zoomStep: PropTypes.number,
  zoom: number$2,
  ratio: string$3,
  disableDownload: bool,
  clickZoom: number$2,
  setRatio: func,
  onZoom: func,
  onLoad: func,
  onError: func,
  crossOrigin: string$3
}, defaultProps$7 = {
  // maxZoom: 5,
  // minZoom: 0.1,
  // zoomStep: 0.1,
  zoom: void 0
}, vuePropsType$7 = vuePropsMake(propTypes$7, defaultProps$7), PreviewImage = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$7
  },
  name: "PreviewImage",
  setup(s, {}) {
    useSlots();
    const o = reactive({
      width: 0,
      height: 0,
      loading: !0,
      offset: {
        x: 0,
        y: 0
      },
      currZoom: 0,
      top: 0,
      left: 0
    }), {
      adapter: l
    } = useBaseComponent(s, o);
    function u() {
      return {
        ...l(),
        getContainer: () => m.value,
        getImage: () => g.value,
        setLoading: (O) => {
          o.loading = O;
        },
        setImageCursor: (O) => {
          g.value.style.cursor = O ? "grab" : "default";
        }
      };
    }
    const c = u(), m = ref$1(), g = ref$1(), v = new PreviewImageFoundation(c);
    onMounted(() => {
      window.addEventListener("resize", b);
    }), onUnmounted(() => {
      window.removeEventListener("resize", b);
    });
    const b = () => {
      v.handleWindowResize();
    }, S = (O) => {
      v.handleRightClickImage(O);
    }, E = (O) => {
      v.handleLoad(O);
    }, P = (O) => {
      v.handleError(O);
    }, T = (O) => {
      v.handleMoveImage(O);
    }, N = (O) => {
      v.handleImageMouseDown(O);
    };
    return watch([() => s.src, () => s.zoom, () => s.ratio, () => s.rotation, () => o.currZoom, () => m.value], (O, [z, Q, W, ue, te], K) => {
      const ve = "zoom" in s && s.zoom !== o.currZoom, ee = s.src && s.src !== z;
      ee && v.setLoading(!0), ve && v.calculatePreviewImage(s.zoom, null), !ve && !ee && ("ratio" in s && s.ratio !== W && v.handleRatioChange(), "rotation" in s && s.rotation !== ue && b());
    }), () => {
      const {
        src: O,
        rotation: z,
        crossOrigin: Q
      } = s, {
        loading: W,
        width: ue,
        height: te,
        top: K,
        left: ve
      } = o, ee = {
        position: "absolute",
        visibility: W ? "hidden" : "visible",
        transform: `rotate(${-z}deg)`,
        top: K + "px",
        left: ve + "px",
        width: `${ue}px`,
        height: `${te}px`
      };
      return createVNode("div", {
        class: `${preViewImgPrefixCls}`,
        ref: m
      }, [createVNode("img", {
        ref: g,
        src: O,
        alt: "previewImag",
        class: `${preViewImgPrefixCls}-img`,
        key: O,
        onMousemove: T,
        onMousedown: N,
        onContextmenu: S,
        onDragstart: (Re) => Re.preventDefault(),
        onLoad: E,
        onError: P,
        style: ee,
        crossorigin: Q
      }, null), W && createVNode(Spin, {
        size: "large",
        wrapperClassName: `${preViewImgPrefixCls}-spin`
      }, null)]);
    };
  }
}), isTargetEmit = (s, o) => {
  const l = s == null ? void 0 : s.composedPath();
  return l == null ? void 0 : l.slice(0, l.length - 4).some((c) => c.className && typeof c.className == "string" ? o.some((m) => c.className.includes(m)) : !1);
}, downloadImage = async (s, o, l) => {
  try {
    const u = await fetch(s);
    if (u.ok) {
      const c = await u.blob(), m = URL.createObjectURL(c), g = document.createElement("a");
      g.href = m, g.download = o, g.click(), URL.revokeObjectURL(m), g.remove();
    } else
      l(s);
  } catch {
    l(s);
  }
}, crossMerge = (s = [], o = []) => {
  let l = [];
  const u = s.length, c = o.length, m = u <= c ? u : c;
  return new Array(m).fill(0).forEach((g, v) => {
    l.push(o[v]), l.push(s[v]);
  }), u > c ? l = l.concat(s.slice(c, u)) : u < c && (l = l.concat(o.slice(u, c))), l;
}, getPreloadImagArr = (s, o, l, u) => {
  const c = o - l, m = o + l, g = s.length;
  let v = [], b = [];
  l >= Math.floor(g / 2) ? u ? (v = s.concat(s).slice(c + g < 0 ? 0 : c + g, o + g), b = s.concat(s).slice(o + 1, m + 1 < 2 * g ? m + 1 : 2 * g)) : (v = s.slice(0, o), b = s.slice(o + 1, g)) : u ? (v = s.concat(s).slice(c + g, o + g), b = s.concat(s).slice(o + 1, m + 1)) : c >= 0 && m < g ? (v = s.slice(c, o), b = s.slice(o + 1, m + 1)) : c < 0 ? (v = s.slice(0, o), b = s.slice(o + 1, 2 * l + 1)) : (b = s.slice(o + 1, g), v = s.slice(g - 2 * l - 1, o));
  const S = crossMerge(v.reverse(), b);
  return Array.from(new Set(S));
}, NOT_CLOSE_TARGETS = ["icon", "footer"];
class PreviewInnerFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this._timer = null, this._startMouseDown = { x: 0, y: 0 }, this.handleViewVisibleChange = () => {
      const { viewerVisible: l } = this.getStates();
      l && (this.setState({
        viewerVisible: !1
      }), this.clearTimer());
    }, this.handleMouseMove = (l) => {
      this._persistEvent(l), this.mouseMoveHandler(l);
    }, this.mouseMoveHandler = lodashExports.throttle((l) => {
      const { viewerVisible: u } = this.getStates();
      this._adapter.isValidTarget(l) ? (u || this.setState({
        viewerVisible: !0
      }), this.updateTimer()) : this.clearTimer();
    }, 50), this.updateTimer = () => {
      const { viewerVisibleDelay: l } = this.getProps();
      this.clearTimer(), this._timer = setTimeout(this.handleViewVisibleChange, l);
    }, this.clearTimer = () => {
      this._timer && (clearTimeout(this._timer), this._timer = null);
    }, this.handleWheel = (l) => {
      this.onWheel(l), handlePrevent(l);
    }, this.onWheel = (l) => {
      const { zoomStep: u, maxZoom: c, minZoom: m } = this.getProps(), { zoom: g } = this.getStates();
      let v;
      l.deltaY < 0 ? g + u <= c && (v = Number((g + u).toFixed(2))) : l.deltaY > 0 && g - u >= m && (v = Number((g - u).toFixed(2))), lodashExports.isUndefined(v) || this.handleZoomImage(v);
    }, this.handleMouseUp = (l) => {
      const { maskClosable: u } = this.getProps();
      let c = !isTargetEmit(l, NOT_CLOSE_TARGETS);
      const { clientX: m, clientY: g } = l, { x: v, y: b } = this._startMouseDown;
      (Math.abs(m - v) > 5 || Math.abs(b - g) > 5) && (c = !1), c && u && this._adapter.notifyVisibleChange(!1);
    }, this.handleMouseDown = (l) => {
      const { clientX: u, clientY: c } = l;
      this._startMouseDown = { x: u, y: c };
    }, this.handleKeyDown = (l) => {
      const { closeOnEsc: u } = this.getProps();
      if (u && l.keyCode === KeyCode.ESC) {
        l.stopPropagation(), this._adapter.notifyVisibleChange(!1), this._adapter.notifyClose();
        return;
      }
    }, this.handleSwitchImage = (l) => {
      const u = l === "prev" ? -1 : 1, { imgSrc: c, currentIndex: m } = this.getStates(), g = c.length, v = (m + u + g) % g;
      "currentIndex" in this.getProps() ? this._adapter.getIsInGroup() && this._adapter.getContext("setCurrentIndex")(v) : this.setState({
        currentIndex: v
      }), this._adapter.notifyChange(v, l), this.setState({
        direction: l,
        rotation: 0
      });
    }, this.handleDownload = () => {
      const { currentIndex: l, imgSrc: u } = this.getStates(), c = this._adapter.getSetDownloadFunc(), m = u[l], g = c ? c(m) : m.slice(m.lastIndexOf("/") + 1).split("?")[0];
      downloadImage(m, g, this._adapter.notifyDownloadError), this._adapter.notifyDownload(m, l);
    }, this.handlePreviewClose = (l) => {
      this._adapter.notifyVisibleChange(!1), this._adapter.notifyClose(), handlePrevent(l);
    }, this.handleAdjustRatio = (l) => {
      this.setState({
        ratio: l
      }), this._adapter.notifyRatioChange(l);
    }, this.handleRotateImage = (l) => {
      const { rotation: u } = this.getStates(), c = u + (l === "left" ? 90 : -90);
      this.setState({
        rotation: c
      }), this._adapter.notifyRotateChange(c);
    }, this.handleZoomImage = (l, u = !0) => {
      const { zoom: c } = this.getStates();
      c !== l && (u && this._adapter.notifyZoom(l, l > c), this.setState({
        zoom: l
      }));
    }, this.preloadGapImage = () => {
      const { preLoad: l, preLoadGap: u, infinite: c, currentIndex: m } = this.getProps(), { imgSrc: g } = this.getStates();
      if (!l || typeof u != "number" || u < 1)
        return;
      const v = getPreloadImagArr(g, m, u, c);
      if (v.length === 0)
        return;
      const b = new Image();
      let S = 0;
      function E(P) {
        S++, S < v.length && (b.src = v[S]);
      }
      b.onload = (P) => {
        this.setLoadSuccessStatus(b.src), E();
      }, b.onerror = E, b.src = v[0];
    }, this.preloadSingleImage = () => {
      const { preLoad: l, preLoadGap: u, infinite: c } = this.getProps(), { imgSrc: m, currentIndex: g, direction: v, imgLoadStatus: b } = this.getStates();
      if (!l || typeof u != "number" || u < 1)
        return;
      let S = g + (v === "prev" ? -1 : 1) * u;
      if (S < 0 || S >= m.length)
        if (c)
          S = (S + m.length) % m.length;
        else
          return;
      if (!b[S]) {
        const E = new Image();
        E.onload = (P) => {
          this.setLoadSuccessStatus(m[S]);
        }, E.src = m[S];
      }
    }, this.setLoadSuccessStatus = (l) => {
      const { imgLoadStatus: u } = this.getStates(), c = { ...u };
      c[l] = !0, this.setState({
        imgLoadStatus: c
      });
    }, this.onImageLoad = (l) => {
      const { preloadAfterVisibleChange: u } = this.getStates();
      this.setLoadSuccessStatus(l), u ? (this.preloadGapImage(), this.setState({
        preloadAfterVisibleChange: !1
      })) : this.preloadSingleImage();
    };
  }
  beforeShow() {
    this._adapter.registerKeyDownListener(), this._adapter.disabledBodyScroll(), this.updateTimer();
  }
  afterHide() {
    this._adapter.unregisterKeyDownListener(), this._adapter.enabledBodyScroll(), this.clearTimer();
  }
}
const prefixCls$2 = cssClasses$4.PREFIX, propTypes$6 = {
  style: object$1,
  className: string$3,
  lazyLoadMargin: string$3,
  visible: bool,
  src: oneOfType([string$3, array$1]),
  currentIndex: number$2,
  defaultCurrentIndex: number$2,
  defaultVisible: bool,
  maskClosable: bool,
  closable: bool,
  zoomStep: number$2,
  infinite: bool,
  showTooltip: bool,
  closeOnEsc: bool,
  prevTip: string$3,
  nextTip: string$3,
  zoomInTip: string$3,
  zoomOutTip: string$3,
  downloadTip: string$3,
  adaptiveTip: string$3,
  originTip: string$3,
  lazyLoad: bool,
  preLoad: bool,
  preLoadGap: number$2,
  disableDownload: bool,
  viewerVisibleDelay: number$2,
  zIndex: number$2,
  maxZoom: number$2,
  minZoom: number$2,
  renderHeader: func,
  renderPreviewMenu: func,
  getPopupContainer: func,
  onVisibleChange: func,
  onChange: func,
  onClose: func,
  onZoomIn: func,
  onZoomOut: func,
  onPrev: func,
  onNext: func,
  onDownload: func,
  onRatioChange: func,
  onRotateChange: func,
  // onRotateLeft: PropTypes.func as PropType<PreviewInnerProps['onRotateLeft']>,
  setDownloadName: func,
  crossOrigin: string$3,
  previewTitle: node$1,
  rotateTip: string$3,
  onRotateLeft: func,
  onDownloadError: func,
  forwardRef: [func, object$1]
}, defaultProps$6 = {
  showTooltip: !1,
  zoomStep: 0.1,
  infinite: !1,
  closeOnEsc: !0,
  lazyLoad: !1,
  preLoad: !0,
  preLoadGap: 2,
  zIndex: numbers.DEFAULT_Z_INDEX,
  maskClosable: !0,
  viewerVisibleDelay: 1e4,
  maxZoom: 5,
  minZoom: 0.1
}, vuePropsType$6 = vuePropsMake(propTypes$6, defaultProps$6), PreviewInner = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$6
  },
  name: "PreviewInner",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps();
    useSlots();
    let l, u, c;
    const m = reactive({
      imgSrc: [],
      imgLoadStatus: /* @__PURE__ */ new Map(),
      zoom: 0.1,
      currentIndex: 0,
      ratio: "adaptation",
      rotation: 0,
      viewerVisible: !0,
      visible: !1,
      preloadAfterVisibleChange: !0,
      direction: ""
    }), {
      adapter: g
    } = useBaseComponent(s, m), {
      context: v
    } = usePreviewContext(), b = ref$1(), S = ref$1(), E = ref$1(), P = ref$1(), T = ref$1();
    function N() {
      return {
        ...g(),
        getIsInGroup: () => W(),
        disabledBodyScroll: () => {
          const {
            getPopupContainer: Gt
          } = s;
          l = document.body.style.overflow || "", !Gt && l !== "hidden" && (document.body.style.overflow = "hidden", document.body.style.width = `calc(${c || "100%"} - ${u}px)`);
        },
        enabledBodyScroll: () => {
          const {
            getPopupContainer: Gt
          } = s;
          !Gt && l !== "hidden" && (document.body.style.overflow = l, document.body.style.width = c);
        },
        notifyChange: (Gt, nn) => {
          const {
            onChange: vt,
            onPrev: Et,
            onNext: Qt
          } = s;
          lodashExports.isFunction(vt) && vt(Gt), nn === "prev" ? Et && Et(Gt) : Qt && Qt(Gt);
        },
        notifyZoom: (Gt, nn) => {
          const {
            onZoomIn: vt,
            onZoomOut: Et
          } = s;
          nn ? lodashExports.isFunction(vt) && vt(Gt) : lodashExports.isFunction(Et) && Et(Gt);
        },
        notifyClose: () => {
          const {
            onClose: Gt
          } = s;
          lodashExports.isFunction(Gt) && Gt();
        },
        notifyVisibleChange: (Gt) => {
          const {
            onVisibleChange: nn
          } = s;
          lodashExports.isFunction(nn) && nn(Gt);
        },
        notifyRatioChange: (Gt) => {
          const {
            onRatioChange: nn
          } = s;
          lodashExports.isFunction(nn) && nn(Gt);
        },
        notifyRotateChange: (Gt) => {
          const {
            onRotateChange: nn
          } = s;
          lodashExports.isFunction(nn) && nn(Gt);
        },
        notifyDownload: (Gt, nn) => {
          const {
            onDownload: vt
          } = s;
          lodashExports.isFunction(vt) && vt(Gt, nn);
        },
        notifyDownloadError: (Gt) => {
          const {
            onDownloadError: nn
          } = s;
          lodashExports.isFunction(nn) && nn(Gt);
        },
        registerKeyDownListener: () => {
          window && window.addEventListener("keydown", xt);
        },
        unregisterKeyDownListener: () => {
          window && window.removeEventListener("keydown", xt);
        },
        getSetDownloadFunc: () => {
          var Gt;
          return ((Gt = v.value) == null ? void 0 : Gt.setDownloadName) ?? s.setDownloadName;
        },
        isValidTarget: (Gt) => {
          const nn = S.value, vt = E.value, Et = P.value, Qt = T.value, un = Gt.target;
          return !(nn && nn.contains(un) || vt && vt.contains(un) || Et && Et.contains(un) || Qt && Qt.contains(un));
        }
      };
    }
    const O = N(), z = new PreviewInnerFoundation(O);
    function Q(Gt, nn) {
      const vt = {};
      let Et = [];
      return Gt.visible && (Et = Array.isArray(Gt.src) ? Gt.src : [Gt.src]), lodashExports.isEqual(Et, nn.imgSrc) || (vt.imgSrc = Et), Gt.visible !== nn.visible && (vt.visible = Gt.visible, Gt.visible && (vt.preloadAfterVisibleChange = !0, vt.viewerVisible = !0, vt.rotation = 0, vt.ratio = "adaptation")), "currentIndex" in o(Gt) && Gt.currentIndex !== nn.currentIndex && (vt.currentIndex = Gt.currentIndex, vt.ratio = "adaptation"), vt;
    }
    watch(() => s, (Gt) => {
      const nn = Q({
        ...s
      }, {
        ...m
      });
      nn && Object.keys(nn).forEach((vt) => {
        m[vt] = nn[vt];
      });
    }, {
      deep: !0,
      immediate: !0
    }), onMounted(() => {
      u = getScrollbarWidth(), c = document.body.style.width, s.visible && z.beforeShow();
    }), watch([() => m.visible, () => s.visible, () => s.src], (Gt, [nn, vt, Et], Qt) => {
      Et !== s.src && z.updateTimer(), !nn && s.visible && z.beforeShow(), nn && !s.visible && z.afterHide();
    }, {
      immediate: !0
    }), onBeforeUnmount(() => {
      z.clearTimer();
    });
    function W() {
      return !!(v && v.value.isGroup);
    }
    const ue = (Gt) => {
      z.handleSwitchImage(Gt);
    }, te = () => {
      z.handleDownload();
    }, K = (Gt) => {
      z.handlePreviewClose(Gt);
    }, ve = (Gt) => {
      z.handleAdjustRatio(Gt);
    }, ee = (Gt) => {
      z.handleRotateImage(Gt);
    }, Re = (Gt, nn = !0) => {
      z.handleZoomImage(Gt);
    }, wt = (Gt) => {
      z.handleMouseUp(Gt);
    }, yt = (Gt) => {
      z.handleMouseMove(Gt);
    };
    function xt(Gt) {
      z.handleKeyDown(Gt);
    }
    function Kt() {
      z.preloadSingleImage();
    }
    function tn(Gt) {
      z.onImageLoad(Gt);
    }
    function ln(Gt) {
      z.handleMouseDown(Gt);
    }
    const rn = (Gt) => {
      z.handleWheel(Gt);
    }, an = (Gt) => {
      b.value && b.value.removeEventListener("wheel", rn), Gt && Gt.addEventListener("wheel", rn, {
        passive: !1
      }), b.value = Gt;
    };
    return () => {
      const {
        getPopupContainer: Gt,
        closable: nn,
        zIndex: vt,
        visible: Et,
        className: Qt,
        style: un,
        infinite: gn,
        zoomStep: dn,
        crossOrigin: yn,
        prevTip: vn,
        nextTip: Pn,
        zoomInTip: On,
        zoomOutTip: _n,
        rotateTip: Nn,
        downloadTip: Un,
        adaptiveTip: Xn,
        originTip: zn,
        showTooltip: jn,
        disableDownload: kn,
        renderPreviewMenu: Yn,
        renderHeader: Zn
      } = s, {
        currentIndex: er,
        imgSrc: bn,
        zoom: Ln,
        ratio: Kn,
        rotation: Bn,
        viewerVisible: Fn
      } = m;
      let Gn = {
        zIndex: vt
      };
      Gt && (Gn = {
        zIndex: vt,
        position: "static"
      });
      const Wn = `${prefixCls$2}-preview`, Mn = cls(Wn, {
        [`${prefixCls$2}-hide`]: !Et,
        [`${Wn}-popup`]: Gt
      }, Qt), Tn = Fn ? "" : `${Wn}-hide`, Rn = bn.length, hn = Rn !== 1 && (gn || er !== 0), Qn = Rn !== 1 && (gn || er !== Rn - 1);
      return Et && createVNode(Index$9, {
        getPopupContainer: Gt,
        style: Gn
      }, {
        default: () => [createVNode("div", {
          class: Mn,
          style: un,
          onMousedown: ln,
          onMouseup: wt,
          ref: an,
          onMousemove: yt
        }, [createVNode(Header, {
          ref: S,
          className: cls(Tn),
          onClose: K,
          renderHeader: Zn,
          closable: nn
        }, null), createVNode(PreviewImage, {
          src: bn[er],
          onZoom: Re,
          disableDownload: kn,
          setRatio: ve,
          zoom: Ln,
          ratio: Kn,
          rotation: Bn,
          crossOrigin: yn,
          onError: Kt,
          onLoad: tn
        }, null), hn && // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        createVNode("div", {
          ref: P,
          class: cls(`${Wn}-icon`, `${Wn}-prev`, Tn),
          onClick: () => ue("prev")
        }, [createVNode(IconComponent$I, {
          size: "large"
        }, null)]), Qn && // eslint-disable-next-line jsx-a11y/click-events-have-key-events,jsx-a11y/no-static-element-interactions
        createVNode("div", {
          ref: T,
          class: cls(`${Wn}-icon`, `${Wn}-next`, Tn),
          onClick: () => ue("next")
        }, [createVNode(IconComponent$H, {
          size: "large"
        }, null)]), createVNode(Footer, {
          forwardRef: E,
          className: Tn,
          totalNum: Rn,
          curPage: er + 1,
          disabledPrev: !hn,
          disabledNext: !Qn,
          zoom: Ln * 100,
          step: dn * 100,
          showTooltip: jn,
          ratio: Kn,
          prevTip: vn,
          nextTip: Pn,
          zIndex: vt,
          zoomInTip: On,
          zoomOutTip: _n,
          rotateTip: Nn,
          downloadTip: Un,
          disableDownload: kn,
          adaptiveTip: Xn,
          originTip: zn,
          onPrev: () => ue("prev"),
          onNext: () => ue("next"),
          onZoomIn: Re,
          onZoomOut: Re,
          onDownload: te,
          onRotate: ee,
          onAdjustRatio: ve,
          renderPreviewMenu: Yn
        }, null)])]
      });
    };
  }
});
class ImageFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleClick = (l) => {
      const { imageID: u, preview: c } = this.getProps();
      if (c)
        if (this._adapter.getIsInGroup()) {
          const { setCurrentIndex: m, handleVisibleChange: g } = this._adapter.getContexts();
          m(u), g(!0);
        } else
          this.handlePreviewVisibleChange(!0);
    }, this.handleLoaded = (l) => {
      const { onLoad: u } = this.getProps();
      u && u(l), this.setState({
        loadStatus: "success"
      });
    }, this.handleError = (l) => {
      const { onError: u } = this.getProps();
      u && u(l), this.setState({
        loadStatus: "error"
      });
    }, this.handlePreviewVisibleChange = (l) => {
      const { preview: u } = this.getProps();
      if (lodashExports.isObject(u)) {
        const { onVisibleChange: c } = u;
        c && c(l), "visible" in u || this.setState({
          previewVisible: l
        });
      } else
        this.setState({
          previewVisible: l
        });
    };
  }
}
const prefixCls$1 = cssClasses$4.PREFIX, propTypes$5 = {
  style: object$1,
  className: string$3,
  src: string$3,
  width: oneOfType([string$3, number$2]),
  height: oneOfType([string$3, number$2]),
  alt: string$3,
  placeholder: node$1,
  fallback: node$1,
  preview: [bool, object$1],
  onLoad: func,
  onError: func,
  onClick: func,
  crossOrigin: string$3,
  imageID: number$2,
  maxZoom: number$2,
  minZoom: number$2,
  setDownloadName: func,
  imgStyle: object$1,
  imgCls: string$3
}, defaultProps$5 = {
  preview: !0
}, vuePropsType$5 = vuePropsMake(propTypes$5, defaultProps$5), Image$1 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$5
  },
  name: "Image",
  setup(s, {}) {
    useSlots();
    const {
      context: o
    } = usePreviewContext(), l = reactive({
      src: "",
      loadStatus: "loading",
      previewVisible: !1
    }), {
      adapter: u
    } = useBaseComponent(s, l);
    function c() {
      return {
        ...u(),
        getIsInGroup: () => S()
        // getContexts: () => context.value,
        // getContext: key => { // eslint-disable-line
        //   if (context.value && key) {
        //     // @ts-ignore
        //     return context.value[key];
        //   }
        // }
      };
    }
    const m = c(), g = new ImageFoundation(m), v = ref$1();
    function b(K, ve) {
      const ee = {};
      if (K.src !== ve.src && (ee.src = K.src, ee.loadStatus = "loading"), lodashExports.isObject(K.preview)) {
        const {
          visible: Re
        } = K.preview;
        lodashExports.isBoolean(Re) && (ee.previewVisible = Re);
      }
      return ee;
    }
    watch([() => s.src, () => s.preview], () => {
      const K = b({
        ...s
      }, {
        ...l
      });
      K && Object.keys(K).forEach((ve) => {
        l[ve] = K[ve];
      });
    }, {
      immediate: !0,
      deep: !0
    });
    function S() {
      return !!(o && o.value.isGroup);
    }
    function E() {
      return o ? o.value.lazyLoad : !1;
    }
    const P = (K) => {
      g.handleClick(K);
    }, T = (K) => {
      g.handleLoaded(K);
    }, N = (K) => {
      g.handleError(K);
    }, O = (K) => {
      g.handlePreviewVisibleChange(K);
    }, z = () => {
      const {
        width: K,
        height: ve
      } = s;
      return createVNode(Image$2, {
        style: {
          width: K,
          height: ve
        }
      }, null);
    }, Q = () => {
      const K = `${prefixCls$1}-status`;
      return createVNode("div", {
        class: K
      }, [createVNode(IconComponent$1, {
        size: "extra-large"
      }, null)]);
    }, W = () => {
      const K = `${prefixCls$1}-status`, {
        placeholder: ve
      } = s;
      return ve ? createVNode("div", {
        class: K
      }, [ve]) : z();
    }, ue = () => {
      const {
        fallback: K
      } = s, ve = `${prefixCls$1}-status`, ee = typeof K == "string" ? createVNode("img", {
        style: {
          width: "100%",
          height: "100%"
        },
        src: K,
        alt: "fallback"
      }, null) : K;
      return K ? createVNode("div", {
        class: ve
      }, [ee]) : Q();
    }, te = () => {
      const {
        loadStatus: K
      } = l;
      return createVNode("div", {
        class: `${prefixCls$1}-overlay`
      }, [K === "error" && ue(), K === "loading" && W()]);
    };
    return () => {
      const {
        src: K,
        loadStatus: ve,
        previewVisible: ee
      } = l, {
        src: Re,
        width: wt,
        height: yt,
        alt: xt,
        style: Kt,
        className: tn,
        crossOrigin: ln,
        preview: rn,
        fallback: an,
        placeholder: Gt,
        imageID: nn,
        setDownloadName: vt,
        imgCls: Et,
        imgStyle: Qt,
        ...un
      } = s, gn = Object.assign({
        width: wt,
        height: yt
      }, Kt), dn = cls(prefixCls$1, tn), yn = ve === "success" && rn && !S(), vn = rn && ve === "success", Pn = typeof rn != "boolean" ? rn.src ?? K : K, On = typeof rn != "boolean" && yn ? {
        ...lodashExports.omit(rn, ["className", "style", "previewCls", "previewStyle"]),
        className: rn == null ? void 0 : rn.previewCls,
        style: rn == null ? void 0 : rn.previewStyle
      } : {};
      return (
        // eslint-disable jsx-a11y/no-static-element-interactions
        // eslint-disable jsx-a11y/click-events-have-key-events
        createVNode("div", {
          style: gn,
          class: dn,
          onClick: P
        }, [createVNode("img", mergeProps$1({
          ref: v
        }, un, {
          src: S() && E() ? void 0 : K,
          "data-src": K,
          alt: xt,
          style: Qt,
          class: cls(`${prefixCls$1}-img`, {
            [`${prefixCls$1}-img-preview`]: vn,
            [`${prefixCls$1}-img-error`]: ve === "error",
            [Et]: !!Et
          }),
          width: wt,
          height: yt,
          crossorigin: ln,
          onError: N,
          onLoad: T
        }), null), ve !== "success" && te(), yn && createVNode(PreviewInner, mergeProps$1(On, {
          src: Pn,
          visible: ee,
          onVisibleChange: O,
          crossOrigin: lodashExports.isUndefined(ln) ? On == null ? void 0 : On.crossOrigin : ln,
          setDownloadName: vt
        }), null)])
      );
    };
  }
});
Image$1.isSemiImage = !0;
class PreviewFoundation extends BaseFoundation$1 {
  constructor() {
    super(...arguments), this.handleVisibleChange = (o) => {
      const { visible: l, onVisibleChange: u } = this.getProps();
      l in this.getProps() || this.setState({
        visible: o
      }), u && u(o);
    }, this.handleCurrentIndexChange = (o) => {
      const { currentIndex: l, onChange: u } = this.getProps();
      l in this.getProps() || this.setState({
        currentIndex: o
      }), u && u(o);
    };
  }
}
const prefixCls = cssClasses$4.PREFIX, propTypes$4 = {
  style: object$1,
  className: string$3,
  visible: bool,
  src: oneOfType([string$3, array$1]),
  currentIndex: number$2,
  defaultCurrentIndex: number$2,
  defaultVisible: bool,
  maskClosable: bool,
  closable: bool,
  zoomStep: number$2,
  infinite: bool,
  showTooltip: bool,
  closeOnEsc: bool,
  prevTip: string$3,
  nextTip: string$3,
  zoomInTip: string$3,
  zoomOutTip: string$3,
  downloadTip: string$3,
  adaptiveTip: string$3,
  originTip: string$3,
  lazyLoad: bool,
  lazyLoadMargin: string$3,
  preLoad: bool,
  preLoadGap: number$2,
  previewCls: string$3,
  previewStyle: object$1,
  disableDownload: bool,
  zIndex: number$2,
  renderHeader: func,
  renderPreviewMenu: func,
  getPopupContainer: func,
  onVisibleChange: func,
  onChange: func,
  onClose: func,
  onZoomIn: func,
  onZoomOut: func,
  onPrev: func,
  onNext: func,
  onDownload: func,
  onRatioChange: func,
  onRotateChange: func,
  previewTitle: node$1,
  rotateTip: string$3,
  viewerVisibleDelay: number$2,
  crossOrigin: string$3,
  maxZoom: number$2,
  minZoom: number$2,
  onRotateLeft: func,
  onDownloadError: func,
  setDownloadName: func,
  forwardRef: [Function, Object]
}, defaultProps$4 = {
  src: [],
  lazyLoad: !0,
  lazyLoadMargin: "0px 100px 100px 0px",
  closable: !0
}, vuePropsType$4 = vuePropsMake(propTypes$4, defaultProps$4), Preview = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$4
  },
  name: "Preview",
  setup(s, {}) {
    const {
      getProps: o
    } = useHasInProps(), l = useSlots(), u = reactive({
      currentIndex: s.currentIndex || s.defaultCurrentIndex || 0,
      visible: s.visible || s.defaultVisible || !1
    }), {
      adapter: c
    } = useBaseComponent(s, u);
    function m() {
      return {
        ...c()
      };
    }
    const g = m(), v = new PreviewFoundation(g), b = getUuidShort({
      prefix: "semi-image-preview-group",
      length: 4
    }), S = ref$1();
    let E;
    onMounted(() => {
      s.lazyLoad && T();
    });
    const P = shallowRef([]);
    watch([() => s.lazyLoad, P], ([W, ue], [te, K], ve) => {
      if (s.lazyLoad) {
        const ee = K == null ? void 0 : K.map((wt) => isVNode(wt) ? wt.key : null), Re = ue == null ? void 0 : ue.map((wt) => isVNode(wt) ? wt.key : null);
        lodashExports.isEqual(ee, Re) || nextTick(() => {
          T();
        });
      }
    });
    function T() {
      E ? E.disconnect() : E = new IntersectionObserver((ue) => {
        ue.forEach((te) => {
          var ve;
          const K = (ve = te.target.dataset) == null ? void 0 : ve.src;
          te.isIntersecting && K && (te.target.src = K, te.target.removeAttribute("data-src")), E.unobserve(te.target);
        });
      }, {
        root: document.querySelector(`#${b}`),
        rootMargin: s.lazyLoadMargin
      }), document.querySelectorAll(`.${prefixCls}-img`).forEach((ue) => E.observe(ue));
    }
    function N(W, ue) {
      const te = {};
      return "currentIndex" in o(W) && W.currentIndex !== ue.currentIndex && (te.currentIndex = W.currentIndex), "visible" in o(W) && W.visible !== ue.visible && (te.visible = W.visible), te;
    }
    watch(() => s, (W) => {
      const ue = N({
        ...s
      }, {
        ...u
      });
      ue && Object.keys(ue).forEach((te) => {
        u[te] = ue[te];
      });
    }, {
      deep: !0
    }), onBeforeUnmount(() => {
      E && (E.disconnect(), E = null);
    });
    const O = (W) => {
      v.handleVisibleChange(W);
    }, z = (W) => {
      v.handleCurrentIndexChange(W);
    }, Q = () => {
      const W = getFragmentChildren(l);
      let ue = 0;
      const te = [], K = [], ve = (ee) => ee.map((Re) => {
        if (Re && Re.props && Re.type && Re.type.isSemiImage) {
          const {
            src: wt,
            preview: yt,
            alt: xt
          } = Re.props;
          if (yt || yt === void 0) {
            const Kt = lodashExports.isObject(yt) ? yt.src ?? wt : wt;
            return te.push(Kt), K.push(yt == null ? void 0 : yt.previewTitle), cloneVNode(Re, {
              imageID: ue++
            });
          }
          return Re;
        }
        return Re && Re.props && Re.props.children ? cloneVNode(Re, {
          children: ve(Re.props.children)
        }) : Re;
      });
      return {
        srcListInChildren: te,
        newChildren: ve(W),
        titles: K
      };
    };
    return () => {
      var an, Gt, nn;
      P.value = ((nn = (Gt = (an = l.default) == null ? void 0 : an.call(l)) == null ? void 0 : Gt[0]) == null ? void 0 : nn.children) || [];
      const {
        src: W,
        className: ue,
        style: te,
        lazyLoad: K,
        setDownloadName: ve,
        ...ee
      } = o(s), Re = {
        ...lodashExports.omit(ee, ["previewCls", "previewStyle"]),
        className: ee == null ? void 0 : ee.previewCls,
        style: ee == null ? void 0 : ee.previewStyle
      }, {
        currentIndex: wt,
        visible: yt
      } = u, {
        srcListInChildren: xt,
        newChildren: Kt,
        titles: tn
      } = Q(), rn = [...Array.isArray(W) ? W : typeof W == "string" ? [W] : [], ...xt];
      return createVNode(PreviewContext.Provider, {
        value: {
          isGroup: !0,
          previewSrc: rn,
          titles: tn,
          currentIndex: wt,
          visible: yt,
          lazyLoad: K,
          previewObserver: E,
          setCurrentIndex: z,
          handleVisibleChange: O,
          setDownloadName: ve
        }
      }, {
        default: () => [createVNode("div", {
          id: b,
          style: te,
          class: cls(`${prefixCls}-preview-group`, ue)
        }, [Kt]), createVNode(PreviewInner, mergeProps$1(Re, {
          ref: S,
          src: rn,
          currentIndex: wt,
          visible: yt,
          onVisibleChange: O
        }), null)]
      });
    };
  }
}), Preview$1 = Preview;
function WithVModel(s, o) {
  return /* @__PURE__ */ defineComponent({
    name: s.name,
    props: {
      //@ts-ignore
      ...s.props,
      modelValue: [Number, String, Object, Array, Boolean],
      "onUpdate:modelValue": Function
    },
    setup(l, {
      emit: u,
      slots: c,
      expose: m
    }) {
      const g = ref$1();
      return m({
        ...g.value
      }), () => l["onUpdate:modelValue"] ? (
        //@ts-ignore
        createVNode(s, mergeProps$1(lodashExports.omit(l, "update:modelValue", "modelValue", (o == null ? void 0 : o.valueKey) || "value", "onChange"), {
          [(o == null ? void 0 : o.valueKey) || "value"]: l.modelValue,
          [(o == null ? void 0 : o.onKeyChangeFnName) || "onChange"]: (v) => {
            var S, E;
            let b = o != null && o.valuePath ? get(v, o.valuePath) : v;
            Array.isArray(b) && (b = [...b]), (S = l.onChange) == null || S.call(l, b), (E = l["onUpdate:modelValue"]) == null || E.call(l, b);
          }
        }), {
          default: c.default
        })
      ) : createVNode(s, lodashExports.omit(l, "update:modelValue", "modelValue"), null);
    }
  });
}
const AutoCompleteVModel = WithVModel(AutoComplete), CascaderVModel = WithVModel(Cascader), CheckboxGroupVModel = WithVModel(CheckboxGroup), DatePickerVModel = WithVModel(DatePicker), InputVModel = WithVModel(Input$1), InputNumberVModel = WithVModel(InputNumber$1), RadioGroupVModel = WithVModel(RadioGroup$1, { valuePath: "target.value" }), RatingVModel = WithVModel(Rating$1), SelectVModel = WithVModel(Select), SliderVModel = WithVModel(Slider$1), SwitchVModel = WithVModel(Switch$1, { valueKey: "checked" }), TagInputVModel = WithVModel(TagInput), TimePickerVModel = WithVModel(TimePicker), TransferVModel = WithVModel(Transfer$1), TreeSelectVModel = WithVModel(TreeSelect$1), UploadVModel = WithVModel(Upload$1, {
  valueKey: "fileList",
  valuePath: "fileList",
  onKeyChangeFnName: "onChange"
}), Lf = class Lf extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.handleCurrentActiveIndexChange = (l, u) => {
      u === "focus" && this._adapter.onCurrentActiveIndexChange(l);
    }, this.completeSingleInput = async (l, u) => {
      var v;
      const c = !!this.getProp("value");
      await this._adapter.onCurrentActiveIndexChange(l + 1);
      const m = [...this.getState("valueList")];
      m[l] = u, c ? this._adapter.notifyValueChange(m) : await this.updateValueList(m);
      const g = this.getProp("count");
      l + 1 > g - 1 ? (this._adapter.changeSpecificInputFocusState(l, "blur"), (v = this.getProp("onComplete")) == null || v(m.join(""))) : this._adapter.changeSpecificInputFocusState(l + 1, "focus");
    }, this.validateValue = (l = "") => {
      const u = this.getProp("format");
      let c = (m) => !0;
      return typeof u == "string" ? u === "number" ? c = (m) => m.length === 0 || Lf.numberReg.test(m) : u === "mixed" && (c = (m) => m.length === 0 || Lf.mixedReg.test(m)) : u instanceof RegExp ? c = (m) => u.test(m) : typeof u == "function" && (c = u), c(l);
    }, this.updateValueList = async (l) => {
      this._adapter.updateValueList(l);
    }, this.handlePaste = async (l, u) => {
      const c = l.clipboardData.getData("text"), m = this.getProp("count");
      for (let g = u, v = 0; g < m && v < c.length; g++, v++) {
        const b = c[v];
        if (this.validateValue(b))
          await this.completeSingleInput(g, b);
        else
          break;
      }
      l.preventDefault();
    }, this.handleKeyDownOnSingleInput = (l, u) => {
      const c = [...this.getState("valueList")];
      l.key === "Backspace" ? (c[u] = "", this.updateValueList(c), this._adapter.changeSpecificInputFocusState(Math.max(0, u - 1), "focus"), l.preventDefault()) : l.key === "Delete" ? (c[u] = "", this.updateValueList(c), this._adapter.changeSpecificInputFocusState(Math.min(c.length - 1, u + 1), "focus"), l.preventDefault()) : l.key === "ArrowLeft" ? (this._adapter.changeSpecificInputFocusState(Math.max(0, u - 1), "focus"), l.preventDefault()) : l.key === "ArrowRight" && (this._adapter.changeSpecificInputFocusState(Math.min(c.length - 1, u + 1), "focus"), l.preventDefault());
    };
  }
};
Lf.numberReg = /^\d*$/, Lf.mixedReg = /^[0-9a-zA-Z]$/;
let PinCodeFoundation = Lf;
const cssClasses$3 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-pincode`
}, propTypes$3 = {
  className: string$3,
  style: object$1,
  size: string$3,
  disabled: bool,
  value: string$3,
  format: node$1,
  onChange: {
    type: func,
    required: !0
  },
  defaultValue: string$3,
  count: number$2,
  autoFocus: bool,
  onComplete: func
}, defaultProps$3 = {
  count: 6,
  format: "number",
  autoFocus: !0
}, vuePropsType$3 = vuePropsMake(propTypes$3, defaultProps$3), PinCode = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$3
  },
  name: "PinCode",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    let l = [];
    const u = reactive({
      valueList: (s.value || s.defaultValue) && (s.value || s.defaultValue).split("") || [],
      currentActiveIndex: 0
    }), {
      adapter: c,
      setStateAsync: m
    } = useBaseComponent(s, u);
    watch([() => s.value], () => {
      b.updateValueList(s.value.split(""));
    });
    function g() {
      return {
        ...c(),
        onCurrentActiveIndexChange: async (E) => {
          await m({
            currentActiveIndex: E
          });
        },
        notifyValueChange: (E) => {
          var P;
          (P = s.onChange) == null || P.call(s, E.join(""));
        },
        changeSpecificInputFocusState: (E, P) => {
          var T, N, O, z;
          P === "focus" ? (N = (T = l[E]) == null ? void 0 : T.focus) == null || N.call(T) : P === "blur" && ((z = (O = l[E]) == null ? void 0 : O.blur) == null || z.call(O));
        },
        updateValueList: async (E) => {
          await m({
            valueList: E
          });
        }
      };
    }
    const v = g(), b = new PinCodeFoundation(v), S = (E) => createVNode(Input$1, {
      forwardRef: (P) => l[E] = P,
      key: `input-${E}`,
      "data-testid": "pin-code-input",
      autoFocus: s.autoFocus && E === 0,
      value: u.valueList[E],
      size: s.size,
      disabled: s.disabled,
      onBlur: () => b.handleCurrentActiveIndexChange(E, "blur"),
      onFocus: () => b.handleCurrentActiveIndexChange(E, "focus"),
      onPaste: (P) => b.handlePaste(P, E),
      onKeyDown: (P) => {
        b.handleKeyDownOnSingleInput(P, E);
      },
      onChange: (P) => {
        const T = P[P.length - 1];
        b.validateValue(T) && b.completeSingleInput(E, T);
      }
    }, null);
    return () => {
      const E = [];
      for (let P = 0; P < s.count; P++)
        E.push(S(P));
      return createVNode("div", {
        class: cls(`${cssClasses$3.PREFIX}-wrapper`, s.className),
        style: s.style
      }, [E]);
    };
  }
}), PinCode$1 = PinCode;
var lottie$1 = { exports: {} };
(function(module, exports) {
  typeof navigator < "u" && function(s, o) {
    module.exports = o();
  }(commonjsGlobal, function() {
    var svgNS = "http://www.w3.org/2000/svg", locationHref = "", _useWebWorker = !1, initialDefaultFrame = -999999, setWebWorker = function(o) {
      _useWebWorker = !!o;
    }, getWebWorker = function() {
      return _useWebWorker;
    }, setLocationHref = function(o) {
      locationHref = o;
    }, getLocationHref = function() {
      return locationHref;
    };
    function createTag(s) {
      return document.createElement(s);
    }
    function extendPrototype(s, o) {
      var l, u = s.length, c;
      for (l = 0; l < u; l += 1) {
        c = s[l].prototype;
        for (var m in c)
          Object.prototype.hasOwnProperty.call(c, m) && (o.prototype[m] = c[m]);
      }
    }
    function getDescriptor(s, o) {
      return Object.getOwnPropertyDescriptor(s, o);
    }
    function createProxyFunction(s) {
      function o() {
      }
      return o.prototype = s, o;
    }
    var audioControllerFactory = function() {
      function s(o) {
        this.audios = [], this.audioFactory = o, this._volume = 1, this._isMuted = !1;
      }
      return s.prototype = {
        addAudio: function(l) {
          this.audios.push(l);
        },
        pause: function() {
          var l, u = this.audios.length;
          for (l = 0; l < u; l += 1)
            this.audios[l].pause();
        },
        resume: function() {
          var l, u = this.audios.length;
          for (l = 0; l < u; l += 1)
            this.audios[l].resume();
        },
        setRate: function(l) {
          var u, c = this.audios.length;
          for (u = 0; u < c; u += 1)
            this.audios[u].setRate(l);
        },
        createAudio: function(l) {
          return this.audioFactory ? this.audioFactory(l) : window.Howl ? new window.Howl({
            src: [l]
          }) : {
            isPlaying: !1,
            play: function() {
              this.isPlaying = !0;
            },
            seek: function() {
              this.isPlaying = !1;
            },
            playing: function() {
            },
            rate: function() {
            },
            setVolume: function() {
            }
          };
        },
        setAudioFactory: function(l) {
          this.audioFactory = l;
        },
        setVolume: function(l) {
          this._volume = l, this._updateVolume();
        },
        mute: function() {
          this._isMuted = !0, this._updateVolume();
        },
        unmute: function() {
          this._isMuted = !1, this._updateVolume();
        },
        getVolume: function() {
          return this._volume;
        },
        _updateVolume: function() {
          var l, u = this.audios.length;
          for (l = 0; l < u; l += 1)
            this.audios[l].volume(this._volume * (this._isMuted ? 0 : 1));
        }
      }, function() {
        return new s();
      };
    }(), createTypedArray = /* @__PURE__ */ function() {
      function s(l, u) {
        var c = 0, m = [], g;
        switch (l) {
          case "int16":
          case "uint8c":
            g = 1;
            break;
          default:
            g = 1.1;
            break;
        }
        for (c = 0; c < u; c += 1)
          m.push(g);
        return m;
      }
      function o(l, u) {
        return l === "float32" ? new Float32Array(u) : l === "int16" ? new Int16Array(u) : l === "uint8c" ? new Uint8ClampedArray(u) : s(l, u);
      }
      return typeof Uint8ClampedArray == "function" && typeof Float32Array == "function" ? o : s;
    }();
    function createSizedArray(s) {
      return Array.apply(null, {
        length: s
      });
    }
    function _typeof$6(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$6 = function(l) {
        return typeof l;
      } : _typeof$6 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$6(s);
    }
    var subframeEnabled = !0, expressionsPlugin = null, expressionsInterfaces = null, idPrefix$1 = "", isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), bmPow = Math.pow, bmSqrt = Math.sqrt, bmFloor = Math.floor, bmMax = Math.max, bmMin = Math.min, BMMath = {};
    (function() {
      var s = ["abs", "acos", "acosh", "asin", "asinh", "atan", "atanh", "atan2", "ceil", "cbrt", "expm1", "clz32", "cos", "cosh", "exp", "floor", "fround", "hypot", "imul", "log", "log1p", "log2", "log10", "max", "min", "pow", "random", "round", "sign", "sin", "sinh", "sqrt", "tan", "tanh", "trunc", "E", "LN10", "LN2", "LOG10E", "LOG2E", "PI", "SQRT1_2", "SQRT2"], o, l = s.length;
      for (o = 0; o < l; o += 1)
        BMMath[s[o]] = Math[s[o]];
    })(), BMMath.random = Math.random, BMMath.abs = function(s) {
      var o = _typeof$6(s);
      if (o === "object" && s.length) {
        var l = createSizedArray(s.length), u, c = s.length;
        for (u = 0; u < c; u += 1)
          l[u] = Math.abs(s[u]);
        return l;
      }
      return Math.abs(s);
    };
    var defaultCurveSegments = 150, degToRads = Math.PI / 180, roundCorner = 0.5519;
    function styleDiv(s) {
      s.style.position = "absolute", s.style.top = 0, s.style.left = 0, s.style.display = "block", s.style.transformOrigin = "0 0", s.style.webkitTransformOrigin = "0 0", s.style.backfaceVisibility = "visible", s.style.webkitBackfaceVisibility = "visible", s.style.transformStyle = "preserve-3d", s.style.webkitTransformStyle = "preserve-3d", s.style.mozTransformStyle = "preserve-3d";
    }
    function BMEnterFrameEvent(s, o, l, u) {
      this.type = s, this.currentTime = o, this.totalTime = l, this.direction = u < 0 ? -1 : 1;
    }
    function BMCompleteEvent(s, o) {
      this.type = s, this.direction = o < 0 ? -1 : 1;
    }
    function BMCompleteLoopEvent(s, o, l, u) {
      this.type = s, this.currentLoop = l, this.totalLoops = o, this.direction = u < 0 ? -1 : 1;
    }
    function BMSegmentStartEvent(s, o, l) {
      this.type = s, this.firstFrame = o, this.totalFrames = l;
    }
    function BMDestroyEvent(s, o) {
      this.type = s, this.target = o;
    }
    function BMRenderFrameErrorEvent(s, o) {
      this.type = "renderFrameError", this.nativeError = s, this.currentTime = o;
    }
    function BMConfigErrorEvent(s) {
      this.type = "configError", this.nativeError = s;
    }
    var createElementID = /* @__PURE__ */ function() {
      var s = 0;
      return function() {
        return s += 1, idPrefix$1 + "__lottie_element_" + s;
      };
    }();
    function HSVtoRGB(s, o, l) {
      var u, c, m, g, v, b, S, E;
      switch (g = Math.floor(s * 6), v = s * 6 - g, b = l * (1 - o), S = l * (1 - v * o), E = l * (1 - (1 - v) * o), g % 6) {
        case 0:
          u = l, c = E, m = b;
          break;
        case 1:
          u = S, c = l, m = b;
          break;
        case 2:
          u = b, c = l, m = E;
          break;
        case 3:
          u = b, c = S, m = l;
          break;
        case 4:
          u = E, c = b, m = l;
          break;
        case 5:
          u = l, c = b, m = S;
          break;
      }
      return [u, c, m];
    }
    function RGBtoHSV(s, o, l) {
      var u = Math.max(s, o, l), c = Math.min(s, o, l), m = u - c, g, v = u === 0 ? 0 : m / u, b = u / 255;
      switch (u) {
        case c:
          g = 0;
          break;
        case s:
          g = o - l + m * (o < l ? 6 : 0), g /= 6 * m;
          break;
        case o:
          g = l - s + m * 2, g /= 6 * m;
          break;
        case l:
          g = s - o + m * 4, g /= 6 * m;
          break;
      }
      return [g, v, b];
    }
    function addSaturationToRGB(s, o) {
      var l = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
      return l[1] += o, l[1] > 1 ? l[1] = 1 : l[1] <= 0 && (l[1] = 0), HSVtoRGB(l[0], l[1], l[2]);
    }
    function addBrightnessToRGB(s, o) {
      var l = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
      return l[2] += o, l[2] > 1 ? l[2] = 1 : l[2] < 0 && (l[2] = 0), HSVtoRGB(l[0], l[1], l[2]);
    }
    function addHueToRGB(s, o) {
      var l = RGBtoHSV(s[0] * 255, s[1] * 255, s[2] * 255);
      return l[0] += o / 360, l[0] > 1 ? l[0] -= 1 : l[0] < 0 && (l[0] += 1), HSVtoRGB(l[0], l[1], l[2]);
    }
    var rgbToHex = function() {
      var s = [], o, l;
      for (o = 0; o < 256; o += 1)
        l = o.toString(16), s[o] = l.length === 1 ? "0" + l : l;
      return function(u, c, m) {
        return u < 0 && (u = 0), c < 0 && (c = 0), m < 0 && (m = 0), "#" + s[u] + s[c] + s[m];
      };
    }(), setSubframeEnabled = function(o) {
      subframeEnabled = !!o;
    }, getSubframeEnabled = function() {
      return subframeEnabled;
    }, setExpressionsPlugin = function(o) {
      expressionsPlugin = o;
    }, getExpressionsPlugin = function() {
      return expressionsPlugin;
    }, setExpressionInterfaces = function(o) {
      expressionsInterfaces = o;
    }, getExpressionInterfaces = function() {
      return expressionsInterfaces;
    }, setDefaultCurveSegments = function(o) {
      defaultCurveSegments = o;
    }, getDefaultCurveSegments = function() {
      return defaultCurveSegments;
    }, setIdPrefix = function(o) {
      idPrefix$1 = o;
    };
    function createNS(s) {
      return document.createElementNS(svgNS, s);
    }
    function _typeof$5(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$5 = function(l) {
        return typeof l;
      } : _typeof$5 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$5(s);
    }
    var dataManager = /* @__PURE__ */ function() {
      var s = 1, o = [], l, u, c = {
        onmessage: function() {
        },
        postMessage: function(N) {
          l({
            data: N
          });
        }
      }, m = {
        postMessage: function(N) {
          c.onmessage({
            data: N
          });
        }
      };
      function g(T) {
        if (window.Worker && window.Blob && getWebWorker()) {
          var N = new Blob(["var _workerSelf = self; self.onmessage = ", T.toString()], {
            type: "text/javascript"
          }), O = URL.createObjectURL(N);
          return new Worker(O);
        }
        return l = T, c;
      }
      function v() {
        u || (u = g(function(N) {
          function O() {
            function Q(an, Gt) {
              var nn, vt, Et = an.length, Qt, un, gn, dn;
              for (vt = 0; vt < Et; vt += 1)
                if (nn = an[vt], "ks" in nn && !nn.completed) {
                  if (nn.completed = !0, nn.hasMask) {
                    var yn = nn.masksProperties;
                    for (un = yn.length, Qt = 0; Qt < un; Qt += 1)
                      if (yn[Qt].pt.k.i)
                        ve(yn[Qt].pt.k);
                      else
                        for (dn = yn[Qt].pt.k.length, gn = 0; gn < dn; gn += 1)
                          yn[Qt].pt.k[gn].s && ve(yn[Qt].pt.k[gn].s[0]), yn[Qt].pt.k[gn].e && ve(yn[Qt].pt.k[gn].e[0]);
                  }
                  nn.ty === 0 ? (nn.layers = te(nn.refId, Gt), Q(nn.layers, Gt)) : nn.ty === 4 ? K(nn.shapes) : nn.ty === 5 && ln(nn);
                }
            }
            function W(an, Gt) {
              if (an) {
                var nn = 0, vt = an.length;
                for (nn = 0; nn < vt; nn += 1)
                  an[nn].t === 1 && (an[nn].data.layers = te(an[nn].data.refId, Gt), Q(an[nn].data.layers, Gt));
              }
            }
            function ue(an, Gt) {
              for (var nn = 0, vt = Gt.length; nn < vt; ) {
                if (Gt[nn].id === an)
                  return Gt[nn];
                nn += 1;
              }
              return null;
            }
            function te(an, Gt) {
              var nn = ue(an, Gt);
              return nn ? nn.layers.__used ? JSON.parse(JSON.stringify(nn.layers)) : (nn.layers.__used = !0, nn.layers) : null;
            }
            function K(an) {
              var Gt, nn = an.length, vt, Et;
              for (Gt = nn - 1; Gt >= 0; Gt -= 1)
                if (an[Gt].ty === "sh")
                  if (an[Gt].ks.k.i)
                    ve(an[Gt].ks.k);
                  else
                    for (Et = an[Gt].ks.k.length, vt = 0; vt < Et; vt += 1)
                      an[Gt].ks.k[vt].s && ve(an[Gt].ks.k[vt].s[0]), an[Gt].ks.k[vt].e && ve(an[Gt].ks.k[vt].e[0]);
                else an[Gt].ty === "gr" && K(an[Gt].it);
            }
            function ve(an) {
              var Gt, nn = an.i.length;
              for (Gt = 0; Gt < nn; Gt += 1)
                an.i[Gt][0] += an.v[Gt][0], an.i[Gt][1] += an.v[Gt][1], an.o[Gt][0] += an.v[Gt][0], an.o[Gt][1] += an.v[Gt][1];
            }
            function ee(an, Gt) {
              var nn = Gt ? Gt.split(".") : [100, 100, 100];
              return an[0] > nn[0] ? !0 : nn[0] > an[0] ? !1 : an[1] > nn[1] ? !0 : nn[1] > an[1] ? !1 : an[2] > nn[2] ? !0 : nn[2] > an[2] ? !1 : null;
            }
            var Re = /* @__PURE__ */ function() {
              var an = [4, 4, 14];
              function Gt(vt) {
                var Et = vt.t.d;
                vt.t.d = {
                  k: [{
                    s: Et,
                    t: 0
                  }]
                };
              }
              function nn(vt) {
                var Et, Qt = vt.length;
                for (Et = 0; Et < Qt; Et += 1)
                  vt[Et].ty === 5 && Gt(vt[Et]);
              }
              return function(vt) {
                if (ee(an, vt.v) && (nn(vt.layers), vt.assets)) {
                  var Et, Qt = vt.assets.length;
                  for (Et = 0; Et < Qt; Et += 1)
                    vt.assets[Et].layers && nn(vt.assets[Et].layers);
                }
              };
            }(), wt = /* @__PURE__ */ function() {
              var an = [4, 7, 99];
              return function(Gt) {
                if (Gt.chars && !ee(an, Gt.v)) {
                  var nn, vt = Gt.chars.length;
                  for (nn = 0; nn < vt; nn += 1) {
                    var Et = Gt.chars[nn];
                    Et.data && Et.data.shapes && (K(Et.data.shapes), Et.data.ip = 0, Et.data.op = 99999, Et.data.st = 0, Et.data.sr = 1, Et.data.ks = {
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      }
                    }, Gt.chars[nn].t || (Et.data.shapes.push({
                      ty: "no"
                    }), Et.data.shapes[0].it.push({
                      p: {
                        k: [0, 0],
                        a: 0
                      },
                      s: {
                        k: [100, 100],
                        a: 0
                      },
                      a: {
                        k: [0, 0],
                        a: 0
                      },
                      r: {
                        k: 0,
                        a: 0
                      },
                      o: {
                        k: 100,
                        a: 0
                      },
                      sk: {
                        k: 0,
                        a: 0
                      },
                      sa: {
                        k: 0,
                        a: 0
                      },
                      ty: "tr"
                    })));
                  }
                }
              };
            }(), yt = /* @__PURE__ */ function() {
              var an = [5, 7, 15];
              function Gt(vt) {
                var Et = vt.t.p;
                typeof Et.a == "number" && (Et.a = {
                  a: 0,
                  k: Et.a
                }), typeof Et.p == "number" && (Et.p = {
                  a: 0,
                  k: Et.p
                }), typeof Et.r == "number" && (Et.r = {
                  a: 0,
                  k: Et.r
                });
              }
              function nn(vt) {
                var Et, Qt = vt.length;
                for (Et = 0; Et < Qt; Et += 1)
                  vt[Et].ty === 5 && Gt(vt[Et]);
              }
              return function(vt) {
                if (ee(an, vt.v) && (nn(vt.layers), vt.assets)) {
                  var Et, Qt = vt.assets.length;
                  for (Et = 0; Et < Qt; Et += 1)
                    vt.assets[Et].layers && nn(vt.assets[Et].layers);
                }
              };
            }(), xt = /* @__PURE__ */ function() {
              var an = [4, 1, 9];
              function Gt(vt) {
                var Et, Qt = vt.length, un, gn;
                for (Et = 0; Et < Qt; Et += 1)
                  if (vt[Et].ty === "gr")
                    Gt(vt[Et].it);
                  else if (vt[Et].ty === "fl" || vt[Et].ty === "st")
                    if (vt[Et].c.k && vt[Et].c.k[0].i)
                      for (gn = vt[Et].c.k.length, un = 0; un < gn; un += 1)
                        vt[Et].c.k[un].s && (vt[Et].c.k[un].s[0] /= 255, vt[Et].c.k[un].s[1] /= 255, vt[Et].c.k[un].s[2] /= 255, vt[Et].c.k[un].s[3] /= 255), vt[Et].c.k[un].e && (vt[Et].c.k[un].e[0] /= 255, vt[Et].c.k[un].e[1] /= 255, vt[Et].c.k[un].e[2] /= 255, vt[Et].c.k[un].e[3] /= 255);
                    else
                      vt[Et].c.k[0] /= 255, vt[Et].c.k[1] /= 255, vt[Et].c.k[2] /= 255, vt[Et].c.k[3] /= 255;
              }
              function nn(vt) {
                var Et, Qt = vt.length;
                for (Et = 0; Et < Qt; Et += 1)
                  vt[Et].ty === 4 && Gt(vt[Et].shapes);
              }
              return function(vt) {
                if (ee(an, vt.v) && (nn(vt.layers), vt.assets)) {
                  var Et, Qt = vt.assets.length;
                  for (Et = 0; Et < Qt; Et += 1)
                    vt.assets[Et].layers && nn(vt.assets[Et].layers);
                }
              };
            }(), Kt = /* @__PURE__ */ function() {
              var an = [4, 4, 18];
              function Gt(vt) {
                var Et, Qt = vt.length, un, gn;
                for (Et = Qt - 1; Et >= 0; Et -= 1)
                  if (vt[Et].ty === "sh")
                    if (vt[Et].ks.k.i)
                      vt[Et].ks.k.c = vt[Et].closed;
                    else
                      for (gn = vt[Et].ks.k.length, un = 0; un < gn; un += 1)
                        vt[Et].ks.k[un].s && (vt[Et].ks.k[un].s[0].c = vt[Et].closed), vt[Et].ks.k[un].e && (vt[Et].ks.k[un].e[0].c = vt[Et].closed);
                  else vt[Et].ty === "gr" && Gt(vt[Et].it);
              }
              function nn(vt) {
                var Et, Qt, un = vt.length, gn, dn, yn, vn;
                for (Qt = 0; Qt < un; Qt += 1) {
                  if (Et = vt[Qt], Et.hasMask) {
                    var Pn = Et.masksProperties;
                    for (dn = Pn.length, gn = 0; gn < dn; gn += 1)
                      if (Pn[gn].pt.k.i)
                        Pn[gn].pt.k.c = Pn[gn].cl;
                      else
                        for (vn = Pn[gn].pt.k.length, yn = 0; yn < vn; yn += 1)
                          Pn[gn].pt.k[yn].s && (Pn[gn].pt.k[yn].s[0].c = Pn[gn].cl), Pn[gn].pt.k[yn].e && (Pn[gn].pt.k[yn].e[0].c = Pn[gn].cl);
                  }
                  Et.ty === 4 && Gt(Et.shapes);
                }
              }
              return function(vt) {
                if (ee(an, vt.v) && (nn(vt.layers), vt.assets)) {
                  var Et, Qt = vt.assets.length;
                  for (Et = 0; Et < Qt; Et += 1)
                    vt.assets[Et].layers && nn(vt.assets[Et].layers);
                }
              };
            }();
            function tn(an) {
              an.__complete || (xt(an), Re(an), wt(an), yt(an), Kt(an), Q(an.layers, an.assets), W(an.chars, an.assets), an.__complete = !0);
            }
            function ln(an) {
              an.t.a.length === 0 && "m" in an.t.p;
            }
            var rn = {};
            return rn.completeData = tn, rn.checkColors = xt, rn.checkChars = wt, rn.checkPathProperties = yt, rn.checkShapes = Kt, rn.completeLayers = Q, rn;
          }
          if (m.dataManager || (m.dataManager = O()), m.assetLoader || (m.assetLoader = /* @__PURE__ */ function() {
            function Q(ue) {
              var te = ue.getResponseHeader("content-type");
              return te && ue.responseType === "json" && te.indexOf("json") !== -1 || ue.response && _typeof$5(ue.response) === "object" ? ue.response : ue.response && typeof ue.response == "string" ? JSON.parse(ue.response) : ue.responseText ? JSON.parse(ue.responseText) : null;
            }
            function W(ue, te, K, ve) {
              var ee, Re = new XMLHttpRequest();
              try {
                Re.responseType = "json";
              } catch {
              }
              Re.onreadystatechange = function() {
                if (Re.readyState === 4)
                  if (Re.status === 200)
                    ee = Q(Re), K(ee);
                  else
                    try {
                      ee = Q(Re), K(ee);
                    } catch (wt) {
                      ve && ve(wt);
                    }
              };
              try {
                Re.open(["G", "E", "T"].join(""), ue, !0);
              } catch {
                Re.open(["G", "E", "T"].join(""), te + "/" + ue, !0);
              }
              Re.send();
            }
            return {
              load: W
            };
          }()), N.data.type === "loadAnimation")
            m.assetLoader.load(N.data.path, N.data.fullPath, function(Q) {
              m.dataManager.completeData(Q), m.postMessage({
                id: N.data.id,
                payload: Q,
                status: "success"
              });
            }, function() {
              m.postMessage({
                id: N.data.id,
                status: "error"
              });
            });
          else if (N.data.type === "complete") {
            var z = N.data.animation;
            m.dataManager.completeData(z), m.postMessage({
              id: N.data.id,
              payload: z,
              status: "success"
            });
          } else N.data.type === "loadData" && m.assetLoader.load(N.data.path, N.data.fullPath, function(Q) {
            m.postMessage({
              id: N.data.id,
              payload: Q,
              status: "success"
            });
          }, function() {
            m.postMessage({
              id: N.data.id,
              status: "error"
            });
          });
        }), u.onmessage = function(T) {
          var N = T.data, O = N.id, z = o[O];
          o[O] = null, N.status === "success" ? z.onComplete(N.payload) : z.onError && z.onError();
        });
      }
      function b(T, N) {
        s += 1;
        var O = "processId_" + s;
        return o[O] = {
          onComplete: T,
          onError: N
        }, O;
      }
      function S(T, N, O) {
        v();
        var z = b(N, O);
        u.postMessage({
          type: "loadAnimation",
          path: T,
          fullPath: window.location.origin + window.location.pathname,
          id: z
        });
      }
      function E(T, N, O) {
        v();
        var z = b(N, O);
        u.postMessage({
          type: "loadData",
          path: T,
          fullPath: window.location.origin + window.location.pathname,
          id: z
        });
      }
      function P(T, N, O) {
        v();
        var z = b(N, O);
        u.postMessage({
          type: "complete",
          animation: T,
          id: z
        });
      }
      return {
        loadAnimation: S,
        loadData: E,
        completeAnimation: P
      };
    }(), ImagePreloader = function() {
      var s = function() {
        var W = createTag("canvas");
        W.width = 1, W.height = 1;
        var ue = W.getContext("2d");
        return ue.fillStyle = "rgba(0,0,0,0)", ue.fillRect(0, 0, 1, 1), W;
      }();
      function o() {
        this.loadedAssets += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function l() {
        this.loadedFootagesCount += 1, this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages && this.imagesLoadedCb && this.imagesLoadedCb(null);
      }
      function u(W, ue, te) {
        var K = "";
        if (W.e)
          K = W.p;
        else if (ue) {
          var ve = W.p;
          ve.indexOf("images/") !== -1 && (ve = ve.split("/")[1]), K = ue + ve;
        } else
          K = te, K += W.u ? W.u : "", K += W.p;
        return K;
      }
      function c(W) {
        var ue = 0, te = setInterval((function() {
          var K = W.getBBox();
          (K.width || ue > 500) && (this._imageLoaded(), clearInterval(te)), ue += 1;
        }).bind(this), 50);
      }
      function m(W) {
        var ue = u(W, this.assetsPath, this.path), te = createNS("image");
        isSafari ? this.testImageLoaded(te) : te.addEventListener("load", this._imageLoaded, !1), te.addEventListener("error", (function() {
          K.img = s, this._imageLoaded();
        }).bind(this), !1), te.setAttributeNS("http://www.w3.org/1999/xlink", "href", ue), this._elementHelper.append ? this._elementHelper.append(te) : this._elementHelper.appendChild(te);
        var K = {
          img: te,
          assetData: W
        };
        return K;
      }
      function g(W) {
        var ue = u(W, this.assetsPath, this.path), te = createTag("img");
        te.crossOrigin = "anonymous", te.addEventListener("load", this._imageLoaded, !1), te.addEventListener("error", (function() {
          K.img = s, this._imageLoaded();
        }).bind(this), !1), te.src = ue;
        var K = {
          img: te,
          assetData: W
        };
        return K;
      }
      function v(W) {
        var ue = {
          assetData: W
        }, te = u(W, this.assetsPath, this.path);
        return dataManager.loadData(te, (function(K) {
          ue.img = K, this._footageLoaded();
        }).bind(this), (function() {
          ue.img = {}, this._footageLoaded();
        }).bind(this)), ue;
      }
      function b(W, ue) {
        this.imagesLoadedCb = ue;
        var te, K = W.length;
        for (te = 0; te < K; te += 1)
          W[te].layers || (!W[te].t || W[te].t === "seq" ? (this.totalImages += 1, this.images.push(this._createImageData(W[te]))) : W[te].t === 3 && (this.totalFootages += 1, this.images.push(this.createFootageData(W[te]))));
      }
      function S(W) {
        this.path = W || "";
      }
      function E(W) {
        this.assetsPath = W || "";
      }
      function P(W) {
        for (var ue = 0, te = this.images.length; ue < te; ) {
          if (this.images[ue].assetData === W)
            return this.images[ue].img;
          ue += 1;
        }
        return null;
      }
      function T() {
        this.imagesLoadedCb = null, this.images.length = 0;
      }
      function N() {
        return this.totalImages === this.loadedAssets;
      }
      function O() {
        return this.totalFootages === this.loadedFootagesCount;
      }
      function z(W, ue) {
        W === "svg" ? (this._elementHelper = ue, this._createImageData = this.createImageData.bind(this)) : this._createImageData = this.createImgData.bind(this);
      }
      function Q() {
        this._imageLoaded = o.bind(this), this._footageLoaded = l.bind(this), this.testImageLoaded = c.bind(this), this.createFootageData = v.bind(this), this.assetsPath = "", this.path = "", this.totalImages = 0, this.totalFootages = 0, this.loadedAssets = 0, this.loadedFootagesCount = 0, this.imagesLoadedCb = null, this.images = [];
      }
      return Q.prototype = {
        loadAssets: b,
        setAssetsPath: E,
        setPath: S,
        loadedImages: N,
        loadedFootages: O,
        destroy: T,
        getAsset: P,
        createImgData: g,
        createImageData: m,
        imageLoaded: o,
        footageLoaded: l,
        setCacheType: z
      }, Q;
    }();
    function BaseEvent() {
    }
    BaseEvent.prototype = {
      triggerEvent: function(o, l) {
        if (this._cbs[o])
          for (var u = this._cbs[o], c = 0; c < u.length; c += 1)
            u[c](l);
      },
      addEventListener: function(o, l) {
        return this._cbs[o] || (this._cbs[o] = []), this._cbs[o].push(l), (function() {
          this.removeEventListener(o, l);
        }).bind(this);
      },
      removeEventListener: function(o, l) {
        if (!l)
          this._cbs[o] = null;
        else if (this._cbs[o]) {
          for (var u = 0, c = this._cbs[o].length; u < c; )
            this._cbs[o][u] === l && (this._cbs[o].splice(u, 1), u -= 1, c -= 1), u += 1;
          this._cbs[o].length || (this._cbs[o] = null);
        }
      }
    };
    var markerParser = /* @__PURE__ */ function() {
      function s(o) {
        for (var l = o.split(`\r
`), u = {}, c, m = 0, g = 0; g < l.length; g += 1)
          c = l[g].split(":"), c.length === 2 && (u[c[0]] = c[1].trim(), m += 1);
        if (m === 0)
          throw new Error();
        return u;
      }
      return function(o) {
        for (var l = [], u = 0; u < o.length; u += 1) {
          var c = o[u], m = {
            time: c.tm,
            duration: c.dr
          };
          try {
            m.payload = JSON.parse(o[u].cm);
          } catch {
            try {
              m.payload = s(o[u].cm);
            } catch {
              m.payload = {
                name: o[u].cm
              };
            }
          }
          l.push(m);
        }
        return l;
      };
    }(), ProjectInterface = /* @__PURE__ */ function() {
      function s(o) {
        this.compositions.push(o);
      }
      return function() {
        function o(l) {
          for (var u = 0, c = this.compositions.length; u < c; ) {
            if (this.compositions[u].data && this.compositions[u].data.nm === l)
              return this.compositions[u].prepareFrame && this.compositions[u].data.xt && this.compositions[u].prepareFrame(this.currentFrame), this.compositions[u].compInterface;
            u += 1;
          }
          return null;
        }
        return o.compositions = [], o.currentFrame = 0, o.registerComposition = s, o;
      };
    }(), renderers = {}, registerRenderer = function(o, l) {
      renderers[o] = l;
    };
    function getRenderer(s) {
      return renderers[s];
    }
    function getRegisteredRenderer() {
      if (renderers.canvas)
        return "canvas";
      for (var s in renderers)
        if (renderers[s])
          return s;
      return "";
    }
    function _typeof$4(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$4 = function(l) {
        return typeof l;
      } : _typeof$4 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$4(s);
    }
    var AnimationItem = function() {
      this._cbs = [], this.name = "", this.path = "", this.isLoaded = !1, this.currentFrame = 0, this.currentRawFrame = 0, this.firstFrame = 0, this.totalFrames = 0, this.frameRate = 0, this.frameMult = 0, this.playSpeed = 1, this.playDirection = 1, this.playCount = 0, this.animationData = {}, this.assets = [], this.isPaused = !0, this.autoplay = !1, this.loop = !0, this.renderer = null, this.animationID = createElementID(), this.assetsPath = "", this.timeCompleted = 0, this.segmentPos = 0, this.isSubframeEnabled = getSubframeEnabled(), this.segments = [], this._idle = !0, this._completedLoop = !1, this.projectInterface = ProjectInterface(), this.imagePreloader = new ImagePreloader(), this.audioController = audioControllerFactory(), this.markers = [], this.configAnimation = this.configAnimation.bind(this), this.onSetupError = this.onSetupError.bind(this), this.onSegmentComplete = this.onSegmentComplete.bind(this), this.drawnFrameEvent = new BMEnterFrameEvent("drawnFrame", 0, 0, 0), this.expressionsPlugin = getExpressionsPlugin();
    };
    extendPrototype([BaseEvent], AnimationItem), AnimationItem.prototype.setParams = function(s) {
      (s.wrapper || s.container) && (this.wrapper = s.wrapper || s.container);
      var o = "svg";
      s.animType ? o = s.animType : s.renderer && (o = s.renderer);
      var l = getRenderer(o);
      this.renderer = new l(this, s.rendererSettings), this.imagePreloader.setCacheType(o, this.renderer.globalData.defs), this.renderer.setProjectInterface(this.projectInterface), this.animType = o, s.loop === "" || s.loop === null || s.loop === void 0 || s.loop === !0 ? this.loop = !0 : s.loop === !1 ? this.loop = !1 : this.loop = parseInt(s.loop, 10), this.autoplay = "autoplay" in s ? s.autoplay : !0, this.name = s.name ? s.name : "", this.autoloadSegments = Object.prototype.hasOwnProperty.call(s, "autoloadSegments") ? s.autoloadSegments : !0, this.assetsPath = s.assetsPath, this.initialSegment = s.initialSegment, s.audioFactory && this.audioController.setAudioFactory(s.audioFactory), s.animationData ? this.setupAnimation(s.animationData) : s.path && (s.path.lastIndexOf("\\") !== -1 ? this.path = s.path.substr(0, s.path.lastIndexOf("\\") + 1) : this.path = s.path.substr(0, s.path.lastIndexOf("/") + 1), this.fileName = s.path.substr(s.path.lastIndexOf("/") + 1), this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf(".json")), dataManager.loadAnimation(s.path, this.configAnimation, this.onSetupError));
    }, AnimationItem.prototype.onSetupError = function() {
      this.trigger("data_failed");
    }, AnimationItem.prototype.setupAnimation = function(s) {
      dataManager.completeAnimation(s, this.configAnimation);
    }, AnimationItem.prototype.setData = function(s, o) {
      o && _typeof$4(o) !== "object" && (o = JSON.parse(o));
      var l = {
        wrapper: s,
        animationData: o
      }, u = s.attributes;
      l.path = u.getNamedItem("data-animation-path") ? u.getNamedItem("data-animation-path").value : u.getNamedItem("data-bm-path") ? u.getNamedItem("data-bm-path").value : u.getNamedItem("bm-path") ? u.getNamedItem("bm-path").value : "", l.animType = u.getNamedItem("data-anim-type") ? u.getNamedItem("data-anim-type").value : u.getNamedItem("data-bm-type") ? u.getNamedItem("data-bm-type").value : u.getNamedItem("bm-type") ? u.getNamedItem("bm-type").value : u.getNamedItem("data-bm-renderer") ? u.getNamedItem("data-bm-renderer").value : u.getNamedItem("bm-renderer") ? u.getNamedItem("bm-renderer").value : getRegisteredRenderer() || "canvas";
      var c = u.getNamedItem("data-anim-loop") ? u.getNamedItem("data-anim-loop").value : u.getNamedItem("data-bm-loop") ? u.getNamedItem("data-bm-loop").value : u.getNamedItem("bm-loop") ? u.getNamedItem("bm-loop").value : "";
      c === "false" ? l.loop = !1 : c === "true" ? l.loop = !0 : c !== "" && (l.loop = parseInt(c, 10));
      var m = u.getNamedItem("data-anim-autoplay") ? u.getNamedItem("data-anim-autoplay").value : u.getNamedItem("data-bm-autoplay") ? u.getNamedItem("data-bm-autoplay").value : u.getNamedItem("bm-autoplay") ? u.getNamedItem("bm-autoplay").value : !0;
      l.autoplay = m !== "false", l.name = u.getNamedItem("data-name") ? u.getNamedItem("data-name").value : u.getNamedItem("data-bm-name") ? u.getNamedItem("data-bm-name").value : u.getNamedItem("bm-name") ? u.getNamedItem("bm-name").value : "";
      var g = u.getNamedItem("data-anim-prerender") ? u.getNamedItem("data-anim-prerender").value : u.getNamedItem("data-bm-prerender") ? u.getNamedItem("data-bm-prerender").value : u.getNamedItem("bm-prerender") ? u.getNamedItem("bm-prerender").value : "";
      g === "false" && (l.prerender = !1), l.path ? this.setParams(l) : this.trigger("destroy");
    }, AnimationItem.prototype.includeLayers = function(s) {
      s.op > this.animationData.op && (this.animationData.op = s.op, this.totalFrames = Math.floor(s.op - this.animationData.ip));
      var o = this.animationData.layers, l, u = o.length, c = s.layers, m, g = c.length;
      for (m = 0; m < g; m += 1)
        for (l = 0; l < u; ) {
          if (o[l].id === c[m].id) {
            o[l] = c[m];
            break;
          }
          l += 1;
        }
      if ((s.chars || s.fonts) && (this.renderer.globalData.fontManager.addChars(s.chars), this.renderer.globalData.fontManager.addFonts(s.fonts, this.renderer.globalData.defs)), s.assets)
        for (u = s.assets.length, l = 0; l < u; l += 1)
          this.animationData.assets.push(s.assets[l]);
      this.animationData.__complete = !1, dataManager.completeAnimation(this.animationData, this.onSegmentComplete);
    }, AnimationItem.prototype.onSegmentComplete = function(s) {
      this.animationData = s;
      var o = getExpressionsPlugin();
      o && o.initExpressions(this), this.loadNextSegment();
    }, AnimationItem.prototype.loadNextSegment = function() {
      var s = this.animationData.segments;
      if (!s || s.length === 0 || !this.autoloadSegments) {
        this.trigger("data_ready"), this.timeCompleted = this.totalFrames;
        return;
      }
      var o = s.shift();
      this.timeCompleted = o.time * this.frameRate;
      var l = this.path + this.fileName + "_" + this.segmentPos + ".json";
      this.segmentPos += 1, dataManager.loadData(l, this.includeLayers.bind(this), (function() {
        this.trigger("data_failed");
      }).bind(this));
    }, AnimationItem.prototype.loadSegments = function() {
      var s = this.animationData.segments;
      s || (this.timeCompleted = this.totalFrames), this.loadNextSegment();
    }, AnimationItem.prototype.imagesLoaded = function() {
      this.trigger("loaded_images"), this.checkLoaded();
    }, AnimationItem.prototype.preloadImages = function() {
      this.imagePreloader.setAssetsPath(this.assetsPath), this.imagePreloader.setPath(this.path), this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));
    }, AnimationItem.prototype.configAnimation = function(s) {
      if (this.renderer)
        try {
          this.animationData = s, this.initialSegment ? (this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]), this.firstFrame = Math.round(this.initialSegment[0])) : (this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip), this.firstFrame = Math.round(this.animationData.ip)), this.renderer.configAnimation(s), s.assets || (s.assets = []), this.assets = this.animationData.assets, this.frameRate = this.animationData.fr, this.frameMult = this.animationData.fr / 1e3, this.renderer.searchExtraCompositions(s.assets), this.markers = markerParser(s.markers || []), this.trigger("config_ready"), this.preloadImages(), this.loadSegments(), this.updaFrameModifier(), this.waitForFontsLoaded(), this.isPaused && this.audioController.pause();
        } catch (o) {
          this.triggerConfigError(o);
        }
    }, AnimationItem.prototype.waitForFontsLoaded = function() {
      this.renderer && (this.renderer.globalData.fontManager.isLoaded ? this.checkLoaded() : setTimeout(this.waitForFontsLoaded.bind(this), 20));
    }, AnimationItem.prototype.checkLoaded = function() {
      if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== "canvas") && this.imagePreloader.loadedFootages()) {
        this.isLoaded = !0;
        var s = getExpressionsPlugin();
        s && s.initExpressions(this), this.renderer.initItems(), setTimeout((function() {
          this.trigger("DOMLoaded");
        }).bind(this), 0), this.gotoFrame(), this.autoplay && this.play();
      }
    }, AnimationItem.prototype.resize = function(s, o) {
      var l = typeof s == "number" ? s : void 0, u = typeof o == "number" ? o : void 0;
      this.renderer.updateContainerSize(l, u);
    }, AnimationItem.prototype.setSubframe = function(s) {
      this.isSubframeEnabled = !!s;
    }, AnimationItem.prototype.gotoFrame = function() {
      this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame, this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted && (this.currentFrame = this.timeCompleted), this.trigger("enterFrame"), this.renderFrame(), this.trigger("drawnFrame");
    }, AnimationItem.prototype.renderFrame = function() {
      if (!(this.isLoaded === !1 || !this.renderer))
        try {
          this.expressionsPlugin && this.expressionsPlugin.resetFrame(), this.renderer.renderFrame(this.currentFrame + this.firstFrame);
        } catch (s) {
          this.triggerRenderFrameError(s);
        }
    }, AnimationItem.prototype.play = function(s) {
      s && this.name !== s || this.isPaused === !0 && (this.isPaused = !1, this.trigger("_play"), this.audioController.resume(), this._idle && (this._idle = !1, this.trigger("_active")));
    }, AnimationItem.prototype.pause = function(s) {
      s && this.name !== s || this.isPaused === !1 && (this.isPaused = !0, this.trigger("_pause"), this._idle = !0, this.trigger("_idle"), this.audioController.pause());
    }, AnimationItem.prototype.togglePause = function(s) {
      s && this.name !== s || (this.isPaused === !0 ? this.play() : this.pause());
    }, AnimationItem.prototype.stop = function(s) {
      s && this.name !== s || (this.pause(), this.playCount = 0, this._completedLoop = !1, this.setCurrentRawFrameValue(0));
    }, AnimationItem.prototype.getMarkerData = function(s) {
      for (var o, l = 0; l < this.markers.length; l += 1)
        if (o = this.markers[l], o.payload && o.payload.name === s)
          return o;
      return null;
    }, AnimationItem.prototype.goToAndStop = function(s, o, l) {
      if (!(l && this.name !== l)) {
        var u = Number(s);
        if (isNaN(u)) {
          var c = this.getMarkerData(s);
          c && this.goToAndStop(c.time, !0);
        } else o ? this.setCurrentRawFrameValue(s) : this.setCurrentRawFrameValue(s * this.frameModifier);
        this.pause();
      }
    }, AnimationItem.prototype.goToAndPlay = function(s, o, l) {
      if (!(l && this.name !== l)) {
        var u = Number(s);
        if (isNaN(u)) {
          var c = this.getMarkerData(s);
          c && (c.duration ? this.playSegments([c.time, c.time + c.duration], !0) : this.goToAndStop(c.time, !0));
        } else
          this.goToAndStop(u, o, l);
        this.play();
      }
    }, AnimationItem.prototype.advanceTime = function(s) {
      if (!(this.isPaused === !0 || this.isLoaded === !1)) {
        var o = this.currentRawFrame + s * this.frameModifier, l = !1;
        o >= this.totalFrames - 1 && this.frameModifier > 0 ? !this.loop || this.playCount === this.loop ? this.checkSegments(o > this.totalFrames ? o % this.totalFrames : 0) || (l = !0, o = this.totalFrames - 1) : o >= this.totalFrames ? (this.playCount += 1, this.checkSegments(o % this.totalFrames) || (this.setCurrentRawFrameValue(o % this.totalFrames), this._completedLoop = !0, this.trigger("loopComplete"))) : this.setCurrentRawFrameValue(o) : o < 0 ? this.checkSegments(o % this.totalFrames) || (this.loop && !(this.playCount-- <= 0 && this.loop !== !0) ? (this.setCurrentRawFrameValue(this.totalFrames + o % this.totalFrames), this._completedLoop ? this.trigger("loopComplete") : this._completedLoop = !0) : (l = !0, o = 0)) : this.setCurrentRawFrameValue(o), l && (this.setCurrentRawFrameValue(o), this.pause(), this.trigger("complete"));
      }
    }, AnimationItem.prototype.adjustSegment = function(s, o) {
      this.playCount = 0, s[1] < s[0] ? (this.frameModifier > 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(-1)), this.totalFrames = s[0] - s[1], this.timeCompleted = this.totalFrames, this.firstFrame = s[1], this.setCurrentRawFrameValue(this.totalFrames - 1e-3 - o)) : s[1] > s[0] && (this.frameModifier < 0 && (this.playSpeed < 0 ? this.setSpeed(-this.playSpeed) : this.setDirection(1)), this.totalFrames = s[1] - s[0], this.timeCompleted = this.totalFrames, this.firstFrame = s[0], this.setCurrentRawFrameValue(1e-3 + o)), this.trigger("segmentStart");
    }, AnimationItem.prototype.setSegment = function(s, o) {
      var l = -1;
      this.isPaused && (this.currentRawFrame + this.firstFrame < s ? l = s : this.currentRawFrame + this.firstFrame > o && (l = o - s)), this.firstFrame = s, this.totalFrames = o - s, this.timeCompleted = this.totalFrames, l !== -1 && this.goToAndStop(l, !0);
    }, AnimationItem.prototype.playSegments = function(s, o) {
      if (o && (this.segments.length = 0), _typeof$4(s[0]) === "object") {
        var l, u = s.length;
        for (l = 0; l < u; l += 1)
          this.segments.push(s[l]);
      } else
        this.segments.push(s);
      this.segments.length && o && this.adjustSegment(this.segments.shift(), 0), this.isPaused && this.play();
    }, AnimationItem.prototype.resetSegments = function(s) {
      this.segments.length = 0, this.segments.push([this.animationData.ip, this.animationData.op]), s && this.checkSegments(0);
    }, AnimationItem.prototype.checkSegments = function(s) {
      return this.segments.length ? (this.adjustSegment(this.segments.shift(), s), !0) : !1;
    }, AnimationItem.prototype.destroy = function(s) {
      s && this.name !== s || !this.renderer || (this.renderer.destroy(), this.imagePreloader.destroy(), this.trigger("destroy"), this._cbs = null, this.onEnterFrame = null, this.onLoopComplete = null, this.onComplete = null, this.onSegmentStart = null, this.onDestroy = null, this.renderer = null, this.expressionsPlugin = null, this.imagePreloader = null, this.projectInterface = null);
    }, AnimationItem.prototype.setCurrentRawFrameValue = function(s) {
      this.currentRawFrame = s, this.gotoFrame();
    }, AnimationItem.prototype.setSpeed = function(s) {
      this.playSpeed = s, this.updaFrameModifier();
    }, AnimationItem.prototype.setDirection = function(s) {
      this.playDirection = s < 0 ? -1 : 1, this.updaFrameModifier();
    }, AnimationItem.prototype.setLoop = function(s) {
      this.loop = s;
    }, AnimationItem.prototype.setVolume = function(s, o) {
      o && this.name !== o || this.audioController.setVolume(s);
    }, AnimationItem.prototype.getVolume = function() {
      return this.audioController.getVolume();
    }, AnimationItem.prototype.mute = function(s) {
      s && this.name !== s || this.audioController.mute();
    }, AnimationItem.prototype.unmute = function(s) {
      s && this.name !== s || this.audioController.unmute();
    }, AnimationItem.prototype.updaFrameModifier = function() {
      this.frameModifier = this.frameMult * this.playSpeed * this.playDirection, this.audioController.setRate(this.playSpeed * this.playDirection);
    }, AnimationItem.prototype.getPath = function() {
      return this.path;
    }, AnimationItem.prototype.getAssetsPath = function(s) {
      var o = "";
      if (s.e)
        o = s.p;
      else if (this.assetsPath) {
        var l = s.p;
        l.indexOf("images/") !== -1 && (l = l.split("/")[1]), o = this.assetsPath + l;
      } else
        o = this.path, o += s.u ? s.u : "", o += s.p;
      return o;
    }, AnimationItem.prototype.getAssetData = function(s) {
      for (var o = 0, l = this.assets.length; o < l; ) {
        if (s === this.assets[o].id)
          return this.assets[o];
        o += 1;
      }
      return null;
    }, AnimationItem.prototype.hide = function() {
      this.renderer.hide();
    }, AnimationItem.prototype.show = function() {
      this.renderer.show();
    }, AnimationItem.prototype.getDuration = function(s) {
      return s ? this.totalFrames : this.totalFrames / this.frameRate;
    }, AnimationItem.prototype.updateDocumentData = function(s, o, l) {
      try {
        var u = this.renderer.getElementByPath(s);
        u.updateDocumentData(o, l);
      } catch {
      }
    }, AnimationItem.prototype.trigger = function(s) {
      if (this._cbs && this._cbs[s])
        switch (s) {
          case "enterFrame":
            this.triggerEvent(s, new BMEnterFrameEvent(s, this.currentFrame, this.totalFrames, this.frameModifier));
            break;
          case "drawnFrame":
            this.drawnFrameEvent.currentTime = this.currentFrame, this.drawnFrameEvent.totalTime = this.totalFrames, this.drawnFrameEvent.direction = this.frameModifier, this.triggerEvent(s, this.drawnFrameEvent);
            break;
          case "loopComplete":
            this.triggerEvent(s, new BMCompleteLoopEvent(s, this.loop, this.playCount, this.frameMult));
            break;
          case "complete":
            this.triggerEvent(s, new BMCompleteEvent(s, this.frameMult));
            break;
          case "segmentStart":
            this.triggerEvent(s, new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames));
            break;
          case "destroy":
            this.triggerEvent(s, new BMDestroyEvent(s, this));
            break;
          default:
            this.triggerEvent(s);
        }
      s === "enterFrame" && this.onEnterFrame && this.onEnterFrame.call(this, new BMEnterFrameEvent(s, this.currentFrame, this.totalFrames, this.frameMult)), s === "loopComplete" && this.onLoopComplete && this.onLoopComplete.call(this, new BMCompleteLoopEvent(s, this.loop, this.playCount, this.frameMult)), s === "complete" && this.onComplete && this.onComplete.call(this, new BMCompleteEvent(s, this.frameMult)), s === "segmentStart" && this.onSegmentStart && this.onSegmentStart.call(this, new BMSegmentStartEvent(s, this.firstFrame, this.totalFrames)), s === "destroy" && this.onDestroy && this.onDestroy.call(this, new BMDestroyEvent(s, this));
    }, AnimationItem.prototype.triggerRenderFrameError = function(s) {
      var o = new BMRenderFrameErrorEvent(s, this.currentFrame);
      this.triggerEvent("error", o), this.onError && this.onError.call(this, o);
    }, AnimationItem.prototype.triggerConfigError = function(s) {
      var o = new BMConfigErrorEvent(s, this.currentFrame);
      this.triggerEvent("error", o), this.onError && this.onError.call(this, o);
    };
    var animationManager = function() {
      var s = {}, o = [], l = 0, u = 0, c = 0, m = !0, g = !1;
      function v(Gt) {
        for (var nn = 0, vt = Gt.target; nn < u; )
          o[nn].animation === vt && (o.splice(nn, 1), nn -= 1, u -= 1, vt.isPaused || P()), nn += 1;
      }
      function b(Gt, nn) {
        if (!Gt)
          return null;
        for (var vt = 0; vt < u; ) {
          if (o[vt].elem === Gt && o[vt].elem !== null)
            return o[vt].animation;
          vt += 1;
        }
        var Et = new AnimationItem();
        return T(Et, Gt), Et.setData(Gt, nn), Et;
      }
      function S() {
        var Gt, nn = o.length, vt = [];
        for (Gt = 0; Gt < nn; Gt += 1)
          vt.push(o[Gt].animation);
        return vt;
      }
      function E() {
        c += 1, xt();
      }
      function P() {
        c -= 1;
      }
      function T(Gt, nn) {
        Gt.addEventListener("destroy", v), Gt.addEventListener("_active", E), Gt.addEventListener("_idle", P), o.push({
          elem: nn,
          animation: Gt
        }), u += 1;
      }
      function N(Gt) {
        var nn = new AnimationItem();
        return T(nn, null), nn.setParams(Gt), nn;
      }
      function O(Gt, nn) {
        var vt;
        for (vt = 0; vt < u; vt += 1)
          o[vt].animation.setSpeed(Gt, nn);
      }
      function z(Gt, nn) {
        var vt;
        for (vt = 0; vt < u; vt += 1)
          o[vt].animation.setDirection(Gt, nn);
      }
      function Q(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.play(Gt);
      }
      function W(Gt) {
        var nn = Gt - l, vt;
        for (vt = 0; vt < u; vt += 1)
          o[vt].animation.advanceTime(nn);
        l = Gt, c && !g ? window.requestAnimationFrame(W) : m = !0;
      }
      function ue(Gt) {
        l = Gt, window.requestAnimationFrame(W);
      }
      function te(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.pause(Gt);
      }
      function K(Gt, nn, vt) {
        var Et;
        for (Et = 0; Et < u; Et += 1)
          o[Et].animation.goToAndStop(Gt, nn, vt);
      }
      function ve(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.stop(Gt);
      }
      function ee(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.togglePause(Gt);
      }
      function Re(Gt) {
        var nn;
        for (nn = u - 1; nn >= 0; nn -= 1)
          o[nn].animation.destroy(Gt);
      }
      function wt(Gt, nn, vt) {
        var Et = [].concat([].slice.call(document.getElementsByClassName("lottie")), [].slice.call(document.getElementsByClassName("bodymovin"))), Qt, un = Et.length;
        for (Qt = 0; Qt < un; Qt += 1)
          vt && Et[Qt].setAttribute("data-bm-type", vt), b(Et[Qt], Gt);
        if (nn && un === 0) {
          vt || (vt = "svg");
          var gn = document.getElementsByTagName("body")[0];
          gn.innerText = "";
          var dn = createTag("div");
          dn.style.width = "100%", dn.style.height = "100%", dn.setAttribute("data-bm-type", vt), gn.appendChild(dn), b(dn, Gt);
        }
      }
      function yt() {
        var Gt;
        for (Gt = 0; Gt < u; Gt += 1)
          o[Gt].animation.resize();
      }
      function xt() {
        !g && c && m && (window.requestAnimationFrame(ue), m = !1);
      }
      function Kt() {
        g = !0;
      }
      function tn() {
        g = !1, xt();
      }
      function ln(Gt, nn) {
        var vt;
        for (vt = 0; vt < u; vt += 1)
          o[vt].animation.setVolume(Gt, nn);
      }
      function rn(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.mute(Gt);
      }
      function an(Gt) {
        var nn;
        for (nn = 0; nn < u; nn += 1)
          o[nn].animation.unmute(Gt);
      }
      return s.registerAnimation = b, s.loadAnimation = N, s.setSpeed = O, s.setDirection = z, s.play = Q, s.pause = te, s.stop = ve, s.togglePause = ee, s.searchAnimations = wt, s.resize = yt, s.goToAndStop = K, s.destroy = Re, s.freeze = Kt, s.unfreeze = tn, s.setVolume = ln, s.mute = rn, s.unmute = an, s.getRegisteredAnimations = S, s;
    }(), BezierFactory = function() {
      var s = {};
      s.getBezierEasing = l;
      var o = {};
      function l(ue, te, K, ve, ee) {
        var Re = ee || ("bez_" + ue + "_" + te + "_" + K + "_" + ve).replace(/\./g, "p");
        if (o[Re])
          return o[Re];
        var wt = new W([ue, te, K, ve]);
        return o[Re] = wt, wt;
      }
      var u = 4, c = 1e-3, m = 1e-7, g = 10, v = 11, b = 1 / (v - 1), S = typeof Float32Array == "function";
      function E(ue, te) {
        return 1 - 3 * te + 3 * ue;
      }
      function P(ue, te) {
        return 3 * te - 6 * ue;
      }
      function T(ue) {
        return 3 * ue;
      }
      function N(ue, te, K) {
        return ((E(te, K) * ue + P(te, K)) * ue + T(te)) * ue;
      }
      function O(ue, te, K) {
        return 3 * E(te, K) * ue * ue + 2 * P(te, K) * ue + T(te);
      }
      function z(ue, te, K, ve, ee) {
        var Re, wt, yt = 0;
        do
          wt = te + (K - te) / 2, Re = N(wt, ve, ee) - ue, Re > 0 ? K = wt : te = wt;
        while (Math.abs(Re) > m && ++yt < g);
        return wt;
      }
      function Q(ue, te, K, ve) {
        for (var ee = 0; ee < u; ++ee) {
          var Re = O(te, K, ve);
          if (Re === 0) return te;
          var wt = N(te, K, ve) - ue;
          te -= wt / Re;
        }
        return te;
      }
      function W(ue) {
        this._p = ue, this._mSampleValues = S ? new Float32Array(v) : new Array(v), this._precomputed = !1, this.get = this.get.bind(this);
      }
      return W.prototype = {
        get: function(te) {
          var K = this._p[0], ve = this._p[1], ee = this._p[2], Re = this._p[3];
          return this._precomputed || this._precompute(), K === ve && ee === Re ? te : te === 0 ? 0 : te === 1 ? 1 : N(this._getTForX(te), ve, Re);
        },
        // Private part
        _precompute: function() {
          var te = this._p[0], K = this._p[1], ve = this._p[2], ee = this._p[3];
          this._precomputed = !0, (te !== K || ve !== ee) && this._calcSampleValues();
        },
        _calcSampleValues: function() {
          for (var te = this._p[0], K = this._p[2], ve = 0; ve < v; ++ve)
            this._mSampleValues[ve] = N(ve * b, te, K);
        },
        /**
             * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
             */
        _getTForX: function(te) {
          for (var K = this._p[0], ve = this._p[2], ee = this._mSampleValues, Re = 0, wt = 1, yt = v - 1; wt !== yt && ee[wt] <= te; ++wt)
            Re += b;
          --wt;
          var xt = (te - ee[wt]) / (ee[wt + 1] - ee[wt]), Kt = Re + xt * b, tn = O(Kt, K, ve);
          return tn >= c ? Q(te, Kt, K, ve) : tn === 0 ? Kt : z(te, Re, Re + b, K, ve);
        }
      }, s;
    }(), pooling = /* @__PURE__ */ function() {
      function s(o) {
        return o.concat(createSizedArray(o.length));
      }
      return {
        double: s
      };
    }(), poolFactory = /* @__PURE__ */ function() {
      return function(s, o, l) {
        var u = 0, c = s, m = createSizedArray(c), g = {
          newElement: v,
          release: b
        };
        function v() {
          var S;
          return u ? (u -= 1, S = m[u]) : S = o(), S;
        }
        function b(S) {
          u === c && (m = pooling.double(m), c *= 2), l && l(S), m[u] = S, u += 1;
        }
        return g;
      };
    }(), bezierLengthPool = function() {
      function s() {
        return {
          addedLength: 0,
          percents: createTypedArray("float32", getDefaultCurveSegments()),
          lengths: createTypedArray("float32", getDefaultCurveSegments())
        };
      }
      return poolFactory(8, s);
    }(), segmentsLengthPool = function() {
      function s() {
        return {
          lengths: [],
          totalLength: 0
        };
      }
      function o(l) {
        var u, c = l.lengths.length;
        for (u = 0; u < c; u += 1)
          bezierLengthPool.release(l.lengths[u]);
        l.lengths.length = 0;
      }
      return poolFactory(8, s, o);
    }();
    function bezFunction() {
      var s = Math;
      function o(T, N, O, z, Q, W) {
        var ue = T * z + N * Q + O * W - Q * z - W * T - O * N;
        return ue > -1e-3 && ue < 1e-3;
      }
      function l(T, N, O, z, Q, W, ue, te, K) {
        if (O === 0 && W === 0 && K === 0)
          return o(T, N, z, Q, ue, te);
        var ve = s.sqrt(s.pow(z - T, 2) + s.pow(Q - N, 2) + s.pow(W - O, 2)), ee = s.sqrt(s.pow(ue - T, 2) + s.pow(te - N, 2) + s.pow(K - O, 2)), Re = s.sqrt(s.pow(ue - z, 2) + s.pow(te - Q, 2) + s.pow(K - W, 2)), wt;
        return ve > ee ? ve > Re ? wt = ve - ee - Re : wt = Re - ee - ve : Re > ee ? wt = Re - ee - ve : wt = ee - ve - Re, wt > -1e-4 && wt < 1e-4;
      }
      var u = /* @__PURE__ */ function() {
        return function(T, N, O, z) {
          var Q = getDefaultCurveSegments(), W, ue, te, K, ve, ee = 0, Re, wt = [], yt = [], xt = bezierLengthPool.newElement();
          for (te = O.length, W = 0; W < Q; W += 1) {
            for (ve = W / (Q - 1), Re = 0, ue = 0; ue < te; ue += 1)
              K = bmPow(1 - ve, 3) * T[ue] + 3 * bmPow(1 - ve, 2) * ve * O[ue] + 3 * (1 - ve) * bmPow(ve, 2) * z[ue] + bmPow(ve, 3) * N[ue], wt[ue] = K, yt[ue] !== null && (Re += bmPow(wt[ue] - yt[ue], 2)), yt[ue] = wt[ue];
            Re && (Re = bmSqrt(Re), ee += Re), xt.percents[W] = ve, xt.lengths[W] = ee;
          }
          return xt.addedLength = ee, xt;
        };
      }();
      function c(T) {
        var N = segmentsLengthPool.newElement(), O = T.c, z = T.v, Q = T.o, W = T.i, ue, te = T._length, K = N.lengths, ve = 0;
        for (ue = 0; ue < te - 1; ue += 1)
          K[ue] = u(z[ue], z[ue + 1], Q[ue], W[ue + 1]), ve += K[ue].addedLength;
        return O && te && (K[ue] = u(z[ue], z[0], Q[ue], W[0]), ve += K[ue].addedLength), N.totalLength = ve, N;
      }
      function m(T) {
        this.segmentLength = 0, this.points = new Array(T);
      }
      function g(T, N) {
        this.partialLength = T, this.point = N;
      }
      var v = /* @__PURE__ */ function() {
        var T = {};
        return function(N, O, z, Q) {
          var W = (N[0] + "_" + N[1] + "_" + O[0] + "_" + O[1] + "_" + z[0] + "_" + z[1] + "_" + Q[0] + "_" + Q[1]).replace(/\./g, "p");
          if (!T[W]) {
            var ue = getDefaultCurveSegments(), te, K, ve, ee, Re, wt = 0, yt, xt, Kt = null;
            N.length === 2 && (N[0] !== O[0] || N[1] !== O[1]) && o(N[0], N[1], O[0], O[1], N[0] + z[0], N[1] + z[1]) && o(N[0], N[1], O[0], O[1], O[0] + Q[0], O[1] + Q[1]) && (ue = 2);
            var tn = new m(ue);
            for (ve = z.length, te = 0; te < ue; te += 1) {
              for (xt = createSizedArray(ve), Re = te / (ue - 1), yt = 0, K = 0; K < ve; K += 1)
                ee = bmPow(1 - Re, 3) * N[K] + 3 * bmPow(1 - Re, 2) * Re * (N[K] + z[K]) + 3 * (1 - Re) * bmPow(Re, 2) * (O[K] + Q[K]) + bmPow(Re, 3) * O[K], xt[K] = ee, Kt !== null && (yt += bmPow(xt[K] - Kt[K], 2));
              yt = bmSqrt(yt), wt += yt, tn.points[te] = new g(yt, xt), Kt = xt;
            }
            tn.segmentLength = wt, T[W] = tn;
          }
          return T[W];
        };
      }();
      function b(T, N) {
        var O = N.percents, z = N.lengths, Q = O.length, W = bmFloor((Q - 1) * T), ue = T * N.addedLength, te = 0;
        if (W === Q - 1 || W === 0 || ue === z[W])
          return O[W];
        for (var K = z[W] > ue ? -1 : 1, ve = !0; ve; )
          if (z[W] <= ue && z[W + 1] > ue ? (te = (ue - z[W]) / (z[W + 1] - z[W]), ve = !1) : W += K, W < 0 || W >= Q - 1) {
            if (W === Q - 1)
              return O[W];
            ve = !1;
          }
        return O[W] + (O[W + 1] - O[W]) * te;
      }
      function S(T, N, O, z, Q, W) {
        var ue = b(Q, W), te = 1 - ue, K = s.round((te * te * te * T[0] + (ue * te * te + te * ue * te + te * te * ue) * O[0] + (ue * ue * te + te * ue * ue + ue * te * ue) * z[0] + ue * ue * ue * N[0]) * 1e3) / 1e3, ve = s.round((te * te * te * T[1] + (ue * te * te + te * ue * te + te * te * ue) * O[1] + (ue * ue * te + te * ue * ue + ue * te * ue) * z[1] + ue * ue * ue * N[1]) * 1e3) / 1e3;
        return [K, ve];
      }
      var E = createTypedArray("float32", 8);
      function P(T, N, O, z, Q, W, ue) {
        Q < 0 ? Q = 0 : Q > 1 && (Q = 1);
        var te = b(Q, ue);
        W = W > 1 ? 1 : W;
        var K = b(W, ue), ve, ee = T.length, Re = 1 - te, wt = 1 - K, yt = Re * Re * Re, xt = te * Re * Re * 3, Kt = te * te * Re * 3, tn = te * te * te, ln = Re * Re * wt, rn = te * Re * wt + Re * te * wt + Re * Re * K, an = te * te * wt + Re * te * K + te * Re * K, Gt = te * te * K, nn = Re * wt * wt, vt = te * wt * wt + Re * K * wt + Re * wt * K, Et = te * K * wt + Re * K * K + te * wt * K, Qt = te * K * K, un = wt * wt * wt, gn = K * wt * wt + wt * K * wt + wt * wt * K, dn = K * K * wt + wt * K * K + K * wt * K, yn = K * K * K;
        for (ve = 0; ve < ee; ve += 1)
          E[ve * 4] = s.round((yt * T[ve] + xt * O[ve] + Kt * z[ve] + tn * N[ve]) * 1e3) / 1e3, E[ve * 4 + 1] = s.round((ln * T[ve] + rn * O[ve] + an * z[ve] + Gt * N[ve]) * 1e3) / 1e3, E[ve * 4 + 2] = s.round((nn * T[ve] + vt * O[ve] + Et * z[ve] + Qt * N[ve]) * 1e3) / 1e3, E[ve * 4 + 3] = s.round((un * T[ve] + gn * O[ve] + dn * z[ve] + yn * N[ve]) * 1e3) / 1e3;
        return E;
      }
      return {
        getSegmentsLength: c,
        getNewSegment: P,
        getPointInSegment: S,
        buildBezierData: v,
        pointOnLine2D: o,
        pointOnLine3D: l
      };
    }
    var bez = bezFunction(), initFrame = initialDefaultFrame, mathAbs = Math.abs;
    function interpolateValue(s, o) {
      var l = this.offsetTime, u;
      this.propType === "multidimensional" && (u = createTypedArray("float32", this.pv.length));
      for (var c = o.lastIndex, m = c, g = this.keyframes.length - 1, v = !0, b, S, E; v; ) {
        if (b = this.keyframes[m], S = this.keyframes[m + 1], m === g - 1 && s >= S.t - l) {
          b.h && (b = S), c = 0;
          break;
        }
        if (S.t - l > s) {
          c = m;
          break;
        }
        m < g - 1 ? m += 1 : (c = 0, v = !1);
      }
      E = this.keyframesMetadata[m] || {};
      var P, T, N, O, z, Q, W = S.t - l, ue = b.t - l, te;
      if (b.to) {
        E.bezierData || (E.bezierData = bez.buildBezierData(b.s, S.s || b.e, b.to, b.ti));
        var K = E.bezierData;
        if (s >= W || s < ue) {
          var ve = s >= W ? K.points.length - 1 : 0;
          for (T = K.points[ve].point.length, P = 0; P < T; P += 1)
            u[P] = K.points[ve].point[P];
        } else {
          E.__fnct ? Q = E.__fnct : (Q = BezierFactory.getBezierEasing(b.o.x, b.o.y, b.i.x, b.i.y, b.n).get, E.__fnct = Q), N = Q((s - ue) / (W - ue));
          var ee = K.segmentLength * N, Re, wt = o.lastFrame < s && o._lastKeyframeIndex === m ? o._lastAddedLength : 0;
          for (z = o.lastFrame < s && o._lastKeyframeIndex === m ? o._lastPoint : 0, v = !0, O = K.points.length; v; ) {
            if (wt += K.points[z].partialLength, ee === 0 || N === 0 || z === K.points.length - 1) {
              for (T = K.points[z].point.length, P = 0; P < T; P += 1)
                u[P] = K.points[z].point[P];
              break;
            } else if (ee >= wt && ee < wt + K.points[z + 1].partialLength) {
              for (Re = (ee - wt) / K.points[z + 1].partialLength, T = K.points[z].point.length, P = 0; P < T; P += 1)
                u[P] = K.points[z].point[P] + (K.points[z + 1].point[P] - K.points[z].point[P]) * Re;
              break;
            }
            z < O - 1 ? z += 1 : v = !1;
          }
          o._lastPoint = z, o._lastAddedLength = wt - K.points[z].partialLength, o._lastKeyframeIndex = m;
        }
      } else {
        var yt, xt, Kt, tn, ln;
        if (g = b.s.length, te = S.s || b.e, this.sh && b.h !== 1)
          if (s >= W)
            u[0] = te[0], u[1] = te[1], u[2] = te[2];
          else if (s <= ue)
            u[0] = b.s[0], u[1] = b.s[1], u[2] = b.s[2];
          else {
            var rn = createQuaternion(b.s), an = createQuaternion(te), Gt = (s - ue) / (W - ue);
            quaternionToEuler(u, slerp(rn, an, Gt));
          }
        else
          for (m = 0; m < g; m += 1)
            b.h !== 1 && (s >= W ? N = 1 : s < ue ? N = 0 : (b.o.x.constructor === Array ? (E.__fnct || (E.__fnct = []), E.__fnct[m] ? Q = E.__fnct[m] : (yt = b.o.x[m] === void 0 ? b.o.x[0] : b.o.x[m], xt = b.o.y[m] === void 0 ? b.o.y[0] : b.o.y[m], Kt = b.i.x[m] === void 0 ? b.i.x[0] : b.i.x[m], tn = b.i.y[m] === void 0 ? b.i.y[0] : b.i.y[m], Q = BezierFactory.getBezierEasing(yt, xt, Kt, tn).get, E.__fnct[m] = Q)) : E.__fnct ? Q = E.__fnct : (yt = b.o.x, xt = b.o.y, Kt = b.i.x, tn = b.i.y, Q = BezierFactory.getBezierEasing(yt, xt, Kt, tn).get, b.keyframeMetadata = Q), N = Q((s - ue) / (W - ue)))), te = S.s || b.e, ln = b.h === 1 ? b.s[m] : b.s[m] + (te[m] - b.s[m]) * N, this.propType === "multidimensional" ? u[m] = ln : u = ln;
      }
      return o.lastIndex = c, u;
    }
    function slerp(s, o, l) {
      var u = [], c = s[0], m = s[1], g = s[2], v = s[3], b = o[0], S = o[1], E = o[2], P = o[3], T, N, O, z, Q;
      return N = c * b + m * S + g * E + v * P, N < 0 && (N = -N, b = -b, S = -S, E = -E, P = -P), 1 - N > 1e-6 ? (T = Math.acos(N), O = Math.sin(T), z = Math.sin((1 - l) * T) / O, Q = Math.sin(l * T) / O) : (z = 1 - l, Q = l), u[0] = z * c + Q * b, u[1] = z * m + Q * S, u[2] = z * g + Q * E, u[3] = z * v + Q * P, u;
    }
    function quaternionToEuler(s, o) {
      var l = o[0], u = o[1], c = o[2], m = o[3], g = Math.atan2(2 * u * m - 2 * l * c, 1 - 2 * u * u - 2 * c * c), v = Math.asin(2 * l * u + 2 * c * m), b = Math.atan2(2 * l * m - 2 * u * c, 1 - 2 * l * l - 2 * c * c);
      s[0] = g / degToRads, s[1] = v / degToRads, s[2] = b / degToRads;
    }
    function createQuaternion(s) {
      var o = s[0] * degToRads, l = s[1] * degToRads, u = s[2] * degToRads, c = Math.cos(o / 2), m = Math.cos(l / 2), g = Math.cos(u / 2), v = Math.sin(o / 2), b = Math.sin(l / 2), S = Math.sin(u / 2), E = c * m * g - v * b * S, P = v * b * g + c * m * S, T = v * m * g + c * b * S, N = c * b * g - v * m * S;
      return [P, T, N, E];
    }
    function getValueAtCurrentTime() {
      var s = this.comp.renderedFrame - this.offsetTime, o = this.keyframes[0].t - this.offsetTime, l = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;
      if (!(s === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= l && s >= l || this._caching.lastFrame < o && s < o))) {
        this._caching.lastFrame >= s && (this._caching._lastKeyframeIndex = -1, this._caching.lastIndex = 0);
        var u = this.interpolateValue(s, this._caching);
        this.pv = u;
      }
      return this._caching.lastFrame = s, this.pv;
    }
    function setVValue(s) {
      var o;
      if (this.propType === "unidimensional")
        o = s * this.mult, mathAbs(this.v - o) > 1e-5 && (this.v = o, this._mdf = !0);
      else
        for (var l = 0, u = this.v.length; l < u; )
          o = s[l] * this.mult, mathAbs(this.v[l] - o) > 1e-5 && (this.v[l] = o, this._mdf = !0), l += 1;
    }
    function processEffectsSequence() {
      if (!(this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length)) {
        if (this.lock) {
          this.setVValue(this.pv);
          return;
        }
        this.lock = !0, this._mdf = this._isFirstFrame;
        var s, o = this.effectsSequence.length, l = this.kf ? this.pv : this.data.k;
        for (s = 0; s < o; s += 1)
          l = this.effectsSequence[s](l);
        this.setVValue(l), this._isFirstFrame = !1, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }
    function addEffect(s) {
      this.effectsSequence.push(s), this.container.addDynamicProperty(this);
    }
    function ValueProperty(s, o, l, u) {
      this.propType = "unidimensional", this.mult = l || 1, this.data = o, this.v = l ? o.k * l : o.k, this.pv = o.k, this._mdf = !1, this.elem = s, this.container = u, this.comp = s.comp, this.k = !1, this.kf = !1, this.vel = 0, this.effectsSequence = [], this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function MultiDimensionalProperty(s, o, l, u) {
      this.propType = "multidimensional", this.mult = l || 1, this.data = o, this._mdf = !1, this.elem = s, this.container = u, this.comp = s.comp, this.k = !1, this.kf = !1, this.frameId = -1;
      var c, m = o.k.length;
      for (this.v = createTypedArray("float32", m), this.pv = createTypedArray("float32", m), this.vel = createTypedArray("float32", m), c = 0; c < m; c += 1)
        this.v[c] = o.k[c] * this.mult, this.pv[c] = o.k[c];
      this._isFirstFrame = !0, this.effectsSequence = [], this.getValue = processEffectsSequence, this.setVValue = setVValue, this.addEffect = addEffect;
    }
    function KeyframedValueProperty(s, o, l, u) {
      this.propType = "unidimensional", this.keyframes = o.k, this.keyframesMetadata = [], this.offsetTime = s.data.st, this.frameId = -1, this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: 0,
        _lastKeyframeIndex: -1
      }, this.k = !0, this.kf = !0, this.data = o, this.mult = l || 1, this.elem = s, this.container = u, this.comp = s.comp, this.v = initFrame, this.pv = initFrame, this._isFirstFrame = !0, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.addEffect = addEffect;
    }
    function KeyframedMultidimensionalProperty(s, o, l, u) {
      this.propType = "multidimensional";
      var c, m = o.k.length, g, v, b, S;
      for (c = 0; c < m - 1; c += 1)
        o.k[c].to && o.k[c].s && o.k[c + 1] && o.k[c + 1].s && (g = o.k[c].s, v = o.k[c + 1].s, b = o.k[c].to, S = o.k[c].ti, (g.length === 2 && !(g[0] === v[0] && g[1] === v[1]) && bez.pointOnLine2D(g[0], g[1], v[0], v[1], g[0] + b[0], g[1] + b[1]) && bez.pointOnLine2D(g[0], g[1], v[0], v[1], v[0] + S[0], v[1] + S[1]) || g.length === 3 && !(g[0] === v[0] && g[1] === v[1] && g[2] === v[2]) && bez.pointOnLine3D(g[0], g[1], g[2], v[0], v[1], v[2], g[0] + b[0], g[1] + b[1], g[2] + b[2]) && bez.pointOnLine3D(g[0], g[1], g[2], v[0], v[1], v[2], v[0] + S[0], v[1] + S[1], v[2] + S[2])) && (o.k[c].to = null, o.k[c].ti = null), g[0] === v[0] && g[1] === v[1] && b[0] === 0 && b[1] === 0 && S[0] === 0 && S[1] === 0 && (g.length === 2 || g[2] === v[2] && b[2] === 0 && S[2] === 0) && (o.k[c].to = null, o.k[c].ti = null));
      this.effectsSequence = [getValueAtCurrentTime.bind(this)], this.data = o, this.keyframes = o.k, this.keyframesMetadata = [], this.offsetTime = s.data.st, this.k = !0, this.kf = !0, this._isFirstFrame = !0, this.mult = l || 1, this.elem = s, this.container = u, this.comp = s.comp, this.getValue = processEffectsSequence, this.setVValue = setVValue, this.interpolateValue = interpolateValue, this.frameId = -1;
      var E = o.k[0].s.length;
      for (this.v = createTypedArray("float32", E), this.pv = createTypedArray("float32", E), c = 0; c < E; c += 1)
        this.v[c] = initFrame, this.pv[c] = initFrame;
      this._caching = {
        lastFrame: initFrame,
        lastIndex: 0,
        value: createTypedArray("float32", E)
      }, this.addEffect = addEffect;
    }
    var PropertyFactory = /* @__PURE__ */ function() {
      function s(l, u, c, m, g) {
        u.sid && (u = l.globalData.slotManager.getProp(u));
        var v;
        if (!u.k.length)
          v = new ValueProperty(l, u, m, g);
        else if (typeof u.k[0] == "number")
          v = new MultiDimensionalProperty(l, u, m, g);
        else
          switch (c) {
            case 0:
              v = new KeyframedValueProperty(l, u, m, g);
              break;
            case 1:
              v = new KeyframedMultidimensionalProperty(l, u, m, g);
              break;
          }
        return v.effectsSequence.length && g.addDynamicProperty(v), v;
      }
      var o = {
        getProp: s
      };
      return o;
    }();
    function DynamicPropertyContainer() {
    }
    DynamicPropertyContainer.prototype = {
      addDynamicProperty: function(o) {
        this.dynamicProperties.indexOf(o) === -1 && (this.dynamicProperties.push(o), this.container.addDynamicProperty(this), this._isAnimated = !0);
      },
      iterateDynamicProperties: function() {
        this._mdf = !1;
        var o, l = this.dynamicProperties.length;
        for (o = 0; o < l; o += 1)
          this.dynamicProperties[o].getValue(), this.dynamicProperties[o]._mdf && (this._mdf = !0);
      },
      initDynamicPropertyContainer: function(o) {
        this.container = o, this.dynamicProperties = [], this._mdf = !1, this._isAnimated = !1;
      }
    };
    var pointPool = function() {
      function s() {
        return createTypedArray("float32", 2);
      }
      return poolFactory(8, s);
    }();
    function ShapePath() {
      this.c = !1, this._length = 0, this._maxLength = 8, this.v = createSizedArray(this._maxLength), this.o = createSizedArray(this._maxLength), this.i = createSizedArray(this._maxLength);
    }
    ShapePath.prototype.setPathData = function(s, o) {
      this.c = s, this.setLength(o);
      for (var l = 0; l < o; )
        this.v[l] = pointPool.newElement(), this.o[l] = pointPool.newElement(), this.i[l] = pointPool.newElement(), l += 1;
    }, ShapePath.prototype.setLength = function(s) {
      for (; this._maxLength < s; )
        this.doubleArrayLength();
      this._length = s;
    }, ShapePath.prototype.doubleArrayLength = function() {
      this.v = this.v.concat(createSizedArray(this._maxLength)), this.i = this.i.concat(createSizedArray(this._maxLength)), this.o = this.o.concat(createSizedArray(this._maxLength)), this._maxLength *= 2;
    }, ShapePath.prototype.setXYAt = function(s, o, l, u, c) {
      var m;
      switch (this._length = Math.max(this._length, u + 1), this._length >= this._maxLength && this.doubleArrayLength(), l) {
        case "v":
          m = this.v;
          break;
        case "i":
          m = this.i;
          break;
        case "o":
          m = this.o;
          break;
        default:
          m = [];
          break;
      }
      (!m[u] || m[u] && !c) && (m[u] = pointPool.newElement()), m[u][0] = s, m[u][1] = o;
    }, ShapePath.prototype.setTripleAt = function(s, o, l, u, c, m, g, v) {
      this.setXYAt(s, o, "v", g, v), this.setXYAt(l, u, "o", g, v), this.setXYAt(c, m, "i", g, v);
    }, ShapePath.prototype.reverse = function() {
      var s = new ShapePath();
      s.setPathData(this.c, this._length);
      var o = this.v, l = this.o, u = this.i, c = 0;
      this.c && (s.setTripleAt(o[0][0], o[0][1], u[0][0], u[0][1], l[0][0], l[0][1], 0, !1), c = 1);
      var m = this._length - 1, g = this._length, v;
      for (v = c; v < g; v += 1)
        s.setTripleAt(o[m][0], o[m][1], u[m][0], u[m][1], l[m][0], l[m][1], v, !1), m -= 1;
      return s;
    }, ShapePath.prototype.length = function() {
      return this._length;
    };
    var shapePool = function() {
      function s() {
        return new ShapePath();
      }
      function o(c) {
        var m = c._length, g;
        for (g = 0; g < m; g += 1)
          pointPool.release(c.v[g]), pointPool.release(c.i[g]), pointPool.release(c.o[g]), c.v[g] = null, c.i[g] = null, c.o[g] = null;
        c._length = 0, c.c = !1;
      }
      function l(c) {
        var m = u.newElement(), g, v = c._length === void 0 ? c.v.length : c._length;
        for (m.setLength(v), m.c = c.c, g = 0; g < v; g += 1)
          m.setTripleAt(c.v[g][0], c.v[g][1], c.o[g][0], c.o[g][1], c.i[g][0], c.i[g][1], g);
        return m;
      }
      var u = poolFactory(4, s, o);
      return u.clone = l, u;
    }();
    function ShapeCollection() {
      this._length = 0, this._maxLength = 4, this.shapes = createSizedArray(this._maxLength);
    }
    ShapeCollection.prototype.addShape = function(s) {
      this._length === this._maxLength && (this.shapes = this.shapes.concat(createSizedArray(this._maxLength)), this._maxLength *= 2), this.shapes[this._length] = s, this._length += 1;
    }, ShapeCollection.prototype.releaseShapes = function() {
      var s;
      for (s = 0; s < this._length; s += 1)
        shapePool.release(this.shapes[s]);
      this._length = 0;
    };
    var shapeCollectionPool = function() {
      var s = {
        newShapeCollection: c,
        release: m
      }, o = 0, l = 4, u = createSizedArray(l);
      function c() {
        var g;
        return o ? (o -= 1, g = u[o]) : g = new ShapeCollection(), g;
      }
      function m(g) {
        var v, b = g._length;
        for (v = 0; v < b; v += 1)
          shapePool.release(g.shapes[v]);
        g._length = 0, o === l && (u = pooling.double(u), l *= 2), u[o] = g, o += 1;
      }
      return s;
    }(), ShapePropertyFactory = function() {
      var s = -999999;
      function o(W, ue, te) {
        var K = te.lastIndex, ve, ee, Re, wt, yt, xt, Kt, tn, ln, rn = this.keyframes;
        if (W < rn[0].t - this.offsetTime)
          ve = rn[0].s[0], Re = !0, K = 0;
        else if (W >= rn[rn.length - 1].t - this.offsetTime)
          ve = rn[rn.length - 1].s ? rn[rn.length - 1].s[0] : rn[rn.length - 2].e[0], Re = !0;
        else {
          for (var an = K, Gt = rn.length - 1, nn = !0, vt, Et, Qt; nn && (vt = rn[an], Et = rn[an + 1], !(Et.t - this.offsetTime > W)); )
            an < Gt - 1 ? an += 1 : nn = !1;
          if (Qt = this.keyframesMetadata[an] || {}, Re = vt.h === 1, K = an, !Re) {
            if (W >= Et.t - this.offsetTime)
              tn = 1;
            else if (W < vt.t - this.offsetTime)
              tn = 0;
            else {
              var un;
              Qt.__fnct ? un = Qt.__fnct : (un = BezierFactory.getBezierEasing(vt.o.x, vt.o.y, vt.i.x, vt.i.y).get, Qt.__fnct = un), tn = un((W - (vt.t - this.offsetTime)) / (Et.t - this.offsetTime - (vt.t - this.offsetTime)));
            }
            ee = Et.s ? Et.s[0] : vt.e[0];
          }
          ve = vt.s[0];
        }
        for (xt = ue._length, Kt = ve.i[0].length, te.lastIndex = K, wt = 0; wt < xt; wt += 1)
          for (yt = 0; yt < Kt; yt += 1)
            ln = Re ? ve.i[wt][yt] : ve.i[wt][yt] + (ee.i[wt][yt] - ve.i[wt][yt]) * tn, ue.i[wt][yt] = ln, ln = Re ? ve.o[wt][yt] : ve.o[wt][yt] + (ee.o[wt][yt] - ve.o[wt][yt]) * tn, ue.o[wt][yt] = ln, ln = Re ? ve.v[wt][yt] : ve.v[wt][yt] + (ee.v[wt][yt] - ve.v[wt][yt]) * tn, ue.v[wt][yt] = ln;
      }
      function l() {
        var W = this.comp.renderedFrame - this.offsetTime, ue = this.keyframes[0].t - this.offsetTime, te = this.keyframes[this.keyframes.length - 1].t - this.offsetTime, K = this._caching.lastFrame;
        return K !== s && (K < ue && W < ue || K > te && W > te) || (this._caching.lastIndex = K < W ? this._caching.lastIndex : 0, this.interpolateShape(W, this.pv, this._caching)), this._caching.lastFrame = W, this.pv;
      }
      function u() {
        this.paths = this.localShapeCollection;
      }
      function c(W, ue) {
        if (W._length !== ue._length || W.c !== ue.c)
          return !1;
        var te, K = W._length;
        for (te = 0; te < K; te += 1)
          if (W.v[te][0] !== ue.v[te][0] || W.v[te][1] !== ue.v[te][1] || W.o[te][0] !== ue.o[te][0] || W.o[te][1] !== ue.o[te][1] || W.i[te][0] !== ue.i[te][0] || W.i[te][1] !== ue.i[te][1])
            return !1;
        return !0;
      }
      function m(W) {
        c(this.v, W) || (this.v = shapePool.clone(W), this.localShapeCollection.releaseShapes(), this.localShapeCollection.addShape(this.v), this._mdf = !0, this.paths = this.localShapeCollection);
      }
      function g() {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (!this.effectsSequence.length) {
            this._mdf = !1;
            return;
          }
          if (this.lock) {
            this.setVValue(this.pv);
            return;
          }
          this.lock = !0, this._mdf = !1;
          var W;
          this.kf ? W = this.pv : this.data.ks ? W = this.data.ks.k : W = this.data.pt.k;
          var ue, te = this.effectsSequence.length;
          for (ue = 0; ue < te; ue += 1)
            W = this.effectsSequence[ue](W);
          this.setVValue(W), this.lock = !1, this.frameId = this.elem.globalData.frameId;
        }
      }
      function v(W, ue, te) {
        this.propType = "shape", this.comp = W.comp, this.container = W, this.elem = W, this.data = ue, this.k = !1, this.kf = !1, this._mdf = !1;
        var K = te === 3 ? ue.pt.k : ue.ks.k;
        this.v = shapePool.clone(K), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.reset = u, this.effectsSequence = [];
      }
      function b(W) {
        this.effectsSequence.push(W), this.container.addDynamicProperty(this);
      }
      v.prototype.interpolateShape = o, v.prototype.getValue = g, v.prototype.setVValue = m, v.prototype.addEffect = b;
      function S(W, ue, te) {
        this.propType = "shape", this.comp = W.comp, this.elem = W, this.container = W, this.offsetTime = W.data.st, this.keyframes = te === 3 ? ue.pt.k : ue.ks.k, this.keyframesMetadata = [], this.k = !0, this.kf = !0;
        var K = this.keyframes[0].s[0].i.length;
        this.v = shapePool.newElement(), this.v.setPathData(this.keyframes[0].s[0].c, K), this.pv = shapePool.clone(this.v), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.paths.addShape(this.v), this.lastFrame = s, this.reset = u, this._caching = {
          lastFrame: s,
          lastIndex: 0
        }, this.effectsSequence = [l.bind(this)];
      }
      S.prototype.getValue = g, S.prototype.interpolateShape = o, S.prototype.setVValue = m, S.prototype.addEffect = b;
      var E = function() {
        var W = roundCorner;
        function ue(te, K) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 4), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.paths = this.localShapeCollection, this.localShapeCollection.addShape(this.v), this.d = K.d, this.elem = te, this.comp = te.comp, this.frameId = -1, this.initDynamicPropertyContainer(te), this.p = PropertyFactory.getProp(te, K.p, 1, 0, this), this.s = PropertyFactory.getProp(te, K.s, 1, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertEllToPath());
        }
        return ue.prototype = {
          reset: u,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertEllToPath());
          },
          convertEllToPath: function() {
            var K = this.p.v[0], ve = this.p.v[1], ee = this.s.v[0] / 2, Re = this.s.v[1] / 2, wt = this.d !== 3, yt = this.v;
            yt.v[0][0] = K, yt.v[0][1] = ve - Re, yt.v[1][0] = wt ? K + ee : K - ee, yt.v[1][1] = ve, yt.v[2][0] = K, yt.v[2][1] = ve + Re, yt.v[3][0] = wt ? K - ee : K + ee, yt.v[3][1] = ve, yt.i[0][0] = wt ? K - ee * W : K + ee * W, yt.i[0][1] = ve - Re, yt.i[1][0] = wt ? K + ee : K - ee, yt.i[1][1] = ve - Re * W, yt.i[2][0] = wt ? K + ee * W : K - ee * W, yt.i[2][1] = ve + Re, yt.i[3][0] = wt ? K - ee : K + ee, yt.i[3][1] = ve + Re * W, yt.o[0][0] = wt ? K + ee * W : K - ee * W, yt.o[0][1] = ve - Re, yt.o[1][0] = wt ? K + ee : K - ee, yt.o[1][1] = ve + Re * W, yt.o[2][0] = wt ? K - ee * W : K + ee * W, yt.o[2][1] = ve + Re, yt.o[3][0] = wt ? K - ee : K + ee, yt.o[3][1] = ve - Re * W;
          }
        }, extendPrototype([DynamicPropertyContainer], ue), ue;
      }(), P = function() {
        function W(ue, te) {
          this.v = shapePool.newElement(), this.v.setPathData(!0, 0), this.elem = ue, this.comp = ue.comp, this.data = te, this.frameId = -1, this.d = te.d, this.initDynamicPropertyContainer(ue), te.sy === 1 ? (this.ir = PropertyFactory.getProp(ue, te.ir, 0, 0, this), this.is = PropertyFactory.getProp(ue, te.is, 0, 0.01, this), this.convertToPath = this.convertStarToPath) : this.convertToPath = this.convertPolygonToPath, this.pt = PropertyFactory.getProp(ue, te.pt, 0, 0, this), this.p = PropertyFactory.getProp(ue, te.p, 1, 0, this), this.r = PropertyFactory.getProp(ue, te.r, 0, degToRads, this), this.or = PropertyFactory.getProp(ue, te.or, 0, 0, this), this.os = PropertyFactory.getProp(ue, te.os, 0, 0.01, this), this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertToPath());
        }
        return W.prototype = {
          reset: u,
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertToPath());
          },
          convertStarToPath: function() {
            var te = Math.floor(this.pt.v) * 2, K = Math.PI * 2 / te, ve = !0, ee = this.or.v, Re = this.ir.v, wt = this.os.v, yt = this.is.v, xt = 2 * Math.PI * ee / (te * 2), Kt = 2 * Math.PI * Re / (te * 2), tn, ln, rn, an, Gt = -Math.PI / 2;
            Gt += this.r.v;
            var nn = this.data.d === 3 ? -1 : 1;
            for (this.v._length = 0, tn = 0; tn < te; tn += 1) {
              ln = ve ? ee : Re, rn = ve ? wt : yt, an = ve ? xt : Kt;
              var vt = ln * Math.cos(Gt), Et = ln * Math.sin(Gt), Qt = vt === 0 && Et === 0 ? 0 : Et / Math.sqrt(vt * vt + Et * Et), un = vt === 0 && Et === 0 ? 0 : -vt / Math.sqrt(vt * vt + Et * Et);
              vt += +this.p.v[0], Et += +this.p.v[1], this.v.setTripleAt(vt, Et, vt - Qt * an * rn * nn, Et - un * an * rn * nn, vt + Qt * an * rn * nn, Et + un * an * rn * nn, tn, !0), ve = !ve, Gt += K * nn;
            }
          },
          convertPolygonToPath: function() {
            var te = Math.floor(this.pt.v), K = Math.PI * 2 / te, ve = this.or.v, ee = this.os.v, Re = 2 * Math.PI * ve / (te * 4), wt, yt = -Math.PI * 0.5, xt = this.data.d === 3 ? -1 : 1;
            for (yt += this.r.v, this.v._length = 0, wt = 0; wt < te; wt += 1) {
              var Kt = ve * Math.cos(yt), tn = ve * Math.sin(yt), ln = Kt === 0 && tn === 0 ? 0 : tn / Math.sqrt(Kt * Kt + tn * tn), rn = Kt === 0 && tn === 0 ? 0 : -Kt / Math.sqrt(Kt * Kt + tn * tn);
              Kt += +this.p.v[0], tn += +this.p.v[1], this.v.setTripleAt(Kt, tn, Kt - ln * Re * ee * xt, tn - rn * Re * ee * xt, Kt + ln * Re * ee * xt, tn + rn * Re * ee * xt, wt, !0), yt += K * xt;
            }
            this.paths.length = 0, this.paths[0] = this.v;
          }
        }, extendPrototype([DynamicPropertyContainer], W), W;
      }(), T = function() {
        function W(ue, te) {
          this.v = shapePool.newElement(), this.v.c = !0, this.localShapeCollection = shapeCollectionPool.newShapeCollection(), this.localShapeCollection.addShape(this.v), this.paths = this.localShapeCollection, this.elem = ue, this.comp = ue.comp, this.frameId = -1, this.d = te.d, this.initDynamicPropertyContainer(ue), this.p = PropertyFactory.getProp(ue, te.p, 1, 0, this), this.s = PropertyFactory.getProp(ue, te.s, 1, 0, this), this.r = PropertyFactory.getProp(ue, te.r, 0, 0, this), this.dynamicProperties.length ? this.k = !0 : (this.k = !1, this.convertRectToPath());
        }
        return W.prototype = {
          convertRectToPath: function() {
            var te = this.p.v[0], K = this.p.v[1], ve = this.s.v[0] / 2, ee = this.s.v[1] / 2, Re = bmMin(ve, ee, this.r.v), wt = Re * (1 - roundCorner);
            this.v._length = 0, this.d === 2 || this.d === 1 ? (this.v.setTripleAt(te + ve, K - ee + Re, te + ve, K - ee + Re, te + ve, K - ee + wt, 0, !0), this.v.setTripleAt(te + ve, K + ee - Re, te + ve, K + ee - wt, te + ve, K + ee - Re, 1, !0), Re !== 0 ? (this.v.setTripleAt(te + ve - Re, K + ee, te + ve - Re, K + ee, te + ve - wt, K + ee, 2, !0), this.v.setTripleAt(te - ve + Re, K + ee, te - ve + wt, K + ee, te - ve + Re, K + ee, 3, !0), this.v.setTripleAt(te - ve, K + ee - Re, te - ve, K + ee - Re, te - ve, K + ee - wt, 4, !0), this.v.setTripleAt(te - ve, K - ee + Re, te - ve, K - ee + wt, te - ve, K - ee + Re, 5, !0), this.v.setTripleAt(te - ve + Re, K - ee, te - ve + Re, K - ee, te - ve + wt, K - ee, 6, !0), this.v.setTripleAt(te + ve - Re, K - ee, te + ve - wt, K - ee, te + ve - Re, K - ee, 7, !0)) : (this.v.setTripleAt(te - ve, K + ee, te - ve + wt, K + ee, te - ve, K + ee, 2), this.v.setTripleAt(te - ve, K - ee, te - ve, K - ee + wt, te - ve, K - ee, 3))) : (this.v.setTripleAt(te + ve, K - ee + Re, te + ve, K - ee + wt, te + ve, K - ee + Re, 0, !0), Re !== 0 ? (this.v.setTripleAt(te + ve - Re, K - ee, te + ve - Re, K - ee, te + ve - wt, K - ee, 1, !0), this.v.setTripleAt(te - ve + Re, K - ee, te - ve + wt, K - ee, te - ve + Re, K - ee, 2, !0), this.v.setTripleAt(te - ve, K - ee + Re, te - ve, K - ee + Re, te - ve, K - ee + wt, 3, !0), this.v.setTripleAt(te - ve, K + ee - Re, te - ve, K + ee - wt, te - ve, K + ee - Re, 4, !0), this.v.setTripleAt(te - ve + Re, K + ee, te - ve + Re, K + ee, te - ve + wt, K + ee, 5, !0), this.v.setTripleAt(te + ve - Re, K + ee, te + ve - wt, K + ee, te + ve - Re, K + ee, 6, !0), this.v.setTripleAt(te + ve, K + ee - Re, te + ve, K + ee - Re, te + ve, K + ee - wt, 7, !0)) : (this.v.setTripleAt(te - ve, K - ee, te - ve + wt, K - ee, te - ve, K - ee, 1, !0), this.v.setTripleAt(te - ve, K + ee, te - ve, K + ee - wt, te - ve, K + ee, 2, !0), this.v.setTripleAt(te + ve, K + ee, te + ve - wt, K + ee, te + ve, K + ee, 3, !0)));
          },
          getValue: function() {
            this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf && this.convertRectToPath());
          },
          reset: u
        }, extendPrototype([DynamicPropertyContainer], W), W;
      }();
      function N(W, ue, te) {
        var K;
        if (te === 3 || te === 4) {
          var ve = te === 3 ? ue.pt : ue.ks, ee = ve.k;
          ee.length ? K = new S(W, ue, te) : K = new v(W, ue, te);
        } else te === 5 ? K = new T(W, ue) : te === 6 ? K = new E(W, ue) : te === 7 && (K = new P(W, ue));
        return K.k && W.addDynamicProperty(K), K;
      }
      function O() {
        return v;
      }
      function z() {
        return S;
      }
      var Q = {};
      return Q.getShapeProp = N, Q.getConstructorFunction = O, Q.getKeyframedConstructorFunction = z, Q;
    }();
    /*!
     Transformation Matrix v2.0
     (c) Epistemex 2014-2015
     www.epistemex.com
     By Ken Fyrstenberg
     Contributions by leeoniya.
     License: MIT, header required.
     */
    var Matrix = /* @__PURE__ */ function() {
      var s = Math.cos, o = Math.sin, l = Math.tan, u = Math.round;
      function c() {
        return this.props[0] = 1, this.props[1] = 0, this.props[2] = 0, this.props[3] = 0, this.props[4] = 0, this.props[5] = 1, this.props[6] = 0, this.props[7] = 0, this.props[8] = 0, this.props[9] = 0, this.props[10] = 1, this.props[11] = 0, this.props[12] = 0, this.props[13] = 0, this.props[14] = 0, this.props[15] = 1, this;
      }
      function m(vt) {
        if (vt === 0)
          return this;
        var Et = s(vt), Qt = o(vt);
        return this._t(Et, -Qt, 0, 0, Qt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function g(vt) {
        if (vt === 0)
          return this;
        var Et = s(vt), Qt = o(vt);
        return this._t(1, 0, 0, 0, 0, Et, -Qt, 0, 0, Qt, Et, 0, 0, 0, 0, 1);
      }
      function v(vt) {
        if (vt === 0)
          return this;
        var Et = s(vt), Qt = o(vt);
        return this._t(Et, 0, Qt, 0, 0, 1, 0, 0, -Qt, 0, Et, 0, 0, 0, 0, 1);
      }
      function b(vt) {
        if (vt === 0)
          return this;
        var Et = s(vt), Qt = o(vt);
        return this._t(Et, -Qt, 0, 0, Qt, Et, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function S(vt, Et) {
        return this._t(1, Et, vt, 1, 0, 0);
      }
      function E(vt, Et) {
        return this.shear(l(vt), l(Et));
      }
      function P(vt, Et) {
        var Qt = s(Et), un = o(Et);
        return this._t(Qt, un, 0, 0, -un, Qt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, l(vt), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(Qt, -un, 0, 0, un, Qt, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
      }
      function T(vt, Et, Qt) {
        return !Qt && Qt !== 0 && (Qt = 1), vt === 1 && Et === 1 && Qt === 1 ? this : this._t(vt, 0, 0, 0, 0, Et, 0, 0, 0, 0, Qt, 0, 0, 0, 0, 1);
      }
      function N(vt, Et, Qt, un, gn, dn, yn, vn, Pn, On, _n, Nn, Un, Xn, zn, jn) {
        return this.props[0] = vt, this.props[1] = Et, this.props[2] = Qt, this.props[3] = un, this.props[4] = gn, this.props[5] = dn, this.props[6] = yn, this.props[7] = vn, this.props[8] = Pn, this.props[9] = On, this.props[10] = _n, this.props[11] = Nn, this.props[12] = Un, this.props[13] = Xn, this.props[14] = zn, this.props[15] = jn, this;
      }
      function O(vt, Et, Qt) {
        return Qt = Qt || 0, vt !== 0 || Et !== 0 || Qt !== 0 ? this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, vt, Et, Qt, 1) : this;
      }
      function z(vt, Et, Qt, un, gn, dn, yn, vn, Pn, On, _n, Nn, Un, Xn, zn, jn) {
        var kn = this.props;
        if (vt === 1 && Et === 0 && Qt === 0 && un === 0 && gn === 0 && dn === 1 && yn === 0 && vn === 0 && Pn === 0 && On === 0 && _n === 1 && Nn === 0)
          return kn[12] = kn[12] * vt + kn[15] * Un, kn[13] = kn[13] * dn + kn[15] * Xn, kn[14] = kn[14] * _n + kn[15] * zn, kn[15] *= jn, this._identityCalculated = !1, this;
        var Yn = kn[0], Zn = kn[1], er = kn[2], bn = kn[3], Ln = kn[4], Kn = kn[5], Bn = kn[6], Fn = kn[7], Gn = kn[8], Wn = kn[9], Mn = kn[10], Tn = kn[11], Rn = kn[12], hn = kn[13], Qn = kn[14], rr = kn[15];
        return kn[0] = Yn * vt + Zn * gn + er * Pn + bn * Un, kn[1] = Yn * Et + Zn * dn + er * On + bn * Xn, kn[2] = Yn * Qt + Zn * yn + er * _n + bn * zn, kn[3] = Yn * un + Zn * vn + er * Nn + bn * jn, kn[4] = Ln * vt + Kn * gn + Bn * Pn + Fn * Un, kn[5] = Ln * Et + Kn * dn + Bn * On + Fn * Xn, kn[6] = Ln * Qt + Kn * yn + Bn * _n + Fn * zn, kn[7] = Ln * un + Kn * vn + Bn * Nn + Fn * jn, kn[8] = Gn * vt + Wn * gn + Mn * Pn + Tn * Un, kn[9] = Gn * Et + Wn * dn + Mn * On + Tn * Xn, kn[10] = Gn * Qt + Wn * yn + Mn * _n + Tn * zn, kn[11] = Gn * un + Wn * vn + Mn * Nn + Tn * jn, kn[12] = Rn * vt + hn * gn + Qn * Pn + rr * Un, kn[13] = Rn * Et + hn * dn + Qn * On + rr * Xn, kn[14] = Rn * Qt + hn * yn + Qn * _n + rr * zn, kn[15] = Rn * un + hn * vn + Qn * Nn + rr * jn, this._identityCalculated = !1, this;
      }
      function Q(vt) {
        var Et = vt.props;
        return this.transform(Et[0], Et[1], Et[2], Et[3], Et[4], Et[5], Et[6], Et[7], Et[8], Et[9], Et[10], Et[11], Et[12], Et[13], Et[14], Et[15]);
      }
      function W() {
        return this._identityCalculated || (this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1), this._identityCalculated = !0), this._identity;
      }
      function ue(vt) {
        for (var Et = 0; Et < 16; ) {
          if (vt.props[Et] !== this.props[Et])
            return !1;
          Et += 1;
        }
        return !0;
      }
      function te(vt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          vt.props[Et] = this.props[Et];
        return vt;
      }
      function K(vt) {
        var Et;
        for (Et = 0; Et < 16; Et += 1)
          this.props[Et] = vt[Et];
      }
      function ve(vt, Et, Qt) {
        return {
          x: vt * this.props[0] + Et * this.props[4] + Qt * this.props[8] + this.props[12],
          y: vt * this.props[1] + Et * this.props[5] + Qt * this.props[9] + this.props[13],
          z: vt * this.props[2] + Et * this.props[6] + Qt * this.props[10] + this.props[14]
        };
      }
      function ee(vt, Et, Qt) {
        return vt * this.props[0] + Et * this.props[4] + Qt * this.props[8] + this.props[12];
      }
      function Re(vt, Et, Qt) {
        return vt * this.props[1] + Et * this.props[5] + Qt * this.props[9] + this.props[13];
      }
      function wt(vt, Et, Qt) {
        return vt * this.props[2] + Et * this.props[6] + Qt * this.props[10] + this.props[14];
      }
      function yt() {
        var vt = this.props[0] * this.props[5] - this.props[1] * this.props[4], Et = this.props[5] / vt, Qt = -this.props[1] / vt, un = -this.props[4] / vt, gn = this.props[0] / vt, dn = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / vt, yn = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / vt, vn = new Matrix();
        return vn.props[0] = Et, vn.props[1] = Qt, vn.props[4] = un, vn.props[5] = gn, vn.props[12] = dn, vn.props[13] = yn, vn;
      }
      function xt(vt) {
        var Et = this.getInverseMatrix();
        return Et.applyToPointArray(vt[0], vt[1], vt[2] || 0);
      }
      function Kt(vt) {
        var Et, Qt = vt.length, un = [];
        for (Et = 0; Et < Qt; Et += 1)
          un[Et] = xt(vt[Et]);
        return un;
      }
      function tn(vt, Et, Qt) {
        var un = createTypedArray("float32", 6);
        if (this.isIdentity())
          un[0] = vt[0], un[1] = vt[1], un[2] = Et[0], un[3] = Et[1], un[4] = Qt[0], un[5] = Qt[1];
        else {
          var gn = this.props[0], dn = this.props[1], yn = this.props[4], vn = this.props[5], Pn = this.props[12], On = this.props[13];
          un[0] = vt[0] * gn + vt[1] * yn + Pn, un[1] = vt[0] * dn + vt[1] * vn + On, un[2] = Et[0] * gn + Et[1] * yn + Pn, un[3] = Et[0] * dn + Et[1] * vn + On, un[4] = Qt[0] * gn + Qt[1] * yn + Pn, un[5] = Qt[0] * dn + Qt[1] * vn + On;
        }
        return un;
      }
      function ln(vt, Et, Qt) {
        var un;
        return this.isIdentity() ? un = [vt, Et, Qt] : un = [vt * this.props[0] + Et * this.props[4] + Qt * this.props[8] + this.props[12], vt * this.props[1] + Et * this.props[5] + Qt * this.props[9] + this.props[13], vt * this.props[2] + Et * this.props[6] + Qt * this.props[10] + this.props[14]], un;
      }
      function rn(vt, Et) {
        if (this.isIdentity())
          return vt + "," + Et;
        var Qt = this.props;
        return Math.round((vt * Qt[0] + Et * Qt[4] + Qt[12]) * 100) / 100 + "," + Math.round((vt * Qt[1] + Et * Qt[5] + Qt[13]) * 100) / 100;
      }
      function an() {
        for (var vt = 0, Et = this.props, Qt = "matrix3d(", un = 1e4; vt < 16; )
          Qt += u(Et[vt] * un) / un, Qt += vt === 15 ? ")" : ",", vt += 1;
        return Qt;
      }
      function Gt(vt) {
        var Et = 1e4;
        return vt < 1e-6 && vt > 0 || vt > -1e-6 && vt < 0 ? u(vt * Et) / Et : vt;
      }
      function nn() {
        var vt = this.props, Et = Gt(vt[0]), Qt = Gt(vt[1]), un = Gt(vt[4]), gn = Gt(vt[5]), dn = Gt(vt[12]), yn = Gt(vt[13]);
        return "matrix(" + Et + "," + Qt + "," + un + "," + gn + "," + dn + "," + yn + ")";
      }
      return function() {
        this.reset = c, this.rotate = m, this.rotateX = g, this.rotateY = v, this.rotateZ = b, this.skew = E, this.skewFromAxis = P, this.shear = S, this.scale = T, this.setTransform = N, this.translate = O, this.transform = z, this.multiply = Q, this.applyToPoint = ve, this.applyToX = ee, this.applyToY = Re, this.applyToZ = wt, this.applyToPointArray = ln, this.applyToTriplePoints = tn, this.applyToPointStringified = rn, this.toCSS = an, this.to2dCSS = nn, this.clone = te, this.cloneFromProps = K, this.equals = ue, this.inversePoints = Kt, this.inversePoint = xt, this.getInverseMatrix = yt, this._t = this.transform, this.isIdentity = W, this._identity = !0, this._identityCalculated = !1, this.props = createTypedArray("float32", 16), this.reset();
      };
    }();
    function _typeof$3(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$3 = function(l) {
        return typeof l;
      } : _typeof$3 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$3(s);
    }
    var lottie = {};
    function setLocation(s) {
      setLocationHref(s);
    }
    function searchAnimations() {
      animationManager.searchAnimations();
    }
    function setSubframeRendering(s) {
      setSubframeEnabled(s);
    }
    function setPrefix(s) {
      setIdPrefix(s);
    }
    function loadAnimation(s) {
      return animationManager.loadAnimation(s);
    }
    function setQuality(s) {
      if (typeof s == "string")
        switch (s) {
          case "high":
            setDefaultCurveSegments(200);
            break;
          default:
          case "medium":
            setDefaultCurveSegments(50);
            break;
          case "low":
            setDefaultCurveSegments(10);
            break;
        }
      else !isNaN(s) && s > 1 && setDefaultCurveSegments(s);
    }
    function inBrowser() {
      return typeof navigator < "u";
    }
    function installPlugin(s, o) {
      s === "expressions" && setExpressionsPlugin(o);
    }
    function getFactory(s) {
      switch (s) {
        case "propertyFactory":
          return PropertyFactory;
        case "shapePropertyFactory":
          return ShapePropertyFactory;
        case "matrix":
          return Matrix;
        default:
          return null;
      }
    }
    lottie.play = animationManager.play, lottie.pause = animationManager.pause, lottie.setLocationHref = setLocation, lottie.togglePause = animationManager.togglePause, lottie.setSpeed = animationManager.setSpeed, lottie.setDirection = animationManager.setDirection, lottie.stop = animationManager.stop, lottie.searchAnimations = searchAnimations, lottie.registerAnimation = animationManager.registerAnimation, lottie.loadAnimation = loadAnimation, lottie.setSubframeRendering = setSubframeRendering, lottie.resize = animationManager.resize, lottie.goToAndStop = animationManager.goToAndStop, lottie.destroy = animationManager.destroy, lottie.setQuality = setQuality, lottie.inBrowser = inBrowser, lottie.installPlugin = installPlugin, lottie.freeze = animationManager.freeze, lottie.unfreeze = animationManager.unfreeze, lottie.setVolume = animationManager.setVolume, lottie.mute = animationManager.mute, lottie.unmute = animationManager.unmute, lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations, lottie.useWebWorker = setWebWorker, lottie.setIDPrefix = setPrefix, lottie.__getFactory = getFactory, lottie.version = "5.12.2";
    function checkReady() {
      document.readyState === "complete" && (clearInterval(readyStateCheckInterval), searchAnimations());
    }
    function getQueryVariable(s) {
      for (var o = queryString.split("&"), l = 0; l < o.length; l += 1) {
        var u = o[l].split("=");
        if (decodeURIComponent(u[0]) == s)
          return decodeURIComponent(u[1]);
      }
      return null;
    }
    var queryString = "";
    {
      var scripts = document.getElementsByTagName("script"), index = scripts.length - 1, myScript = scripts[index] || {
        src: ""
      };
      queryString = myScript.src ? myScript.src.replace(/^[^\?]+\??/, "") : "", getQueryVariable("renderer");
    }
    var readyStateCheckInterval = setInterval(checkReady, 100);
    try {
      _typeof$3(exports) !== "object" && (window.bodymovin = lottie);
    } catch (s) {
    }
    var ShapeModifiers = function() {
      var s = {}, o = {};
      s.registerModifier = l, s.getModifier = u;
      function l(c, m) {
        o[c] || (o[c] = m);
      }
      function u(c, m, g) {
        return new o[c](m, g);
      }
      return s;
    }();
    function ShapeModifier() {
    }
    ShapeModifier.prototype.initModifierProperties = function() {
    }, ShapeModifier.prototype.addShapeToModifier = function() {
    }, ShapeModifier.prototype.addShape = function(s) {
      if (!this.closed) {
        s.sh.container.addDynamicProperty(s.sh);
        var o = {
          shape: s.sh,
          data: s,
          localShapeCollection: shapeCollectionPool.newShapeCollection()
        };
        this.shapes.push(o), this.addShapeToModifier(o), this._isAnimated && s.setAsAnimated();
      }
    }, ShapeModifier.prototype.init = function(s, o) {
      this.shapes = [], this.elem = s, this.initDynamicPropertyContainer(s), this.initModifierProperties(s, o), this.frameId = initialDefaultFrame, this.closed = !1, this.k = !1, this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, ShapeModifier.prototype.processKeys = function() {
      this.elem.globalData.frameId !== this.frameId && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties());
    }, extendPrototype([DynamicPropertyContainer], ShapeModifier);
    function TrimModifier() {
    }
    extendPrototype([ShapeModifier], TrimModifier), TrimModifier.prototype.initModifierProperties = function(s, o) {
      this.s = PropertyFactory.getProp(s, o.s, 0, 0.01, this), this.e = PropertyFactory.getProp(s, o.e, 0, 0.01, this), this.o = PropertyFactory.getProp(s, o.o, 0, 0, this), this.sValue = 0, this.eValue = 0, this.getValue = this.processKeys, this.m = o.m, this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;
    }, TrimModifier.prototype.addShapeToModifier = function(s) {
      s.pathsData = [];
    }, TrimModifier.prototype.calculateShapeEdges = function(s, o, l, u, c) {
      var m = [];
      o <= 1 ? m.push({
        s,
        e: o
      }) : s >= 1 ? m.push({
        s: s - 1,
        e: o - 1
      }) : (m.push({
        s,
        e: 1
      }), m.push({
        s: 0,
        e: o - 1
      }));
      var g = [], v, b = m.length, S;
      for (v = 0; v < b; v += 1)
        if (S = m[v], !(S.e * c < u || S.s * c > u + l)) {
          var E, P;
          S.s * c <= u ? E = 0 : E = (S.s * c - u) / l, S.e * c >= u + l ? P = 1 : P = (S.e * c - u) / l, g.push([E, P]);
        }
      return g.length || g.push([0, 0]), g;
    }, TrimModifier.prototype.releasePathsData = function(s) {
      var o, l = s.length;
      for (o = 0; o < l; o += 1)
        segmentsLengthPool.release(s[o]);
      return s.length = 0, s;
    }, TrimModifier.prototype.processShapes = function(s) {
      var o, l;
      if (this._mdf || s) {
        var u = this.o.v % 360 / 360;
        if (u < 0 && (u += 1), this.s.v > 1 ? o = 1 + u : this.s.v < 0 ? o = 0 + u : o = this.s.v + u, this.e.v > 1 ? l = 1 + u : this.e.v < 0 ? l = 0 + u : l = this.e.v + u, o > l) {
          var c = o;
          o = l, l = c;
        }
        o = Math.round(o * 1e4) * 1e-4, l = Math.round(l * 1e4) * 1e-4, this.sValue = o, this.eValue = l;
      } else
        o = this.sValue, l = this.eValue;
      var m, g, v = this.shapes.length, b, S, E, P, T, N = 0;
      if (l === o)
        for (g = 0; g < v; g += 1)
          this.shapes[g].localShapeCollection.releaseShapes(), this.shapes[g].shape._mdf = !0, this.shapes[g].shape.paths = this.shapes[g].localShapeCollection, this._mdf && (this.shapes[g].pathsData.length = 0);
      else if (l === 1 && o === 0 || l === 0 && o === 1) {
        if (this._mdf)
          for (g = 0; g < v; g += 1)
            this.shapes[g].pathsData.length = 0, this.shapes[g].shape._mdf = !0;
      } else {
        var O = [], z, Q;
        for (g = 0; g < v; g += 1)
          if (z = this.shapes[g], !z.shape._mdf && !this._mdf && !s && this.m !== 2)
            z.shape.paths = z.localShapeCollection;
          else {
            if (m = z.shape.paths, S = m._length, T = 0, !z.shape._mdf && z.pathsData.length)
              T = z.totalShapeLength;
            else {
              for (E = this.releasePathsData(z.pathsData), b = 0; b < S; b += 1)
                P = bez.getSegmentsLength(m.shapes[b]), E.push(P), T += P.totalLength;
              z.totalShapeLength = T, z.pathsData = E;
            }
            N += T, z.shape._mdf = !0;
          }
        var W = o, ue = l, te = 0, K;
        for (g = v - 1; g >= 0; g -= 1)
          if (z = this.shapes[g], z.shape._mdf) {
            for (Q = z.localShapeCollection, Q.releaseShapes(), this.m === 2 && v > 1 ? (K = this.calculateShapeEdges(o, l, z.totalShapeLength, te, N), te += z.totalShapeLength) : K = [[W, ue]], S = K.length, b = 0; b < S; b += 1) {
              W = K[b][0], ue = K[b][1], O.length = 0, ue <= 1 ? O.push({
                s: z.totalShapeLength * W,
                e: z.totalShapeLength * ue
              }) : W >= 1 ? O.push({
                s: z.totalShapeLength * (W - 1),
                e: z.totalShapeLength * (ue - 1)
              }) : (O.push({
                s: z.totalShapeLength * W,
                e: z.totalShapeLength
              }), O.push({
                s: 0,
                e: z.totalShapeLength * (ue - 1)
              }));
              var ve = this.addShapes(z, O[0]);
              if (O[0].s !== O[0].e) {
                if (O.length > 1) {
                  var ee = z.shape.paths.shapes[z.shape.paths._length - 1];
                  if (ee.c) {
                    var Re = ve.pop();
                    this.addPaths(ve, Q), ve = this.addShapes(z, O[1], Re);
                  } else
                    this.addPaths(ve, Q), ve = this.addShapes(z, O[1]);
                }
                this.addPaths(ve, Q);
              }
            }
            z.shape.paths = Q;
          }
      }
    }, TrimModifier.prototype.addPaths = function(s, o) {
      var l, u = s.length;
      for (l = 0; l < u; l += 1)
        o.addShape(s[l]);
    }, TrimModifier.prototype.addSegment = function(s, o, l, u, c, m, g) {
      c.setXYAt(o[0], o[1], "o", m), c.setXYAt(l[0], l[1], "i", m + 1), g && c.setXYAt(s[0], s[1], "v", m), c.setXYAt(u[0], u[1], "v", m + 1);
    }, TrimModifier.prototype.addSegmentFromArray = function(s, o, l, u) {
      o.setXYAt(s[1], s[5], "o", l), o.setXYAt(s[2], s[6], "i", l + 1), u && o.setXYAt(s[0], s[4], "v", l), o.setXYAt(s[3], s[7], "v", l + 1);
    }, TrimModifier.prototype.addShapes = function(s, o, l) {
      var u = s.pathsData, c = s.shape.paths.shapes, m, g = s.shape.paths._length, v, b, S = 0, E, P, T, N, O = [], z, Q = !0;
      for (l ? (P = l._length, z = l._length) : (l = shapePool.newElement(), P = 0, z = 0), O.push(l), m = 0; m < g; m += 1) {
        for (T = u[m].lengths, l.c = c[m].c, b = c[m].c ? T.length : T.length + 1, v = 1; v < b; v += 1)
          if (E = T[v - 1], S + E.addedLength < o.s)
            S += E.addedLength, l.c = !1;
          else if (S > o.e) {
            l.c = !1;
            break;
          } else
            o.s <= S && o.e >= S + E.addedLength ? (this.addSegment(c[m].v[v - 1], c[m].o[v - 1], c[m].i[v], c[m].v[v], l, P, Q), Q = !1) : (N = bez.getNewSegment(c[m].v[v - 1], c[m].v[v], c[m].o[v - 1], c[m].i[v], (o.s - S) / E.addedLength, (o.e - S) / E.addedLength, T[v - 1]), this.addSegmentFromArray(N, l, P, Q), Q = !1, l.c = !1), S += E.addedLength, P += 1;
        if (c[m].c && T.length) {
          if (E = T[v - 1], S <= o.e) {
            var W = T[v - 1].addedLength;
            o.s <= S && o.e >= S + W ? (this.addSegment(c[m].v[v - 1], c[m].o[v - 1], c[m].i[0], c[m].v[0], l, P, Q), Q = !1) : (N = bez.getNewSegment(c[m].v[v - 1], c[m].v[0], c[m].o[v - 1], c[m].i[0], (o.s - S) / W, (o.e - S) / W, T[v - 1]), this.addSegmentFromArray(N, l, P, Q), Q = !1, l.c = !1);
          } else
            l.c = !1;
          S += E.addedLength, P += 1;
        }
        if (l._length && (l.setXYAt(l.v[z][0], l.v[z][1], "i", z), l.setXYAt(l.v[l._length - 1][0], l.v[l._length - 1][1], "o", l._length - 1)), S > o.e)
          break;
        m < g - 1 && (l = shapePool.newElement(), Q = !0, O.push(l), P = 0);
      }
      return O;
    };
    function PuckerAndBloatModifier() {
    }
    extendPrototype([ShapeModifier], PuckerAndBloatModifier), PuckerAndBloatModifier.prototype.initModifierProperties = function(s, o) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(s, o.a, 0, null, this), this._isAnimated = !!this.amount.effectsSequence.length;
    }, PuckerAndBloatModifier.prototype.processPath = function(s, o) {
      var l = o / 100, u = [0, 0], c = s._length, m = 0;
      for (m = 0; m < c; m += 1)
        u[0] += s.v[m][0], u[1] += s.v[m][1];
      u[0] /= c, u[1] /= c;
      var g = shapePool.newElement();
      g.c = s.c;
      var v, b, S, E, P, T;
      for (m = 0; m < c; m += 1)
        v = s.v[m][0] + (u[0] - s.v[m][0]) * l, b = s.v[m][1] + (u[1] - s.v[m][1]) * l, S = s.o[m][0] + (u[0] - s.o[m][0]) * -l, E = s.o[m][1] + (u[1] - s.o[m][1]) * -l, P = s.i[m][0] + (u[0] - s.i[m][0]) * -l, T = s.i[m][1] + (u[1] - s.i[m][1]) * -l, g.setTripleAt(v, b, S, E, P, T, m);
      return g;
    }, PuckerAndBloatModifier.prototype.processShapes = function(s) {
      var o, l, u = this.shapes.length, c, m, g = this.amount.v;
      if (g !== 0) {
        var v, b;
        for (l = 0; l < u; l += 1) {
          if (v = this.shapes[l], b = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !s))
            for (b.releaseShapes(), v.shape._mdf = !0, o = v.shape.paths.shapes, m = v.shape.paths._length, c = 0; c < m; c += 1)
              b.addShape(this.processPath(o[c], g));
          v.shape.paths = v.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    var TransformPropertyFactory = function() {
      var s = [0, 0];
      function o(b) {
        var S = this._mdf;
        this.iterateDynamicProperties(), this._mdf = this._mdf || S, this.a && b.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.s && b.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && b.skewFromAxis(-this.sk.v, this.sa.v), this.r ? b.rotate(-this.r.v) : b.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.data.p.s ? this.data.p.z ? b.translate(this.px.v, this.py.v, -this.pz.v) : b.translate(this.px.v, this.py.v, 0) : b.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
      }
      function l(b) {
        if (this.elem.globalData.frameId !== this.frameId) {
          if (this._isDirty && (this.precalculateMatrix(), this._isDirty = !1), this.iterateDynamicProperties(), this._mdf || b) {
            var S;
            if (this.v.cloneFromProps(this.pre.props), this.appliedTransformations < 1 && this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations < 2 && this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.sk && this.appliedTransformations < 3 && this.v.skewFromAxis(-this.sk.v, this.sa.v), this.r && this.appliedTransformations < 4 ? this.v.rotate(-this.r.v) : !this.r && this.appliedTransformations < 4 && this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.autoOriented) {
              var E, P;
              if (S = this.elem.globalData.frameRate, this.p && this.p.keyframes && this.p.getValueAtTime)
                this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t ? (E = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / S, 0), P = this.p.getValueAtTime(this.p.keyframes[0].t / S, 0)) : this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t ? (E = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / S, 0), P = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / S, 0)) : (E = this.p.pv, P = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / S, this.p.offsetTime));
              else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {
                E = [], P = [];
                var T = this.px, N = this.py;
                T._caching.lastFrame + T.offsetTime <= T.keyframes[0].t ? (E[0] = T.getValueAtTime((T.keyframes[0].t + 0.01) / S, 0), E[1] = N.getValueAtTime((N.keyframes[0].t + 0.01) / S, 0), P[0] = T.getValueAtTime(T.keyframes[0].t / S, 0), P[1] = N.getValueAtTime(N.keyframes[0].t / S, 0)) : T._caching.lastFrame + T.offsetTime >= T.keyframes[T.keyframes.length - 1].t ? (E[0] = T.getValueAtTime(T.keyframes[T.keyframes.length - 1].t / S, 0), E[1] = N.getValueAtTime(N.keyframes[N.keyframes.length - 1].t / S, 0), P[0] = T.getValueAtTime((T.keyframes[T.keyframes.length - 1].t - 0.01) / S, 0), P[1] = N.getValueAtTime((N.keyframes[N.keyframes.length - 1].t - 0.01) / S, 0)) : (E = [T.pv, N.pv], P[0] = T.getValueAtTime((T._caching.lastFrame + T.offsetTime - 0.01) / S, T.offsetTime), P[1] = N.getValueAtTime((N._caching.lastFrame + N.offsetTime - 0.01) / S, N.offsetTime));
              } else
                P = s, E = P;
              this.v.rotate(-Math.atan2(E[1] - P[1], E[0] - P[0]));
            }
            this.data.p && this.data.p.s ? this.data.p.z ? this.v.translate(this.px.v, this.py.v, -this.pz.v) : this.v.translate(this.px.v, this.py.v, 0) : this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);
          }
          this.frameId = this.elem.globalData.frameId;
        }
      }
      function u() {
        if (this.appliedTransformations = 0, this.pre.reset(), !this.a.effectsSequence.length)
          this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]), this.appliedTransformations = 1;
        else
          return;
        if (!this.s.effectsSequence.length)
          this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]), this.appliedTransformations = 2;
        else
          return;
        if (this.sk)
          if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length)
            this.pre.skewFromAxis(-this.sk.v, this.sa.v), this.appliedTransformations = 3;
          else
            return;
        this.r ? this.r.effectsSequence.length || (this.pre.rotate(-this.r.v), this.appliedTransformations = 4) : !this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length && (this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]), this.appliedTransformations = 4);
      }
      function c() {
      }
      function m(b) {
        this._addDynamicProperty(b), this.elem.addDynamicProperty(b), this._isDirty = !0;
      }
      function g(b, S, E) {
        if (this.elem = b, this.frameId = -1, this.propType = "transform", this.data = S, this.v = new Matrix(), this.pre = new Matrix(), this.appliedTransformations = 0, this.initDynamicPropertyContainer(E || b), S.p && S.p.s ? (this.px = PropertyFactory.getProp(b, S.p.x, 0, 0, this), this.py = PropertyFactory.getProp(b, S.p.y, 0, 0, this), S.p.z && (this.pz = PropertyFactory.getProp(b, S.p.z, 0, 0, this))) : this.p = PropertyFactory.getProp(b, S.p || {
          k: [0, 0, 0]
        }, 1, 0, this), S.rx) {
          if (this.rx = PropertyFactory.getProp(b, S.rx, 0, degToRads, this), this.ry = PropertyFactory.getProp(b, S.ry, 0, degToRads, this), this.rz = PropertyFactory.getProp(b, S.rz, 0, degToRads, this), S.or.k[0].ti) {
            var P, T = S.or.k.length;
            for (P = 0; P < T; P += 1)
              S.or.k[P].to = null, S.or.k[P].ti = null;
          }
          this.or = PropertyFactory.getProp(b, S.or, 1, degToRads, this), this.or.sh = !0;
        } else
          this.r = PropertyFactory.getProp(b, S.r || {
            k: 0
          }, 0, degToRads, this);
        S.sk && (this.sk = PropertyFactory.getProp(b, S.sk, 0, degToRads, this), this.sa = PropertyFactory.getProp(b, S.sa, 0, degToRads, this)), this.a = PropertyFactory.getProp(b, S.a || {
          k: [0, 0, 0]
        }, 1, 0, this), this.s = PropertyFactory.getProp(b, S.s || {
          k: [100, 100, 100]
        }, 1, 0.01, this), S.o ? this.o = PropertyFactory.getProp(b, S.o, 0, 0.01, b) : this.o = {
          _mdf: !1,
          v: 1
        }, this._isDirty = !0, this.dynamicProperties.length || this.getValue(!0);
      }
      g.prototype = {
        applyToMatrix: o,
        getValue: l,
        precalculateMatrix: u,
        autoOrient: c
      }, extendPrototype([DynamicPropertyContainer], g), g.prototype.addDynamicProperty = m, g.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;
      function v(b, S, E) {
        return new g(b, S, E);
      }
      return {
        getTransformProperty: v
      };
    }();
    function RepeaterModifier() {
    }
    extendPrototype([ShapeModifier], RepeaterModifier), RepeaterModifier.prototype.initModifierProperties = function(s, o) {
      this.getValue = this.processKeys, this.c = PropertyFactory.getProp(s, o.c, 0, null, this), this.o = PropertyFactory.getProp(s, o.o, 0, null, this), this.tr = TransformPropertyFactory.getTransformProperty(s, o.tr, this), this.so = PropertyFactory.getProp(s, o.tr.so, 0, 0.01, this), this.eo = PropertyFactory.getProp(s, o.tr.eo, 0, 0.01, this), this.data = o, this.dynamicProperties.length || this.getValue(!0), this._isAnimated = !!this.dynamicProperties.length, this.pMatrix = new Matrix(), this.rMatrix = new Matrix(), this.sMatrix = new Matrix(), this.tMatrix = new Matrix(), this.matrix = new Matrix();
    }, RepeaterModifier.prototype.applyTransforms = function(s, o, l, u, c, m) {
      var g = m ? -1 : 1, v = u.s.v[0] + (1 - u.s.v[0]) * (1 - c), b = u.s.v[1] + (1 - u.s.v[1]) * (1 - c);
      s.translate(u.p.v[0] * g * c, u.p.v[1] * g * c, u.p.v[2]), o.translate(-u.a.v[0], -u.a.v[1], u.a.v[2]), o.rotate(-u.r.v * g * c), o.translate(u.a.v[0], u.a.v[1], u.a.v[2]), l.translate(-u.a.v[0], -u.a.v[1], u.a.v[2]), l.scale(m ? 1 / v : v, m ? 1 / b : b), l.translate(u.a.v[0], u.a.v[1], u.a.v[2]);
    }, RepeaterModifier.prototype.init = function(s, o, l, u) {
      for (this.elem = s, this.arr = o, this.pos = l, this.elemsData = u, this._currentCopies = 0, this._elements = [], this._groups = [], this.frameId = -1, this.initDynamicPropertyContainer(s), this.initModifierProperties(s, o[l]); l > 0; )
        l -= 1, this._elements.unshift(o[l]);
      this.dynamicProperties.length ? this.k = !0 : this.getValue(!0);
    }, RepeaterModifier.prototype.resetElements = function(s) {
      var o, l = s.length;
      for (o = 0; o < l; o += 1)
        s[o]._processed = !1, s[o].ty === "gr" && this.resetElements(s[o].it);
    }, RepeaterModifier.prototype.cloneElements = function(s) {
      var o = JSON.parse(JSON.stringify(s));
      return this.resetElements(o), o;
    }, RepeaterModifier.prototype.changeGroupRender = function(s, o) {
      var l, u = s.length;
      for (l = 0; l < u; l += 1)
        s[l]._render = o, s[l].ty === "gr" && this.changeGroupRender(s[l].it, o);
    }, RepeaterModifier.prototype.processShapes = function(s) {
      var o, l, u, c, m, g = !1;
      if (this._mdf || s) {
        var v = Math.ceil(this.c.v);
        if (this._groups.length < v) {
          for (; this._groups.length < v; ) {
            var b = {
              it: this.cloneElements(this._elements),
              ty: "gr"
            };
            b.it.push({
              a: {
                a: 0,
                ix: 1,
                k: [0, 0]
              },
              nm: "Transform",
              o: {
                a: 0,
                ix: 7,
                k: 100
              },
              p: {
                a: 0,
                ix: 2,
                k: [0, 0]
              },
              r: {
                a: 1,
                ix: 6,
                k: [{
                  s: 0,
                  e: 0,
                  t: 0
                }, {
                  s: 0,
                  e: 0,
                  t: 1
                }]
              },
              s: {
                a: 0,
                ix: 3,
                k: [100, 100]
              },
              sa: {
                a: 0,
                ix: 5,
                k: 0
              },
              sk: {
                a: 0,
                ix: 4,
                k: 0
              },
              ty: "tr"
            }), this.arr.splice(0, 0, b), this._groups.splice(0, 0, b), this._currentCopies += 1;
          }
          this.elem.reloadShapes(), g = !0;
        }
        m = 0;
        var S;
        for (u = 0; u <= this._groups.length - 1; u += 1) {
          if (S = m < v, this._groups[u]._render = S, this.changeGroupRender(this._groups[u].it, S), !S) {
            var E = this.elemsData[u].it, P = E[E.length - 1];
            P.transform.op.v !== 0 ? (P.transform.op._mdf = !0, P.transform.op.v = 0) : P.transform.op._mdf = !1;
          }
          m += 1;
        }
        this._currentCopies = v;
        var T = this.o.v, N = T % 1, O = T > 0 ? Math.floor(T) : Math.ceil(T), z = this.pMatrix.props, Q = this.rMatrix.props, W = this.sMatrix.props;
        this.pMatrix.reset(), this.rMatrix.reset(), this.sMatrix.reset(), this.tMatrix.reset(), this.matrix.reset();
        var ue = 0;
        if (T > 0) {
          for (; ue < O; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), ue += 1;
          N && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, N, !1), ue += N);
        } else if (T < 0) {
          for (; ue > O; )
            this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !0), ue -= 1;
          N && (this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -N, !0), ue -= N);
        }
        u = this.data.m === 1 ? 0 : this._currentCopies - 1, c = this.data.m === 1 ? 1 : -1, m = this._currentCopies;
        for (var te, K; m; ) {
          if (o = this.elemsData[u].it, l = o[o.length - 1].transform.mProps.v.props, K = l.length, o[o.length - 1].transform.mProps._mdf = !0, o[o.length - 1].transform.op._mdf = !0, o[o.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (u / (this._currentCopies - 1)), ue !== 0) {
            for ((u !== 0 && c === 1 || u !== this._currentCopies - 1 && c === -1) && this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, !1), this.matrix.transform(Q[0], Q[1], Q[2], Q[3], Q[4], Q[5], Q[6], Q[7], Q[8], Q[9], Q[10], Q[11], Q[12], Q[13], Q[14], Q[15]), this.matrix.transform(W[0], W[1], W[2], W[3], W[4], W[5], W[6], W[7], W[8], W[9], W[10], W[11], W[12], W[13], W[14], W[15]), this.matrix.transform(z[0], z[1], z[2], z[3], z[4], z[5], z[6], z[7], z[8], z[9], z[10], z[11], z[12], z[13], z[14], z[15]), te = 0; te < K; te += 1)
              l[te] = this.matrix.props[te];
            this.matrix.reset();
          } else
            for (this.matrix.reset(), te = 0; te < K; te += 1)
              l[te] = this.matrix.props[te];
          ue += 1, m -= 1, u += c;
        }
      } else
        for (m = this._currentCopies, u = 0, c = 1; m; )
          o = this.elemsData[u].it, l = o[o.length - 1].transform.mProps.v.props, o[o.length - 1].transform.mProps._mdf = !1, o[o.length - 1].transform.op._mdf = !1, m -= 1, u += c;
      return g;
    }, RepeaterModifier.prototype.addShape = function() {
    };
    function RoundCornersModifier() {
    }
    extendPrototype([ShapeModifier], RoundCornersModifier), RoundCornersModifier.prototype.initModifierProperties = function(s, o) {
      this.getValue = this.processKeys, this.rd = PropertyFactory.getProp(s, o.r, 0, null, this), this._isAnimated = !!this.rd.effectsSequence.length;
    }, RoundCornersModifier.prototype.processPath = function(s, o) {
      var l = shapePool.newElement();
      l.c = s.c;
      var u, c = s._length, m, g, v, b, S, E, P = 0, T, N, O, z, Q, W;
      for (u = 0; u < c; u += 1)
        m = s.v[u], v = s.o[u], g = s.i[u], m[0] === v[0] && m[1] === v[1] && m[0] === g[0] && m[1] === g[1] ? (u === 0 || u === c - 1) && !s.c ? (l.setTripleAt(m[0], m[1], v[0], v[1], g[0], g[1], P), P += 1) : (u === 0 ? b = s.v[c - 1] : b = s.v[u - 1], S = Math.sqrt(Math.pow(m[0] - b[0], 2) + Math.pow(m[1] - b[1], 2)), E = S ? Math.min(S / 2, o) / S : 0, Q = m[0] + (b[0] - m[0]) * E, T = Q, W = m[1] - (m[1] - b[1]) * E, N = W, O = T - (T - m[0]) * roundCorner, z = N - (N - m[1]) * roundCorner, l.setTripleAt(T, N, O, z, Q, W, P), P += 1, u === c - 1 ? b = s.v[0] : b = s.v[u + 1], S = Math.sqrt(Math.pow(m[0] - b[0], 2) + Math.pow(m[1] - b[1], 2)), E = S ? Math.min(S / 2, o) / S : 0, O = m[0] + (b[0] - m[0]) * E, T = O, z = m[1] + (b[1] - m[1]) * E, N = z, Q = T - (T - m[0]) * roundCorner, W = N - (N - m[1]) * roundCorner, l.setTripleAt(T, N, O, z, Q, W, P), P += 1) : (l.setTripleAt(s.v[u][0], s.v[u][1], s.o[u][0], s.o[u][1], s.i[u][0], s.i[u][1], P), P += 1);
      return l;
    }, RoundCornersModifier.prototype.processShapes = function(s) {
      var o, l, u = this.shapes.length, c, m, g = this.rd.v;
      if (g !== 0) {
        var v, b;
        for (l = 0; l < u; l += 1) {
          if (v = this.shapes[l], b = v.localShapeCollection, !(!v.shape._mdf && !this._mdf && !s))
            for (b.releaseShapes(), v.shape._mdf = !0, o = v.shape.paths.shapes, m = v.shape.paths._length, c = 0; c < m; c += 1)
              b.addShape(this.processPath(o[c], g));
          v.shape.paths = v.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function floatEqual(s, o) {
      return Math.abs(s - o) * 1e5 <= Math.min(Math.abs(s), Math.abs(o));
    }
    function floatZero(s) {
      return Math.abs(s) <= 1e-5;
    }
    function lerp(s, o, l) {
      return s * (1 - l) + o * l;
    }
    function lerpPoint(s, o, l) {
      return [lerp(s[0], o[0], l), lerp(s[1], o[1], l)];
    }
    function quadRoots(s, o, l) {
      if (s === 0) return [];
      var u = o * o - 4 * s * l;
      if (u < 0) return [];
      var c = -o / (2 * s);
      if (u === 0) return [c];
      var m = Math.sqrt(u) / (2 * s);
      return [c - m, c + m];
    }
    function polynomialCoefficients(s, o, l, u) {
      return [-s + 3 * o - 3 * l + u, 3 * s - 6 * o + 3 * l, -3 * s + 3 * o, s];
    }
    function singlePoint(s) {
      return new PolynomialBezier(s, s, s, s, !1);
    }
    function PolynomialBezier(s, o, l, u, c) {
      c && pointEqual(s, o) && (o = lerpPoint(s, u, 1 / 3)), c && pointEqual(l, u) && (l = lerpPoint(s, u, 2 / 3));
      var m = polynomialCoefficients(s[0], o[0], l[0], u[0]), g = polynomialCoefficients(s[1], o[1], l[1], u[1]);
      this.a = [m[0], g[0]], this.b = [m[1], g[1]], this.c = [m[2], g[2]], this.d = [m[3], g[3]], this.points = [s, o, l, u];
    }
    PolynomialBezier.prototype.point = function(s) {
      return [((this.a[0] * s + this.b[0]) * s + this.c[0]) * s + this.d[0], ((this.a[1] * s + this.b[1]) * s + this.c[1]) * s + this.d[1]];
    }, PolynomialBezier.prototype.derivative = function(s) {
      return [(3 * s * this.a[0] + 2 * this.b[0]) * s + this.c[0], (3 * s * this.a[1] + 2 * this.b[1]) * s + this.c[1]];
    }, PolynomialBezier.prototype.tangentAngle = function(s) {
      var o = this.derivative(s);
      return Math.atan2(o[1], o[0]);
    }, PolynomialBezier.prototype.normalAngle = function(s) {
      var o = this.derivative(s);
      return Math.atan2(o[0], o[1]);
    }, PolynomialBezier.prototype.inflectionPoints = function() {
      var s = this.a[1] * this.b[0] - this.a[0] * this.b[1];
      if (floatZero(s)) return [];
      var o = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / s, l = o * o - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / s;
      if (l < 0) return [];
      var u = Math.sqrt(l);
      return floatZero(u) ? u > 0 && u < 1 ? [o] : [] : [o - u, o + u].filter(function(c) {
        return c > 0 && c < 1;
      });
    }, PolynomialBezier.prototype.split = function(s) {
      if (s <= 0) return [singlePoint(this.points[0]), this];
      if (s >= 1) return [this, singlePoint(this.points[this.points.length - 1])];
      var o = lerpPoint(this.points[0], this.points[1], s), l = lerpPoint(this.points[1], this.points[2], s), u = lerpPoint(this.points[2], this.points[3], s), c = lerpPoint(o, l, s), m = lerpPoint(l, u, s), g = lerpPoint(c, m, s);
      return [new PolynomialBezier(this.points[0], o, c, g, !0), new PolynomialBezier(g, m, u, this.points[3], !0)];
    };
    function extrema(s, o) {
      var l = s.points[0][o], u = s.points[s.points.length - 1][o];
      if (l > u) {
        var c = u;
        u = l, l = c;
      }
      for (var m = quadRoots(3 * s.a[o], 2 * s.b[o], s.c[o]), g = 0; g < m.length; g += 1)
        if (m[g] > 0 && m[g] < 1) {
          var v = s.point(m[g])[o];
          v < l ? l = v : v > u && (u = v);
        }
      return {
        min: l,
        max: u
      };
    }
    PolynomialBezier.prototype.bounds = function() {
      return {
        x: extrema(this, 0),
        y: extrema(this, 1)
      };
    }, PolynomialBezier.prototype.boundingBox = function() {
      var s = this.bounds();
      return {
        left: s.x.min,
        right: s.x.max,
        top: s.y.min,
        bottom: s.y.max,
        width: s.x.max - s.x.min,
        height: s.y.max - s.y.min,
        cx: (s.x.max + s.x.min) / 2,
        cy: (s.y.max + s.y.min) / 2
      };
    };
    function intersectData(s, o, l) {
      var u = s.boundingBox();
      return {
        cx: u.cx,
        cy: u.cy,
        width: u.width,
        height: u.height,
        bez: s,
        t: (o + l) / 2,
        t1: o,
        t2: l
      };
    }
    function splitData(s) {
      var o = s.bez.split(0.5);
      return [intersectData(o[0], s.t1, s.t), intersectData(o[1], s.t, s.t2)];
    }
    function boxIntersect(s, o) {
      return Math.abs(s.cx - o.cx) * 2 < s.width + o.width && Math.abs(s.cy - o.cy) * 2 < s.height + o.height;
    }
    function intersectsImpl(s, o, l, u, c, m) {
      if (boxIntersect(s, o)) {
        if (l >= m || s.width <= u && s.height <= u && o.width <= u && o.height <= u) {
          c.push([s.t, o.t]);
          return;
        }
        var g = splitData(s), v = splitData(o);
        intersectsImpl(g[0], v[0], l + 1, u, c, m), intersectsImpl(g[0], v[1], l + 1, u, c, m), intersectsImpl(g[1], v[0], l + 1, u, c, m), intersectsImpl(g[1], v[1], l + 1, u, c, m);
      }
    }
    PolynomialBezier.prototype.intersections = function(s, o, l) {
      o === void 0 && (o = 2), l === void 0 && (l = 7);
      var u = [];
      return intersectsImpl(intersectData(this, 0, 1), intersectData(s, 0, 1), 0, o, u, l), u;
    }, PolynomialBezier.shapeSegment = function(s, o) {
      var l = (o + 1) % s.length();
      return new PolynomialBezier(s.v[o], s.o[o], s.i[l], s.v[l], !0);
    }, PolynomialBezier.shapeSegmentInverted = function(s, o) {
      var l = (o + 1) % s.length();
      return new PolynomialBezier(s.v[l], s.i[l], s.o[o], s.v[o], !0);
    };
    function crossProduct(s, o) {
      return [s[1] * o[2] - s[2] * o[1], s[2] * o[0] - s[0] * o[2], s[0] * o[1] - s[1] * o[0]];
    }
    function lineIntersection(s, o, l, u) {
      var c = [s[0], s[1], 1], m = [o[0], o[1], 1], g = [l[0], l[1], 1], v = [u[0], u[1], 1], b = crossProduct(crossProduct(c, m), crossProduct(g, v));
      return floatZero(b[2]) ? null : [b[0] / b[2], b[1] / b[2]];
    }
    function polarOffset(s, o, l) {
      return [s[0] + Math.cos(o) * l, s[1] - Math.sin(o) * l];
    }
    function pointDistance(s, o) {
      return Math.hypot(s[0] - o[0], s[1] - o[1]);
    }
    function pointEqual(s, o) {
      return floatEqual(s[0], o[0]) && floatEqual(s[1], o[1]);
    }
    function ZigZagModifier() {
    }
    extendPrototype([ShapeModifier], ZigZagModifier), ZigZagModifier.prototype.initModifierProperties = function(s, o) {
      this.getValue = this.processKeys, this.amplitude = PropertyFactory.getProp(s, o.s, 0, null, this), this.frequency = PropertyFactory.getProp(s, o.r, 0, null, this), this.pointsType = PropertyFactory.getProp(s, o.pt, 0, null, this), this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;
    };
    function setPoint(s, o, l, u, c, m, g) {
      var v = l - Math.PI / 2, b = l + Math.PI / 2, S = o[0] + Math.cos(l) * u * c, E = o[1] - Math.sin(l) * u * c;
      s.setTripleAt(S, E, S + Math.cos(v) * m, E - Math.sin(v) * m, S + Math.cos(b) * g, E - Math.sin(b) * g, s.length());
    }
    function getPerpendicularVector(s, o) {
      var l = [o[0] - s[0], o[1] - s[1]], u = -Math.PI * 0.5, c = [Math.cos(u) * l[0] - Math.sin(u) * l[1], Math.sin(u) * l[0] + Math.cos(u) * l[1]];
      return c;
    }
    function getProjectingAngle(s, o) {
      var l = o === 0 ? s.length() - 1 : o - 1, u = (o + 1) % s.length(), c = s.v[l], m = s.v[u], g = getPerpendicularVector(c, m);
      return Math.atan2(0, 1) - Math.atan2(g[1], g[0]);
    }
    function zigZagCorner(s, o, l, u, c, m, g) {
      var v = getProjectingAngle(o, l), b = o.v[l % o._length], S = o.v[l === 0 ? o._length - 1 : l - 1], E = o.v[(l + 1) % o._length], P = m === 2 ? Math.sqrt(Math.pow(b[0] - S[0], 2) + Math.pow(b[1] - S[1], 2)) : 0, T = m === 2 ? Math.sqrt(Math.pow(b[0] - E[0], 2) + Math.pow(b[1] - E[1], 2)) : 0;
      setPoint(s, o.v[l % o._length], v, g, u, T / ((c + 1) * 2), P / ((c + 1) * 2));
    }
    function zigZagSegment(s, o, l, u, c, m) {
      for (var g = 0; g < u; g += 1) {
        var v = (g + 1) / (u + 1), b = c === 2 ? Math.sqrt(Math.pow(o.points[3][0] - o.points[0][0], 2) + Math.pow(o.points[3][1] - o.points[0][1], 2)) : 0, S = o.normalAngle(v), E = o.point(v);
        setPoint(s, E, S, m, l, b / ((u + 1) * 2), b / ((u + 1) * 2)), m = -m;
      }
      return m;
    }
    ZigZagModifier.prototype.processPath = function(s, o, l, u) {
      var c = s._length, m = shapePool.newElement();
      if (m.c = s.c, s.c || (c -= 1), c === 0) return m;
      var g = -1, v = PolynomialBezier.shapeSegment(s, 0);
      zigZagCorner(m, s, 0, o, l, u, g);
      for (var b = 0; b < c; b += 1)
        g = zigZagSegment(m, v, o, l, u, -g), b === c - 1 && !s.c ? v = null : v = PolynomialBezier.shapeSegment(s, (b + 1) % c), zigZagCorner(m, s, b + 1, o, l, u, g);
      return m;
    }, ZigZagModifier.prototype.processShapes = function(s) {
      var o, l, u = this.shapes.length, c, m, g = this.amplitude.v, v = Math.max(0, Math.round(this.frequency.v)), b = this.pointsType.v;
      if (g !== 0) {
        var S, E;
        for (l = 0; l < u; l += 1) {
          if (S = this.shapes[l], E = S.localShapeCollection, !(!S.shape._mdf && !this._mdf && !s))
            for (E.releaseShapes(), S.shape._mdf = !0, o = S.shape.paths.shapes, m = S.shape.paths._length, c = 0; c < m; c += 1)
              E.addShape(this.processPath(o[c], g, v, b));
          S.shape.paths = S.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function linearOffset(s, o, l) {
      var u = Math.atan2(o[0] - s[0], o[1] - s[1]);
      return [polarOffset(s, u, l), polarOffset(o, u, l)];
    }
    function offsetSegment(s, o) {
      var l, u, c, m, g, v, b;
      b = linearOffset(s.points[0], s.points[1], o), l = b[0], u = b[1], b = linearOffset(s.points[1], s.points[2], o), c = b[0], m = b[1], b = linearOffset(s.points[2], s.points[3], o), g = b[0], v = b[1];
      var S = lineIntersection(l, u, c, m);
      S === null && (S = u);
      var E = lineIntersection(g, v, c, m);
      return E === null && (E = g), new PolynomialBezier(l, S, E, v);
    }
    function joinLines(s, o, l, u, c) {
      var m = o.points[3], g = l.points[0];
      if (u === 3 || pointEqual(m, g)) return m;
      if (u === 2) {
        var v = -o.tangentAngle(1), b = -l.tangentAngle(0) + Math.PI, S = lineIntersection(m, polarOffset(m, v + Math.PI / 2, 100), g, polarOffset(g, v + Math.PI / 2, 100)), E = S ? pointDistance(S, m) : pointDistance(m, g) / 2, P = polarOffset(m, v, 2 * E * roundCorner);
        return s.setXYAt(P[0], P[1], "o", s.length() - 1), P = polarOffset(g, b, 2 * E * roundCorner), s.setTripleAt(g[0], g[1], g[0], g[1], P[0], P[1], s.length()), g;
      }
      var T = pointEqual(m, o.points[2]) ? o.points[0] : o.points[2], N = pointEqual(g, l.points[1]) ? l.points[3] : l.points[1], O = lineIntersection(T, m, g, N);
      return O && pointDistance(O, m) < c ? (s.setTripleAt(O[0], O[1], O[0], O[1], O[0], O[1], s.length()), O) : m;
    }
    function getIntersection(s, o) {
      var l = s.intersections(o);
      return l.length && floatEqual(l[0][0], 1) && l.shift(), l.length ? l[0] : null;
    }
    function pruneSegmentIntersection(s, o) {
      var l = s.slice(), u = o.slice(), c = getIntersection(s[s.length - 1], o[0]);
      return c && (l[s.length - 1] = s[s.length - 1].split(c[0])[0], u[0] = o[0].split(c[1])[1]), s.length > 1 && o.length > 1 && (c = getIntersection(s[0], o[o.length - 1]), c) ? [[s[0].split(c[0])[0]], [o[o.length - 1].split(c[1])[1]]] : [l, u];
    }
    function pruneIntersections(s) {
      for (var o, l = 1; l < s.length; l += 1)
        o = pruneSegmentIntersection(s[l - 1], s[l]), s[l - 1] = o[0], s[l] = o[1];
      return s.length > 1 && (o = pruneSegmentIntersection(s[s.length - 1], s[0]), s[s.length - 1] = o[0], s[0] = o[1]), s;
    }
    function offsetSegmentSplit(s, o) {
      var l = s.inflectionPoints(), u, c, m, g;
      if (l.length === 0)
        return [offsetSegment(s, o)];
      if (l.length === 1 || floatEqual(l[1], 1))
        return m = s.split(l[0]), u = m[0], c = m[1], [offsetSegment(u, o), offsetSegment(c, o)];
      m = s.split(l[0]), u = m[0];
      var v = (l[1] - l[0]) / (1 - l[0]);
      return m = m[1].split(v), g = m[0], c = m[1], [offsetSegment(u, o), offsetSegment(g, o), offsetSegment(c, o)];
    }
    function OffsetPathModifier() {
    }
    extendPrototype([ShapeModifier], OffsetPathModifier), OffsetPathModifier.prototype.initModifierProperties = function(s, o) {
      this.getValue = this.processKeys, this.amount = PropertyFactory.getProp(s, o.a, 0, null, this), this.miterLimit = PropertyFactory.getProp(s, o.ml, 0, null, this), this.lineJoin = o.lj, this._isAnimated = this.amount.effectsSequence.length !== 0;
    }, OffsetPathModifier.prototype.processPath = function(s, o, l, u) {
      var c = shapePool.newElement();
      c.c = s.c;
      var m = s.length();
      s.c || (m -= 1);
      var g, v, b, S = [];
      for (g = 0; g < m; g += 1)
        b = PolynomialBezier.shapeSegment(s, g), S.push(offsetSegmentSplit(b, o));
      if (!s.c)
        for (g = m - 1; g >= 0; g -= 1)
          b = PolynomialBezier.shapeSegmentInverted(s, g), S.push(offsetSegmentSplit(b, o));
      S = pruneIntersections(S);
      var E = null, P = null;
      for (g = 0; g < S.length; g += 1) {
        var T = S[g];
        for (P && (E = joinLines(c, P, T[0], l, u)), P = T[T.length - 1], v = 0; v < T.length; v += 1)
          b = T[v], E && pointEqual(b.points[0], E) ? c.setXYAt(b.points[1][0], b.points[1][1], "o", c.length() - 1) : c.setTripleAt(b.points[0][0], b.points[0][1], b.points[1][0], b.points[1][1], b.points[0][0], b.points[0][1], c.length()), c.setTripleAt(b.points[3][0], b.points[3][1], b.points[3][0], b.points[3][1], b.points[2][0], b.points[2][1], c.length()), E = b.points[3];
      }
      return S.length && joinLines(c, P, S[0][0], l, u), c;
    }, OffsetPathModifier.prototype.processShapes = function(s) {
      var o, l, u = this.shapes.length, c, m, g = this.amount.v, v = this.miterLimit.v, b = this.lineJoin;
      if (g !== 0) {
        var S, E;
        for (l = 0; l < u; l += 1) {
          if (S = this.shapes[l], E = S.localShapeCollection, !(!S.shape._mdf && !this._mdf && !s))
            for (E.releaseShapes(), S.shape._mdf = !0, o = S.shape.paths.shapes, m = S.shape.paths._length, c = 0; c < m; c += 1)
              E.addShape(this.processPath(o[c], g, b, v));
          S.shape.paths = S.localShapeCollection;
        }
      }
      this.dynamicProperties.length || (this._mdf = !1);
    };
    function getFontProperties(s) {
      for (var o = s.fStyle ? s.fStyle.split(" ") : [], l = "normal", u = "normal", c = o.length, m, g = 0; g < c; g += 1)
        switch (m = o[g].toLowerCase(), m) {
          case "italic":
            u = "italic";
            break;
          case "bold":
            l = "700";
            break;
          case "black":
            l = "900";
            break;
          case "medium":
            l = "500";
            break;
          case "regular":
          case "normal":
            l = "400";
            break;
          case "light":
          case "thin":
            l = "200";
            break;
        }
      return {
        style: u,
        weight: s.fWeight || l
      };
    }
    var FontManager = function() {
      var s = 5e3, o = {
        w: 0,
        size: 0,
        shapes: [],
        data: {
          shapes: []
        }
      }, l = [];
      l = l.concat([2304, 2305, 2306, 2307, 2362, 2363, 2364, 2364, 2366, 2367, 2368, 2369, 2370, 2371, 2372, 2373, 2374, 2375, 2376, 2377, 2378, 2379, 2380, 2381, 2382, 2383, 2387, 2388, 2389, 2390, 2391, 2402, 2403]);
      var u = 127988, c = 917631, m = 917601, g = 917626, v = 65039, b = 8205, S = 127462, E = 127487, P = ["d83cdffb", "d83cdffc", "d83cdffd", "d83cdffe", "d83cdfff"];
      function T(Gt) {
        var nn = Gt.split(","), vt, Et = nn.length, Qt = [];
        for (vt = 0; vt < Et; vt += 1)
          nn[vt] !== "sans-serif" && nn[vt] !== "monospace" && Qt.push(nn[vt]);
        return Qt.join(",");
      }
      function N(Gt, nn) {
        var vt = createTag("span");
        vt.setAttribute("aria-hidden", !0), vt.style.fontFamily = nn;
        var Et = createTag("span");
        Et.innerText = "giItT1WQy@!-/#", vt.style.position = "absolute", vt.style.left = "-10000px", vt.style.top = "-10000px", vt.style.fontSize = "300px", vt.style.fontVariant = "normal", vt.style.fontStyle = "normal", vt.style.fontWeight = "normal", vt.style.letterSpacing = "0", vt.appendChild(Et), document.body.appendChild(vt);
        var Qt = Et.offsetWidth;
        return Et.style.fontFamily = T(Gt) + ", " + nn, {
          node: Et,
          w: Qt,
          parent: vt
        };
      }
      function O() {
        var Gt, nn = this.fonts.length, vt, Et, Qt = nn;
        for (Gt = 0; Gt < nn; Gt += 1)
          this.fonts[Gt].loaded ? Qt -= 1 : this.fonts[Gt].fOrigin === "n" || this.fonts[Gt].origin === 0 ? this.fonts[Gt].loaded = !0 : (vt = this.fonts[Gt].monoCase.node, Et = this.fonts[Gt].monoCase.w, vt.offsetWidth !== Et ? (Qt -= 1, this.fonts[Gt].loaded = !0) : (vt = this.fonts[Gt].sansCase.node, Et = this.fonts[Gt].sansCase.w, vt.offsetWidth !== Et && (Qt -= 1, this.fonts[Gt].loaded = !0)), this.fonts[Gt].loaded && (this.fonts[Gt].sansCase.parent.parentNode.removeChild(this.fonts[Gt].sansCase.parent), this.fonts[Gt].monoCase.parent.parentNode.removeChild(this.fonts[Gt].monoCase.parent)));
        Qt !== 0 && Date.now() - this.initTime < s ? setTimeout(this.checkLoadedFontsBinded, 20) : setTimeout(this.setIsLoadedBinded, 10);
      }
      function z(Gt, nn) {
        var vt = document.body && nn ? "svg" : "canvas", Et, Qt = getFontProperties(Gt);
        if (vt === "svg") {
          var un = createNS("text");
          un.style.fontSize = "100px", un.setAttribute("font-family", Gt.fFamily), un.setAttribute("font-style", Qt.style), un.setAttribute("font-weight", Qt.weight), un.textContent = "1", Gt.fClass ? (un.style.fontFamily = "inherit", un.setAttribute("class", Gt.fClass)) : un.style.fontFamily = Gt.fFamily, nn.appendChild(un), Et = un;
        } else {
          var gn = new OffscreenCanvas(500, 500).getContext("2d");
          gn.font = Qt.style + " " + Qt.weight + " 100px " + Gt.fFamily, Et = gn;
        }
        function dn(yn) {
          return vt === "svg" ? (Et.textContent = yn, Et.getComputedTextLength()) : Et.measureText(yn).width;
        }
        return {
          measureText: dn
        };
      }
      function Q(Gt, nn) {
        if (!Gt) {
          this.isLoaded = !0;
          return;
        }
        if (this.chars) {
          this.isLoaded = !0, this.fonts = Gt.list;
          return;
        }
        if (!document.body) {
          this.isLoaded = !0, Gt.list.forEach(function(_n) {
            _n.helper = z(_n), _n.cache = {};
          }), this.fonts = Gt.list;
          return;
        }
        var vt = Gt.list, Et, Qt = vt.length, un = Qt;
        for (Et = 0; Et < Qt; Et += 1) {
          var gn = !0, dn, yn;
          if (vt[Et].loaded = !1, vt[Et].monoCase = N(vt[Et].fFamily, "monospace"), vt[Et].sansCase = N(vt[Et].fFamily, "sans-serif"), !vt[Et].fPath)
            vt[Et].loaded = !0, un -= 1;
          else if (vt[Et].fOrigin === "p" || vt[Et].origin === 3) {
            if (dn = document.querySelectorAll('style[f-forigin="p"][f-family="' + vt[Et].fFamily + '"], style[f-origin="3"][f-family="' + vt[Et].fFamily + '"]'), dn.length > 0 && (gn = !1), gn) {
              var vn = createTag("style");
              vn.setAttribute("f-forigin", vt[Et].fOrigin), vn.setAttribute("f-origin", vt[Et].origin), vn.setAttribute("f-family", vt[Et].fFamily), vn.type = "text/css", vn.innerText = "@font-face {font-family: " + vt[Et].fFamily + "; font-style: normal; src: url('" + vt[Et].fPath + "');}", nn.appendChild(vn);
            }
          } else if (vt[Et].fOrigin === "g" || vt[Et].origin === 1) {
            for (dn = document.querySelectorAll('link[f-forigin="g"], link[f-origin="1"]'), yn = 0; yn < dn.length; yn += 1)
              dn[yn].href.indexOf(vt[Et].fPath) !== -1 && (gn = !1);
            if (gn) {
              var Pn = createTag("link");
              Pn.setAttribute("f-forigin", vt[Et].fOrigin), Pn.setAttribute("f-origin", vt[Et].origin), Pn.type = "text/css", Pn.rel = "stylesheet", Pn.href = vt[Et].fPath, document.body.appendChild(Pn);
            }
          } else if (vt[Et].fOrigin === "t" || vt[Et].origin === 2) {
            for (dn = document.querySelectorAll('script[f-forigin="t"], script[f-origin="2"]'), yn = 0; yn < dn.length; yn += 1)
              vt[Et].fPath === dn[yn].src && (gn = !1);
            if (gn) {
              var On = createTag("link");
              On.setAttribute("f-forigin", vt[Et].fOrigin), On.setAttribute("f-origin", vt[Et].origin), On.setAttribute("rel", "stylesheet"), On.setAttribute("href", vt[Et].fPath), nn.appendChild(On);
            }
          }
          vt[Et].helper = z(vt[Et], nn), vt[Et].cache = {}, this.fonts.push(vt[Et]);
        }
        un === 0 ? this.isLoaded = !0 : setTimeout(this.checkLoadedFonts.bind(this), 100);
      }
      function W(Gt) {
        if (Gt) {
          this.chars || (this.chars = []);
          var nn, vt = Gt.length, Et, Qt = this.chars.length, un;
          for (nn = 0; nn < vt; nn += 1) {
            for (Et = 0, un = !1; Et < Qt; )
              this.chars[Et].style === Gt[nn].style && this.chars[Et].fFamily === Gt[nn].fFamily && this.chars[Et].ch === Gt[nn].ch && (un = !0), Et += 1;
            un || (this.chars.push(Gt[nn]), Qt += 1);
          }
        }
      }
      function ue(Gt, nn, vt) {
        for (var Et = 0, Qt = this.chars.length; Et < Qt; ) {
          if (this.chars[Et].ch === Gt && this.chars[Et].style === nn && this.chars[Et].fFamily === vt)
            return this.chars[Et];
          Et += 1;
        }
        return (typeof Gt == "string" && Gt.charCodeAt(0) !== 13 || !Gt) && console && console.warn && !this._warned && (this._warned = !0, console.warn("Missing character from exported characters list: ", Gt, nn, vt)), o;
      }
      function te(Gt, nn, vt) {
        var Et = this.getFontByName(nn), Qt = Gt;
        if (!Et.cache[Qt]) {
          var un = Et.helper;
          if (Gt === " ") {
            var gn = un.measureText("|" + Gt + "|"), dn = un.measureText("||");
            Et.cache[Qt] = (gn - dn) / 100;
          } else
            Et.cache[Qt] = un.measureText(Gt) / 100;
        }
        return Et.cache[Qt] * vt;
      }
      function K(Gt) {
        for (var nn = 0, vt = this.fonts.length; nn < vt; ) {
          if (this.fonts[nn].fName === Gt)
            return this.fonts[nn];
          nn += 1;
        }
        return this.fonts[0];
      }
      function ve(Gt) {
        var nn = 0, vt = Gt.charCodeAt(0);
        if (vt >= 55296 && vt <= 56319) {
          var Et = Gt.charCodeAt(1);
          Et >= 56320 && Et <= 57343 && (nn = (vt - 55296) * 1024 + Et - 56320 + 65536);
        }
        return nn;
      }
      function ee(Gt, nn) {
        var vt = Gt.toString(16) + nn.toString(16);
        return P.indexOf(vt) !== -1;
      }
      function Re(Gt) {
        return Gt === b;
      }
      function wt(Gt) {
        return Gt === v;
      }
      function yt(Gt) {
        var nn = ve(Gt);
        return nn >= S && nn <= E;
      }
      function xt(Gt) {
        return yt(Gt.substr(0, 2)) && yt(Gt.substr(2, 2));
      }
      function Kt(Gt) {
        return l.indexOf(Gt) !== -1;
      }
      function tn(Gt, nn) {
        var vt = ve(Gt.substr(nn, 2));
        if (vt !== u)
          return !1;
        var Et = 0;
        for (nn += 2; Et < 5; ) {
          if (vt = ve(Gt.substr(nn, 2)), vt < m || vt > g)
            return !1;
          Et += 1, nn += 2;
        }
        return ve(Gt.substr(nn, 2)) === c;
      }
      function ln() {
        this.isLoaded = !0;
      }
      var rn = function() {
        this.fonts = [], this.chars = null, this.typekitLoaded = 0, this.isLoaded = !1, this._warned = !1, this.initTime = Date.now(), this.setIsLoadedBinded = this.setIsLoaded.bind(this), this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);
      };
      rn.isModifier = ee, rn.isZeroWidthJoiner = Re, rn.isFlagEmoji = xt, rn.isRegionalCode = yt, rn.isCombinedCharacter = Kt, rn.isRegionalFlag = tn, rn.isVariationSelector = wt, rn.BLACK_FLAG_CODE_POINT = u;
      var an = {
        addChars: W,
        addFonts: Q,
        getCharData: ue,
        getFontByName: K,
        measureText: te,
        checkLoadedFonts: O,
        setIsLoaded: ln
      };
      return rn.prototype = an, rn;
    }();
    function SlotManager(s) {
      this.animationData = s;
    }
    SlotManager.prototype.getProp = function(s) {
      return this.animationData.slots && this.animationData.slots[s.sid] ? Object.assign(s, this.animationData.slots[s.sid].p) : s;
    };
    function slotFactory(s) {
      return new SlotManager(s);
    }
    function RenderableElement() {
    }
    RenderableElement.prototype = {
      initRenderable: function() {
        this.isInRange = !1, this.hidden = !1, this.isTransparent = !1, this.renderableComponents = [];
      },
      addRenderableComponent: function(o) {
        this.renderableComponents.indexOf(o) === -1 && this.renderableComponents.push(o);
      },
      removeRenderableComponent: function(o) {
        this.renderableComponents.indexOf(o) !== -1 && this.renderableComponents.splice(this.renderableComponents.indexOf(o), 1);
      },
      prepareRenderableFrame: function(o) {
        this.checkLayerLimits(o);
      },
      checkTransparency: function() {
        this.finalTransform.mProp.o.v <= 0 ? !this.isTransparent && this.globalData.renderConfig.hideOnTransparent && (this.isTransparent = !0, this.hide()) : this.isTransparent && (this.isTransparent = !1, this.show());
      },
      /**
         * @function
         * Initializes frame related properties.
         *
         * @param {number} num
         * current frame number in Layer's time
         *
         */
      checkLayerLimits: function(o) {
        this.data.ip - this.data.st <= o && this.data.op - this.data.st > o ? this.isInRange !== !0 && (this.globalData._mdf = !0, this._mdf = !0, this.isInRange = !0, this.show()) : this.isInRange !== !1 && (this.globalData._mdf = !0, this.isInRange = !1, this.hide());
      },
      renderRenderable: function() {
        var o, l = this.renderableComponents.length;
        for (o = 0; o < l; o += 1)
          this.renderableComponents[o].renderFrame(this._isFirstFrame);
      },
      sourceRectAtTime: function() {
        return {
          top: 0,
          left: 0,
          width: 100,
          height: 100
        };
      },
      getLayerSize: function() {
        return this.data.ty === 5 ? {
          w: this.data.textData.width,
          h: this.data.textData.height
        } : {
          w: this.data.width,
          h: this.data.height
        };
      }
    };
    var getBlendMode = /* @__PURE__ */ function() {
      var s = {
        0: "source-over",
        1: "multiply",
        2: "screen",
        3: "overlay",
        4: "darken",
        5: "lighten",
        6: "color-dodge",
        7: "color-burn",
        8: "hard-light",
        9: "soft-light",
        10: "difference",
        11: "exclusion",
        12: "hue",
        13: "saturation",
        14: "color",
        15: "luminosity"
      };
      return function(o) {
        return s[o] || "";
      };
    }();
    function SliderEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 0, 0, l);
    }
    function AngleEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 0, 0, l);
    }
    function ColorEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 1, 0, l);
    }
    function PointEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 1, 0, l);
    }
    function LayerIndexEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 0, 0, l);
    }
    function MaskIndexEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 0, 0, l);
    }
    function CheckboxEffect(s, o, l) {
      this.p = PropertyFactory.getProp(o, s.v, 0, 0, l);
    }
    function NoValueEffect() {
      this.p = {};
    }
    function EffectsManager(s, o) {
      var l = s.ef || [];
      this.effectElements = [];
      var u, c = l.length, m;
      for (u = 0; u < c; u += 1)
        m = new GroupEffect(l[u], o), this.effectElements.push(m);
    }
    function GroupEffect(s, o) {
      this.init(s, o);
    }
    extendPrototype([DynamicPropertyContainer], GroupEffect), GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties, GroupEffect.prototype.init = function(s, o) {
      this.data = s, this.effectElements = [], this.initDynamicPropertyContainer(o);
      var l, u = this.data.ef.length, c, m = this.data.ef;
      for (l = 0; l < u; l += 1) {
        switch (c = null, m[l].ty) {
          case 0:
            c = new SliderEffect(m[l], o, this);
            break;
          case 1:
            c = new AngleEffect(m[l], o, this);
            break;
          case 2:
            c = new ColorEffect(m[l], o, this);
            break;
          case 3:
            c = new PointEffect(m[l], o, this);
            break;
          case 4:
          case 7:
            c = new CheckboxEffect(m[l], o, this);
            break;
          case 10:
            c = new LayerIndexEffect(m[l], o, this);
            break;
          case 11:
            c = new MaskIndexEffect(m[l], o, this);
            break;
          case 5:
            c = new EffectsManager(m[l], o);
            break;
          default:
            c = new NoValueEffect(m[l]);
            break;
        }
        c && this.effectElements.push(c);
      }
    };
    function BaseElement() {
    }
    BaseElement.prototype = {
      checkMasks: function() {
        if (!this.data.hasMask)
          return !1;
        for (var o = 0, l = this.data.masksProperties.length; o < l; ) {
          if (this.data.masksProperties[o].mode !== "n" && this.data.masksProperties[o].cl !== !1)
            return !0;
          o += 1;
        }
        return !1;
      },
      initExpressions: function() {
        var o = getExpressionInterfaces();
        if (o) {
          var l = o("layer"), u = o("effects"), c = o("shape"), m = o("text"), g = o("comp");
          this.layerInterface = l(this), this.data.hasMask && this.maskManager && this.layerInterface.registerMaskInterface(this.maskManager);
          var v = u.createEffectsInterface(this, this.layerInterface);
          this.layerInterface.registerEffectsInterface(v), this.data.ty === 0 || this.data.xt ? this.compInterface = g(this) : this.data.ty === 4 ? (this.layerInterface.shapeInterface = c(this.shapesData, this.itemsData, this.layerInterface), this.layerInterface.content = this.layerInterface.shapeInterface) : this.data.ty === 5 && (this.layerInterface.textInterface = m(this), this.layerInterface.text = this.layerInterface.textInterface);
        }
      },
      setBlendMode: function() {
        var o = getBlendMode(this.data.bm), l = this.baseElement || this.layerElement;
        l.style["mix-blend-mode"] = o;
      },
      initBaseData: function(o, l, u) {
        this.globalData = l, this.comp = u, this.data = o, this.layerId = createElementID(), this.data.sr || (this.data.sr = 1), this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);
      },
      getType: function() {
        return this.type;
      },
      sourceRectAtTime: function() {
      }
    };
    function FrameElement() {
    }
    FrameElement.prototype = {
      /**
         * @function
         * Initializes frame related properties.
         *
         */
      initFrame: function() {
        this._isFirstFrame = !1, this.dynamicProperties = [], this._mdf = !1;
      },
      /**
         * @function
         * Calculates all dynamic values
         *
         * @param {number} num
         * current frame number in Layer's time
         * @param {boolean} isVisible
         * if layers is currently in range
         *
         */
      prepareProperties: function(o, l) {
        var u, c = this.dynamicProperties.length;
        for (u = 0; u < c; u += 1)
          (l || this._isParent && this.dynamicProperties[u].propType === "transform") && (this.dynamicProperties[u].getValue(), this.dynamicProperties[u]._mdf && (this.globalData._mdf = !0, this._mdf = !0));
      },
      addDynamicProperty: function(o) {
        this.dynamicProperties.indexOf(o) === -1 && this.dynamicProperties.push(o);
      }
    };
    function FootageElement(s, o, l) {
      this.initFrame(), this.initRenderable(), this.assetData = o.getAssetData(s.refId), this.footageData = o.imageLoader.getAsset(this.assetData), this.initBaseData(s, o, l);
    }
    FootageElement.prototype.prepareFrame = function() {
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], FootageElement), FootageElement.prototype.getBaseElement = function() {
      return null;
    }, FootageElement.prototype.renderFrame = function() {
    }, FootageElement.prototype.destroy = function() {
    }, FootageElement.prototype.initExpressions = function() {
      var s = getExpressionInterfaces();
      if (s) {
        var o = s("footage");
        this.layerInterface = o(this);
      }
    }, FootageElement.prototype.getFootageData = function() {
      return this.footageData;
    };
    function AudioElement(s, o, l) {
      this.initFrame(), this.initRenderable(), this.assetData = o.getAssetData(s.refId), this.initBaseData(s, o, l), this._isPlaying = !1, this._canPlay = !1;
      var u = this.globalData.getAssetsPath(this.assetData);
      this.audio = this.globalData.audioController.createAudio(u), this._currentTime = 0, this.globalData.audioController.addAudio(this), this._volumeMultiplier = 1, this._volume = 1, this._previousVolume = null, this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, o.frameRate, this) : {
        _placeholder: !0
      }, this.lv = PropertyFactory.getProp(this, s.au && s.au.lv ? s.au.lv : {
        k: [100]
      }, 1, 0.01, this);
    }
    AudioElement.prototype.prepareFrame = function(s) {
      if (this.prepareRenderableFrame(s, !0), this.prepareProperties(s, !0), this.tm._placeholder)
        this._currentTime = s / this.data.sr;
      else {
        var o = this.tm.v;
        this._currentTime = o;
      }
      this._volume = this.lv.v[0];
      var l = this._volume * this._volumeMultiplier;
      this._previousVolume !== l && (this._previousVolume = l, this.audio.volume(l));
    }, extendPrototype([RenderableElement, BaseElement, FrameElement], AudioElement), AudioElement.prototype.renderFrame = function() {
      this.isInRange && this._canPlay && (this._isPlaying ? (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) && this.audio.seek(this._currentTime / this.globalData.frameRate) : (this.audio.play(), this.audio.seek(this._currentTime / this.globalData.frameRate), this._isPlaying = !0));
    }, AudioElement.prototype.show = function() {
    }, AudioElement.prototype.hide = function() {
      this.audio.pause(), this._isPlaying = !1;
    }, AudioElement.prototype.pause = function() {
      this.audio.pause(), this._isPlaying = !1, this._canPlay = !1;
    }, AudioElement.prototype.resume = function() {
      this._canPlay = !0;
    }, AudioElement.prototype.setRate = function(s) {
      this.audio.rate(s);
    }, AudioElement.prototype.volume = function(s) {
      this._volumeMultiplier = s, this._previousVolume = s * this._volume, this.audio.volume(this._previousVolume);
    }, AudioElement.prototype.getBaseElement = function() {
      return null;
    }, AudioElement.prototype.destroy = function() {
    }, AudioElement.prototype.sourceRectAtTime = function() {
    }, AudioElement.prototype.initExpressions = function() {
    };
    function BaseRenderer() {
    }
    BaseRenderer.prototype.checkLayers = function(s) {
      var o, l = this.layers.length, u;
      for (this.completeLayers = !0, o = l - 1; o >= 0; o -= 1)
        this.elements[o] || (u = this.layers[o], u.ip - u.st <= s - this.layers[o].st && u.op - u.st > s - this.layers[o].st && this.buildItem(o)), this.completeLayers = this.elements[o] ? this.completeLayers : !1;
      this.checkPendingElements();
    }, BaseRenderer.prototype.createItem = function(s) {
      switch (s.ty) {
        case 2:
          return this.createImage(s);
        case 0:
          return this.createComp(s);
        case 1:
          return this.createSolid(s);
        case 3:
          return this.createNull(s);
        case 4:
          return this.createShape(s);
        case 5:
          return this.createText(s);
        case 6:
          return this.createAudio(s);
        case 13:
          return this.createCamera(s);
        case 15:
          return this.createFootage(s);
        default:
          return this.createNull(s);
      }
    }, BaseRenderer.prototype.createCamera = function() {
      throw new Error("You're using a 3d camera. Try the html renderer.");
    }, BaseRenderer.prototype.createAudio = function(s) {
      return new AudioElement(s, this.globalData, this);
    }, BaseRenderer.prototype.createFootage = function(s) {
      return new FootageElement(s, this.globalData, this);
    }, BaseRenderer.prototype.buildAllItems = function() {
      var s, o = this.layers.length;
      for (s = 0; s < o; s += 1)
        this.buildItem(s);
      this.checkPendingElements();
    }, BaseRenderer.prototype.includeLayers = function(s) {
      this.completeLayers = !1;
      var o, l = s.length, u, c = this.layers.length;
      for (o = 0; o < l; o += 1)
        for (u = 0; u < c; ) {
          if (this.layers[u].id === s[o].id) {
            this.layers[u] = s[o];
            break;
          }
          u += 1;
        }
    }, BaseRenderer.prototype.setProjectInterface = function(s) {
      this.globalData.projectInterface = s;
    }, BaseRenderer.prototype.initItems = function() {
      this.globalData.progressiveLoad || this.buildAllItems();
    }, BaseRenderer.prototype.buildElementParenting = function(s, o, l) {
      for (var u = this.elements, c = this.layers, m = 0, g = c.length; m < g; )
        c[m].ind == o && (!u[m] || u[m] === !0 ? (this.buildItem(m), this.addPendingElement(s)) : (l.push(u[m]), u[m].setAsParent(), c[m].parent !== void 0 ? this.buildElementParenting(s, c[m].parent, l) : s.setHierarchy(l))), m += 1;
    }, BaseRenderer.prototype.addPendingElement = function(s) {
      this.pendingElements.push(s);
    }, BaseRenderer.prototype.searchExtraCompositions = function(s) {
      var o, l = s.length;
      for (o = 0; o < l; o += 1)
        if (s[o].xt) {
          var u = this.createComp(s[o]);
          u.initExpressions(), this.globalData.projectInterface.registerComposition(u);
        }
    }, BaseRenderer.prototype.getElementById = function(s) {
      var o, l = this.elements.length;
      for (o = 0; o < l; o += 1)
        if (this.elements[o].data.ind === s)
          return this.elements[o];
      return null;
    }, BaseRenderer.prototype.getElementByPath = function(s) {
      var o = s.shift(), l;
      if (typeof o == "number")
        l = this.elements[o];
      else {
        var u, c = this.elements.length;
        for (u = 0; u < c; u += 1)
          if (this.elements[u].data.nm === o) {
            l = this.elements[u];
            break;
          }
      }
      return s.length === 0 ? l : l.getElementByPath(s);
    }, BaseRenderer.prototype.setupGlobalData = function(s, o) {
      this.globalData.fontManager = new FontManager(), this.globalData.slotManager = slotFactory(s), this.globalData.fontManager.addChars(s.chars), this.globalData.fontManager.addFonts(s.fonts, o), this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem), this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem), this.globalData.imageLoader = this.animationItem.imagePreloader, this.globalData.audioController = this.animationItem.audioController, this.globalData.frameId = 0, this.globalData.frameRate = s.fr, this.globalData.nm = s.nm, this.globalData.compSize = {
        w: s.w,
        h: s.h
      };
    };
    var effectTypes = {
      TRANSFORM_EFFECT: "transformEFfect"
    };
    function TransformElement() {
    }
    TransformElement.prototype = {
      initTransform: function() {
        var o = new Matrix();
        this.finalTransform = {
          mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {
            o: 0
          },
          _matMdf: !1,
          _localMatMdf: !1,
          _opMdf: !1,
          mat: o,
          localMat: o,
          localOpacity: 1
        }, this.data.ao && (this.finalTransform.mProp.autoOriented = !0), this.data.ty;
      },
      renderTransform: function() {
        if (this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame, this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame, this.hierarchy) {
          var o, l = this.finalTransform.mat, u = 0, c = this.hierarchy.length;
          if (!this.finalTransform._matMdf)
            for (; u < c; ) {
              if (this.hierarchy[u].finalTransform.mProp._mdf) {
                this.finalTransform._matMdf = !0;
                break;
              }
              u += 1;
            }
          if (this.finalTransform._matMdf)
            for (o = this.finalTransform.mProp.v.props, l.cloneFromProps(o), u = 0; u < c; u += 1)
              l.multiply(this.hierarchy[u].finalTransform.mProp.v);
        }
        this.finalTransform._matMdf && (this.finalTransform._localMatMdf = this.finalTransform._matMdf), this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v);
      },
      renderLocalTransform: function() {
        if (this.localTransforms) {
          var o = 0, l = this.localTransforms.length;
          if (this.finalTransform._localMatMdf = this.finalTransform._matMdf, !this.finalTransform._localMatMdf || !this.finalTransform._opMdf)
            for (; o < l; )
              this.localTransforms[o]._mdf && (this.finalTransform._localMatMdf = !0), this.localTransforms[o]._opMdf && !this.finalTransform._opMdf && (this.finalTransform.localOpacity = this.finalTransform.mProp.o.v, this.finalTransform._opMdf = !0), o += 1;
          if (this.finalTransform._localMatMdf) {
            var u = this.finalTransform.localMat;
            for (this.localTransforms[0].matrix.clone(u), o = 1; o < l; o += 1) {
              var c = this.localTransforms[o].matrix;
              u.multiply(c);
            }
            u.multiply(this.finalTransform.mat);
          }
          if (this.finalTransform._opMdf) {
            var m = this.finalTransform.localOpacity;
            for (o = 0; o < l; o += 1)
              m *= this.localTransforms[o].opacity * 0.01;
            this.finalTransform.localOpacity = m;
          }
        }
      },
      searchEffectTransforms: function() {
        if (this.renderableEffectsManager) {
          var o = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
          if (o.length) {
            this.localTransforms = [], this.finalTransform.localMat = new Matrix();
            var l = 0, u = o.length;
            for (l = 0; l < u; l += 1)
              this.localTransforms.push(o[l]);
          }
        }
      },
      globalToLocal: function(o) {
        var l = [];
        l.push(this.finalTransform);
        for (var u = !0, c = this.comp; u; )
          c.finalTransform ? (c.data.hasMask && l.splice(0, 0, c.finalTransform), c = c.comp) : u = !1;
        var m, g = l.length, v;
        for (m = 0; m < g; m += 1)
          v = l[m].mat.applyToPointArray(0, 0, 0), o = [o[0] - v[0], o[1] - v[1], 0];
        return o;
      },
      mHelper: new Matrix()
    };
    function MaskElement(s, o, l) {
      this.data = s, this.element = o, this.globalData = l, this.storedData = [], this.masksProperties = this.data.masksProperties || [], this.maskElement = null;
      var u = this.globalData.defs, c, m = this.masksProperties ? this.masksProperties.length : 0;
      this.viewData = createSizedArray(m), this.solidPath = "";
      var g, v = this.masksProperties, b = 0, S = [], E, P, T = createElementID(), N, O, z, Q, W = "clipPath", ue = "clip-path";
      for (c = 0; c < m; c += 1)
        if ((v[c].mode !== "a" && v[c].mode !== "n" || v[c].inv || v[c].o.k !== 100 || v[c].o.x) && (W = "mask", ue = "mask"), (v[c].mode === "s" || v[c].mode === "i") && b === 0 ? (N = createNS("rect"), N.setAttribute("fill", "#ffffff"), N.setAttribute("width", this.element.comp.data.w || 0), N.setAttribute("height", this.element.comp.data.h || 0), S.push(N)) : N = null, g = createNS("path"), v[c].mode === "n")
          this.viewData[c] = {
            op: PropertyFactory.getProp(this.element, v[c].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, v[c], 3),
            elem: g,
            lastPath: ""
          }, u.appendChild(g);
        else {
          b += 1, g.setAttribute("fill", v[c].mode === "s" ? "#000000" : "#ffffff"), g.setAttribute("clip-rule", "nonzero");
          var te;
          if (v[c].x.k !== 0 ? (W = "mask", ue = "mask", Q = PropertyFactory.getProp(this.element, v[c].x, 0, null, this.element), te = createElementID(), O = createNS("filter"), O.setAttribute("id", te), z = createNS("feMorphology"), z.setAttribute("operator", "erode"), z.setAttribute("in", "SourceGraphic"), z.setAttribute("radius", "0"), O.appendChild(z), u.appendChild(O), g.setAttribute("stroke", v[c].mode === "s" ? "#000000" : "#ffffff")) : (z = null, Q = null), this.storedData[c] = {
            elem: g,
            x: Q,
            expan: z,
            lastPath: "",
            lastOperator: "",
            filterId: te,
            lastRadius: 0
          }, v[c].mode === "i") {
            P = S.length;
            var K = createNS("g");
            for (E = 0; E < P; E += 1)
              K.appendChild(S[E]);
            var ve = createNS("mask");
            ve.setAttribute("mask-type", "alpha"), ve.setAttribute("id", T + "_" + b), ve.appendChild(g), u.appendChild(ve), K.setAttribute("mask", "url(" + getLocationHref() + "#" + T + "_" + b + ")"), S.length = 0, S.push(K);
          } else
            S.push(g);
          v[c].inv && !this.solidPath && (this.solidPath = this.createLayerSolidPath()), this.viewData[c] = {
            elem: g,
            lastPath: "",
            op: PropertyFactory.getProp(this.element, v[c].o, 0, 0.01, this.element),
            prop: ShapePropertyFactory.getShapeProp(this.element, v[c], 3),
            invRect: N
          }, this.viewData[c].prop.k || this.drawPath(v[c], this.viewData[c].prop.v, this.viewData[c]);
        }
      for (this.maskElement = createNS(W), m = S.length, c = 0; c < m; c += 1)
        this.maskElement.appendChild(S[c]);
      b > 0 && (this.maskElement.setAttribute("id", T), this.element.maskedElement.setAttribute(ue, "url(" + getLocationHref() + "#" + T + ")"), u.appendChild(this.maskElement)), this.viewData.length && this.element.addRenderableComponent(this);
    }
    MaskElement.prototype.getMaskProperty = function(s) {
      return this.viewData[s].prop;
    }, MaskElement.prototype.renderFrame = function(s) {
      var o = this.element.finalTransform.mat, l, u = this.masksProperties.length;
      for (l = 0; l < u; l += 1)
        if ((this.viewData[l].prop._mdf || s) && this.drawPath(this.masksProperties[l], this.viewData[l].prop.v, this.viewData[l]), (this.viewData[l].op._mdf || s) && this.viewData[l].elem.setAttribute("fill-opacity", this.viewData[l].op.v), this.masksProperties[l].mode !== "n" && (this.viewData[l].invRect && (this.element.finalTransform.mProp._mdf || s) && this.viewData[l].invRect.setAttribute("transform", o.getInverseMatrix().to2dCSS()), this.storedData[l].x && (this.storedData[l].x._mdf || s))) {
          var c = this.storedData[l].expan;
          this.storedData[l].x.v < 0 ? (this.storedData[l].lastOperator !== "erode" && (this.storedData[l].lastOperator = "erode", this.storedData[l].elem.setAttribute("filter", "url(" + getLocationHref() + "#" + this.storedData[l].filterId + ")")), c.setAttribute("radius", -this.storedData[l].x.v)) : (this.storedData[l].lastOperator !== "dilate" && (this.storedData[l].lastOperator = "dilate", this.storedData[l].elem.setAttribute("filter", null)), this.storedData[l].elem.setAttribute("stroke-width", this.storedData[l].x.v * 2));
        }
    }, MaskElement.prototype.getMaskelement = function() {
      return this.maskElement;
    }, MaskElement.prototype.createLayerSolidPath = function() {
      var s = "M0,0 ";
      return s += " h" + this.globalData.compSize.w, s += " v" + this.globalData.compSize.h, s += " h-" + this.globalData.compSize.w, s += " v-" + this.globalData.compSize.h + " ", s;
    }, MaskElement.prototype.drawPath = function(s, o, l) {
      var u = " M" + o.v[0][0] + "," + o.v[0][1], c, m;
      for (m = o._length, c = 1; c < m; c += 1)
        u += " C" + o.o[c - 1][0] + "," + o.o[c - 1][1] + " " + o.i[c][0] + "," + o.i[c][1] + " " + o.v[c][0] + "," + o.v[c][1];
      if (o.c && m > 1 && (u += " C" + o.o[c - 1][0] + "," + o.o[c - 1][1] + " " + o.i[0][0] + "," + o.i[0][1] + " " + o.v[0][0] + "," + o.v[0][1]), l.lastPath !== u) {
        var g = "";
        l.elem && (o.c && (g = s.inv ? this.solidPath + u : u), l.elem.setAttribute("d", g)), l.lastPath = u;
      }
    }, MaskElement.prototype.destroy = function() {
      this.element = null, this.globalData = null, this.maskElement = null, this.data = null, this.masksProperties = null;
    };
    var filtersFactory = function() {
      var s = {};
      s.createFilter = o, s.createAlphaToLuminanceFilter = l;
      function o(u, c) {
        var m = createNS("filter");
        return m.setAttribute("id", u), c !== !0 && (m.setAttribute("filterUnits", "objectBoundingBox"), m.setAttribute("x", "0%"), m.setAttribute("y", "0%"), m.setAttribute("width", "100%"), m.setAttribute("height", "100%")), m;
      }
      function l() {
        var u = createNS("feColorMatrix");
        return u.setAttribute("type", "matrix"), u.setAttribute("color-interpolation-filters", "sRGB"), u.setAttribute("values", "0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1"), u;
      }
      return s;
    }(), featureSupport = function() {
      var s = {
        maskType: !0,
        svgLumaHidden: !0,
        offscreenCanvas: typeof OffscreenCanvas < "u"
      };
      return (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\/\d./i.test(navigator.userAgent)) && (s.maskType = !1), /firefox/i.test(navigator.userAgent) && (s.svgLumaHidden = !1), s;
    }(), registeredEffects$1 = {}, idPrefix = "filter_result_";
    function SVGEffects(s) {
      var o, l = "SourceGraphic", u = s.data.ef ? s.data.ef.length : 0, c = createElementID(), m = filtersFactory.createFilter(c, !0), g = 0;
      this.filters = [];
      var v;
      for (o = 0; o < u; o += 1) {
        v = null;
        var b = s.data.ef[o].ty;
        if (registeredEffects$1[b]) {
          var S = registeredEffects$1[b].effect;
          v = new S(m, s.effectsManager.effectElements[o], s, idPrefix + g, l), l = idPrefix + g, registeredEffects$1[b].countsAsEffect && (g += 1);
        }
        v && this.filters.push(v);
      }
      g && (s.globalData.defs.appendChild(m), s.layerElement.setAttribute("filter", "url(" + getLocationHref() + "#" + c + ")")), this.filters.length && s.addRenderableComponent(this);
    }
    SVGEffects.prototype.renderFrame = function(s) {
      var o, l = this.filters.length;
      for (o = 0; o < l; o += 1)
        this.filters[o].renderFrame(s);
    }, SVGEffects.prototype.getEffects = function(s) {
      var o, l = this.filters.length, u = [];
      for (o = 0; o < l; o += 1)
        this.filters[o].type === s && u.push(this.filters[o]);
      return u;
    };
    function registerEffect$1(s, o, l) {
      registeredEffects$1[s] = {
        effect: o,
        countsAsEffect: l
      };
    }
    function SVGBaseElement() {
    }
    SVGBaseElement.prototype = {
      initRendererElement: function() {
        this.layerElement = createNS("g");
      },
      createContainerElements: function() {
        this.matteElement = createNS("g"), this.transformedElement = this.layerElement, this.maskedElement = this.layerElement, this._sizeChanged = !1;
        var o = null;
        if (this.data.td) {
          this.matteMasks = {};
          var l = createNS("g");
          l.setAttribute("id", this.layerId), l.appendChild(this.layerElement), o = l, this.globalData.defs.appendChild(l);
        } else this.data.tt ? (this.matteElement.appendChild(this.layerElement), o = this.matteElement, this.baseElement = this.matteElement) : this.baseElement = this.layerElement;
        if (this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.ty === 0 && !this.data.hd) {
          var u = createNS("clipPath"), c = createNS("path");
          c.setAttribute("d", "M0,0 L" + this.data.w + ",0 L" + this.data.w + "," + this.data.h + " L0," + this.data.h + "z");
          var m = createElementID();
          if (u.setAttribute("id", m), u.appendChild(c), this.globalData.defs.appendChild(u), this.checkMasks()) {
            var g = createNS("g");
            g.setAttribute("clip-path", "url(" + getLocationHref() + "#" + m + ")"), g.appendChild(this.layerElement), this.transformedElement = g, o ? o.appendChild(this.transformedElement) : this.baseElement = this.transformedElement;
          } else
            this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + m + ")");
        }
        this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        this.finalTransform._localMatMdf && this.transformedElement.setAttribute("transform", this.finalTransform.localMat.to2dCSS()), this.finalTransform._opMdf && this.transformedElement.setAttribute("opacity", this.finalTransform.localOpacity);
      },
      destroyBaseElement: function() {
        this.layerElement = null, this.matteElement = null, this.maskManager.destroy();
      },
      getBaseElement: function() {
        return this.data.hd ? null : this.baseElement;
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData), this.renderableEffectsManager = new SVGEffects(this), this.searchEffectTransforms();
      },
      getMatte: function(o) {
        if (this.matteMasks || (this.matteMasks = {}), !this.matteMasks[o]) {
          var l = this.layerId + "_" + o, u, c, m, g;
          if (o === 1 || o === 3) {
            var v = createNS("mask");
            v.setAttribute("id", l), v.setAttribute("mask-type", o === 3 ? "luminance" : "alpha"), m = createNS("use"), m.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), v.appendChild(m), this.globalData.defs.appendChild(v), !featureSupport.maskType && o === 1 && (v.setAttribute("mask-type", "luminance"), u = createElementID(), c = filtersFactory.createFilter(u), this.globalData.defs.appendChild(c), c.appendChild(filtersFactory.createAlphaToLuminanceFilter()), g = createNS("g"), g.appendChild(m), v.appendChild(g), g.setAttribute("filter", "url(" + getLocationHref() + "#" + u + ")"));
          } else if (o === 2) {
            var b = createNS("mask");
            b.setAttribute("id", l), b.setAttribute("mask-type", "alpha");
            var S = createNS("g");
            b.appendChild(S), u = createElementID(), c = filtersFactory.createFilter(u);
            var E = createNS("feComponentTransfer");
            E.setAttribute("in", "SourceGraphic"), c.appendChild(E);
            var P = createNS("feFuncA");
            P.setAttribute("type", "table"), P.setAttribute("tableValues", "1.0 0.0"), E.appendChild(P), this.globalData.defs.appendChild(c);
            var T = createNS("rect");
            T.setAttribute("width", this.comp.data.w), T.setAttribute("height", this.comp.data.h), T.setAttribute("x", "0"), T.setAttribute("y", "0"), T.setAttribute("fill", "#ffffff"), T.setAttribute("opacity", "0"), S.setAttribute("filter", "url(" + getLocationHref() + "#" + u + ")"), S.appendChild(T), m = createNS("use"), m.setAttributeNS("http://www.w3.org/1999/xlink", "href", "#" + this.layerId), S.appendChild(m), featureSupport.maskType || (b.setAttribute("mask-type", "luminance"), c.appendChild(filtersFactory.createAlphaToLuminanceFilter()), g = createNS("g"), S.appendChild(T), g.appendChild(this.layerElement), S.appendChild(g)), this.globalData.defs.appendChild(b);
          }
          this.matteMasks[o] = l;
        }
        return this.matteMasks[o];
      },
      setMatte: function(o) {
        this.matteElement && this.matteElement.setAttribute("mask", "url(" + getLocationHref() + "#" + o + ")");
      }
    };
    function HierarchyElement() {
    }
    HierarchyElement.prototype = {
      /**
         * @function
         * Initializes hierarchy properties
         *
         */
      initHierarchy: function() {
        this.hierarchy = [], this._isParent = !1, this.checkParenting();
      },
      /**
         * @function
         * Sets layer's hierarchy.
         * @param {array} hierarch
         * layer's parent list
         *
         */
      setHierarchy: function(o) {
        this.hierarchy = o;
      },
      /**
         * @function
         * Sets layer as parent.
         *
         */
      setAsParent: function() {
        this._isParent = !0;
      },
      /**
         * @function
         * Searches layer's parenting chain
         *
         */
      checkParenting: function() {
        this.data.parent !== void 0 && this.comp.buildElementParenting(this, this.data.parent, []);
      }
    };
    function RenderableDOMElement() {
    }
    (function() {
      var s = {
        initElement: function(l, u, c) {
          this.initFrame(), this.initBaseData(l, u, c), this.initTransform(l, u, c), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide();
        },
        hide: function() {
          if (!this.hidden && (!this.isInRange || this.isTransparent)) {
            var l = this.baseElement || this.layerElement;
            l.style.display = "none", this.hidden = !0;
          }
        },
        show: function() {
          if (this.isInRange && !this.isTransparent) {
            if (!this.data.hd) {
              var l = this.baseElement || this.layerElement;
              l.style.display = "block";
            }
            this.hidden = !1, this._isFirstFrame = !0;
          }
        },
        renderFrame: function() {
          this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
        },
        renderInnerContent: function() {
        },
        prepareFrame: function(l) {
          this._mdf = !1, this.prepareRenderableFrame(l), this.prepareProperties(l, this.isInRange), this.checkTransparency();
        },
        destroy: function() {
          this.innerElem = null, this.destroyBaseElement();
        }
      };
      extendPrototype([RenderableElement, createProxyFunction(s)], RenderableDOMElement);
    })();
    function IImageElement(s, o, l) {
      this.assetData = o.getAssetData(s.refId), this.assetData && this.assetData.sid && (this.assetData = o.slotManager.getProp(this.assetData)), this.initElement(s, o, l), this.sourceRect = {
        top: 0,
        left: 0,
        width: this.assetData.w,
        height: this.assetData.h
      };
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], IImageElement), IImageElement.prototype.createContent = function() {
      var s = this.globalData.getAssetsPath(this.assetData);
      this.innerElem = createNS("image"), this.innerElem.setAttribute("width", this.assetData.w + "px"), this.innerElem.setAttribute("height", this.assetData.h + "px"), this.innerElem.setAttribute("preserveAspectRatio", this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio), this.innerElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", s), this.layerElement.appendChild(this.innerElem);
    }, IImageElement.prototype.sourceRectAtTime = function() {
      return this.sourceRect;
    };
    function ProcessedElement(s, o) {
      this.elem = s, this.pos = o;
    }
    function IShapeElement() {
    }
    IShapeElement.prototype = {
      addShapeToModifiers: function(o) {
        var l, u = this.shapeModifiers.length;
        for (l = 0; l < u; l += 1)
          this.shapeModifiers[l].addShape(o);
      },
      isShapeInAnimatedModifiers: function(o) {
        for (var l = 0, u = this.shapeModifiers.length; l < u; )
          if (this.shapeModifiers[l].isAnimatedWithShape(o))
            return !0;
        return !1;
      },
      renderModifiers: function() {
        if (this.shapeModifiers.length) {
          var o, l = this.shapes.length;
          for (o = 0; o < l; o += 1)
            this.shapes[o].sh.reset();
          l = this.shapeModifiers.length;
          var u;
          for (o = l - 1; o >= 0 && (u = this.shapeModifiers[o].processShapes(this._isFirstFrame), !u); o -= 1)
            ;
        }
      },
      searchProcessedElement: function(o) {
        for (var l = this.processedElements, u = 0, c = l.length; u < c; ) {
          if (l[u].elem === o)
            return l[u].pos;
          u += 1;
        }
        return 0;
      },
      addProcessedElement: function(o, l) {
        for (var u = this.processedElements, c = u.length; c; )
          if (c -= 1, u[c].elem === o) {
            u[c].pos = l;
            return;
          }
        u.push(new ProcessedElement(o, l));
      },
      prepareFrame: function(o) {
        this.prepareRenderableFrame(o), this.prepareProperties(o, this.isInRange);
      }
    };
    var lineCapEnum = {
      1: "butt",
      2: "round",
      3: "square"
    }, lineJoinEnum = {
      1: "miter",
      2: "round",
      3: "bevel"
    };
    function SVGShapeData(s, o, l) {
      this.caches = [], this.styles = [], this.transformers = s, this.lStr = "", this.sh = l, this.lvl = o, this._isAnimated = !!l.k;
      for (var u = 0, c = s.length; u < c; ) {
        if (s[u].mProps.dynamicProperties.length) {
          this._isAnimated = !0;
          break;
        }
        u += 1;
      }
    }
    SVGShapeData.prototype.setAsAnimated = function() {
      this._isAnimated = !0;
    };
    function SVGStyleData(s, o) {
      this.data = s, this.type = s.ty, this.d = "", this.lvl = o, this._mdf = !1, this.closed = s.hd === !0, this.pElem = createNS("path"), this.msElem = null;
    }
    SVGStyleData.prototype.reset = function() {
      this.d = "", this._mdf = !1;
    };
    function DashProperty(s, o, l, u) {
      this.elem = s, this.frameId = -1, this.dataProps = createSizedArray(o.length), this.renderer = l, this.k = !1, this.dashStr = "", this.dashArray = createTypedArray("float32", o.length ? o.length - 1 : 0), this.dashoffset = createTypedArray("float32", 1), this.initDynamicPropertyContainer(u);
      var c, m = o.length || 0, g;
      for (c = 0; c < m; c += 1)
        g = PropertyFactory.getProp(s, o[c].v, 0, 0, this), this.k = g.k || this.k, this.dataProps[c] = {
          n: o[c].n,
          p: g
        };
      this.k || this.getValue(!0), this._isAnimated = this.k;
    }
    DashProperty.prototype.getValue = function(s) {
      if (!(this.elem.globalData.frameId === this.frameId && !s) && (this.frameId = this.elem.globalData.frameId, this.iterateDynamicProperties(), this._mdf = this._mdf || s, this._mdf)) {
        var o = 0, l = this.dataProps.length;
        for (this.renderer === "svg" && (this.dashStr = ""), o = 0; o < l; o += 1)
          this.dataProps[o].n !== "o" ? this.renderer === "svg" ? this.dashStr += " " + this.dataProps[o].p.v : this.dashArray[o] = this.dataProps[o].p.v : this.dashoffset[0] = this.dataProps[o].p.v;
      }
    }, extendPrototype([DynamicPropertyContainer], DashProperty);
    function SVGStrokeStyleData(s, o, l) {
      this.initDynamicPropertyContainer(s), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(s, o.o, 0, 0.01, this), this.w = PropertyFactory.getProp(s, o.w, 0, null, this), this.d = new DashProperty(s, o.d || {}, "svg", this), this.c = PropertyFactory.getProp(s, o.c, 1, 255, this), this.style = l, this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([DynamicPropertyContainer], SVGStrokeStyleData);
    function SVGFillStyleData(s, o, l) {
      this.initDynamicPropertyContainer(s), this.getValue = this.iterateDynamicProperties, this.o = PropertyFactory.getProp(s, o.o, 0, 0.01, this), this.c = PropertyFactory.getProp(s, o.c, 1, 255, this), this.style = l;
    }
    extendPrototype([DynamicPropertyContainer], SVGFillStyleData);
    function SVGNoStyleData(s, o, l) {
      this.initDynamicPropertyContainer(s), this.getValue = this.iterateDynamicProperties, this.style = l;
    }
    extendPrototype([DynamicPropertyContainer], SVGNoStyleData);
    function GradientProperty(s, o, l) {
      this.data = o, this.c = createTypedArray("uint8c", o.p * 4);
      var u = o.k.k[0].s ? o.k.k[0].s.length - o.p * 4 : o.k.k.length - o.p * 4;
      this.o = createTypedArray("float32", u), this._cmdf = !1, this._omdf = !1, this._collapsable = this.checkCollapsable(), this._hasOpacity = u, this.initDynamicPropertyContainer(l), this.prop = PropertyFactory.getProp(s, o.k, 1, null, this), this.k = this.prop.k, this.getValue(!0);
    }
    GradientProperty.prototype.comparePoints = function(s, o) {
      for (var l = 0, u = this.o.length / 2, c; l < u; ) {
        if (c = Math.abs(s[l * 4] - s[o * 4 + l * 2]), c > 0.01)
          return !1;
        l += 1;
      }
      return !0;
    }, GradientProperty.prototype.checkCollapsable = function() {
      if (this.o.length / 2 !== this.c.length / 4)
        return !1;
      if (this.data.k.k[0].s)
        for (var s = 0, o = this.data.k.k.length; s < o; ) {
          if (!this.comparePoints(this.data.k.k[s].s, this.data.p))
            return !1;
          s += 1;
        }
      else if (!this.comparePoints(this.data.k.k, this.data.p))
        return !1;
      return !0;
    }, GradientProperty.prototype.getValue = function(s) {
      if (this.prop.getValue(), this._mdf = !1, this._cmdf = !1, this._omdf = !1, this.prop._mdf || s) {
        var o, l = this.data.p * 4, u, c;
        for (o = 0; o < l; o += 1)
          u = o % 4 === 0 ? 100 : 255, c = Math.round(this.prop.v[o] * u), this.c[o] !== c && (this.c[o] = c, this._cmdf = !s);
        if (this.o.length)
          for (l = this.prop.v.length, o = this.data.p * 4; o < l; o += 1)
            u = o % 2 === 0 ? 100 : 1, c = o % 2 === 0 ? Math.round(this.prop.v[o] * 100) : this.prop.v[o], this.o[o - this.data.p * 4] !== c && (this.o[o - this.data.p * 4] = c, this._omdf = !s);
        this._mdf = !s;
      }
    }, extendPrototype([DynamicPropertyContainer], GradientProperty);
    function SVGGradientFillStyleData(s, o, l) {
      this.initDynamicPropertyContainer(s), this.getValue = this.iterateDynamicProperties, this.initGradientData(s, o, l);
    }
    SVGGradientFillStyleData.prototype.initGradientData = function(s, o, l) {
      this.o = PropertyFactory.getProp(s, o.o, 0, 0.01, this), this.s = PropertyFactory.getProp(s, o.s, 1, null, this), this.e = PropertyFactory.getProp(s, o.e, 1, null, this), this.h = PropertyFactory.getProp(s, o.h || {
        k: 0
      }, 0, 0.01, this), this.a = PropertyFactory.getProp(s, o.a || {
        k: 0
      }, 0, degToRads, this), this.g = new GradientProperty(s, o.g, this), this.style = l, this.stops = [], this.setGradientData(l.pElem, o), this.setGradientOpacity(o, l), this._isAnimated = !!this._isAnimated;
    }, SVGGradientFillStyleData.prototype.setGradientData = function(s, o) {
      var l = createElementID(), u = createNS(o.t === 1 ? "linearGradient" : "radialGradient");
      u.setAttribute("id", l), u.setAttribute("spreadMethod", "pad"), u.setAttribute("gradientUnits", "userSpaceOnUse");
      var c = [], m, g, v;
      for (v = o.g.p * 4, g = 0; g < v; g += 4)
        m = createNS("stop"), u.appendChild(m), c.push(m);
      s.setAttribute(o.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + l + ")"), this.gf = u, this.cst = c;
    }, SVGGradientFillStyleData.prototype.setGradientOpacity = function(s, o) {
      if (this.g._hasOpacity && !this.g._collapsable) {
        var l, u, c, m = createNS("mask"), g = createNS("path");
        m.appendChild(g);
        var v = createElementID(), b = createElementID();
        m.setAttribute("id", b);
        var S = createNS(s.t === 1 ? "linearGradient" : "radialGradient");
        S.setAttribute("id", v), S.setAttribute("spreadMethod", "pad"), S.setAttribute("gradientUnits", "userSpaceOnUse"), c = s.g.k.k[0].s ? s.g.k.k[0].s.length : s.g.k.k.length;
        var E = this.stops;
        for (u = s.g.p * 4; u < c; u += 2)
          l = createNS("stop"), l.setAttribute("stop-color", "rgb(255,255,255)"), S.appendChild(l), E.push(l);
        g.setAttribute(s.ty === "gf" ? "fill" : "stroke", "url(" + getLocationHref() + "#" + v + ")"), s.ty === "gs" && (g.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]), g.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]), s.lj === 1 && g.setAttribute("stroke-miterlimit", s.ml)), this.of = S, this.ms = m, this.ost = E, this.maskId = b, o.msElem = g;
      }
    }, extendPrototype([DynamicPropertyContainer], SVGGradientFillStyleData);
    function SVGGradientStrokeStyleData(s, o, l) {
      this.initDynamicPropertyContainer(s), this.getValue = this.iterateDynamicProperties, this.w = PropertyFactory.getProp(s, o.w, 0, null, this), this.d = new DashProperty(s, o.d || {}, "svg", this), this.initGradientData(s, o, l), this._isAnimated = !!this._isAnimated;
    }
    extendPrototype([SVGGradientFillStyleData, DynamicPropertyContainer], SVGGradientStrokeStyleData);
    function ShapeGroupData() {
      this.it = [], this.prevViewData = [], this.gr = createNS("g");
    }
    function SVGTransformData(s, o, l) {
      this.transform = {
        mProps: s,
        op: o,
        container: l
      }, this.elements = [], this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;
    }
    var buildShapeString = function(o, l, u, c) {
      if (l === 0)
        return "";
      var m = o.o, g = o.i, v = o.v, b, S = " M" + c.applyToPointStringified(v[0][0], v[0][1]);
      for (b = 1; b < l; b += 1)
        S += " C" + c.applyToPointStringified(m[b - 1][0], m[b - 1][1]) + " " + c.applyToPointStringified(g[b][0], g[b][1]) + " " + c.applyToPointStringified(v[b][0], v[b][1]);
      return u && l && (S += " C" + c.applyToPointStringified(m[b - 1][0], m[b - 1][1]) + " " + c.applyToPointStringified(g[0][0], g[0][1]) + " " + c.applyToPointStringified(v[0][0], v[0][1]), S += "z"), S;
    }, SVGElementsRenderer = function() {
      var s = new Matrix(), o = new Matrix(), l = {
        createRenderFunction: u
      };
      function u(P) {
        switch (P.ty) {
          case "fl":
            return v;
          case "gf":
            return S;
          case "gs":
            return b;
          case "st":
            return E;
          case "sh":
          case "el":
          case "rc":
          case "sr":
            return g;
          case "tr":
            return c;
          case "no":
            return m;
          default:
            return null;
        }
      }
      function c(P, T, N) {
        (N || T.transform.op._mdf) && T.transform.container.setAttribute("opacity", T.transform.op.v), (N || T.transform.mProps._mdf) && T.transform.container.setAttribute("transform", T.transform.mProps.v.to2dCSS());
      }
      function m() {
      }
      function g(P, T, N) {
        var O, z, Q, W, ue, te, K = T.styles.length, ve = T.lvl, ee, Re, wt, yt;
        for (te = 0; te < K; te += 1) {
          if (W = T.sh._mdf || N, T.styles[te].lvl < ve) {
            for (Re = o.reset(), wt = ve - T.styles[te].lvl, yt = T.transformers.length - 1; !W && wt > 0; )
              W = T.transformers[yt].mProps._mdf || W, wt -= 1, yt -= 1;
            if (W)
              for (wt = ve - T.styles[te].lvl, yt = T.transformers.length - 1; wt > 0; )
                Re.multiply(T.transformers[yt].mProps.v), wt -= 1, yt -= 1;
          } else
            Re = s;
          if (ee = T.sh.paths, z = ee._length, W) {
            for (Q = "", O = 0; O < z; O += 1)
              ue = ee.shapes[O], ue && ue._length && (Q += buildShapeString(ue, ue._length, ue.c, Re));
            T.caches[te] = Q;
          } else
            Q = T.caches[te];
          T.styles[te].d += P.hd === !0 ? "" : Q, T.styles[te]._mdf = W || T.styles[te]._mdf;
        }
      }
      function v(P, T, N) {
        var O = T.style;
        (T.c._mdf || N) && O.pElem.setAttribute("fill", "rgb(" + bmFloor(T.c.v[0]) + "," + bmFloor(T.c.v[1]) + "," + bmFloor(T.c.v[2]) + ")"), (T.o._mdf || N) && O.pElem.setAttribute("fill-opacity", T.o.v);
      }
      function b(P, T, N) {
        S(P, T, N), E(P, T, N);
      }
      function S(P, T, N) {
        var O = T.gf, z = T.g._hasOpacity, Q = T.s.v, W = T.e.v;
        if (T.o._mdf || N) {
          var ue = P.ty === "gf" ? "fill-opacity" : "stroke-opacity";
          T.style.pElem.setAttribute(ue, T.o.v);
        }
        if (T.s._mdf || N) {
          var te = P.t === 1 ? "x1" : "cx", K = te === "x1" ? "y1" : "cy";
          O.setAttribute(te, Q[0]), O.setAttribute(K, Q[1]), z && !T.g._collapsable && (T.of.setAttribute(te, Q[0]), T.of.setAttribute(K, Q[1]));
        }
        var ve, ee, Re, wt;
        if (T.g._cmdf || N) {
          ve = T.cst;
          var yt = T.g.c;
          for (Re = ve.length, ee = 0; ee < Re; ee += 1)
            wt = ve[ee], wt.setAttribute("offset", yt[ee * 4] + "%"), wt.setAttribute("stop-color", "rgb(" + yt[ee * 4 + 1] + "," + yt[ee * 4 + 2] + "," + yt[ee * 4 + 3] + ")");
        }
        if (z && (T.g._omdf || N)) {
          var xt = T.g.o;
          for (T.g._collapsable ? ve = T.cst : ve = T.ost, Re = ve.length, ee = 0; ee < Re; ee += 1)
            wt = ve[ee], T.g._collapsable || wt.setAttribute("offset", xt[ee * 2] + "%"), wt.setAttribute("stop-opacity", xt[ee * 2 + 1]);
        }
        if (P.t === 1)
          (T.e._mdf || N) && (O.setAttribute("x2", W[0]), O.setAttribute("y2", W[1]), z && !T.g._collapsable && (T.of.setAttribute("x2", W[0]), T.of.setAttribute("y2", W[1])));
        else {
          var Kt;
          if ((T.s._mdf || T.e._mdf || N) && (Kt = Math.sqrt(Math.pow(Q[0] - W[0], 2) + Math.pow(Q[1] - W[1], 2)), O.setAttribute("r", Kt), z && !T.g._collapsable && T.of.setAttribute("r", Kt)), T.e._mdf || T.h._mdf || T.a._mdf || N) {
            Kt || (Kt = Math.sqrt(Math.pow(Q[0] - W[0], 2) + Math.pow(Q[1] - W[1], 2)));
            var tn = Math.atan2(W[1] - Q[1], W[0] - Q[0]), ln = T.h.v;
            ln >= 1 ? ln = 0.99 : ln <= -1 && (ln = -0.99);
            var rn = Kt * ln, an = Math.cos(tn + T.a.v) * rn + Q[0], Gt = Math.sin(tn + T.a.v) * rn + Q[1];
            O.setAttribute("fx", an), O.setAttribute("fy", Gt), z && !T.g._collapsable && (T.of.setAttribute("fx", an), T.of.setAttribute("fy", Gt));
          }
        }
      }
      function E(P, T, N) {
        var O = T.style, z = T.d;
        z && (z._mdf || N) && z.dashStr && (O.pElem.setAttribute("stroke-dasharray", z.dashStr), O.pElem.setAttribute("stroke-dashoffset", z.dashoffset[0])), T.c && (T.c._mdf || N) && O.pElem.setAttribute("stroke", "rgb(" + bmFloor(T.c.v[0]) + "," + bmFloor(T.c.v[1]) + "," + bmFloor(T.c.v[2]) + ")"), (T.o._mdf || N) && O.pElem.setAttribute("stroke-opacity", T.o.v), (T.w._mdf || N) && (O.pElem.setAttribute("stroke-width", T.w.v), O.msElem && O.msElem.setAttribute("stroke-width", T.w.v));
      }
      return l;
    }();
    function SVGShapeElement(s, o, l) {
      this.shapes = [], this.shapesData = s.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.initElement(s, o, l), this.prevViewData = [];
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableDOMElement], SVGShapeElement), SVGShapeElement.prototype.initSecondaryElement = function() {
    }, SVGShapeElement.prototype.identityMatrix = new Matrix(), SVGShapeElement.prototype.buildExpressionInterface = function() {
    }, SVGShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes();
    }, SVGShapeElement.prototype.filterUniqueShapes = function() {
      var s, o = this.shapes.length, l, u, c = this.stylesList.length, m, g = [], v = !1;
      for (u = 0; u < c; u += 1) {
        for (m = this.stylesList[u], v = !1, g.length = 0, s = 0; s < o; s += 1)
          l = this.shapes[s], l.styles.indexOf(m) !== -1 && (g.push(l), v = l._isAnimated || v);
        g.length > 1 && v && this.setShapesAsAnimated(g);
      }
    }, SVGShapeElement.prototype.setShapesAsAnimated = function(s) {
      var o, l = s.length;
      for (o = 0; o < l; o += 1)
        s[o].setAsAnimated();
    }, SVGShapeElement.prototype.createStyleElement = function(s, o) {
      var l, u = new SVGStyleData(s, o), c = u.pElem;
      if (s.ty === "st")
        l = new SVGStrokeStyleData(this, s, u);
      else if (s.ty === "fl")
        l = new SVGFillStyleData(this, s, u);
      else if (s.ty === "gf" || s.ty === "gs") {
        var m = s.ty === "gf" ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;
        l = new m(this, s, u), this.globalData.defs.appendChild(l.gf), l.maskId && (this.globalData.defs.appendChild(l.ms), this.globalData.defs.appendChild(l.of), c.setAttribute("mask", "url(" + getLocationHref() + "#" + l.maskId + ")"));
      } else s.ty === "no" && (l = new SVGNoStyleData(this, s, u));
      return (s.ty === "st" || s.ty === "gs") && (c.setAttribute("stroke-linecap", lineCapEnum[s.lc || 2]), c.setAttribute("stroke-linejoin", lineJoinEnum[s.lj || 2]), c.setAttribute("fill-opacity", "0"), s.lj === 1 && c.setAttribute("stroke-miterlimit", s.ml)), s.r === 2 && c.setAttribute("fill-rule", "evenodd"), s.ln && c.setAttribute("id", s.ln), s.cl && c.setAttribute("class", s.cl), s.bm && (c.style["mix-blend-mode"] = getBlendMode(s.bm)), this.stylesList.push(u), this.addToAnimatedContents(s, l), l;
    }, SVGShapeElement.prototype.createGroupElement = function(s) {
      var o = new ShapeGroupData();
      return s.ln && o.gr.setAttribute("id", s.ln), s.cl && o.gr.setAttribute("class", s.cl), s.bm && (o.gr.style["mix-blend-mode"] = getBlendMode(s.bm)), o;
    }, SVGShapeElement.prototype.createTransformElement = function(s, o) {
      var l = TransformPropertyFactory.getTransformProperty(this, s, this), u = new SVGTransformData(l, l.o, o);
      return this.addToAnimatedContents(s, u), u;
    }, SVGShapeElement.prototype.createShapeElement = function(s, o, l) {
      var u = 4;
      s.ty === "rc" ? u = 5 : s.ty === "el" ? u = 6 : s.ty === "sr" && (u = 7);
      var c = ShapePropertyFactory.getShapeProp(this, s, u, this), m = new SVGShapeData(o, l, c);
      return this.shapes.push(m), this.addShapeToModifiers(m), this.addToAnimatedContents(s, m), m;
    }, SVGShapeElement.prototype.addToAnimatedContents = function(s, o) {
      for (var l = 0, u = this.animatedContents.length; l < u; ) {
        if (this.animatedContents[l].element === o)
          return;
        l += 1;
      }
      this.animatedContents.push({
        fn: SVGElementsRenderer.createRenderFunction(s),
        element: o,
        data: s
      });
    }, SVGShapeElement.prototype.setElementStyles = function(s) {
      var o = s.styles, l, u = this.stylesList.length;
      for (l = 0; l < u; l += 1)
        this.stylesList[l].closed || o.push(this.stylesList[l]);
    }, SVGShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var s, o = this.itemsData.length;
      for (s = 0; s < o; s += 1)
        this.prevViewData[s] = this.itemsData[s];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], !0), this.filterUniqueShapes(), o = this.dynamicProperties.length, s = 0; s < o; s += 1)
        this.dynamicProperties[s].getValue();
      this.renderModifiers();
    }, SVGShapeElement.prototype.searchShapes = function(s, o, l, u, c, m, g) {
      var v = [].concat(m), b, S = s.length - 1, E, P, T = [], N = [], O, z, Q;
      for (b = S; b >= 0; b -= 1) {
        if (Q = this.searchProcessedElement(s[b]), Q ? o[b] = l[Q - 1] : s[b]._render = g, s[b].ty === "fl" || s[b].ty === "st" || s[b].ty === "gf" || s[b].ty === "gs" || s[b].ty === "no")
          Q ? o[b].style.closed = !1 : o[b] = this.createStyleElement(s[b], c), s[b]._render && o[b].style.pElem.parentNode !== u && u.appendChild(o[b].style.pElem), T.push(o[b].style);
        else if (s[b].ty === "gr") {
          if (!Q)
            o[b] = this.createGroupElement(s[b]);
          else
            for (P = o[b].it.length, E = 0; E < P; E += 1)
              o[b].prevViewData[E] = o[b].it[E];
          this.searchShapes(s[b].it, o[b].it, o[b].prevViewData, o[b].gr, c + 1, v, g), s[b]._render && o[b].gr.parentNode !== u && u.appendChild(o[b].gr);
        } else s[b].ty === "tr" ? (Q || (o[b] = this.createTransformElement(s[b], u)), O = o[b].transform, v.push(O)) : s[b].ty === "sh" || s[b].ty === "rc" || s[b].ty === "el" || s[b].ty === "sr" ? (Q || (o[b] = this.createShapeElement(s[b], v, c)), this.setElementStyles(o[b])) : s[b].ty === "tm" || s[b].ty === "rd" || s[b].ty === "ms" || s[b].ty === "pb" || s[b].ty === "zz" || s[b].ty === "op" ? (Q ? (z = o[b], z.closed = !1) : (z = ShapeModifiers.getModifier(s[b].ty), z.init(this, s[b]), o[b] = z, this.shapeModifiers.push(z)), N.push(z)) : s[b].ty === "rp" && (Q ? (z = o[b], z.closed = !0) : (z = ShapeModifiers.getModifier(s[b].ty), o[b] = z, z.init(this, s, b, o), this.shapeModifiers.push(z), g = !1), N.push(z));
        this.addProcessedElement(s[b], b + 1);
      }
      for (S = T.length, b = 0; b < S; b += 1)
        T[b].closed = !0;
      for (S = N.length, b = 0; b < S; b += 1)
        N[b].closed = !0;
    }, SVGShapeElement.prototype.renderInnerContent = function() {
      this.renderModifiers();
      var s, o = this.stylesList.length;
      for (s = 0; s < o; s += 1)
        this.stylesList[s].reset();
      for (this.renderShape(), s = 0; s < o; s += 1)
        (this.stylesList[s]._mdf || this._isFirstFrame) && (this.stylesList[s].msElem && (this.stylesList[s].msElem.setAttribute("d", this.stylesList[s].d), this.stylesList[s].d = "M0 0" + this.stylesList[s].d), this.stylesList[s].pElem.setAttribute("d", this.stylesList[s].d || "M0 0"));
    }, SVGShapeElement.prototype.renderShape = function() {
      var s, o = this.animatedContents.length, l;
      for (s = 0; s < o; s += 1)
        l = this.animatedContents[s], (this._isFirstFrame || l.element._isAnimated) && l.data !== !0 && l.fn(l.data, l.element, this._isFirstFrame);
    }, SVGShapeElement.prototype.destroy = function() {
      this.destroyBaseElement(), this.shapesData = null, this.itemsData = null;
    };
    function LetterProps(s, o, l, u, c, m) {
      this.o = s, this.sw = o, this.sc = l, this.fc = u, this.m = c, this.p = m, this._mdf = {
        o: !0,
        sw: !!o,
        sc: !!l,
        fc: !!u,
        m: !0,
        p: !0
      };
    }
    LetterProps.prototype.update = function(s, o, l, u, c, m) {
      this._mdf.o = !1, this._mdf.sw = !1, this._mdf.sc = !1, this._mdf.fc = !1, this._mdf.m = !1, this._mdf.p = !1;
      var g = !1;
      return this.o !== s && (this.o = s, this._mdf.o = !0, g = !0), this.sw !== o && (this.sw = o, this._mdf.sw = !0, g = !0), this.sc !== l && (this.sc = l, this._mdf.sc = !0, g = !0), this.fc !== u && (this.fc = u, this._mdf.fc = !0, g = !0), this.m !== c && (this.m = c, this._mdf.m = !0, g = !0), m.length && (this.p[0] !== m[0] || this.p[1] !== m[1] || this.p[4] !== m[4] || this.p[5] !== m[5] || this.p[12] !== m[12] || this.p[13] !== m[13]) && (this.p = m, this._mdf.p = !0, g = !0), g;
    };
    function TextProperty(s, o) {
      this._frameId = initialDefaultFrame, this.pv = "", this.v = "", this.kf = !1, this._isFirstFrame = !0, this._mdf = !1, o.d && o.d.sid && (o.d = s.globalData.slotManager.getProp(o.d)), this.data = o, this.elem = s, this.comp = this.elem.comp, this.keysIndex = 0, this.canResize = !1, this.minimumFontSize = 1, this.effectsSequence = [], this.currentData = {
        ascent: 0,
        boxWidth: this.defaultBoxWidth,
        f: "",
        fStyle: "",
        fWeight: "",
        fc: "",
        j: "",
        justifyOffset: "",
        l: [],
        lh: 0,
        lineWidths: [],
        ls: "",
        of: "",
        s: "",
        sc: "",
        sw: 0,
        t: 0,
        tr: 0,
        sz: 0,
        ps: null,
        fillColorAnim: !1,
        strokeColorAnim: !1,
        strokeWidthAnim: !1,
        yOffset: 0,
        finalSize: 0,
        finalText: [],
        finalLineHeight: 0,
        __complete: !1
      }, this.copyData(this.currentData, this.data.d.k[0].s), this.searchProperty() || this.completeTextData(this.currentData);
    }
    TextProperty.prototype.defaultBoxWidth = [0, 0], TextProperty.prototype.copyData = function(s, o) {
      for (var l in o)
        Object.prototype.hasOwnProperty.call(o, l) && (s[l] = o[l]);
      return s;
    }, TextProperty.prototype.setCurrentData = function(s) {
      s.__complete || this.completeTextData(s), this.currentData = s, this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth, this._mdf = !0;
    }, TextProperty.prototype.searchProperty = function() {
      return this.searchKeyframes();
    }, TextProperty.prototype.searchKeyframes = function() {
      return this.kf = this.data.d.k.length > 1, this.kf && this.addEffect(this.getKeyframeValue.bind(this)), this.kf;
    }, TextProperty.prototype.addEffect = function(s) {
      this.effectsSequence.push(s), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.getValue = function(s) {
      if (!((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !s)) {
        this.currentData.t = this.data.d.k[this.keysIndex].s.t;
        var o = this.currentData, l = this.keysIndex;
        if (this.lock) {
          this.setCurrentData(this.currentData);
          return;
        }
        this.lock = !0, this._mdf = !1;
        var u, c = this.effectsSequence.length, m = s || this.data.d.k[this.keysIndex].s;
        for (u = 0; u < c; u += 1)
          l !== this.keysIndex ? m = this.effectsSequence[u](m, m.t) : m = this.effectsSequence[u](this.currentData, m.t);
        o !== m && this.setCurrentData(m), this.v = this.currentData, this.pv = this.v, this.lock = !1, this.frameId = this.elem.globalData.frameId;
      }
    }, TextProperty.prototype.getKeyframeValue = function() {
      for (var s = this.data.d.k, o = this.elem.comp.renderedFrame, l = 0, u = s.length; l <= u - 1 && !(l === u - 1 || s[l + 1].t > o); )
        l += 1;
      return this.keysIndex !== l && (this.keysIndex = l), this.data.d.k[this.keysIndex].s;
    }, TextProperty.prototype.buildFinalText = function(s) {
      for (var o = [], l = 0, u = s.length, c, m, g = !1, v = !1, b = ""; l < u; )
        g = v, v = !1, c = s.charCodeAt(l), b = s.charAt(l), FontManager.isCombinedCharacter(c) ? g = !0 : c >= 55296 && c <= 56319 ? FontManager.isRegionalFlag(s, l) ? b = s.substr(l, 14) : (m = s.charCodeAt(l + 1), m >= 56320 && m <= 57343 && (FontManager.isModifier(c, m) ? (b = s.substr(l, 2), g = !0) : FontManager.isFlagEmoji(s.substr(l, 4)) ? b = s.substr(l, 4) : b = s.substr(l, 2))) : c > 56319 ? (m = s.charCodeAt(l + 1), FontManager.isVariationSelector(c) && (g = !0)) : FontManager.isZeroWidthJoiner(c) && (g = !0, v = !0), g ? (o[o.length - 1] += b, g = !1) : o.push(b), l += b.length;
      return o;
    }, TextProperty.prototype.completeTextData = function(s) {
      s.__complete = !0;
      var o = this.elem.globalData.fontManager, l = this.data, u = [], c, m, g, v = 0, b, S = l.m.g, E = 0, P = 0, T = 0, N = [], O = 0, z = 0, Q, W, ue = o.getFontByName(s.f), te, K = 0, ve = getFontProperties(ue);
      s.fWeight = ve.weight, s.fStyle = ve.style, s.finalSize = s.s, s.finalText = this.buildFinalText(s.t), m = s.finalText.length, s.finalLineHeight = s.lh;
      var ee = s.tr / 1e3 * s.finalSize, Re;
      if (s.sz)
        for (var wt = !0, yt = s.sz[0], xt = s.sz[1], Kt, tn; wt; ) {
          tn = this.buildFinalText(s.t), Kt = 0, O = 0, m = tn.length, ee = s.tr / 1e3 * s.finalSize;
          var ln = -1;
          for (c = 0; c < m; c += 1)
            Re = tn[c].charCodeAt(0), g = !1, tn[c] === " " ? ln = c : (Re === 13 || Re === 3) && (O = 0, g = !0, Kt += s.finalLineHeight || s.finalSize * 1.2), o.chars ? (te = o.getCharData(tn[c], ue.fStyle, ue.fFamily), K = g ? 0 : te.w * s.finalSize / 100) : K = o.measureText(tn[c], s.f, s.finalSize), O + K > yt && tn[c] !== " " ? (ln === -1 ? m += 1 : c = ln, Kt += s.finalLineHeight || s.finalSize * 1.2, tn.splice(c, ln === c ? 1 : 0, "\r"), ln = -1, O = 0) : (O += K, O += ee);
          Kt += ue.ascent * s.finalSize / 100, this.canResize && s.finalSize > this.minimumFontSize && xt < Kt ? (s.finalSize -= 1, s.finalLineHeight = s.finalSize * s.lh / s.s) : (s.finalText = tn, m = s.finalText.length, wt = !1);
        }
      O = -ee, K = 0;
      var rn = 0, an;
      for (c = 0; c < m; c += 1)
        if (g = !1, an = s.finalText[c], Re = an.charCodeAt(0), Re === 13 || Re === 3 ? (rn = 0, N.push(O), z = O > z ? O : z, O = -2 * ee, b = "", g = !0, T += 1) : b = an, o.chars ? (te = o.getCharData(an, ue.fStyle, o.getFontByName(s.f).fFamily), K = g ? 0 : te.w * s.finalSize / 100) : K = o.measureText(b, s.f, s.finalSize), an === " " ? rn += K + ee : (O += K + ee + rn, rn = 0), u.push({
          l: K,
          an: K,
          add: E,
          n: g,
          anIndexes: [],
          val: b,
          line: T,
          animatorJustifyOffset: 0
        }), S == 2) {
          if (E += K, b === "" || b === " " || c === m - 1) {
            for ((b === "" || b === " ") && (E -= K); P <= c; )
              u[P].an = E, u[P].ind = v, u[P].extra = K, P += 1;
            v += 1, E = 0;
          }
        } else if (S == 3) {
          if (E += K, b === "" || c === m - 1) {
            for (b === "" && (E -= K); P <= c; )
              u[P].an = E, u[P].ind = v, u[P].extra = K, P += 1;
            E = 0, v += 1;
          }
        } else
          u[v].ind = v, u[v].extra = 0, v += 1;
      if (s.l = u, z = O > z ? O : z, N.push(O), s.sz)
        s.boxWidth = s.sz[0], s.justifyOffset = 0;
      else
        switch (s.boxWidth = z, s.j) {
          case 1:
            s.justifyOffset = -s.boxWidth;
            break;
          case 2:
            s.justifyOffset = -s.boxWidth / 2;
            break;
          default:
            s.justifyOffset = 0;
        }
      s.lineWidths = N;
      var Gt = l.a, nn, vt;
      W = Gt.length;
      var Et, Qt, un = [];
      for (Q = 0; Q < W; Q += 1) {
        for (nn = Gt[Q], nn.a.sc && (s.strokeColorAnim = !0), nn.a.sw && (s.strokeWidthAnim = !0), (nn.a.fc || nn.a.fh || nn.a.fs || nn.a.fb) && (s.fillColorAnim = !0), Qt = 0, Et = nn.s.b, c = 0; c < m; c += 1)
          vt = u[c], vt.anIndexes[Q] = Qt, (Et == 1 && vt.val !== "" || Et == 2 && vt.val !== "" && vt.val !== " " || Et == 3 && (vt.n || vt.val == " " || c == m - 1) || Et == 4 && (vt.n || c == m - 1)) && (nn.s.rn === 1 && un.push(Qt), Qt += 1);
        l.a[Q].s.totalChars = Qt;
        var gn = -1, dn;
        if (nn.s.rn === 1)
          for (c = 0; c < m; c += 1)
            vt = u[c], gn != vt.anIndexes[Q] && (gn = vt.anIndexes[Q], dn = un.splice(Math.floor(Math.random() * un.length), 1)[0]), vt.anIndexes[Q] = dn;
      }
      s.yOffset = s.finalLineHeight || s.finalSize * 1.2, s.ls = s.ls || 0, s.ascent = ue.ascent * s.finalSize / 100;
    }, TextProperty.prototype.updateDocumentData = function(s, o) {
      o = o === void 0 ? this.keysIndex : o;
      var l = this.copyData({}, this.data.d.k[o].s);
      l = this.copyData(l, s), this.data.d.k[o].s = l, this.recalculate(o), this.setCurrentData(l), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.recalculate = function(s) {
      var o = this.data.d.k[s].s;
      o.__complete = !1, this.keysIndex = 0, this._isFirstFrame = !0, this.getValue(o);
    }, TextProperty.prototype.canResizeFont = function(s) {
      this.canResize = s, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    }, TextProperty.prototype.setMinimumFontSize = function(s) {
      this.minimumFontSize = Math.floor(s) || 1, this.recalculate(this.keysIndex), this.elem.addDynamicProperty(this);
    };
    var TextSelectorProp = function() {
      var s = Math.max, o = Math.min, l = Math.floor;
      function u(m, g) {
        this._currentTextLength = -1, this.k = !1, this.data = g, this.elem = m, this.comp = m.comp, this.finalS = 0, this.finalE = 0, this.initDynamicPropertyContainer(m), this.s = PropertyFactory.getProp(m, g.s || {
          k: 0
        }, 0, 0, this), "e" in g ? this.e = PropertyFactory.getProp(m, g.e, 0, 0, this) : this.e = {
          v: 100
        }, this.o = PropertyFactory.getProp(m, g.o || {
          k: 0
        }, 0, 0, this), this.xe = PropertyFactory.getProp(m, g.xe || {
          k: 0
        }, 0, 0, this), this.ne = PropertyFactory.getProp(m, g.ne || {
          k: 0
        }, 0, 0, this), this.sm = PropertyFactory.getProp(m, g.sm || {
          k: 100
        }, 0, 0, this), this.a = PropertyFactory.getProp(m, g.a, 0, 0.01, this), this.dynamicProperties.length || this.getValue();
      }
      u.prototype = {
        getMult: function(g) {
          this._currentTextLength !== this.elem.textProperty.currentData.l.length && this.getValue();
          var v = 0, b = 0, S = 1, E = 1;
          this.ne.v > 0 ? v = this.ne.v / 100 : b = -this.ne.v / 100, this.xe.v > 0 ? S = 1 - this.xe.v / 100 : E = 1 + this.xe.v / 100;
          var P = BezierFactory.getBezierEasing(v, b, S, E).get, T = 0, N = this.finalS, O = this.finalE, z = this.data.sh;
          if (z === 2)
            O === N ? T = g >= O ? 1 : 0 : T = s(0, o(0.5 / (O - N) + (g - N) / (O - N), 1)), T = P(T);
          else if (z === 3)
            O === N ? T = g >= O ? 0 : 1 : T = 1 - s(0, o(0.5 / (O - N) + (g - N) / (O - N), 1)), T = P(T);
          else if (z === 4)
            O === N ? T = 0 : (T = s(0, o(0.5 / (O - N) + (g - N) / (O - N), 1)), T < 0.5 ? T *= 2 : T = 1 - 2 * (T - 0.5)), T = P(T);
          else if (z === 5) {
            if (O === N)
              T = 0;
            else {
              var Q = O - N;
              g = o(s(0, g + 0.5 - N), O - N);
              var W = -Q / 2 + g, ue = Q / 2;
              T = Math.sqrt(1 - W * W / (ue * ue));
            }
            T = P(T);
          } else z === 6 ? (O === N ? T = 0 : (g = o(s(0, g + 0.5 - N), O - N), T = (1 + Math.cos(Math.PI + Math.PI * 2 * g / (O - N))) / 2), T = P(T)) : (g >= l(N) && (g - N < 0 ? T = s(0, o(o(O, 1) - (N - g), 1)) : T = s(0, o(O - g, 1))), T = P(T));
          if (this.sm.v !== 100) {
            var te = this.sm.v * 0.01;
            te === 0 && (te = 1e-8);
            var K = 0.5 - te * 0.5;
            T < K ? T = 0 : (T = (T - K) / te, T > 1 && (T = 1));
          }
          return T * this.a.v;
        },
        getValue: function(g) {
          this.iterateDynamicProperties(), this._mdf = g || this._mdf, this._currentTextLength = this.elem.textProperty.currentData.l.length || 0, g && this.data.r === 2 && (this.e.v = this._currentTextLength);
          var v = this.data.r === 2 ? 1 : 100 / this.data.totalChars, b = this.o.v / v, S = this.s.v / v + b, E = this.e.v / v + b;
          if (S > E) {
            var P = S;
            S = E, E = P;
          }
          this.finalS = S, this.finalE = E;
        }
      }, extendPrototype([DynamicPropertyContainer], u);
      function c(m, g, v) {
        return new u(m, g);
      }
      return {
        getTextSelectorProp: c
      };
    }();
    function TextAnimatorDataProperty(s, o, l) {
      var u = {
        propType: !1
      }, c = PropertyFactory.getProp, m = o.a;
      this.a = {
        r: m.r ? c(s, m.r, 0, degToRads, l) : u,
        rx: m.rx ? c(s, m.rx, 0, degToRads, l) : u,
        ry: m.ry ? c(s, m.ry, 0, degToRads, l) : u,
        sk: m.sk ? c(s, m.sk, 0, degToRads, l) : u,
        sa: m.sa ? c(s, m.sa, 0, degToRads, l) : u,
        s: m.s ? c(s, m.s, 1, 0.01, l) : u,
        a: m.a ? c(s, m.a, 1, 0, l) : u,
        o: m.o ? c(s, m.o, 0, 0.01, l) : u,
        p: m.p ? c(s, m.p, 1, 0, l) : u,
        sw: m.sw ? c(s, m.sw, 0, 0, l) : u,
        sc: m.sc ? c(s, m.sc, 1, 0, l) : u,
        fc: m.fc ? c(s, m.fc, 1, 0, l) : u,
        fh: m.fh ? c(s, m.fh, 0, 0, l) : u,
        fs: m.fs ? c(s, m.fs, 0, 0.01, l) : u,
        fb: m.fb ? c(s, m.fb, 0, 0.01, l) : u,
        t: m.t ? c(s, m.t, 0, 0, l) : u
      }, this.s = TextSelectorProp.getTextSelectorProp(s, o.s, l), this.s.t = o.s.t;
    }
    function TextAnimatorProperty(s, o, l) {
      this._isFirstFrame = !0, this._hasMaskedPath = !1, this._frameId = -1, this._textData = s, this._renderType = o, this._elem = l, this._animatorsData = createSizedArray(this._textData.a.length), this._pathData = {}, this._moreOptions = {
        alignment: {}
      }, this.renderedLetters = [], this.lettersChangedFlag = !1, this.initDynamicPropertyContainer(l);
    }
    TextAnimatorProperty.prototype.searchProperties = function() {
      var s, o = this._textData.a.length, l, u = PropertyFactory.getProp;
      for (s = 0; s < o; s += 1)
        l = this._textData.a[s], this._animatorsData[s] = new TextAnimatorDataProperty(this._elem, l, this);
      this._textData.p && "m" in this._textData.p ? (this._pathData = {
        a: u(this._elem, this._textData.p.a, 0, 0, this),
        f: u(this._elem, this._textData.p.f, 0, 0, this),
        l: u(this._elem, this._textData.p.l, 0, 0, this),
        r: u(this._elem, this._textData.p.r, 0, 0, this),
        p: u(this._elem, this._textData.p.p, 0, 0, this),
        m: this._elem.maskManager.getMaskProperty(this._textData.p.m)
      }, this._hasMaskedPath = !0) : this._hasMaskedPath = !1, this._moreOptions.alignment = u(this._elem, this._textData.m.a, 1, 0, this);
    }, TextAnimatorProperty.prototype.getMeasures = function(s, o) {
      if (this.lettersChangedFlag = o, !(!this._mdf && !this._isFirstFrame && !o && (!this._hasMaskedPath || !this._pathData.m._mdf))) {
        this._isFirstFrame = !1;
        var l = this._moreOptions.alignment.v, u = this._animatorsData, c = this._textData, m = this.mHelper, g = this._renderType, v = this.renderedLetters.length, b, S, E, P, T = s.l, N, O, z, Q, W, ue, te, K, ve, ee, Re, wt, yt, xt, Kt;
        if (this._hasMaskedPath) {
          if (Kt = this._pathData.m, !this._pathData.n || this._pathData._mdf) {
            var tn = Kt.v;
            this._pathData.r.v && (tn = tn.reverse()), N = {
              tLength: 0,
              segments: []
            }, P = tn._length - 1;
            var ln;
            for (wt = 0, E = 0; E < P; E += 1)
              ln = bez.buildBezierData(tn.v[E], tn.v[E + 1], [tn.o[E][0] - tn.v[E][0], tn.o[E][1] - tn.v[E][1]], [tn.i[E + 1][0] - tn.v[E + 1][0], tn.i[E + 1][1] - tn.v[E + 1][1]]), N.tLength += ln.segmentLength, N.segments.push(ln), wt += ln.segmentLength;
            E = P, Kt.v.c && (ln = bez.buildBezierData(tn.v[E], tn.v[0], [tn.o[E][0] - tn.v[E][0], tn.o[E][1] - tn.v[E][1]], [tn.i[0][0] - tn.v[0][0], tn.i[0][1] - tn.v[0][1]]), N.tLength += ln.segmentLength, N.segments.push(ln), wt += ln.segmentLength), this._pathData.pi = N;
          }
          if (N = this._pathData.pi, O = this._pathData.f.v, te = 0, ue = 1, Q = 0, W = !0, ee = N.segments, O < 0 && Kt.v.c)
            for (N.tLength < Math.abs(O) && (O = -Math.abs(O) % N.tLength), te = ee.length - 1, ve = ee[te].points, ue = ve.length - 1; O < 0; )
              O += ve[ue].partialLength, ue -= 1, ue < 0 && (te -= 1, ve = ee[te].points, ue = ve.length - 1);
          ve = ee[te].points, K = ve[ue - 1], z = ve[ue], Re = z.partialLength;
        }
        P = T.length, b = 0, S = 0;
        var rn = s.finalSize * 1.2 * 0.714, an = !0, Gt, nn, vt, Et, Qt;
        Et = u.length;
        var un, gn = -1, dn, yn, vn, Pn = O, On = te, _n = ue, Nn = -1, Un, Xn, zn, jn, kn, Yn, Zn, er, bn = "", Ln = this.defaultPropsArray, Kn;
        if (s.j === 2 || s.j === 1) {
          var Bn = 0, Fn = 0, Gn = s.j === 2 ? -0.5 : -1, Wn = 0, Mn = !0;
          for (E = 0; E < P; E += 1)
            if (T[E].n) {
              for (Bn && (Bn += Fn); Wn < E; )
                T[Wn].animatorJustifyOffset = Bn, Wn += 1;
              Bn = 0, Mn = !0;
            } else {
              for (vt = 0; vt < Et; vt += 1)
                Gt = u[vt].a, Gt.t.propType && (Mn && s.j === 2 && (Fn += Gt.t.v * Gn), nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), un.length ? Bn += Gt.t.v * un[0] * Gn : Bn += Gt.t.v * un * Gn);
              Mn = !1;
            }
          for (Bn && (Bn += Fn); Wn < E; )
            T[Wn].animatorJustifyOffset = Bn, Wn += 1;
        }
        for (E = 0; E < P; E += 1) {
          if (m.reset(), Un = 1, T[E].n)
            b = 0, S += s.yOffset, S += an ? 1 : 0, O = Pn, an = !1, this._hasMaskedPath && (te = On, ue = _n, ve = ee[te].points, K = ve[ue - 1], z = ve[ue], Re = z.partialLength, Q = 0), bn = "", er = "", Yn = "", Kn = "", Ln = this.defaultPropsArray;
          else {
            if (this._hasMaskedPath) {
              if (Nn !== T[E].line) {
                switch (s.j) {
                  case 1:
                    O += wt - s.lineWidths[T[E].line];
                    break;
                  case 2:
                    O += (wt - s.lineWidths[T[E].line]) / 2;
                    break;
                }
                Nn = T[E].line;
              }
              gn !== T[E].ind && (T[gn] && (O += T[gn].extra), O += T[E].an / 2, gn = T[E].ind), O += l[0] * T[E].an * 5e-3;
              var Tn = 0;
              for (vt = 0; vt < Et; vt += 1)
                Gt = u[vt].a, Gt.p.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), un.length ? Tn += Gt.p.v[0] * un[0] : Tn += Gt.p.v[0] * un), Gt.a.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), un.length ? Tn += Gt.a.v[0] * un[0] : Tn += Gt.a.v[0] * un);
              for (W = !0, this._pathData.a.v && (O = T[0].an * 0.5 + (wt - this._pathData.f.v - T[0].an * 0.5 - T[T.length - 1].an * 0.5) * gn / (P - 1), O += this._pathData.f.v); W; )
                Q + Re >= O + Tn || !ve ? (yt = (O + Tn - Q) / z.partialLength, yn = K.point[0] + (z.point[0] - K.point[0]) * yt, vn = K.point[1] + (z.point[1] - K.point[1]) * yt, m.translate(-l[0] * T[E].an * 5e-3, -(l[1] * rn) * 0.01), W = !1) : ve && (Q += z.partialLength, ue += 1, ue >= ve.length && (ue = 0, te += 1, ee[te] ? ve = ee[te].points : Kt.v.c ? (ue = 0, te = 0, ve = ee[te].points) : (Q -= z.partialLength, ve = null)), ve && (K = z, z = ve[ue], Re = z.partialLength));
              dn = T[E].an / 2 - T[E].add, m.translate(-dn, 0, 0);
            } else
              dn = T[E].an / 2 - T[E].add, m.translate(-dn, 0, 0), m.translate(-l[0] * T[E].an * 5e-3, -l[1] * rn * 0.01, 0);
            for (vt = 0; vt < Et; vt += 1)
              Gt = u[vt].a, Gt.t.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), (b !== 0 || s.j !== 0) && (this._hasMaskedPath ? un.length ? O += Gt.t.v * un[0] : O += Gt.t.v * un : un.length ? b += Gt.t.v * un[0] : b += Gt.t.v * un));
            for (s.strokeWidthAnim && (zn = s.sw || 0), s.strokeColorAnim && (s.sc ? Xn = [s.sc[0], s.sc[1], s.sc[2]] : Xn = [0, 0, 0]), s.fillColorAnim && s.fc && (jn = [s.fc[0], s.fc[1], s.fc[2]]), vt = 0; vt < Et; vt += 1)
              Gt = u[vt].a, Gt.a.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), un.length ? m.translate(-Gt.a.v[0] * un[0], -Gt.a.v[1] * un[1], Gt.a.v[2] * un[2]) : m.translate(-Gt.a.v[0] * un, -Gt.a.v[1] * un, Gt.a.v[2] * un));
            for (vt = 0; vt < Et; vt += 1)
              Gt = u[vt].a, Gt.s.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), un.length ? m.scale(1 + (Gt.s.v[0] - 1) * un[0], 1 + (Gt.s.v[1] - 1) * un[1], 1) : m.scale(1 + (Gt.s.v[0] - 1) * un, 1 + (Gt.s.v[1] - 1) * un, 1));
            for (vt = 0; vt < Et; vt += 1) {
              if (Gt = u[vt].a, nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), Gt.sk.propType && (un.length ? m.skewFromAxis(-Gt.sk.v * un[0], Gt.sa.v * un[1]) : m.skewFromAxis(-Gt.sk.v * un, Gt.sa.v * un)), Gt.r.propType && (un.length ? m.rotateZ(-Gt.r.v * un[2]) : m.rotateZ(-Gt.r.v * un)), Gt.ry.propType && (un.length ? m.rotateY(Gt.ry.v * un[1]) : m.rotateY(Gt.ry.v * un)), Gt.rx.propType && (un.length ? m.rotateX(Gt.rx.v * un[0]) : m.rotateX(Gt.rx.v * un)), Gt.o.propType && (un.length ? Un += (Gt.o.v * un[0] - Un) * un[0] : Un += (Gt.o.v * un - Un) * un), s.strokeWidthAnim && Gt.sw.propType && (un.length ? zn += Gt.sw.v * un[0] : zn += Gt.sw.v * un), s.strokeColorAnim && Gt.sc.propType)
                for (kn = 0; kn < 3; kn += 1)
                  un.length ? Xn[kn] += (Gt.sc.v[kn] - Xn[kn]) * un[0] : Xn[kn] += (Gt.sc.v[kn] - Xn[kn]) * un;
              if (s.fillColorAnim && s.fc) {
                if (Gt.fc.propType)
                  for (kn = 0; kn < 3; kn += 1)
                    un.length ? jn[kn] += (Gt.fc.v[kn] - jn[kn]) * un[0] : jn[kn] += (Gt.fc.v[kn] - jn[kn]) * un;
                Gt.fh.propType && (un.length ? jn = addHueToRGB(jn, Gt.fh.v * un[0]) : jn = addHueToRGB(jn, Gt.fh.v * un)), Gt.fs.propType && (un.length ? jn = addSaturationToRGB(jn, Gt.fs.v * un[0]) : jn = addSaturationToRGB(jn, Gt.fs.v * un)), Gt.fb.propType && (un.length ? jn = addBrightnessToRGB(jn, Gt.fb.v * un[0]) : jn = addBrightnessToRGB(jn, Gt.fb.v * un));
              }
            }
            for (vt = 0; vt < Et; vt += 1)
              Gt = u[vt].a, Gt.p.propType && (nn = u[vt].s, un = nn.getMult(T[E].anIndexes[vt], c.a[vt].s.totalChars), this._hasMaskedPath ? un.length ? m.translate(0, Gt.p.v[1] * un[0], -Gt.p.v[2] * un[1]) : m.translate(0, Gt.p.v[1] * un, -Gt.p.v[2] * un) : un.length ? m.translate(Gt.p.v[0] * un[0], Gt.p.v[1] * un[1], -Gt.p.v[2] * un[2]) : m.translate(Gt.p.v[0] * un, Gt.p.v[1] * un, -Gt.p.v[2] * un));
            if (s.strokeWidthAnim && (Yn = zn < 0 ? 0 : zn), s.strokeColorAnim && (Zn = "rgb(" + Math.round(Xn[0] * 255) + "," + Math.round(Xn[1] * 255) + "," + Math.round(Xn[2] * 255) + ")"), s.fillColorAnim && s.fc && (er = "rgb(" + Math.round(jn[0] * 255) + "," + Math.round(jn[1] * 255) + "," + Math.round(jn[2] * 255) + ")"), this._hasMaskedPath) {
              if (m.translate(0, -s.ls), m.translate(0, l[1] * rn * 0.01 + S, 0), this._pathData.p.v) {
                xt = (z.point[1] - K.point[1]) / (z.point[0] - K.point[0]);
                var Rn = Math.atan(xt) * 180 / Math.PI;
                z.point[0] < K.point[0] && (Rn += 180), m.rotate(-Rn * Math.PI / 180);
              }
              m.translate(yn, vn, 0), O -= l[0] * T[E].an * 5e-3, T[E + 1] && gn !== T[E + 1].ind && (O += T[E].an / 2, O += s.tr * 1e-3 * s.finalSize);
            } else {
              switch (m.translate(b, S, 0), s.ps && m.translate(s.ps[0], s.ps[1] + s.ascent, 0), s.j) {
                case 1:
                  m.translate(T[E].animatorJustifyOffset + s.justifyOffset + (s.boxWidth - s.lineWidths[T[E].line]), 0, 0);
                  break;
                case 2:
                  m.translate(T[E].animatorJustifyOffset + s.justifyOffset + (s.boxWidth - s.lineWidths[T[E].line]) / 2, 0, 0);
                  break;
              }
              m.translate(0, -s.ls), m.translate(dn, 0, 0), m.translate(l[0] * T[E].an * 5e-3, l[1] * rn * 0.01, 0), b += T[E].l + s.tr * 1e-3 * s.finalSize;
            }
            g === "html" ? bn = m.toCSS() : g === "svg" ? bn = m.to2dCSS() : Ln = [m.props[0], m.props[1], m.props[2], m.props[3], m.props[4], m.props[5], m.props[6], m.props[7], m.props[8], m.props[9], m.props[10], m.props[11], m.props[12], m.props[13], m.props[14], m.props[15]], Kn = Un;
          }
          v <= E ? (Qt = new LetterProps(Kn, Yn, Zn, er, bn, Ln), this.renderedLetters.push(Qt), v += 1, this.lettersChangedFlag = !0) : (Qt = this.renderedLetters[E], this.lettersChangedFlag = Qt.update(Kn, Yn, Zn, er, bn, Ln) || this.lettersChangedFlag);
        }
      }
    }, TextAnimatorProperty.prototype.getValue = function() {
      this._elem.globalData.frameId !== this._frameId && (this._frameId = this._elem.globalData.frameId, this.iterateDynamicProperties());
    }, TextAnimatorProperty.prototype.mHelper = new Matrix(), TextAnimatorProperty.prototype.defaultPropsArray = [], extendPrototype([DynamicPropertyContainer], TextAnimatorProperty);
    function ITextElement() {
    }
    ITextElement.prototype.initElement = function(s, o, l) {
      this.lettersChangedFlag = !0, this.initFrame(), this.initBaseData(s, o, l), this.textProperty = new TextProperty(this, s.t, this.dynamicProperties), this.textAnimator = new TextAnimatorProperty(s.t, this.renderType, this), this.initTransform(s, o, l), this.initHierarchy(), this.initRenderable(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), this.createContent(), this.hide(), this.textAnimator.searchProperties(this.dynamicProperties);
    }, ITextElement.prototype.prepareFrame = function(s) {
      this._mdf = !1, this.prepareRenderableFrame(s), this.prepareProperties(s, this.isInRange);
    }, ITextElement.prototype.createPathShape = function(s, o) {
      var l, u = o.length, c, m = "";
      for (l = 0; l < u; l += 1)
        o[l].ty === "sh" && (c = o[l].ks.k, m += buildShapeString(c, c.i.length, !0, s));
      return m;
    }, ITextElement.prototype.updateDocumentData = function(s, o) {
      this.textProperty.updateDocumentData(s, o);
    }, ITextElement.prototype.canResizeFont = function(s) {
      this.textProperty.canResizeFont(s);
    }, ITextElement.prototype.setMinimumFontSize = function(s) {
      this.textProperty.setMinimumFontSize(s);
    }, ITextElement.prototype.applyTextPropertiesToMatrix = function(s, o, l, u, c) {
      switch (s.ps && o.translate(s.ps[0], s.ps[1] + s.ascent, 0), o.translate(0, -s.ls, 0), s.j) {
        case 1:
          o.translate(s.justifyOffset + (s.boxWidth - s.lineWidths[l]), 0, 0);
          break;
        case 2:
          o.translate(s.justifyOffset + (s.boxWidth - s.lineWidths[l]) / 2, 0, 0);
          break;
      }
      o.translate(u, c, 0);
    }, ITextElement.prototype.buildColor = function(s) {
      return "rgb(" + Math.round(s[0] * 255) + "," + Math.round(s[1] * 255) + "," + Math.round(s[2] * 255) + ")";
    }, ITextElement.prototype.emptyProp = new LetterProps(), ITextElement.prototype.destroy = function() {
    }, ITextElement.prototype.validateText = function() {
      (this.textProperty._mdf || this.textProperty._isFirstFrame) && (this.buildNewText(), this.textProperty._isFirstFrame = !1, this.textProperty._mdf = !1);
    };
    var emptyShapeData = {
      shapes: []
    };
    function SVGTextLottieElement(s, o, l) {
      this.textSpans = [], this.renderType = "svg", this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, SVGBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], SVGTextLottieElement), SVGTextLottieElement.prototype.createContent = function() {
      this.data.singleShape && !this.globalData.fontManager.chars && (this.textContainer = createNS("text"));
    }, SVGTextLottieElement.prototype.buildTextContents = function(s) {
      for (var o = 0, l = s.length, u = [], c = ""; o < l; )
        s[o] === "\r" || s[o] === "" ? (u.push(c), c = "") : c += s[o], o += 1;
      return u.push(c), u;
    }, SVGTextLottieElement.prototype.buildShapeData = function(s, o) {
      if (s.shapes && s.shapes.length) {
        var l = s.shapes[0];
        if (l.it) {
          var u = l.it[l.it.length - 1];
          u.s && (u.s.k[0] = o, u.s.k[1] = o);
        }
      }
      return s;
    }, SVGTextLottieElement.prototype.buildNewText = function() {
      this.addDynamicProperty(this);
      var s, o, l = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(l ? l.l.length : 0), l.fc ? this.layerElement.setAttribute("fill", this.buildColor(l.fc)) : this.layerElement.setAttribute("fill", "rgba(0,0,0,0)"), l.sc && (this.layerElement.setAttribute("stroke", this.buildColor(l.sc)), this.layerElement.setAttribute("stroke-width", l.sw)), this.layerElement.setAttribute("font-size", l.finalSize);
      var u = this.globalData.fontManager.getFontByName(l.f);
      if (u.fClass)
        this.layerElement.setAttribute("class", u.fClass);
      else {
        this.layerElement.setAttribute("font-family", u.fFamily);
        var c = l.fWeight, m = l.fStyle;
        this.layerElement.setAttribute("font-style", m), this.layerElement.setAttribute("font-weight", c);
      }
      this.layerElement.setAttribute("aria-label", l.t);
      var g = l.l || [], v = !!this.globalData.fontManager.chars;
      o = g.length;
      var b, S = this.mHelper, E = "", P = this.data.singleShape, T = 0, N = 0, O = !0, z = l.tr * 1e-3 * l.finalSize;
      if (P && !v && !l.sz) {
        var Q = this.textContainer, W = "start";
        switch (l.j) {
          case 1:
            W = "end";
            break;
          case 2:
            W = "middle";
            break;
          default:
            W = "start";
            break;
        }
        Q.setAttribute("text-anchor", W), Q.setAttribute("letter-spacing", z);
        var ue = this.buildTextContents(l.finalText);
        for (o = ue.length, N = l.ps ? l.ps[1] + l.ascent : 0, s = 0; s < o; s += 1)
          b = this.textSpans[s].span || createNS("tspan"), b.textContent = ue[s], b.setAttribute("x", 0), b.setAttribute("y", N), b.style.display = "inherit", Q.appendChild(b), this.textSpans[s] || (this.textSpans[s] = {
            span: null,
            glyph: null
          }), this.textSpans[s].span = b, N += l.finalLineHeight;
        this.layerElement.appendChild(Q);
      } else {
        var te = this.textSpans.length, K;
        for (s = 0; s < o; s += 1) {
          if (this.textSpans[s] || (this.textSpans[s] = {
            span: null,
            childSpan: null,
            glyph: null
          }), !v || !P || s === 0) {
            if (b = te > s ? this.textSpans[s].span : createNS(v ? "g" : "text"), te <= s) {
              if (b.setAttribute("stroke-linecap", "butt"), b.setAttribute("stroke-linejoin", "round"), b.setAttribute("stroke-miterlimit", "4"), this.textSpans[s].span = b, v) {
                var ve = createNS("g");
                b.appendChild(ve), this.textSpans[s].childSpan = ve;
              }
              this.textSpans[s].span = b, this.layerElement.appendChild(b);
            }
            b.style.display = "inherit";
          }
          if (S.reset(), P && (g[s].n && (T = -z, N += l.yOffset, N += O ? 1 : 0, O = !1), this.applyTextPropertiesToMatrix(l, S, g[s].line, T, N), T += g[s].l || 0, T += z), v) {
            K = this.globalData.fontManager.getCharData(l.finalText[s], u.fStyle, this.globalData.fontManager.getFontByName(l.f).fFamily);
            var ee;
            if (K.t === 1)
              ee = new SVGCompElement(K.data, this.globalData, this);
            else {
              var Re = emptyShapeData;
              K.data && K.data.shapes && (Re = this.buildShapeData(K.data, l.finalSize)), ee = new SVGShapeElement(Re, this.globalData, this);
            }
            if (this.textSpans[s].glyph) {
              var wt = this.textSpans[s].glyph;
              this.textSpans[s].childSpan.removeChild(wt.layerElement), wt.destroy();
            }
            this.textSpans[s].glyph = ee, ee._debug = !0, ee.prepareFrame(0), ee.renderFrame(), this.textSpans[s].childSpan.appendChild(ee.layerElement), K.t === 1 && this.textSpans[s].childSpan.setAttribute("transform", "scale(" + l.finalSize / 100 + "," + l.finalSize / 100 + ")");
          } else
            P && b.setAttribute("transform", "translate(" + S.props[12] + "," + S.props[13] + ")"), b.textContent = g[s].val, b.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve");
        }
        P && b && b.setAttribute("d", E);
      }
      for (; s < this.textSpans.length; )
        this.textSpans[s].span.style.display = "none", s += 1;
      this._sizeChanged = !0;
    }, SVGTextLottieElement.prototype.sourceRectAtTime = function() {
      if (this.prepareFrame(this.comp.renderedFrame - this.data.st), this.renderInnerContent(), this._sizeChanged) {
        this._sizeChanged = !1;
        var s = this.layerElement.getBBox();
        this.bbox = {
          top: s.y,
          left: s.x,
          width: s.width,
          height: s.height
        };
      }
      return this.bbox;
    }, SVGTextLottieElement.prototype.getValue = function() {
      var s, o = this.textSpans.length, l;
      for (this.renderedFrame = this.comp.renderedFrame, s = 0; s < o; s += 1)
        l = this.textSpans[s].glyph, l && (l.prepareFrame(this.comp.renderedFrame - this.data.st), l._mdf && (this._mdf = !0));
    }, SVGTextLottieElement.prototype.renderInnerContent = function() {
      if (this.validateText(), (!this.data.singleShape || this._mdf) && (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), this.lettersChangedFlag || this.textAnimator.lettersChangedFlag)) {
        this._sizeChanged = !0;
        var s, o, l = this.textAnimator.renderedLetters, u = this.textProperty.currentData.l;
        o = u.length;
        var c, m, g;
        for (s = 0; s < o; s += 1)
          u[s].n || (c = l[s], m = this.textSpans[s].span, g = this.textSpans[s].glyph, g && g.renderFrame(), c._mdf.m && m.setAttribute("transform", c.m), c._mdf.o && m.setAttribute("opacity", c.o), c._mdf.sw && m.setAttribute("stroke-width", c.sw), c._mdf.sc && m.setAttribute("stroke", c.sc), c._mdf.fc && m.setAttribute("fill", c.fc));
      }
    };
    function ISolidElement(s, o, l) {
      this.initElement(s, o, l);
    }
    extendPrototype([IImageElement], ISolidElement), ISolidElement.prototype.createContent = function() {
      var s = createNS("rect");
      s.setAttribute("width", this.data.sw), s.setAttribute("height", this.data.sh), s.setAttribute("fill", this.data.sc), this.layerElement.appendChild(s);
    };
    function NullElement(s, o, l) {
      this.initFrame(), this.initBaseData(s, o, l), this.initFrame(), this.initTransform(s, o, l), this.initHierarchy();
    }
    NullElement.prototype.prepareFrame = function(s) {
      this.prepareProperties(s, !0);
    }, NullElement.prototype.renderFrame = function() {
    }, NullElement.prototype.getBaseElement = function() {
      return null;
    }, NullElement.prototype.destroy = function() {
    }, NullElement.prototype.sourceRectAtTime = function() {
    }, NullElement.prototype.hide = function() {
    }, extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement], NullElement);
    function SVGRendererBase() {
    }
    extendPrototype([BaseRenderer], SVGRendererBase), SVGRendererBase.prototype.createNull = function(s) {
      return new NullElement(s, this.globalData, this);
    }, SVGRendererBase.prototype.createShape = function(s) {
      return new SVGShapeElement(s, this.globalData, this);
    }, SVGRendererBase.prototype.createText = function(s) {
      return new SVGTextLottieElement(s, this.globalData, this);
    }, SVGRendererBase.prototype.createImage = function(s) {
      return new IImageElement(s, this.globalData, this);
    }, SVGRendererBase.prototype.createSolid = function(s) {
      return new ISolidElement(s, this.globalData, this);
    }, SVGRendererBase.prototype.configAnimation = function(s) {
      this.svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg"), this.svgElement.setAttribute("xmlns:xlink", "http://www.w3.org/1999/xlink"), this.renderConfig.viewBoxSize ? this.svgElement.setAttribute("viewBox", this.renderConfig.viewBoxSize) : this.svgElement.setAttribute("viewBox", "0 0 " + s.w + " " + s.h), this.renderConfig.viewBoxOnly || (this.svgElement.setAttribute("width", s.w), this.svgElement.setAttribute("height", s.h), this.svgElement.style.width = "100%", this.svgElement.style.height = "100%", this.svgElement.style.transform = "translate3d(0,0,0)", this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility), this.renderConfig.width && this.svgElement.setAttribute("width", this.renderConfig.width), this.renderConfig.height && this.svgElement.setAttribute("height", this.renderConfig.height), this.renderConfig.className && this.svgElement.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.svgElement.setAttribute("id", this.renderConfig.id), this.renderConfig.focusable !== void 0 && this.svgElement.setAttribute("focusable", this.renderConfig.focusable), this.svgElement.setAttribute("preserveAspectRatio", this.renderConfig.preserveAspectRatio), this.animationItem.wrapper.appendChild(this.svgElement);
      var o = this.globalData.defs;
      this.setupGlobalData(s, o), this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.data = s;
      var l = createNS("clipPath"), u = createNS("rect");
      u.setAttribute("width", s.w), u.setAttribute("height", s.h), u.setAttribute("x", 0), u.setAttribute("y", 0);
      var c = createElementID();
      l.setAttribute("id", c), l.appendChild(u), this.layerElement.setAttribute("clip-path", "url(" + getLocationHref() + "#" + c + ")"), o.appendChild(l), this.layers = s.layers, this.elements = createSizedArray(s.layers.length);
    }, SVGRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.layerElement = null, this.globalData.defs = null;
      var s, o = this.layers ? this.layers.length : 0;
      for (s = 0; s < o; s += 1)
        this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, SVGRendererBase.prototype.updateContainerSize = function() {
    }, SVGRendererBase.prototype.findIndexByInd = function(s) {
      var o = 0, l = this.layers.length;
      for (o = 0; o < l; o += 1)
        if (this.layers[o].ind === s)
          return o;
      return -1;
    }, SVGRendererBase.prototype.buildItem = function(s) {
      var o = this.elements;
      if (!(o[s] || this.layers[s].ty === 99)) {
        o[s] = !0;
        var l = this.createItem(this.layers[s]);
        if (o[s] = l, getExpressionsPlugin() && (this.layers[s].ty === 0 && this.globalData.projectInterface.registerComposition(l), l.initExpressions()), this.appendElementInPos(l, s), this.layers[s].tt) {
          var u = "tp" in this.layers[s] ? this.findIndexByInd(this.layers[s].tp) : s - 1;
          if (u === -1)
            return;
          if (!this.elements[u] || this.elements[u] === !0)
            this.buildItem(u), this.addPendingElement(l);
          else {
            var c = o[u], m = c.getMatte(this.layers[s].tt);
            l.setMatte(m);
          }
        }
      }
    }, SVGRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var s = this.pendingElements.pop();
        if (s.checkParenting(), s.data.tt)
          for (var o = 0, l = this.elements.length; o < l; ) {
            if (this.elements[o] === s) {
              var u = "tp" in s.data ? this.findIndexByInd(s.data.tp) : o - 1, c = this.elements[u], m = c.getMatte(this.layers[o].tt);
              s.setMatte(m);
              break;
            }
            o += 1;
          }
      }
    }, SVGRendererBase.prototype.renderFrame = function(s) {
      if (!(this.renderedFrame === s || this.destroyed)) {
        s === null ? s = this.renderedFrame : this.renderedFrame = s, this.globalData.frameNum = s, this.globalData.frameId += 1, this.globalData.projectInterface.currentFrame = s, this.globalData._mdf = !1;
        var o, l = this.layers.length;
        for (this.completeLayers || this.checkLayers(s), o = l - 1; o >= 0; o -= 1)
          (this.completeLayers || this.elements[o]) && this.elements[o].prepareFrame(s - this.layers[o].st);
        if (this.globalData._mdf)
          for (o = 0; o < l; o += 1)
            (this.completeLayers || this.elements[o]) && this.elements[o].renderFrame();
      }
    }, SVGRendererBase.prototype.appendElementInPos = function(s, o) {
      var l = s.getBaseElement();
      if (l) {
        for (var u = 0, c; u < o; )
          this.elements[u] && this.elements[u] !== !0 && this.elements[u].getBaseElement() && (c = this.elements[u].getBaseElement()), u += 1;
        c ? this.layerElement.insertBefore(l, c) : this.layerElement.appendChild(l);
      }
    }, SVGRendererBase.prototype.hide = function() {
      this.layerElement.style.display = "none";
    }, SVGRendererBase.prototype.show = function() {
      this.layerElement.style.display = "block";
    };
    function ICompElement() {
    }
    extendPrototype([BaseElement, TransformElement, HierarchyElement, FrameElement, RenderableDOMElement], ICompElement), ICompElement.prototype.initElement = function(s, o, l) {
      this.initFrame(), this.initBaseData(s, o, l), this.initTransform(s, o, l), this.initRenderable(), this.initHierarchy(), this.initRendererElement(), this.createContainerElements(), this.createRenderableComponents(), (this.data.xt || !o.progressiveLoad) && this.buildAllItems(), this.hide();
    }, ICompElement.prototype.prepareFrame = function(s) {
      if (this._mdf = !1, this.prepareRenderableFrame(s), this.prepareProperties(s, this.isInRange), !(!this.isInRange && !this.data.xt)) {
        if (this.tm._placeholder)
          this.renderedFrame = s / this.data.sr;
        else {
          var o = this.tm.v;
          o === this.data.op && (o = this.data.op - 1), this.renderedFrame = o;
        }
        var l, u = this.elements.length;
        for (this.completeLayers || this.checkLayers(this.renderedFrame), l = u - 1; l >= 0; l -= 1)
          (this.completeLayers || this.elements[l]) && (this.elements[l].prepareFrame(this.renderedFrame - this.layers[l].st), this.elements[l]._mdf && (this._mdf = !0));
      }
    }, ICompElement.prototype.renderInnerContent = function() {
      var s, o = this.layers.length;
      for (s = 0; s < o; s += 1)
        (this.completeLayers || this.elements[s]) && this.elements[s].renderFrame();
    }, ICompElement.prototype.setElements = function(s) {
      this.elements = s;
    }, ICompElement.prototype.getElements = function() {
      return this.elements;
    }, ICompElement.prototype.destroyElements = function() {
      var s, o = this.layers.length;
      for (s = 0; s < o; s += 1)
        this.elements[s] && this.elements[s].destroy();
    }, ICompElement.prototype.destroy = function() {
      this.destroyElements(), this.destroyBaseElement();
    };
    function SVGCompElement(s, o, l) {
      this.layers = s.layers, this.supports3d = !0, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(s, o, l), this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, o.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([SVGRendererBase, ICompElement, SVGBaseElement], SVGCompElement), SVGCompElement.prototype.createComp = function(s) {
      return new SVGCompElement(s, this.globalData, this);
    };
    function SVGRenderer(s, o) {
      this.animationItem = s, this.layers = null, this.renderedFrame = -1, this.svgElement = createNS("svg");
      var l = "";
      if (o && o.title) {
        var u = createNS("title"), c = createElementID();
        u.setAttribute("id", c), u.textContent = o.title, this.svgElement.appendChild(u), l += c;
      }
      if (o && o.description) {
        var m = createNS("desc"), g = createElementID();
        m.setAttribute("id", g), m.textContent = o.description, this.svgElement.appendChild(m), l += " " + g;
      }
      l && this.svgElement.setAttribute("aria-labelledby", l);
      var v = createNS("defs");
      this.svgElement.appendChild(v);
      var b = createNS("g");
      this.svgElement.appendChild(b), this.layerElement = b, this.renderConfig = {
        preserveAspectRatio: o && o.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: o && o.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: o && o.contentVisibility || "visible",
        progressiveLoad: o && o.progressiveLoad || !1,
        hideOnTransparent: !(o && o.hideOnTransparent === !1),
        viewBoxOnly: o && o.viewBoxOnly || !1,
        viewBoxSize: o && o.viewBoxSize || !1,
        className: o && o.className || "",
        id: o && o.id || "",
        focusable: o && o.focusable,
        filterSize: {
          width: o && o.filterSize && o.filterSize.width || "100%",
          height: o && o.filterSize && o.filterSize.height || "100%",
          x: o && o.filterSize && o.filterSize.x || "0%",
          y: o && o.filterSize && o.filterSize.y || "0%"
        },
        width: o && o.width,
        height: o && o.height,
        runExpressions: !o || o.runExpressions === void 0 || o.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        defs: v,
        renderConfig: this.renderConfig
      }, this.elements = [], this.pendingElements = [], this.destroyed = !1, this.rendererType = "svg";
    }
    extendPrototype([SVGRendererBase], SVGRenderer), SVGRenderer.prototype.createComp = function(s) {
      return new SVGCompElement(s, this.globalData, this);
    };
    function ShapeTransformManager() {
      this.sequences = {}, this.sequenceList = [], this.transform_key_count = 0;
    }
    ShapeTransformManager.prototype = {
      addTransformSequence: function(o) {
        var l, u = o.length, c = "_";
        for (l = 0; l < u; l += 1)
          c += o[l].transform.key + "_";
        var m = this.sequences[c];
        return m || (m = {
          transforms: [].concat(o),
          finalTransform: new Matrix(),
          _mdf: !1
        }, this.sequences[c] = m, this.sequenceList.push(m)), m;
      },
      processSequence: function(o, l) {
        for (var u = 0, c = o.transforms.length, m = l; u < c && !l; ) {
          if (o.transforms[u].transform.mProps._mdf) {
            m = !0;
            break;
          }
          u += 1;
        }
        if (m)
          for (o.finalTransform.reset(), u = c - 1; u >= 0; u -= 1)
            o.finalTransform.multiply(o.transforms[u].transform.mProps.v);
        o._mdf = m;
      },
      processSequences: function(o) {
        var l, u = this.sequenceList.length;
        for (l = 0; l < u; l += 1)
          this.processSequence(this.sequenceList[l], o);
      },
      getNewKey: function() {
        return this.transform_key_count += 1, "_" + this.transform_key_count;
      }
    };
    var lumaLoader = function() {
      var o = "__lottie_element_luma_buffer", l = null, u = null, c = null;
      function m() {
        var b = createNS("svg"), S = createNS("filter"), E = createNS("feColorMatrix");
        return S.setAttribute("id", o), E.setAttribute("type", "matrix"), E.setAttribute("color-interpolation-filters", "sRGB"), E.setAttribute("values", "0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0"), S.appendChild(E), b.appendChild(S), b.setAttribute("id", o + "_svg"), featureSupport.svgLumaHidden && (b.style.display = "none"), b;
      }
      function g() {
        l || (c = m(), document.body.appendChild(c), l = createTag("canvas"), u = l.getContext("2d"), u.filter = "url(#" + o + ")", u.fillStyle = "rgba(0,0,0,0)", u.fillRect(0, 0, 1, 1));
      }
      function v(b) {
        return l || g(), l.width = b.width, l.height = b.height, u.filter = "url(#" + o + ")", l;
      }
      return {
        load: g,
        get: v
      };
    };
    function createCanvas(s, o) {
      if (featureSupport.offscreenCanvas)
        return new OffscreenCanvas(s, o);
      var l = createTag("canvas");
      return l.width = s, l.height = o, l;
    }
    var assetLoader = function() {
      return {
        loadLumaCanvas: lumaLoader.load,
        getLumaCanvas: lumaLoader.get,
        createCanvas
      };
    }(), registeredEffects = {};
    function CVEffects(s) {
      var o, l = s.data.ef ? s.data.ef.length : 0;
      this.filters = [];
      var u;
      for (o = 0; o < l; o += 1) {
        u = null;
        var c = s.data.ef[o].ty;
        if (registeredEffects[c]) {
          var m = registeredEffects[c].effect;
          u = new m(s.effectsManager.effectElements[o], s);
        }
        u && this.filters.push(u);
      }
      this.filters.length && s.addRenderableComponent(this);
    }
    CVEffects.prototype.renderFrame = function(s) {
      var o, l = this.filters.length;
      for (o = 0; o < l; o += 1)
        this.filters[o].renderFrame(s);
    }, CVEffects.prototype.getEffects = function(s) {
      var o, l = this.filters.length, u = [];
      for (o = 0; o < l; o += 1)
        this.filters[o].type === s && u.push(this.filters[o]);
      return u;
    };
    function registerEffect(s, o) {
      registeredEffects[s] = {
        effect: o
      };
    }
    function CVMaskElement(s, o) {
      this.data = s, this.element = o, this.masksProperties = this.data.masksProperties || [], this.viewData = createSizedArray(this.masksProperties.length);
      var l, u = this.masksProperties.length, c = !1;
      for (l = 0; l < u; l += 1)
        this.masksProperties[l].mode !== "n" && (c = !0), this.viewData[l] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[l], 3);
      this.hasMasks = c, c && this.element.addRenderableComponent(this);
    }
    CVMaskElement.prototype.renderFrame = function() {
      if (this.hasMasks) {
        var s = this.element.finalTransform.mat, o = this.element.canvasContext, l, u = this.masksProperties.length, c, m, g;
        for (o.beginPath(), l = 0; l < u; l += 1)
          if (this.masksProperties[l].mode !== "n") {
            this.masksProperties[l].inv && (o.moveTo(0, 0), o.lineTo(this.element.globalData.compSize.w, 0), o.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h), o.lineTo(0, this.element.globalData.compSize.h), o.lineTo(0, 0)), g = this.viewData[l].v, c = s.applyToPointArray(g.v[0][0], g.v[0][1], 0), o.moveTo(c[0], c[1]);
            var v, b = g._length;
            for (v = 1; v < b; v += 1)
              m = s.applyToTriplePoints(g.o[v - 1], g.i[v], g.v[v]), o.bezierCurveTo(m[0], m[1], m[2], m[3], m[4], m[5]);
            m = s.applyToTriplePoints(g.o[v - 1], g.i[0], g.v[0]), o.bezierCurveTo(m[0], m[1], m[2], m[3], m[4], m[5]);
          }
        this.element.globalData.renderer.save(!0), o.clip();
      }
    }, CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty, CVMaskElement.prototype.destroy = function() {
      this.element = null;
    };
    function CVBaseElement() {
    }
    var operationsMap = {
      1: "source-in",
      2: "source-out",
      3: "source-in",
      4: "source-out"
    };
    CVBaseElement.prototype = {
      createElements: function() {
      },
      initRendererElement: function() {
      },
      createContainerElements: function() {
        if (this.data.tt >= 1) {
          this.buffers = [];
          var o = this.globalData.canvasContext, l = assetLoader.createCanvas(o.canvas.width, o.canvas.height);
          this.buffers.push(l);
          var u = assetLoader.createCanvas(o.canvas.width, o.canvas.height);
          this.buffers.push(u), this.data.tt >= 3 && !document._isProxy && assetLoader.loadLumaCanvas();
        }
        this.canvasContext = this.globalData.canvasContext, this.transformCanvas = this.globalData.transformCanvas, this.renderableEffectsManager = new CVEffects(this), this.searchEffectTransforms();
      },
      createContent: function() {
      },
      setBlendMode: function() {
        var o = this.globalData;
        if (o.blendMode !== this.data.bm) {
          o.blendMode = this.data.bm;
          var l = getBlendMode(this.data.bm);
          o.canvasContext.globalCompositeOperation = l;
        }
      },
      createRenderableComponents: function() {
        this.maskManager = new CVMaskElement(this.data, this), this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);
      },
      hideElement: function() {
        !this.hidden && (!this.isInRange || this.isTransparent) && (this.hidden = !0);
      },
      showElement: function() {
        this.isInRange && !this.isTransparent && (this.hidden = !1, this._isFirstFrame = !0, this.maskManager._isFirstFrame = !0);
      },
      clearCanvas: function(o) {
        o.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);
      },
      prepareLayer: function() {
        if (this.data.tt >= 1) {
          var o = this.buffers[0], l = o.getContext("2d");
          this.clearCanvas(l), l.drawImage(this.canvasContext.canvas, 0, 0), this.currentTransform = this.canvasContext.getTransform(), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
        }
      },
      exitLayer: function() {
        if (this.data.tt >= 1) {
          var o = this.buffers[1], l = o.getContext("2d");
          this.clearCanvas(l), l.drawImage(this.canvasContext.canvas, 0, 0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.setTransform(this.currentTransform);
          var u = this.comp.getElementById("tp" in this.data ? this.data.tp : this.data.ind - 1);
          if (u.renderFrame(!0), this.canvasContext.setTransform(1, 0, 0, 1, 0, 0), this.data.tt >= 3 && !document._isProxy) {
            var c = assetLoader.getLumaCanvas(this.canvasContext.canvas), m = c.getContext("2d");
            m.drawImage(this.canvasContext.canvas, 0, 0), this.clearCanvas(this.canvasContext), this.canvasContext.drawImage(c, 0, 0);
          }
          this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt], this.canvasContext.drawImage(o, 0, 0), this.canvasContext.globalCompositeOperation = "destination-over", this.canvasContext.drawImage(this.buffers[0], 0, 0), this.canvasContext.setTransform(this.currentTransform), this.canvasContext.globalCompositeOperation = "source-over";
        }
      },
      renderFrame: function(o) {
        if (!(this.hidden || this.data.hd) && !(this.data.td === 1 && !o)) {
          this.renderTransform(), this.renderRenderable(), this.renderLocalTransform(), this.setBlendMode();
          var l = this.data.ty === 0;
          this.prepareLayer(), this.globalData.renderer.save(l), this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props), this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity), this.renderInnerContent(), this.globalData.renderer.restore(l), this.exitLayer(), this.maskManager.hasMasks && this.globalData.renderer.restore(!0), this._isFirstFrame && (this._isFirstFrame = !1);
        }
      },
      destroy: function() {
        this.canvasContext = null, this.data = null, this.globalData = null, this.maskManager.destroy();
      },
      mHelper: new Matrix()
    }, CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement, CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;
    function CVShapeData(s, o, l, u) {
      this.styledShapes = [], this.tr = [0, 0, 0, 0, 0, 0];
      var c = 4;
      o.ty === "rc" ? c = 5 : o.ty === "el" ? c = 6 : o.ty === "sr" && (c = 7), this.sh = ShapePropertyFactory.getShapeProp(s, o, c, s);
      var m, g = l.length, v;
      for (m = 0; m < g; m += 1)
        l[m].closed || (v = {
          transforms: u.addTransformSequence(l[m].transforms),
          trNodes: []
        }, this.styledShapes.push(v), l[m].elements.push(v));
    }
    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;
    function CVShapeElement(s, o, l) {
      this.shapes = [], this.shapesData = s.shapes, this.stylesList = [], this.itemsData = [], this.prevViewData = [], this.shapeModifiers = [], this.processedElements = [], this.transformsManager = new ShapeTransformManager(), this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, IShapeElement, HierarchyElement, FrameElement, RenderableElement], CVShapeElement), CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement, CVShapeElement.prototype.transformHelper = {
      opacity: 1,
      _opMdf: !1
    }, CVShapeElement.prototype.dashResetter = [], CVShapeElement.prototype.createContent = function() {
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []);
    }, CVShapeElement.prototype.createStyleElement = function(s, o) {
      var l = {
        data: s,
        type: s.ty,
        preTransforms: this.transformsManager.addTransformSequence(o),
        transforms: [],
        elements: [],
        closed: s.hd === !0
      }, u = {};
      if (s.ty === "fl" || s.ty === "st" ? (u.c = PropertyFactory.getProp(this, s.c, 1, 255, this), u.c.k || (l.co = "rgb(" + bmFloor(u.c.v[0]) + "," + bmFloor(u.c.v[1]) + "," + bmFloor(u.c.v[2]) + ")")) : (s.ty === "gf" || s.ty === "gs") && (u.s = PropertyFactory.getProp(this, s.s, 1, null, this), u.e = PropertyFactory.getProp(this, s.e, 1, null, this), u.h = PropertyFactory.getProp(this, s.h || {
        k: 0
      }, 0, 0.01, this), u.a = PropertyFactory.getProp(this, s.a || {
        k: 0
      }, 0, degToRads, this), u.g = new GradientProperty(this, s.g, this)), u.o = PropertyFactory.getProp(this, s.o, 0, 0.01, this), s.ty === "st" || s.ty === "gs") {
        if (l.lc = lineCapEnum[s.lc || 2], l.lj = lineJoinEnum[s.lj || 2], s.lj == 1 && (l.ml = s.ml), u.w = PropertyFactory.getProp(this, s.w, 0, null, this), u.w.k || (l.wi = u.w.v), s.d) {
          var c = new DashProperty(this, s.d, "canvas", this);
          u.d = c, u.d.k || (l.da = u.d.dashArray, l.do = u.d.dashoffset[0]);
        }
      } else
        l.r = s.r === 2 ? "evenodd" : "nonzero";
      return this.stylesList.push(l), u.style = l, u;
    }, CVShapeElement.prototype.createGroupElement = function() {
      var s = {
        it: [],
        prevViewData: []
      };
      return s;
    }, CVShapeElement.prototype.createTransformElement = function(s) {
      var o = {
        transform: {
          opacity: 1,
          _opMdf: !1,
          key: this.transformsManager.getNewKey(),
          op: PropertyFactory.getProp(this, s.o, 0, 0.01, this),
          mProps: TransformPropertyFactory.getTransformProperty(this, s, this)
        }
      };
      return o;
    }, CVShapeElement.prototype.createShapeElement = function(s) {
      var o = new CVShapeData(this, s, this.stylesList, this.transformsManager);
      return this.shapes.push(o), this.addShapeToModifiers(o), o;
    }, CVShapeElement.prototype.reloadShapes = function() {
      this._isFirstFrame = !0;
      var s, o = this.itemsData.length;
      for (s = 0; s < o; s += 1)
        this.prevViewData[s] = this.itemsData[s];
      for (this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, !0, []), o = this.dynamicProperties.length, s = 0; s < o; s += 1)
        this.dynamicProperties[s].getValue();
      this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame);
    }, CVShapeElement.prototype.addTransformToStyleList = function(s) {
      var o, l = this.stylesList.length;
      for (o = 0; o < l; o += 1)
        this.stylesList[o].closed || this.stylesList[o].transforms.push(s);
    }, CVShapeElement.prototype.removeTransformFromStyleList = function() {
      var s, o = this.stylesList.length;
      for (s = 0; s < o; s += 1)
        this.stylesList[s].closed || this.stylesList[s].transforms.pop();
    }, CVShapeElement.prototype.closeStyles = function(s) {
      var o, l = s.length;
      for (o = 0; o < l; o += 1)
        s[o].closed = !0;
    }, CVShapeElement.prototype.searchShapes = function(s, o, l, u, c) {
      var m, g = s.length - 1, v, b, S = [], E = [], P, T, N, O = [].concat(c);
      for (m = g; m >= 0; m -= 1) {
        if (P = this.searchProcessedElement(s[m]), P ? o[m] = l[P - 1] : s[m]._shouldRender = u, s[m].ty === "fl" || s[m].ty === "st" || s[m].ty === "gf" || s[m].ty === "gs")
          P ? o[m].style.closed = !1 : o[m] = this.createStyleElement(s[m], O), S.push(o[m].style);
        else if (s[m].ty === "gr") {
          if (!P)
            o[m] = this.createGroupElement(s[m]);
          else
            for (b = o[m].it.length, v = 0; v < b; v += 1)
              o[m].prevViewData[v] = o[m].it[v];
          this.searchShapes(s[m].it, o[m].it, o[m].prevViewData, u, O);
        } else s[m].ty === "tr" ? (P || (N = this.createTransformElement(s[m]), o[m] = N), O.push(o[m]), this.addTransformToStyleList(o[m])) : s[m].ty === "sh" || s[m].ty === "rc" || s[m].ty === "el" || s[m].ty === "sr" ? P || (o[m] = this.createShapeElement(s[m])) : s[m].ty === "tm" || s[m].ty === "rd" || s[m].ty === "pb" || s[m].ty === "zz" || s[m].ty === "op" ? (P ? (T = o[m], T.closed = !1) : (T = ShapeModifiers.getModifier(s[m].ty), T.init(this, s[m]), o[m] = T, this.shapeModifiers.push(T)), E.push(T)) : s[m].ty === "rp" && (P ? (T = o[m], T.closed = !0) : (T = ShapeModifiers.getModifier(s[m].ty), o[m] = T, T.init(this, s, m, o), this.shapeModifiers.push(T), u = !1), E.push(T));
        this.addProcessedElement(s[m], m + 1);
      }
      for (this.removeTransformFromStyleList(), this.closeStyles(S), g = E.length, m = 0; m < g; m += 1)
        E[m].closed = !0;
    }, CVShapeElement.prototype.renderInnerContent = function() {
      this.transformHelper.opacity = 1, this.transformHelper._opMdf = !1, this.renderModifiers(), this.transformsManager.processSequences(this._isFirstFrame), this.renderShape(this.transformHelper, this.shapesData, this.itemsData, !0);
    }, CVShapeElement.prototype.renderShapeTransform = function(s, o) {
      (s._opMdf || o.op._mdf || this._isFirstFrame) && (o.opacity = s.opacity, o.opacity *= o.op.v, o._opMdf = !0);
    }, CVShapeElement.prototype.drawLayer = function() {
      var s, o = this.stylesList.length, l, u, c, m, g, v, b = this.globalData.renderer, S = this.globalData.canvasContext, E, P;
      for (s = 0; s < o; s += 1)
        if (P = this.stylesList[s], E = P.type, !((E === "st" || E === "gs") && P.wi === 0 || !P.data._shouldRender || P.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {
          for (b.save(), g = P.elements, E === "st" || E === "gs" ? (b.ctxStrokeStyle(E === "st" ? P.co : P.grd), b.ctxLineWidth(P.wi), b.ctxLineCap(P.lc), b.ctxLineJoin(P.lj), b.ctxMiterLimit(P.ml || 0)) : b.ctxFillStyle(E === "fl" ? P.co : P.grd), b.ctxOpacity(P.coOp), E !== "st" && E !== "gs" && S.beginPath(), b.ctxTransform(P.preTransforms.finalTransform.props), u = g.length, l = 0; l < u; l += 1) {
            for ((E === "st" || E === "gs") && (S.beginPath(), P.da && (S.setLineDash(P.da), S.lineDashOffset = P.do)), v = g[l].trNodes, m = v.length, c = 0; c < m; c += 1)
              v[c].t === "m" ? S.moveTo(v[c].p[0], v[c].p[1]) : v[c].t === "c" ? S.bezierCurveTo(v[c].pts[0], v[c].pts[1], v[c].pts[2], v[c].pts[3], v[c].pts[4], v[c].pts[5]) : S.closePath();
            (E === "st" || E === "gs") && (b.ctxStroke(), P.da && S.setLineDash(this.dashResetter));
          }
          E !== "st" && E !== "gs" && this.globalData.renderer.ctxFill(P.r), b.restore();
        }
    }, CVShapeElement.prototype.renderShape = function(s, o, l, u) {
      var c, m = o.length - 1, g;
      for (g = s, c = m; c >= 0; c -= 1)
        o[c].ty === "tr" ? (g = l[c].transform, this.renderShapeTransform(s, g)) : o[c].ty === "sh" || o[c].ty === "el" || o[c].ty === "rc" || o[c].ty === "sr" ? this.renderPath(o[c], l[c]) : o[c].ty === "fl" ? this.renderFill(o[c], l[c], g) : o[c].ty === "st" ? this.renderStroke(o[c], l[c], g) : o[c].ty === "gf" || o[c].ty === "gs" ? this.renderGradientFill(o[c], l[c], g) : o[c].ty === "gr" ? this.renderShape(g, o[c].it, l[c].it) : o[c].ty;
      u && this.drawLayer();
    }, CVShapeElement.prototype.renderStyledShape = function(s, o) {
      if (this._isFirstFrame || o._mdf || s.transforms._mdf) {
        var l = s.trNodes, u = o.paths, c, m, g, v = u._length;
        l.length = 0;
        var b = s.transforms.finalTransform;
        for (g = 0; g < v; g += 1) {
          var S = u.shapes[g];
          if (S && S.v) {
            for (m = S._length, c = 1; c < m; c += 1)
              c === 1 && l.push({
                t: "m",
                p: b.applyToPointArray(S.v[0][0], S.v[0][1], 0)
              }), l.push({
                t: "c",
                pts: b.applyToTriplePoints(S.o[c - 1], S.i[c], S.v[c])
              });
            m === 1 && l.push({
              t: "m",
              p: b.applyToPointArray(S.v[0][0], S.v[0][1], 0)
            }), S.c && m && (l.push({
              t: "c",
              pts: b.applyToTriplePoints(S.o[c - 1], S.i[0], S.v[0])
            }), l.push({
              t: "z"
            }));
          }
        }
        s.trNodes = l;
      }
    }, CVShapeElement.prototype.renderPath = function(s, o) {
      if (s.hd !== !0 && s._shouldRender) {
        var l, u = o.styledShapes.length;
        for (l = 0; l < u; l += 1)
          this.renderStyledShape(o.styledShapes[l], o.sh);
      }
    }, CVShapeElement.prototype.renderFill = function(s, o, l) {
      var u = o.style;
      (o.c._mdf || this._isFirstFrame) && (u.co = "rgb(" + bmFloor(o.c.v[0]) + "," + bmFloor(o.c.v[1]) + "," + bmFloor(o.c.v[2]) + ")"), (o.o._mdf || l._opMdf || this._isFirstFrame) && (u.coOp = o.o.v * l.opacity);
    }, CVShapeElement.prototype.renderGradientFill = function(s, o, l) {
      var u = o.style, c;
      if (!u.grd || o.g._mdf || o.s._mdf || o.e._mdf || s.t !== 1 && (o.h._mdf || o.a._mdf)) {
        var m = this.globalData.canvasContext, g = o.s.v, v = o.e.v;
        if (s.t === 1)
          c = m.createLinearGradient(g[0], g[1], v[0], v[1]);
        else {
          var b = Math.sqrt(Math.pow(g[0] - v[0], 2) + Math.pow(g[1] - v[1], 2)), S = Math.atan2(v[1] - g[1], v[0] - g[0]), E = o.h.v;
          E >= 1 ? E = 0.99 : E <= -1 && (E = -0.99);
          var P = b * E, T = Math.cos(S + o.a.v) * P + g[0], N = Math.sin(S + o.a.v) * P + g[1];
          c = m.createRadialGradient(T, N, 0, g[0], g[1], b);
        }
        var O, z = s.g.p, Q = o.g.c, W = 1;
        for (O = 0; O < z; O += 1)
          o.g._hasOpacity && o.g._collapsable && (W = o.g.o[O * 2 + 1]), c.addColorStop(Q[O * 4] / 100, "rgba(" + Q[O * 4 + 1] + "," + Q[O * 4 + 2] + "," + Q[O * 4 + 3] + "," + W + ")");
        u.grd = c;
      }
      u.coOp = o.o.v * l.opacity;
    }, CVShapeElement.prototype.renderStroke = function(s, o, l) {
      var u = o.style, c = o.d;
      c && (c._mdf || this._isFirstFrame) && (u.da = c.dashArray, u.do = c.dashoffset[0]), (o.c._mdf || this._isFirstFrame) && (u.co = "rgb(" + bmFloor(o.c.v[0]) + "," + bmFloor(o.c.v[1]) + "," + bmFloor(o.c.v[2]) + ")"), (o.o._mdf || l._opMdf || this._isFirstFrame) && (u.coOp = o.o.v * l.opacity), (o.w._mdf || this._isFirstFrame) && (u.wi = o.w.v);
    }, CVShapeElement.prototype.destroy = function() {
      this.shapesData = null, this.globalData = null, this.canvasContext = null, this.stylesList.length = 0, this.itemsData.length = 0;
    };
    function CVTextElement(s, o, l) {
      this.textSpans = [], this.yOffset = 0, this.fillColorAnim = !1, this.strokeColorAnim = !1, this.strokeWidthAnim = !1, this.stroke = !1, this.fill = !1, this.justifyOffset = 0, this.currentRender = null, this.renderType = "canvas", this.values = {
        fill: "rgba(0,0,0,0)",
        stroke: "rgba(0,0,0,0)",
        sWidth: 0,
        fValue: ""
      }, this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement, ITextElement], CVTextElement), CVTextElement.prototype.tHelper = createTag("canvas").getContext("2d"), CVTextElement.prototype.buildNewText = function() {
      var s = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
      var o = !1;
      s.fc ? (o = !0, this.values.fill = this.buildColor(s.fc)) : this.values.fill = "rgba(0,0,0,0)", this.fill = o;
      var l = !1;
      s.sc && (l = !0, this.values.stroke = this.buildColor(s.sc), this.values.sWidth = s.sw);
      var u = this.globalData.fontManager.getFontByName(s.f), c, m, g = s.l, v = this.mHelper;
      this.stroke = l, this.values.fValue = s.finalSize + "px " + this.globalData.fontManager.getFontByName(s.f).fFamily, m = s.finalText.length;
      var b, S, E, P, T, N, O, z, Q, W, ue = this.data.singleShape, te = s.tr * 1e-3 * s.finalSize, K = 0, ve = 0, ee = !0, Re = 0;
      for (c = 0; c < m; c += 1) {
        b = this.globalData.fontManager.getCharData(s.finalText[c], u.fStyle, this.globalData.fontManager.getFontByName(s.f).fFamily), S = b && b.data || {}, v.reset(), ue && g[c].n && (K = -te, ve += s.yOffset, ve += ee ? 1 : 0, ee = !1), T = S.shapes ? S.shapes[0].it : [], O = T.length, v.scale(s.finalSize / 100, s.finalSize / 100), ue && this.applyTextPropertiesToMatrix(s, v, g[c].line, K, ve), Q = createSizedArray(O - 1);
        var wt = 0;
        for (N = 0; N < O; N += 1)
          if (T[N].ty === "sh") {
            for (P = T[N].ks.k.i.length, z = T[N].ks.k, W = [], E = 1; E < P; E += 1)
              E === 1 && W.push(v.applyToX(z.v[0][0], z.v[0][1], 0), v.applyToY(z.v[0][0], z.v[0][1], 0)), W.push(v.applyToX(z.o[E - 1][0], z.o[E - 1][1], 0), v.applyToY(z.o[E - 1][0], z.o[E - 1][1], 0), v.applyToX(z.i[E][0], z.i[E][1], 0), v.applyToY(z.i[E][0], z.i[E][1], 0), v.applyToX(z.v[E][0], z.v[E][1], 0), v.applyToY(z.v[E][0], z.v[E][1], 0));
            W.push(v.applyToX(z.o[E - 1][0], z.o[E - 1][1], 0), v.applyToY(z.o[E - 1][0], z.o[E - 1][1], 0), v.applyToX(z.i[0][0], z.i[0][1], 0), v.applyToY(z.i[0][0], z.i[0][1], 0), v.applyToX(z.v[0][0], z.v[0][1], 0), v.applyToY(z.v[0][0], z.v[0][1], 0)), Q[wt] = W, wt += 1;
          }
        ue && (K += g[c].l, K += te), this.textSpans[Re] ? this.textSpans[Re].elem = Q : this.textSpans[Re] = {
          elem: Q
        }, Re += 1;
      }
    }, CVTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var s = this.canvasContext;
      s.font = this.values.fValue, this.globalData.renderer.ctxLineCap("butt"), this.globalData.renderer.ctxLineJoin("miter"), this.globalData.renderer.ctxMiterLimit(4), this.data.singleShape || this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);
      var o, l, u, c, m, g, v = this.textAnimator.renderedLetters, b = this.textProperty.currentData.l;
      l = b.length;
      var S, E = null, P = null, T = null, N, O, z = this.globalData.renderer;
      for (o = 0; o < l; o += 1)
        if (!b[o].n) {
          if (S = v[o], S && (z.save(), z.ctxTransform(S.p), z.ctxOpacity(S.o)), this.fill) {
            for (S && S.fc ? E !== S.fc && (z.ctxFillStyle(S.fc), E = S.fc) : E !== this.values.fill && (E = this.values.fill, z.ctxFillStyle(this.values.fill)), N = this.textSpans[o].elem, c = N.length, this.globalData.canvasContext.beginPath(), u = 0; u < c; u += 1)
              for (O = N[u], g = O.length, this.globalData.canvasContext.moveTo(O[0], O[1]), m = 2; m < g; m += 6)
                this.globalData.canvasContext.bezierCurveTo(O[m], O[m + 1], O[m + 2], O[m + 3], O[m + 4], O[m + 5]);
            this.globalData.canvasContext.closePath(), z.ctxFill();
          }
          if (this.stroke) {
            for (S && S.sw ? T !== S.sw && (T = S.sw, z.ctxLineWidth(S.sw)) : T !== this.values.sWidth && (T = this.values.sWidth, z.ctxLineWidth(this.values.sWidth)), S && S.sc ? P !== S.sc && (P = S.sc, z.ctxStrokeStyle(S.sc)) : P !== this.values.stroke && (P = this.values.stroke, z.ctxStrokeStyle(this.values.stroke)), N = this.textSpans[o].elem, c = N.length, this.globalData.canvasContext.beginPath(), u = 0; u < c; u += 1)
              for (O = N[u], g = O.length, this.globalData.canvasContext.moveTo(O[0], O[1]), m = 2; m < g; m += 6)
                this.globalData.canvasContext.bezierCurveTo(O[m], O[m + 1], O[m + 2], O[m + 3], O[m + 4], O[m + 5]);
            this.globalData.canvasContext.closePath(), z.ctxStroke();
          }
          S && this.globalData.renderer.restore();
        }
    };
    function CVImageElement(s, o, l) {
      this.assetData = o.getAssetData(s.refId), this.img = o.imageLoader.getAsset(this.assetData), this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVImageElement), CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVImageElement.prototype.createContent = function() {
      if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {
        var s = createTag("canvas");
        s.width = this.assetData.w, s.height = this.assetData.h;
        var o = s.getContext("2d"), l = this.img.width, u = this.img.height, c = l / u, m = this.assetData.w / this.assetData.h, g, v, b = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;
        c > m && b === "xMidYMid slice" || c < m && b !== "xMidYMid slice" ? (v = u, g = v * m) : (g = l, v = g / m), o.drawImage(this.img, (l - g) / 2, (u - v) / 2, g, v, 0, 0, this.assetData.w, this.assetData.h), this.img = s;
      }
    }, CVImageElement.prototype.renderInnerContent = function() {
      this.canvasContext.drawImage(this.img, 0, 0);
    }, CVImageElement.prototype.destroy = function() {
      this.img = null;
    };
    function CVSolidElement(s, o, l) {
      this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, CVBaseElement, HierarchyElement, FrameElement, RenderableElement], CVSolidElement), CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement, CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame, CVSolidElement.prototype.renderInnerContent = function() {
      this.globalData.renderer.ctxFillStyle(this.data.sc), this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);
    };
    function CanvasRendererBase() {
    }
    extendPrototype([BaseRenderer], CanvasRendererBase), CanvasRendererBase.prototype.createShape = function(s) {
      return new CVShapeElement(s, this.globalData, this);
    }, CanvasRendererBase.prototype.createText = function(s) {
      return new CVTextElement(s, this.globalData, this);
    }, CanvasRendererBase.prototype.createImage = function(s) {
      return new CVImageElement(s, this.globalData, this);
    }, CanvasRendererBase.prototype.createSolid = function(s) {
      return new CVSolidElement(s, this.globalData, this);
    }, CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, CanvasRendererBase.prototype.ctxTransform = function(s) {
      s[0] === 1 && s[1] === 0 && s[4] === 0 && s[5] === 1 && s[12] === 0 && s[13] === 0 || this.canvasContext.transform(s[0], s[1], s[4], s[5], s[12], s[13]);
    }, CanvasRendererBase.prototype.ctxOpacity = function(s) {
      this.canvasContext.globalAlpha *= s < 0 ? 0 : s;
    }, CanvasRendererBase.prototype.ctxFillStyle = function(s) {
      this.canvasContext.fillStyle = s;
    }, CanvasRendererBase.prototype.ctxStrokeStyle = function(s) {
      this.canvasContext.strokeStyle = s;
    }, CanvasRendererBase.prototype.ctxLineWidth = function(s) {
      this.canvasContext.lineWidth = s;
    }, CanvasRendererBase.prototype.ctxLineCap = function(s) {
      this.canvasContext.lineCap = s;
    }, CanvasRendererBase.prototype.ctxLineJoin = function(s) {
      this.canvasContext.lineJoin = s;
    }, CanvasRendererBase.prototype.ctxMiterLimit = function(s) {
      this.canvasContext.miterLimit = s;
    }, CanvasRendererBase.prototype.ctxFill = function(s) {
      this.canvasContext.fill(s);
    }, CanvasRendererBase.prototype.ctxFillRect = function(s, o, l, u) {
      this.canvasContext.fillRect(s, o, l, u);
    }, CanvasRendererBase.prototype.ctxStroke = function() {
      this.canvasContext.stroke();
    }, CanvasRendererBase.prototype.reset = function() {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      this.contextData.reset();
    }, CanvasRendererBase.prototype.save = function() {
      this.canvasContext.save();
    }, CanvasRendererBase.prototype.restore = function(s) {
      if (!this.renderConfig.clearCanvas) {
        this.canvasContext.restore();
        return;
      }
      s && (this.globalData.blendMode = "source-over"), this.contextData.restore(s);
    }, CanvasRendererBase.prototype.configAnimation = function(s) {
      if (this.animationItem.wrapper) {
        this.animationItem.container = createTag("canvas");
        var o = this.animationItem.container.style;
        o.width = "100%", o.height = "100%";
        var l = "0px 0px 0px";
        o.transformOrigin = l, o.mozTransformOrigin = l, o.webkitTransformOrigin = l, o["-webkit-transform"] = l, o.contentVisibility = this.renderConfig.contentVisibility, this.animationItem.wrapper.appendChild(this.animationItem.container), this.canvasContext = this.animationItem.container.getContext("2d"), this.renderConfig.className && this.animationItem.container.setAttribute("class", this.renderConfig.className), this.renderConfig.id && this.animationItem.container.setAttribute("id", this.renderConfig.id);
      } else
        this.canvasContext = this.renderConfig.context;
      this.contextData.setContext(this.canvasContext), this.data = s, this.layers = s.layers, this.transformCanvas = {
        w: s.w,
        h: s.h,
        sx: 0,
        sy: 0,
        tx: 0,
        ty: 0
      }, this.setupGlobalData(s, document.body), this.globalData.canvasContext = this.canvasContext, this.globalData.renderer = this, this.globalData.isDashed = !1, this.globalData.progressiveLoad = this.renderConfig.progressiveLoad, this.globalData.transformCanvas = this.transformCanvas, this.elements = createSizedArray(s.layers.length), this.updateContainerSize();
    }, CanvasRendererBase.prototype.updateContainerSize = function(s, o) {
      this.reset();
      var l, u;
      s ? (l = s, u = o, this.canvasContext.canvas.width = l, this.canvasContext.canvas.height = u) : (this.animationItem.wrapper && this.animationItem.container ? (l = this.animationItem.wrapper.offsetWidth, u = this.animationItem.wrapper.offsetHeight) : (l = this.canvasContext.canvas.width, u = this.canvasContext.canvas.height), this.canvasContext.canvas.width = l * this.renderConfig.dpr, this.canvasContext.canvas.height = u * this.renderConfig.dpr);
      var c, m;
      if (this.renderConfig.preserveAspectRatio.indexOf("meet") !== -1 || this.renderConfig.preserveAspectRatio.indexOf("slice") !== -1) {
        var g = this.renderConfig.preserveAspectRatio.split(" "), v = g[1] || "meet", b = g[0] || "xMidYMid", S = b.substr(0, 4), E = b.substr(4);
        c = l / u, m = this.transformCanvas.w / this.transformCanvas.h, m > c && v === "meet" || m < c && v === "slice" ? (this.transformCanvas.sx = l / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = l / (this.transformCanvas.w / this.renderConfig.dpr)) : (this.transformCanvas.sx = u / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.sy = u / (this.transformCanvas.h / this.renderConfig.dpr)), S === "xMid" && (m < c && v === "meet" || m > c && v === "slice") ? this.transformCanvas.tx = (l - this.transformCanvas.w * (u / this.transformCanvas.h)) / 2 * this.renderConfig.dpr : S === "xMax" && (m < c && v === "meet" || m > c && v === "slice") ? this.transformCanvas.tx = (l - this.transformCanvas.w * (u / this.transformCanvas.h)) * this.renderConfig.dpr : this.transformCanvas.tx = 0, E === "YMid" && (m > c && v === "meet" || m < c && v === "slice") ? this.transformCanvas.ty = (u - this.transformCanvas.h * (l / this.transformCanvas.w)) / 2 * this.renderConfig.dpr : E === "YMax" && (m > c && v === "meet" || m < c && v === "slice") ? this.transformCanvas.ty = (u - this.transformCanvas.h * (l / this.transformCanvas.w)) * this.renderConfig.dpr : this.transformCanvas.ty = 0;
      } else this.renderConfig.preserveAspectRatio === "none" ? (this.transformCanvas.sx = l / (this.transformCanvas.w / this.renderConfig.dpr), this.transformCanvas.sy = u / (this.transformCanvas.h / this.renderConfig.dpr), this.transformCanvas.tx = 0, this.transformCanvas.ty = 0) : (this.transformCanvas.sx = this.renderConfig.dpr, this.transformCanvas.sy = this.renderConfig.dpr, this.transformCanvas.tx = 0, this.transformCanvas.ty = 0);
      this.transformCanvas.props = [this.transformCanvas.sx, 0, 0, 0, 0, this.transformCanvas.sy, 0, 0, 0, 0, 1, 0, this.transformCanvas.tx, this.transformCanvas.ty, 0, 1], this.ctxTransform(this.transformCanvas.props), this.canvasContext.beginPath(), this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h), this.canvasContext.closePath(), this.canvasContext.clip(), this.renderFrame(this.renderedFrame, !0);
    }, CanvasRendererBase.prototype.destroy = function() {
      this.renderConfig.clearCanvas && this.animationItem.wrapper && (this.animationItem.wrapper.innerText = "");
      var s, o = this.layers ? this.layers.length : 0;
      for (s = o - 1; s >= 0; s -= 1)
        this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
      this.elements.length = 0, this.globalData.canvasContext = null, this.animationItem.container = null, this.destroyed = !0;
    }, CanvasRendererBase.prototype.renderFrame = function(s, o) {
      if (!(this.renderedFrame === s && this.renderConfig.clearCanvas === !0 && !o || this.destroyed || s === -1)) {
        this.renderedFrame = s, this.globalData.frameNum = s - this.animationItem._isFirstFrame, this.globalData.frameId += 1, this.globalData._mdf = !this.renderConfig.clearCanvas || o, this.globalData.projectInterface.currentFrame = s;
        var l, u = this.layers.length;
        for (this.completeLayers || this.checkLayers(s), l = u - 1; l >= 0; l -= 1)
          (this.completeLayers || this.elements[l]) && this.elements[l].prepareFrame(s - this.layers[l].st);
        if (this.globalData._mdf) {
          for (this.renderConfig.clearCanvas === !0 ? this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h) : this.save(), l = u - 1; l >= 0; l -= 1)
            (this.completeLayers || this.elements[l]) && this.elements[l].renderFrame();
          this.renderConfig.clearCanvas !== !0 && this.restore();
        }
      }
    }, CanvasRendererBase.prototype.buildItem = function(s) {
      var o = this.elements;
      if (!(o[s] || this.layers[s].ty === 99)) {
        var l = this.createItem(this.layers[s], this, this.globalData);
        o[s] = l, l.initExpressions();
      }
    }, CanvasRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var s = this.pendingElements.pop();
        s.checkParenting();
      }
    }, CanvasRendererBase.prototype.hide = function() {
      this.animationItem.container.style.display = "none";
    }, CanvasRendererBase.prototype.show = function() {
      this.animationItem.container.style.display = "block";
    };
    function CanvasContext() {
      this.opacity = -1, this.transform = createTypedArray("float32", 16), this.fillStyle = "", this.strokeStyle = "", this.lineWidth = "", this.lineCap = "", this.lineJoin = "", this.miterLimit = "", this.id = Math.random();
    }
    function CVContextData() {
      this.stack = [], this.cArrPos = 0, this.cTr = new Matrix();
      var s, o = 15;
      for (s = 0; s < o; s += 1) {
        var l = new CanvasContext();
        this.stack[s] = l;
      }
      this._length = o, this.nativeContext = null, this.transformMat = new Matrix(), this.currentOpacity = 1, this.currentFillStyle = "", this.appliedFillStyle = "", this.currentStrokeStyle = "", this.appliedStrokeStyle = "", this.currentLineWidth = "", this.appliedLineWidth = "", this.currentLineCap = "", this.appliedLineCap = "", this.currentLineJoin = "", this.appliedLineJoin = "", this.appliedMiterLimit = "", this.currentMiterLimit = "";
    }
    CVContextData.prototype.duplicate = function() {
      var s = this._length * 2, o = 0;
      for (o = this._length; o < s; o += 1)
        this.stack[o] = new CanvasContext();
      this._length = s;
    }, CVContextData.prototype.reset = function() {
      this.cArrPos = 0, this.cTr.reset(), this.stack[this.cArrPos].opacity = 1;
    }, CVContextData.prototype.restore = function(s) {
      this.cArrPos -= 1;
      var o = this.stack[this.cArrPos], l = o.transform, u, c = this.cTr.props;
      for (u = 0; u < 16; u += 1)
        c[u] = l[u];
      if (s) {
        this.nativeContext.restore();
        var m = this.stack[this.cArrPos + 1];
        this.appliedFillStyle = m.fillStyle, this.appliedStrokeStyle = m.strokeStyle, this.appliedLineWidth = m.lineWidth, this.appliedLineCap = m.lineCap, this.appliedLineJoin = m.lineJoin, this.appliedMiterLimit = m.miterLimit;
      }
      this.nativeContext.setTransform(l[0], l[1], l[4], l[5], l[12], l[13]), (s || o.opacity !== -1 && this.currentOpacity !== o.opacity) && (this.nativeContext.globalAlpha = o.opacity, this.currentOpacity = o.opacity), this.currentFillStyle = o.fillStyle, this.currentStrokeStyle = o.strokeStyle, this.currentLineWidth = o.lineWidth, this.currentLineCap = o.lineCap, this.currentLineJoin = o.lineJoin, this.currentMiterLimit = o.miterLimit;
    }, CVContextData.prototype.save = function(s) {
      s && this.nativeContext.save();
      var o = this.cTr.props;
      this._length <= this.cArrPos && this.duplicate();
      var l = this.stack[this.cArrPos], u;
      for (u = 0; u < 16; u += 1)
        l.transform[u] = o[u];
      this.cArrPos += 1;
      var c = this.stack[this.cArrPos];
      c.opacity = l.opacity, c.fillStyle = l.fillStyle, c.strokeStyle = l.strokeStyle, c.lineWidth = l.lineWidth, c.lineCap = l.lineCap, c.lineJoin = l.lineJoin, c.miterLimit = l.miterLimit;
    }, CVContextData.prototype.setOpacity = function(s) {
      this.stack[this.cArrPos].opacity = s;
    }, CVContextData.prototype.setContext = function(s) {
      this.nativeContext = s;
    }, CVContextData.prototype.fillStyle = function(s) {
      this.stack[this.cArrPos].fillStyle !== s && (this.currentFillStyle = s, this.stack[this.cArrPos].fillStyle = s);
    }, CVContextData.prototype.strokeStyle = function(s) {
      this.stack[this.cArrPos].strokeStyle !== s && (this.currentStrokeStyle = s, this.stack[this.cArrPos].strokeStyle = s);
    }, CVContextData.prototype.lineWidth = function(s) {
      this.stack[this.cArrPos].lineWidth !== s && (this.currentLineWidth = s, this.stack[this.cArrPos].lineWidth = s);
    }, CVContextData.prototype.lineCap = function(s) {
      this.stack[this.cArrPos].lineCap !== s && (this.currentLineCap = s, this.stack[this.cArrPos].lineCap = s);
    }, CVContextData.prototype.lineJoin = function(s) {
      this.stack[this.cArrPos].lineJoin !== s && (this.currentLineJoin = s, this.stack[this.cArrPos].lineJoin = s);
    }, CVContextData.prototype.miterLimit = function(s) {
      this.stack[this.cArrPos].miterLimit !== s && (this.currentMiterLimit = s, this.stack[this.cArrPos].miterLimit = s);
    }, CVContextData.prototype.transform = function(s) {
      this.transformMat.cloneFromProps(s);
      var o = this.cTr;
      this.transformMat.multiply(o), o.cloneFromProps(this.transformMat.props);
      var l = o.props;
      this.nativeContext.setTransform(l[0], l[1], l[4], l[5], l[12], l[13]);
    }, CVContextData.prototype.opacity = function(s) {
      var o = this.stack[this.cArrPos].opacity;
      o *= s < 0 ? 0 : s, this.stack[this.cArrPos].opacity !== o && (this.currentOpacity !== s && (this.nativeContext.globalAlpha = s, this.currentOpacity = s), this.stack[this.cArrPos].opacity = o);
    }, CVContextData.prototype.fill = function(s) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fill(s);
    }, CVContextData.prototype.fillRect = function(s, o, l, u) {
      this.appliedFillStyle !== this.currentFillStyle && (this.appliedFillStyle = this.currentFillStyle, this.nativeContext.fillStyle = this.appliedFillStyle), this.nativeContext.fillRect(s, o, l, u);
    }, CVContextData.prototype.stroke = function() {
      this.appliedStrokeStyle !== this.currentStrokeStyle && (this.appliedStrokeStyle = this.currentStrokeStyle, this.nativeContext.strokeStyle = this.appliedStrokeStyle), this.appliedLineWidth !== this.currentLineWidth && (this.appliedLineWidth = this.currentLineWidth, this.nativeContext.lineWidth = this.appliedLineWidth), this.appliedLineCap !== this.currentLineCap && (this.appliedLineCap = this.currentLineCap, this.nativeContext.lineCap = this.appliedLineCap), this.appliedLineJoin !== this.currentLineJoin && (this.appliedLineJoin = this.currentLineJoin, this.nativeContext.lineJoin = this.appliedLineJoin), this.appliedMiterLimit !== this.currentMiterLimit && (this.appliedMiterLimit = this.currentMiterLimit, this.nativeContext.miterLimit = this.appliedMiterLimit), this.nativeContext.stroke();
    };
    function CVCompElement(s, o, l) {
      this.completeLayers = !1, this.layers = s.layers, this.pendingElements = [], this.elements = createSizedArray(this.layers.length), this.initElement(s, o, l), this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, o.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([CanvasRendererBase, ICompElement, CVBaseElement], CVCompElement), CVCompElement.prototype.renderInnerContent = function() {
      var s = this.canvasContext;
      s.beginPath(), s.moveTo(0, 0), s.lineTo(this.data.w, 0), s.lineTo(this.data.w, this.data.h), s.lineTo(0, this.data.h), s.lineTo(0, 0), s.clip();
      var o, l = this.layers.length;
      for (o = l - 1; o >= 0; o -= 1)
        (this.completeLayers || this.elements[o]) && this.elements[o].renderFrame();
    }, CVCompElement.prototype.destroy = function() {
      var s, o = this.layers.length;
      for (s = o - 1; s >= 0; s -= 1)
        this.elements[s] && this.elements[s].destroy();
      this.layers = null, this.elements = null;
    }, CVCompElement.prototype.createComp = function(s) {
      return new CVCompElement(s, this.globalData, this);
    };
    function CanvasRenderer(s, o) {
      this.animationItem = s, this.renderConfig = {
        clearCanvas: o && o.clearCanvas !== void 0 ? o.clearCanvas : !0,
        context: o && o.context || null,
        progressiveLoad: o && o.progressiveLoad || !1,
        preserveAspectRatio: o && o.preserveAspectRatio || "xMidYMid meet",
        imagePreserveAspectRatio: o && o.imagePreserveAspectRatio || "xMidYMid slice",
        contentVisibility: o && o.contentVisibility || "visible",
        className: o && o.className || "",
        id: o && o.id || "",
        runExpressions: !o || o.runExpressions === void 0 || o.runExpressions
      }, this.renderConfig.dpr = o && o.dpr || 1, this.animationItem.wrapper && (this.renderConfig.dpr = o && o.dpr || window.devicePixelRatio || 1), this.renderedFrame = -1, this.globalData = {
        frameNum: -1,
        _mdf: !1,
        renderConfig: this.renderConfig,
        currentGlobalAlpha: -1
      }, this.contextData = new CVContextData(), this.elements = [], this.pendingElements = [], this.transformMat = new Matrix(), this.completeLayers = !1, this.rendererType = "canvas", this.renderConfig.clearCanvas && (this.ctxTransform = this.contextData.transform.bind(this.contextData), this.ctxOpacity = this.contextData.opacity.bind(this.contextData), this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData), this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData), this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData), this.ctxLineCap = this.contextData.lineCap.bind(this.contextData), this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData), this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData), this.ctxFill = this.contextData.fill.bind(this.contextData), this.ctxFillRect = this.contextData.fillRect.bind(this.contextData), this.ctxStroke = this.contextData.stroke.bind(this.contextData), this.save = this.contextData.save.bind(this.contextData));
    }
    extendPrototype([CanvasRendererBase], CanvasRenderer), CanvasRenderer.prototype.createComp = function(s) {
      return new CVCompElement(s, this.globalData, this);
    };
    function HBaseElement() {
    }
    HBaseElement.prototype = {
      checkBlendMode: function() {
      },
      initRendererElement: function() {
        this.baseElement = createTag(this.data.tg || "div"), this.data.hasMask ? (this.svgElement = createNS("svg"), this.layerElement = createNS("g"), this.maskedElement = this.layerElement, this.svgElement.appendChild(this.layerElement), this.baseElement.appendChild(this.svgElement)) : this.layerElement = this.baseElement, styleDiv(this.baseElement);
      },
      createContainerElements: function() {
        this.renderableEffectsManager = new CVEffects(this), this.transformedElement = this.baseElement, this.maskedElement = this.layerElement, this.data.ln && this.layerElement.setAttribute("id", this.data.ln), this.data.cl && this.layerElement.setAttribute("class", this.data.cl), this.data.bm !== 0 && this.setBlendMode();
      },
      renderElement: function() {
        var o = this.transformedElement ? this.transformedElement.style : {};
        if (this.finalTransform._matMdf) {
          var l = this.finalTransform.mat.toCSS();
          o.transform = l, o.webkitTransform = l;
        }
        this.finalTransform._opMdf && (o.opacity = this.finalTransform.mProp.o.v);
      },
      renderFrame: function() {
        this.data.hd || this.hidden || (this.renderTransform(), this.renderRenderable(), this.renderElement(), this.renderInnerContent(), this._isFirstFrame && (this._isFirstFrame = !1));
      },
      destroy: function() {
        this.layerElement = null, this.transformedElement = null, this.matteElement && (this.matteElement = null), this.maskManager && (this.maskManager.destroy(), this.maskManager = null);
      },
      createRenderableComponents: function() {
        this.maskManager = new MaskElement(this.data, this, this.globalData);
      },
      addEffects: function() {
      },
      setMatte: function() {
      }
    }, HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement, HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy, HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;
    function HSolidElement(s, o, l) {
      this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement], HSolidElement), HSolidElement.prototype.createContent = function() {
      var s;
      this.data.hasMask ? (s = createNS("rect"), s.setAttribute("width", this.data.sw), s.setAttribute("height", this.data.sh), s.setAttribute("fill", this.data.sc), this.svgElement.setAttribute("width", this.data.sw), this.svgElement.setAttribute("height", this.data.sh)) : (s = createTag("div"), s.style.width = this.data.sw + "px", s.style.height = this.data.sh + "px", s.style.backgroundColor = this.data.sc), this.layerElement.appendChild(s);
    };
    function HShapeElement(s, o, l) {
      this.shapes = [], this.shapesData = s.shapes, this.stylesList = [], this.shapeModifiers = [], this.itemsData = [], this.processedElements = [], this.animatedContents = [], this.shapesContainer = createNS("g"), this.initElement(s, o, l), this.prevViewData = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      };
    }
    extendPrototype([BaseElement, TransformElement, HSolidElement, SVGShapeElement, HBaseElement, HierarchyElement, FrameElement, RenderableElement], HShapeElement), HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent, HShapeElement.prototype.createContent = function() {
      var s;
      if (this.baseElement.style.fontSize = 0, this.data.hasMask)
        this.layerElement.appendChild(this.shapesContainer), s = this.svgElement;
      else {
        s = createNS("svg");
        var o = this.comp.data ? this.comp.data : this.globalData.compSize;
        s.setAttribute("width", o.w), s.setAttribute("height", o.h), s.appendChild(this.shapesContainer), this.layerElement.appendChild(s);
      }
      this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], !0), this.filterUniqueShapes(), this.shapeCont = s;
    }, HShapeElement.prototype.getTransformedPoint = function(s, o) {
      var l, u = s.length;
      for (l = 0; l < u; l += 1)
        o = s[l].mProps.v.applyToPointArray(o[0], o[1], 0);
      return o;
    }, HShapeElement.prototype.calculateShapeBoundingBox = function(s, o) {
      var l = s.sh.v, u = s.transformers, c, m = l._length, g, v, b, S;
      if (!(m <= 1)) {
        for (c = 0; c < m - 1; c += 1)
          g = this.getTransformedPoint(u, l.v[c]), v = this.getTransformedPoint(u, l.o[c]), b = this.getTransformedPoint(u, l.i[c + 1]), S = this.getTransformedPoint(u, l.v[c + 1]), this.checkBounds(g, v, b, S, o);
        l.c && (g = this.getTransformedPoint(u, l.v[c]), v = this.getTransformedPoint(u, l.o[c]), b = this.getTransformedPoint(u, l.i[0]), S = this.getTransformedPoint(u, l.v[0]), this.checkBounds(g, v, b, S, o));
      }
    }, HShapeElement.prototype.checkBounds = function(s, o, l, u, c) {
      this.getBoundsOfCurve(s, o, l, u);
      var m = this.shapeBoundingBox;
      c.x = bmMin(m.left, c.x), c.xMax = bmMax(m.right, c.xMax), c.y = bmMin(m.top, c.y), c.yMax = bmMax(m.bottom, c.yMax);
    }, HShapeElement.prototype.shapeBoundingBox = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, HShapeElement.prototype.tempBoundingBox = {
      x: 0,
      xMax: 0,
      y: 0,
      yMax: 0,
      width: 0,
      height: 0
    }, HShapeElement.prototype.getBoundsOfCurve = function(s, o, l, u) {
      for (var c = [[s[0], u[0]], [s[1], u[1]]], m, g, v, b, S, E, P, T = 0; T < 2; ++T)
        g = 6 * s[T] - 12 * o[T] + 6 * l[T], m = -3 * s[T] + 9 * o[T] - 9 * l[T] + 3 * u[T], v = 3 * o[T] - 3 * s[T], g |= 0, m |= 0, v |= 0, m === 0 && g === 0 || (m === 0 ? (b = -v / g, b > 0 && b < 1 && c[T].push(this.calculateF(b, s, o, l, u, T))) : (S = g * g - 4 * v * m, S >= 0 && (E = (-g + bmSqrt(S)) / (2 * m), E > 0 && E < 1 && c[T].push(this.calculateF(E, s, o, l, u, T)), P = (-g - bmSqrt(S)) / (2 * m), P > 0 && P < 1 && c[T].push(this.calculateF(P, s, o, l, u, T)))));
      this.shapeBoundingBox.left = bmMin.apply(null, c[0]), this.shapeBoundingBox.top = bmMin.apply(null, c[1]), this.shapeBoundingBox.right = bmMax.apply(null, c[0]), this.shapeBoundingBox.bottom = bmMax.apply(null, c[1]);
    }, HShapeElement.prototype.calculateF = function(s, o, l, u, c, m) {
      return bmPow(1 - s, 3) * o[m] + 3 * bmPow(1 - s, 2) * s * l[m] + 3 * (1 - s) * bmPow(s, 2) * u[m] + bmPow(s, 3) * c[m];
    }, HShapeElement.prototype.calculateBoundingBox = function(s, o) {
      var l, u = s.length;
      for (l = 0; l < u; l += 1)
        s[l] && s[l].sh ? this.calculateShapeBoundingBox(s[l], o) : s[l] && s[l].it ? this.calculateBoundingBox(s[l].it, o) : s[l] && s[l].style && s[l].w && this.expandStrokeBoundingBox(s[l].w, o);
    }, HShapeElement.prototype.expandStrokeBoundingBox = function(s, o) {
      var l = 0;
      if (s.keyframes) {
        for (var u = 0; u < s.keyframes.length; u += 1) {
          var c = s.keyframes[u].s;
          c > l && (l = c);
        }
        l *= s.mult;
      } else
        l = s.v * s.mult;
      o.x -= l, o.xMax += l, o.y -= l, o.yMax += l;
    }, HShapeElement.prototype.currentBoxContains = function(s) {
      return this.currentBBox.x <= s.x && this.currentBBox.y <= s.y && this.currentBBox.width + this.currentBBox.x >= s.x + s.width && this.currentBBox.height + this.currentBBox.y >= s.y + s.height;
    }, HShapeElement.prototype.renderInnerContent = function() {
      if (this._renderShapeFrame(), !this.hidden && (this._isFirstFrame || this._mdf)) {
        var s = this.tempBoundingBox, o = 999999;
        if (s.x = o, s.xMax = -o, s.y = o, s.yMax = -o, this.calculateBoundingBox(this.itemsData, s), s.width = s.xMax < s.x ? 0 : s.xMax - s.x, s.height = s.yMax < s.y ? 0 : s.yMax - s.y, this.currentBoxContains(s))
          return;
        var l = !1;
        if (this.currentBBox.w !== s.width && (this.currentBBox.w = s.width, this.shapeCont.setAttribute("width", s.width), l = !0), this.currentBBox.h !== s.height && (this.currentBBox.h = s.height, this.shapeCont.setAttribute("height", s.height), l = !0), l || this.currentBBox.x !== s.x || this.currentBBox.y !== s.y) {
          this.currentBBox.w = s.width, this.currentBBox.h = s.height, this.currentBBox.x = s.x, this.currentBBox.y = s.y, this.shapeCont.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h);
          var u = this.shapeCont.style, c = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
          u.transform = c, u.webkitTransform = c;
        }
      }
    };
    function HTextElement(s, o, l) {
      this.textSpans = [], this.textPaths = [], this.currentBBox = {
        x: 999999,
        y: -999999,
        h: 0,
        w: 0
      }, this.renderType = "svg", this.isMasked = !1, this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HierarchyElement, FrameElement, RenderableDOMElement, ITextElement], HTextElement), HTextElement.prototype.createContent = function() {
      if (this.isMasked = this.checkMasks(), this.isMasked) {
        this.renderType = "svg", this.compW = this.comp.data.w, this.compH = this.comp.data.h, this.svgElement.setAttribute("width", this.compW), this.svgElement.setAttribute("height", this.compH);
        var s = createNS("g");
        this.maskedElement.appendChild(s), this.innerElem = s;
      } else
        this.renderType = "html", this.innerElem = this.layerElement;
      this.checkParenting();
    }, HTextElement.prototype.buildNewText = function() {
      var s = this.textProperty.currentData;
      this.renderedLetters = createSizedArray(s.l ? s.l.length : 0);
      var o = this.innerElem.style, l = s.fc ? this.buildColor(s.fc) : "rgba(0,0,0,0)";
      o.fill = l, o.color = l, s.sc && (o.stroke = this.buildColor(s.sc), o.strokeWidth = s.sw + "px");
      var u = this.globalData.fontManager.getFontByName(s.f);
      if (!this.globalData.fontManager.chars)
        if (o.fontSize = s.finalSize + "px", o.lineHeight = s.finalSize + "px", u.fClass)
          this.innerElem.className = u.fClass;
        else {
          o.fontFamily = u.fFamily;
          var c = s.fWeight, m = s.fStyle;
          o.fontStyle = m, o.fontWeight = c;
        }
      var g, v, b = s.l;
      v = b.length;
      var S, E, P, T = this.mHelper, N, O = "", z = 0;
      for (g = 0; g < v; g += 1) {
        if (this.globalData.fontManager.chars ? (this.textPaths[z] ? S = this.textPaths[z] : (S = createNS("path"), S.setAttribute("stroke-linecap", lineCapEnum[1]), S.setAttribute("stroke-linejoin", lineJoinEnum[2]), S.setAttribute("stroke-miterlimit", "4")), this.isMasked || (this.textSpans[z] ? (E = this.textSpans[z], P = E.children[0]) : (E = createTag("div"), E.style.lineHeight = 0, P = createNS("svg"), P.appendChild(S), styleDiv(E)))) : this.isMasked ? S = this.textPaths[z] ? this.textPaths[z] : createNS("text") : this.textSpans[z] ? (E = this.textSpans[z], S = this.textPaths[z]) : (E = createTag("span"), styleDiv(E), S = createTag("span"), styleDiv(S), E.appendChild(S)), this.globalData.fontManager.chars) {
          var Q = this.globalData.fontManager.getCharData(s.finalText[g], u.fStyle, this.globalData.fontManager.getFontByName(s.f).fFamily), W;
          if (Q ? W = Q.data : W = null, T.reset(), W && W.shapes && W.shapes.length && (N = W.shapes[0].it, T.scale(s.finalSize / 100, s.finalSize / 100), O = this.createPathShape(T, N), S.setAttribute("d", O)), this.isMasked)
            this.innerElem.appendChild(S);
          else {
            if (this.innerElem.appendChild(E), W && W.shapes) {
              document.body.appendChild(P);
              var ue = P.getBBox();
              P.setAttribute("width", ue.width + 2), P.setAttribute("height", ue.height + 2), P.setAttribute("viewBox", ue.x - 1 + " " + (ue.y - 1) + " " + (ue.width + 2) + " " + (ue.height + 2));
              var te = P.style, K = "translate(" + (ue.x - 1) + "px," + (ue.y - 1) + "px)";
              te.transform = K, te.webkitTransform = K, b[g].yOffset = ue.y - 1;
            } else
              P.setAttribute("width", 1), P.setAttribute("height", 1);
            E.appendChild(P);
          }
        } else if (S.textContent = b[g].val, S.setAttributeNS("http://www.w3.org/XML/1998/namespace", "xml:space", "preserve"), this.isMasked)
          this.innerElem.appendChild(S);
        else {
          this.innerElem.appendChild(E);
          var ve = S.style, ee = "translate3d(0," + -s.finalSize / 1.2 + "px,0)";
          ve.transform = ee, ve.webkitTransform = ee;
        }
        this.isMasked ? this.textSpans[z] = S : this.textSpans[z] = E, this.textSpans[z].style.display = "block", this.textPaths[z] = S, z += 1;
      }
      for (; z < this.textSpans.length; )
        this.textSpans[z].style.display = "none", z += 1;
    }, HTextElement.prototype.renderInnerContent = function() {
      this.validateText();
      var s;
      if (this.data.singleShape) {
        if (!this._isFirstFrame && !this.lettersChangedFlag)
          return;
        if (this.isMasked && this.finalTransform._matMdf) {
          this.svgElement.setAttribute("viewBox", -this.finalTransform.mProp.p.v[0] + " " + -this.finalTransform.mProp.p.v[1] + " " + this.compW + " " + this.compH), s = this.svgElement.style;
          var o = "translate(" + -this.finalTransform.mProp.p.v[0] + "px," + -this.finalTransform.mProp.p.v[1] + "px)";
          s.transform = o, s.webkitTransform = o;
        }
      }
      if (this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag), !(!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag)) {
        var l, u, c = 0, m = this.textAnimator.renderedLetters, g = this.textProperty.currentData.l;
        u = g.length;
        var v, b, S;
        for (l = 0; l < u; l += 1)
          g[l].n ? c += 1 : (b = this.textSpans[l], S = this.textPaths[l], v = m[c], c += 1, v._mdf.m && (this.isMasked ? b.setAttribute("transform", v.m) : (b.style.webkitTransform = v.m, b.style.transform = v.m)), b.style.opacity = v.o, v.sw && v._mdf.sw && S.setAttribute("stroke-width", v.sw), v.sc && v._mdf.sc && S.setAttribute("stroke", v.sc), v.fc && v._mdf.fc && (S.setAttribute("fill", v.fc), S.style.color = v.fc));
        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {
          var E = this.innerElem.getBBox();
          this.currentBBox.w !== E.width && (this.currentBBox.w = E.width, this.svgElement.setAttribute("width", E.width)), this.currentBBox.h !== E.height && (this.currentBBox.h = E.height, this.svgElement.setAttribute("height", E.height));
          var P = 1;
          if (this.currentBBox.w !== E.width + P * 2 || this.currentBBox.h !== E.height + P * 2 || this.currentBBox.x !== E.x - P || this.currentBBox.y !== E.y - P) {
            this.currentBBox.w = E.width + P * 2, this.currentBBox.h = E.height + P * 2, this.currentBBox.x = E.x - P, this.currentBBox.y = E.y - P, this.svgElement.setAttribute("viewBox", this.currentBBox.x + " " + this.currentBBox.y + " " + this.currentBBox.w + " " + this.currentBBox.h), s = this.svgElement.style;
            var T = "translate(" + this.currentBBox.x + "px," + this.currentBBox.y + "px)";
            s.transform = T, s.webkitTransform = T;
          }
        }
      }
    };
    function HCameraElement(s, o, l) {
      this.initFrame(), this.initBaseData(s, o, l), this.initHierarchy();
      var u = PropertyFactory.getProp;
      if (this.pe = u(this, s.pe, 0, 0, this), s.ks.p.s ? (this.px = u(this, s.ks.p.x, 1, 0, this), this.py = u(this, s.ks.p.y, 1, 0, this), this.pz = u(this, s.ks.p.z, 1, 0, this)) : this.p = u(this, s.ks.p, 1, 0, this), s.ks.a && (this.a = u(this, s.ks.a, 1, 0, this)), s.ks.or.k.length && s.ks.or.k[0].to) {
        var c, m = s.ks.or.k.length;
        for (c = 0; c < m; c += 1)
          s.ks.or.k[c].to = null, s.ks.or.k[c].ti = null;
      }
      this.or = u(this, s.ks.or, 1, degToRads, this), this.or.sh = !0, this.rx = u(this, s.ks.rx, 0, degToRads, this), this.ry = u(this, s.ks.ry, 0, degToRads, this), this.rz = u(this, s.ks.rz, 0, degToRads, this), this.mat = new Matrix(), this._prevMat = new Matrix(), this._isFirstFrame = !0, this.finalTransform = {
        mProp: this
      };
    }
    extendPrototype([BaseElement, FrameElement, HierarchyElement], HCameraElement), HCameraElement.prototype.setup = function() {
      var s, o = this.comp.threeDElements.length, l, u, c;
      for (s = 0; s < o; s += 1)
        if (l = this.comp.threeDElements[s], l.type === "3d") {
          u = l.perspectiveElem.style, c = l.container.style;
          var m = this.pe.v + "px", g = "0px 0px 0px", v = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
          u.perspective = m, u.webkitPerspective = m, c.transformOrigin = g, c.mozTransformOrigin = g, c.webkitTransformOrigin = g, u.transform = v, u.webkitTransform = v;
        }
    }, HCameraElement.prototype.createElements = function() {
    }, HCameraElement.prototype.hide = function() {
    }, HCameraElement.prototype.renderFrame = function() {
      var s = this._isFirstFrame, o, l;
      if (this.hierarchy)
        for (l = this.hierarchy.length, o = 0; o < l; o += 1)
          s = this.hierarchy[o].finalTransform.mProp._mdf || s;
      if (s || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {
        if (this.mat.reset(), this.hierarchy)
          for (l = this.hierarchy.length - 1, o = l; o >= 0; o -= 1) {
            var u = this.hierarchy[o].finalTransform.mProp;
            this.mat.translate(-u.p.v[0], -u.p.v[1], u.p.v[2]), this.mat.rotateX(-u.or.v[0]).rotateY(-u.or.v[1]).rotateZ(u.or.v[2]), this.mat.rotateX(-u.rx.v).rotateY(-u.ry.v).rotateZ(u.rz.v), this.mat.scale(1 / u.s.v[0], 1 / u.s.v[1], 1 / u.s.v[2]), this.mat.translate(u.a.v[0], u.a.v[1], u.a.v[2]);
          }
        if (this.p ? this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]) : this.mat.translate(-this.px.v, -this.py.v, this.pz.v), this.a) {
          var c;
          this.p ? c = [this.p.v[0] - this.a.v[0], this.p.v[1] - this.a.v[1], this.p.v[2] - this.a.v[2]] : c = [this.px.v - this.a.v[0], this.py.v - this.a.v[1], this.pz.v - this.a.v[2]];
          var m = Math.sqrt(Math.pow(c[0], 2) + Math.pow(c[1], 2) + Math.pow(c[2], 2)), g = [c[0] / m, c[1] / m, c[2] / m], v = Math.sqrt(g[2] * g[2] + g[0] * g[0]), b = Math.atan2(g[1], v), S = Math.atan2(g[0], -g[2]);
          this.mat.rotateY(S).rotateX(-b);
        }
        this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v), this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]), this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0), this.mat.translate(0, 0, this.pe.v);
        var E = !this._prevMat.equals(this.mat);
        if ((E || this.pe._mdf) && this.comp.threeDElements) {
          l = this.comp.threeDElements.length;
          var P, T, N;
          for (o = 0; o < l; o += 1)
            if (P = this.comp.threeDElements[o], P.type === "3d") {
              if (E) {
                var O = this.mat.toCSS();
                N = P.container.style, N.transform = O, N.webkitTransform = O;
              }
              this.pe._mdf && (T = P.perspectiveElem.style, T.perspective = this.pe.v + "px", T.webkitPerspective = this.pe.v + "px");
            }
          this.mat.clone(this._prevMat);
        }
      }
      this._isFirstFrame = !1;
    }, HCameraElement.prototype.prepareFrame = function(s) {
      this.prepareProperties(s, !0);
    }, HCameraElement.prototype.destroy = function() {
    }, HCameraElement.prototype.getBaseElement = function() {
      return null;
    };
    function HImageElement(s, o, l) {
      this.assetData = o.getAssetData(s.refId), this.initElement(s, o, l);
    }
    extendPrototype([BaseElement, TransformElement, HBaseElement, HSolidElement, HierarchyElement, FrameElement, RenderableElement], HImageElement), HImageElement.prototype.createContent = function() {
      var s = this.globalData.getAssetsPath(this.assetData), o = new Image();
      this.data.hasMask ? (this.imageElem = createNS("image"), this.imageElem.setAttribute("width", this.assetData.w + "px"), this.imageElem.setAttribute("height", this.assetData.h + "px"), this.imageElem.setAttributeNS("http://www.w3.org/1999/xlink", "href", s), this.layerElement.appendChild(this.imageElem), this.baseElement.setAttribute("width", this.assetData.w), this.baseElement.setAttribute("height", this.assetData.h)) : this.layerElement.appendChild(o), o.crossOrigin = "anonymous", o.src = s, this.data.ln && this.baseElement.setAttribute("id", this.data.ln);
    };
    function HybridRendererBase(s, o) {
      this.animationItem = s, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: o && o.className || "",
        imagePreserveAspectRatio: o && o.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(o && o.hideOnTransparent === !1),
        filterSize: {
          width: o && o.filterSize && o.filterSize.width || "400%",
          height: o && o.filterSize && o.filterSize.height || "400%",
          x: o && o.filterSize && o.filterSize.x || "-100%",
          y: o && o.filterSize && o.filterSize.y || "-100%"
        }
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([BaseRenderer], HybridRendererBase), HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem, HybridRendererBase.prototype.checkPendingElements = function() {
      for (; this.pendingElements.length; ) {
        var s = this.pendingElements.pop();
        s.checkParenting();
      }
    }, HybridRendererBase.prototype.appendElementInPos = function(s, o) {
      var l = s.getBaseElement();
      if (l) {
        var u = this.layers[o];
        if (!u.ddd || !this.supports3d)
          if (this.threeDElements)
            this.addTo3dContainer(l, o);
          else {
            for (var c = 0, m, g, v; c < o; )
              this.elements[c] && this.elements[c] !== !0 && this.elements[c].getBaseElement && (g = this.elements[c], v = this.layers[c].ddd ? this.getThreeDContainerByPos(c) : g.getBaseElement(), m = v || m), c += 1;
            m ? (!u.ddd || !this.supports3d) && this.layerElement.insertBefore(l, m) : (!u.ddd || !this.supports3d) && this.layerElement.appendChild(l);
          }
        else
          this.addTo3dContainer(l, o);
      }
    }, HybridRendererBase.prototype.createShape = function(s) {
      return this.supports3d ? new HShapeElement(s, this.globalData, this) : new SVGShapeElement(s, this.globalData, this);
    }, HybridRendererBase.prototype.createText = function(s) {
      return this.supports3d ? new HTextElement(s, this.globalData, this) : new SVGTextLottieElement(s, this.globalData, this);
    }, HybridRendererBase.prototype.createCamera = function(s) {
      return this.camera = new HCameraElement(s, this.globalData, this), this.camera;
    }, HybridRendererBase.prototype.createImage = function(s) {
      return this.supports3d ? new HImageElement(s, this.globalData, this) : new IImageElement(s, this.globalData, this);
    }, HybridRendererBase.prototype.createSolid = function(s) {
      return this.supports3d ? new HSolidElement(s, this.globalData, this) : new ISolidElement(s, this.globalData, this);
    }, HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull, HybridRendererBase.prototype.getThreeDContainerByPos = function(s) {
      for (var o = 0, l = this.threeDElements.length; o < l; ) {
        if (this.threeDElements[o].startPos <= s && this.threeDElements[o].endPos >= s)
          return this.threeDElements[o].perspectiveElem;
        o += 1;
      }
      return null;
    }, HybridRendererBase.prototype.createThreeDContainer = function(s, o) {
      var l = createTag("div"), u, c;
      styleDiv(l);
      var m = createTag("div");
      if (styleDiv(m), o === "3d") {
        u = l.style, u.width = this.globalData.compSize.w + "px", u.height = this.globalData.compSize.h + "px";
        var g = "50% 50%";
        u.webkitTransformOrigin = g, u.mozTransformOrigin = g, u.transformOrigin = g, c = m.style;
        var v = "matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)";
        c.transform = v, c.webkitTransform = v;
      }
      l.appendChild(m);
      var b = {
        container: m,
        perspectiveElem: l,
        startPos: s,
        endPos: s,
        type: o
      };
      return this.threeDElements.push(b), b;
    }, HybridRendererBase.prototype.build3dContainers = function() {
      var s, o = this.layers.length, l, u = "";
      for (s = 0; s < o; s += 1)
        this.layers[s].ddd && this.layers[s].ty !== 3 ? (u !== "3d" && (u = "3d", l = this.createThreeDContainer(s, "3d")), l.endPos = Math.max(l.endPos, s)) : (u !== "2d" && (u = "2d", l = this.createThreeDContainer(s, "2d")), l.endPos = Math.max(l.endPos, s));
      for (o = this.threeDElements.length, s = o - 1; s >= 0; s -= 1)
        this.resizerElem.appendChild(this.threeDElements[s].perspectiveElem);
    }, HybridRendererBase.prototype.addTo3dContainer = function(s, o) {
      for (var l = 0, u = this.threeDElements.length; l < u; ) {
        if (o <= this.threeDElements[l].endPos) {
          for (var c = this.threeDElements[l].startPos, m; c < o; )
            this.elements[c] && this.elements[c].getBaseElement && (m = this.elements[c].getBaseElement()), c += 1;
          m ? this.threeDElements[l].container.insertBefore(s, m) : this.threeDElements[l].container.appendChild(s);
          break;
        }
        l += 1;
      }
    }, HybridRendererBase.prototype.configAnimation = function(s) {
      var o = createTag("div"), l = this.animationItem.wrapper, u = o.style;
      u.width = s.w + "px", u.height = s.h + "px", this.resizerElem = o, styleDiv(o), u.transformStyle = "flat", u.mozTransformStyle = "flat", u.webkitTransformStyle = "flat", this.renderConfig.className && o.setAttribute("class", this.renderConfig.className), l.appendChild(o), u.overflow = "hidden";
      var c = createNS("svg");
      c.setAttribute("width", "1"), c.setAttribute("height", "1"), styleDiv(c), this.resizerElem.appendChild(c);
      var m = createNS("defs");
      c.appendChild(m), this.data = s, this.setupGlobalData(s, c), this.globalData.defs = m, this.layers = s.layers, this.layerElement = this.resizerElem, this.build3dContainers(), this.updateContainerSize();
    }, HybridRendererBase.prototype.destroy = function() {
      this.animationItem.wrapper && (this.animationItem.wrapper.innerText = ""), this.animationItem.container = null, this.globalData.defs = null;
      var s, o = this.layers ? this.layers.length : 0;
      for (s = 0; s < o; s += 1)
        this.elements[s] && this.elements[s].destroy && this.elements[s].destroy();
      this.elements.length = 0, this.destroyed = !0, this.animationItem = null;
    }, HybridRendererBase.prototype.updateContainerSize = function() {
      var s = this.animationItem.wrapper.offsetWidth, o = this.animationItem.wrapper.offsetHeight, l = s / o, u = this.globalData.compSize.w / this.globalData.compSize.h, c, m, g, v;
      u > l ? (c = s / this.globalData.compSize.w, m = s / this.globalData.compSize.w, g = 0, v = (o - this.globalData.compSize.h * (s / this.globalData.compSize.w)) / 2) : (c = o / this.globalData.compSize.h, m = o / this.globalData.compSize.h, g = (s - this.globalData.compSize.w * (o / this.globalData.compSize.h)) / 2, v = 0);
      var b = this.resizerElem.style;
      b.webkitTransform = "matrix3d(" + c + ",0,0,0,0," + m + ",0,0,0,0,1,0," + g + "," + v + ",0,1)", b.transform = b.webkitTransform;
    }, HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame, HybridRendererBase.prototype.hide = function() {
      this.resizerElem.style.display = "none";
    }, HybridRendererBase.prototype.show = function() {
      this.resizerElem.style.display = "block";
    }, HybridRendererBase.prototype.initItems = function() {
      if (this.buildAllItems(), this.camera)
        this.camera.setup();
      else {
        var s = this.globalData.compSize.w, o = this.globalData.compSize.h, l, u = this.threeDElements.length;
        for (l = 0; l < u; l += 1) {
          var c = this.threeDElements[l].perspectiveElem.style;
          c.webkitPerspective = Math.sqrt(Math.pow(s, 2) + Math.pow(o, 2)) + "px", c.perspective = c.webkitPerspective;
        }
      }
    }, HybridRendererBase.prototype.searchExtraCompositions = function(s) {
      var o, l = s.length, u = createTag("div");
      for (o = 0; o < l; o += 1)
        if (s[o].xt) {
          var c = this.createComp(s[o], u, this.globalData.comp, null);
          c.initExpressions(), this.globalData.projectInterface.registerComposition(c);
        }
    };
    function HCompElement(s, o, l) {
      this.layers = s.layers, this.supports3d = !s.hasMask, this.completeLayers = !1, this.pendingElements = [], this.elements = this.layers ? createSizedArray(this.layers.length) : [], this.initElement(s, o, l), this.tm = s.tm ? PropertyFactory.getProp(this, s.tm, 0, o.frameRate, this) : {
        _placeholder: !0
      };
    }
    extendPrototype([HybridRendererBase, ICompElement, HBaseElement], HCompElement), HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements, HCompElement.prototype.createContainerElements = function() {
      this._createBaseContainerElements(), this.data.hasMask ? (this.svgElement.setAttribute("width", this.data.w), this.svgElement.setAttribute("height", this.data.h), this.transformedElement = this.baseElement) : this.transformedElement = this.layerElement;
    }, HCompElement.prototype.addTo3dContainer = function(s, o) {
      for (var l = 0, u; l < o; )
        this.elements[l] && this.elements[l].getBaseElement && (u = this.elements[l].getBaseElement()), l += 1;
      u ? this.layerElement.insertBefore(s, u) : this.layerElement.appendChild(s);
    }, HCompElement.prototype.createComp = function(s) {
      return this.supports3d ? new HCompElement(s, this.globalData, this) : new SVGCompElement(s, this.globalData, this);
    };
    function HybridRenderer(s, o) {
      this.animationItem = s, this.layers = null, this.renderedFrame = -1, this.renderConfig = {
        className: o && o.className || "",
        imagePreserveAspectRatio: o && o.imagePreserveAspectRatio || "xMidYMid slice",
        hideOnTransparent: !(o && o.hideOnTransparent === !1),
        filterSize: {
          width: o && o.filterSize && o.filterSize.width || "400%",
          height: o && o.filterSize && o.filterSize.height || "400%",
          x: o && o.filterSize && o.filterSize.x || "-100%",
          y: o && o.filterSize && o.filterSize.y || "-100%"
        },
        runExpressions: !o || o.runExpressions === void 0 || o.runExpressions
      }, this.globalData = {
        _mdf: !1,
        frameNum: -1,
        renderConfig: this.renderConfig
      }, this.pendingElements = [], this.elements = [], this.threeDElements = [], this.destroyed = !1, this.camera = null, this.supports3d = !0, this.rendererType = "html";
    }
    extendPrototype([HybridRendererBase], HybridRenderer), HybridRenderer.prototype.createComp = function(s) {
      return this.supports3d ? new HCompElement(s, this.globalData, this) : new SVGCompElement(s, this.globalData, this);
    };
    var CompExpressionInterface = /* @__PURE__ */ function() {
      return function(s) {
        function o(l) {
          for (var u = 0, c = s.layers.length; u < c; ) {
            if (s.layers[u].nm === l || s.layers[u].ind === l)
              return s.elements[u].layerInterface;
            u += 1;
          }
          return null;
        }
        return Object.defineProperty(o, "_name", {
          value: s.data.nm
        }), o.layer = o, o.pixelAspect = 1, o.height = s.data.h || s.globalData.compSize.h, o.width = s.data.w || s.globalData.compSize.w, o.pixelAspect = 1, o.frameDuration = 1 / s.globalData.frameRate, o.displayStartTime = 0, o.numLayers = s.layers.length, o;
      };
    }();
    function _typeof$2(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$2 = function(l) {
        return typeof l;
      } : _typeof$2 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$2(s);
    }
    function seedRandom(s, o) {
      var l = this, u = 256, c = 6, m = 52, g = "random", v = o.pow(u, c), b = o.pow(2, m), S = b * 2, E = u - 1, P;
      function T(te, K, ve) {
        var ee = [];
        K = K === !0 ? {
          entropy: !0
        } : K || {};
        var Re = Q(z(K.entropy ? [te, ue(s)] : te === null ? W() : te, 3), ee), wt = new N(ee), yt = function() {
          for (var Kt = wt.g(c), tn = v, ln = 0; Kt < b; )
            Kt = (Kt + ln) * u, tn *= u, ln = wt.g(1);
          for (; Kt >= S; )
            Kt /= 2, tn /= 2, ln >>>= 1;
          return (Kt + ln) / tn;
        };
        return yt.int32 = function() {
          return wt.g(4) | 0;
        }, yt.quick = function() {
          return wt.g(4) / 4294967296;
        }, yt.double = yt, Q(ue(wt.S), s), (K.pass || ve || function(xt, Kt, tn, ln) {
          return ln && (ln.S && O(ln, wt), xt.state = function() {
            return O(wt, {});
          }), tn ? (o[g] = xt, Kt) : xt;
        })(yt, Re, "global" in K ? K.global : this == o, K.state);
      }
      o["seed" + g] = T;
      function N(te) {
        var K, ve = te.length, ee = this, Re = 0, wt = ee.i = ee.j = 0, yt = ee.S = [];
        for (ve || (te = [ve++]); Re < u; )
          yt[Re] = Re++;
        for (Re = 0; Re < u; Re++)
          yt[Re] = yt[wt = E & wt + te[Re % ve] + (K = yt[Re])], yt[wt] = K;
        ee.g = function(xt) {
          for (var Kt, tn = 0, ln = ee.i, rn = ee.j, an = ee.S; xt--; )
            Kt = an[ln = E & ln + 1], tn = tn * u + an[E & (an[ln] = an[rn = E & rn + Kt]) + (an[rn] = Kt)];
          return ee.i = ln, ee.j = rn, tn;
        };
      }
      function O(te, K) {
        return K.i = te.i, K.j = te.j, K.S = te.S.slice(), K;
      }
      function z(te, K) {
        var ve = [], ee = _typeof$2(te), Re;
        if (K && ee == "object")
          for (Re in te)
            try {
              ve.push(z(te[Re], K - 1));
            } catch {
            }
        return ve.length ? ve : ee == "string" ? te : te + "\0";
      }
      function Q(te, K) {
        for (var ve = te + "", ee, Re = 0; Re < ve.length; )
          K[E & Re] = E & (ee ^= K[E & Re] * 19) + ve.charCodeAt(Re++);
        return ue(K);
      }
      function W() {
        try {
          var te = new Uint8Array(u);
          return (l.crypto || l.msCrypto).getRandomValues(te), ue(te);
        } catch {
          var K = l.navigator, ve = K && K.plugins;
          return [+/* @__PURE__ */ new Date(), l, ve, l.screen, ue(s)];
        }
      }
      function ue(te) {
        return String.fromCharCode.apply(0, te);
      }
      Q(o.random(), s);
    }
    function initialize$2(s) {
      seedRandom([], s);
    }
    var propTypes = {
      SHAPE: "shape"
    };
    function _typeof$1(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof$1 = function(l) {
        return typeof l;
      } : _typeof$1 = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof$1(s);
    }
    var ExpressionManager = function() {
      var ob = {}, Math = BMMath, window = null, document = null, XMLHttpRequest = null, fetch = null, frames = null, _lottieGlobal = {};
      initialize$2(BMMath);
      function resetFrame() {
        _lottieGlobal = {};
      }
      function $bm_isInstanceOfArray(s) {
        return s.constructor === Array || s.constructor === Float32Array;
      }
      function isNumerable(s, o) {
        return s === "number" || o instanceof Number || s === "boolean" || s === "string";
      }
      function $bm_neg(s) {
        var o = _typeof$1(s);
        if (o === "number" || s instanceof Number || o === "boolean")
          return -s;
        if ($bm_isInstanceOfArray(s)) {
          var l, u = s.length, c = [];
          for (l = 0; l < u; l += 1)
            c[l] = -s[l];
          return c;
        }
        return s.propType ? s.v : -s;
      }
      var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, "easeIn").get, easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, "easeOut").get, easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, "easeInOut").get;
      function sum(s, o) {
        var l = _typeof$1(s), u = _typeof$1(o);
        if (isNumerable(l, s) && isNumerable(u, o) || l === "string" || u === "string")
          return s + o;
        if ($bm_isInstanceOfArray(s) && isNumerable(u, o))
          return s = s.slice(0), s[0] += o, s;
        if (isNumerable(l, s) && $bm_isInstanceOfArray(o))
          return o = o.slice(0), o[0] = s + o[0], o;
        if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(o)) {
          for (var c = 0, m = s.length, g = o.length, v = []; c < m || c < g; )
            (typeof s[c] == "number" || s[c] instanceof Number) && (typeof o[c] == "number" || o[c] instanceof Number) ? v[c] = s[c] + o[c] : v[c] = o[c] === void 0 ? s[c] : s[c] || o[c], c += 1;
          return v;
        }
        return 0;
      }
      var add = sum;
      function sub(s, o) {
        var l = _typeof$1(s), u = _typeof$1(o);
        if (isNumerable(l, s) && isNumerable(u, o))
          return l === "string" && (s = parseInt(s, 10)), u === "string" && (o = parseInt(o, 10)), s - o;
        if ($bm_isInstanceOfArray(s) && isNumerable(u, o))
          return s = s.slice(0), s[0] -= o, s;
        if (isNumerable(l, s) && $bm_isInstanceOfArray(o))
          return o = o.slice(0), o[0] = s - o[0], o;
        if ($bm_isInstanceOfArray(s) && $bm_isInstanceOfArray(o)) {
          for (var c = 0, m = s.length, g = o.length, v = []; c < m || c < g; )
            (typeof s[c] == "number" || s[c] instanceof Number) && (typeof o[c] == "number" || o[c] instanceof Number) ? v[c] = s[c] - o[c] : v[c] = o[c] === void 0 ? s[c] : s[c] || o[c], c += 1;
          return v;
        }
        return 0;
      }
      function mul(s, o) {
        var l = _typeof$1(s), u = _typeof$1(o), c;
        if (isNumerable(l, s) && isNumerable(u, o))
          return s * o;
        var m, g;
        if ($bm_isInstanceOfArray(s) && isNumerable(u, o)) {
          for (g = s.length, c = createTypedArray("float32", g), m = 0; m < g; m += 1)
            c[m] = s[m] * o;
          return c;
        }
        if (isNumerable(l, s) && $bm_isInstanceOfArray(o)) {
          for (g = o.length, c = createTypedArray("float32", g), m = 0; m < g; m += 1)
            c[m] = s * o[m];
          return c;
        }
        return 0;
      }
      function div(s, o) {
        var l = _typeof$1(s), u = _typeof$1(o), c;
        if (isNumerable(l, s) && isNumerable(u, o))
          return s / o;
        var m, g;
        if ($bm_isInstanceOfArray(s) && isNumerable(u, o)) {
          for (g = s.length, c = createTypedArray("float32", g), m = 0; m < g; m += 1)
            c[m] = s[m] / o;
          return c;
        }
        if (isNumerable(l, s) && $bm_isInstanceOfArray(o)) {
          for (g = o.length, c = createTypedArray("float32", g), m = 0; m < g; m += 1)
            c[m] = s / o[m];
          return c;
        }
        return 0;
      }
      function mod(s, o) {
        return typeof s == "string" && (s = parseInt(s, 10)), typeof o == "string" && (o = parseInt(o, 10)), s % o;
      }
      var $bm_sum = sum, $bm_sub = sub, $bm_mul = mul, $bm_div = div, $bm_mod = mod;
      function clamp(s, o, l) {
        if (o > l) {
          var u = l;
          l = o, o = u;
        }
        return Math.min(Math.max(s, o), l);
      }
      function radiansToDegrees(s) {
        return s / degToRads;
      }
      var radians_to_degrees = radiansToDegrees;
      function degreesToRadians(s) {
        return s * degToRads;
      }
      var degrees_to_radians = radiansToDegrees, helperLengthArray = [0, 0, 0, 0, 0, 0];
      function length(s, o) {
        if (typeof s == "number" || s instanceof Number)
          return o = o || 0, Math.abs(s - o);
        o || (o = helperLengthArray);
        var l, u = Math.min(s.length, o.length), c = 0;
        for (l = 0; l < u; l += 1)
          c += Math.pow(o[l] - s[l], 2);
        return Math.sqrt(c);
      }
      function normalize(s) {
        return div(s, length(s));
      }
      function rgbToHsl(s) {
        var o = s[0], l = s[1], u = s[2], c = Math.max(o, l, u), m = Math.min(o, l, u), g, v, b = (c + m) / 2;
        if (c === m)
          g = 0, v = 0;
        else {
          var S = c - m;
          switch (v = b > 0.5 ? S / (2 - c - m) : S / (c + m), c) {
            case o:
              g = (l - u) / S + (l < u ? 6 : 0);
              break;
            case l:
              g = (u - o) / S + 2;
              break;
            case u:
              g = (o - l) / S + 4;
              break;
          }
          g /= 6;
        }
        return [g, v, b, s[3]];
      }
      function hue2rgb(s, o, l) {
        return l < 0 && (l += 1), l > 1 && (l -= 1), l < 1 / 6 ? s + (o - s) * 6 * l : l < 1 / 2 ? o : l < 2 / 3 ? s + (o - s) * (2 / 3 - l) * 6 : s;
      }
      function hslToRgb(s) {
        var o = s[0], l = s[1], u = s[2], c, m, g;
        if (l === 0)
          c = u, g = u, m = u;
        else {
          var v = u < 0.5 ? u * (1 + l) : u + l - u * l, b = 2 * u - v;
          c = hue2rgb(b, v, o + 1 / 3), m = hue2rgb(b, v, o), g = hue2rgb(b, v, o - 1 / 3);
        }
        return [c, m, g, s[3]];
      }
      function linear(s, o, l, u, c) {
        if ((u === void 0 || c === void 0) && (u = o, c = l, o = 0, l = 1), l < o) {
          var m = l;
          l = o, o = m;
        }
        if (s <= o)
          return u;
        if (s >= l)
          return c;
        var g = l === o ? 0 : (s - o) / (l - o);
        if (!u.length)
          return u + (c - u) * g;
        var v, b = u.length, S = createTypedArray("float32", b);
        for (v = 0; v < b; v += 1)
          S[v] = u[v] + (c[v] - u[v]) * g;
        return S;
      }
      function random(s, o) {
        if (o === void 0 && (s === void 0 ? (s = 0, o = 1) : (o = s, s = void 0)), o.length) {
          var l, u = o.length;
          s || (s = createTypedArray("float32", u));
          var c = createTypedArray("float32", u), m = BMMath.random();
          for (l = 0; l < u; l += 1)
            c[l] = s[l] + m * (o[l] - s[l]);
          return c;
        }
        s === void 0 && (s = 0);
        var g = BMMath.random();
        return s + g * (o - s);
      }
      function createPath(s, o, l, u) {
        var c, m = s.length, g = shapePool.newElement();
        g.setPathData(!!u, m);
        var v = [0, 0], b, S;
        for (c = 0; c < m; c += 1)
          b = o && o[c] ? o[c] : v, S = l && l[c] ? l[c] : v, g.setTripleAt(s[c][0], s[c][1], S[0] + s[c][0], S[1] + s[c][1], b[0] + s[c][0], b[1] + s[c][1], c, !0);
        return g;
      }
      function initiateExpression(elem, data, property) {
        function noOp(s) {
          return s;
        }
        if (!elem.globalData.renderConfig.runExpressions)
          return noOp;
        var val = data.x, needsVelocity = /velocity(?![\w\d])/.test(val), _needsRandom = val.indexOf("random") !== -1, elemType = elem.data.ty, transform, $bm_transform, content, effect, thisProperty = property;
        thisProperty.valueAtTime = thisProperty.getValueAtTime, Object.defineProperty(thisProperty, "value", {
          get: function() {
            return thisProperty.v;
          }
        }), elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate, elem.comp.displayStartTime = 0;
        var inPoint = elem.data.ip / elem.comp.globalData.frameRate, outPoint = elem.data.op / elem.comp.globalData.frameRate, width = elem.data.sw ? elem.data.sw : 0, height = elem.data.sh ? elem.data.sh : 0, name = elem.data.nm, loopIn, loop_in, loopOut, loop_out, smooth, toWorld, fromWorld, fromComp, toComp, fromCompToSurface, position, rotation, anchorPoint, scale, thisLayer, thisComp, mask, valueAtTime, velocityAtTime, scoped_bm_rt, expression_function = eval("[function _expression_function(){" + val + ";scoped_bm_rt=$bm_rt}]")[0], numKeys = property.kf ? data.k.length : 0, active = !this.data || this.data.hd !== !0, wiggle = (function s(o, l) {
          var u, c, m = this.pv.length ? this.pv.length : 1, g = createTypedArray("float32", m);
          o = 5;
          var v = Math.floor(time * o);
          for (u = 0, c = 0; u < v; ) {
            for (c = 0; c < m; c += 1)
              g[c] += -l + l * 2 * BMMath.random();
            u += 1;
          }
          var b = time * o, S = b - Math.floor(b), E = createTypedArray("float32", m);
          if (m > 1) {
            for (c = 0; c < m; c += 1)
              E[c] = this.pv[c] + g[c] + (-l + l * 2 * BMMath.random()) * S;
            return E;
          }
          return this.pv + g[0] + (-l + l * 2 * BMMath.random()) * S;
        }).bind(this);
        thisProperty.loopIn && (loopIn = thisProperty.loopIn.bind(thisProperty), loop_in = loopIn), thisProperty.loopOut && (loopOut = thisProperty.loopOut.bind(thisProperty), loop_out = loopOut), thisProperty.smooth && (smooth = thisProperty.smooth.bind(thisProperty));
        function loopInDuration(s, o) {
          return loopIn(s, o, !0);
        }
        function loopOutDuration(s, o) {
          return loopOut(s, o, !0);
        }
        this.getValueAtTime && (valueAtTime = this.getValueAtTime.bind(this)), this.getVelocityAtTime && (velocityAtTime = this.getVelocityAtTime.bind(this));
        var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);
        function lookAt(s, o) {
          var l = [o[0] - s[0], o[1] - s[1], o[2] - s[2]], u = Math.atan2(l[0], Math.sqrt(l[1] * l[1] + l[2] * l[2])) / degToRads, c = -Math.atan2(l[1], l[2]) / degToRads;
          return [c, u, 0];
        }
        function easeOut(s, o, l, u, c) {
          return applyEase(easeOutBez, s, o, l, u, c);
        }
        function easeIn(s, o, l, u, c) {
          return applyEase(easeInBez, s, o, l, u, c);
        }
        function ease(s, o, l, u, c) {
          return applyEase(easeInOutBez, s, o, l, u, c);
        }
        function applyEase(s, o, l, u, c, m) {
          c === void 0 ? (c = l, m = u) : o = (o - l) / (u - l), o > 1 ? o = 1 : o < 0 && (o = 0);
          var g = s(o);
          if ($bm_isInstanceOfArray(c)) {
            var v, b = c.length, S = createTypedArray("float32", b);
            for (v = 0; v < b; v += 1)
              S[v] = (m[v] - c[v]) * g + c[v];
            return S;
          }
          return (m - c) * g + c;
        }
        function nearestKey(s) {
          var o, l = data.k.length, u, c;
          if (!data.k.length || typeof data.k[0] == "number")
            u = 0, c = 0;
          else if (u = -1, s *= elem.comp.globalData.frameRate, s < data.k[0].t)
            u = 1, c = data.k[0].t;
          else {
            for (o = 0; o < l - 1; o += 1)
              if (s === data.k[o].t) {
                u = o + 1, c = data.k[o].t;
                break;
              } else if (s > data.k[o].t && s < data.k[o + 1].t) {
                s - data.k[o].t > data.k[o + 1].t - s ? (u = o + 2, c = data.k[o + 1].t) : (u = o + 1, c = data.k[o].t);
                break;
              }
            u === -1 && (u = o + 1, c = data.k[o].t);
          }
          var m = {};
          return m.index = u, m.time = c / elem.comp.globalData.frameRate, m;
        }
        function key(s) {
          var o, l, u;
          if (!data.k.length || typeof data.k[0] == "number")
            throw new Error("The property has no keyframe at index " + s);
          s -= 1, o = {
            time: data.k[s].t / elem.comp.globalData.frameRate,
            value: []
          };
          var c = Object.prototype.hasOwnProperty.call(data.k[s], "s") ? data.k[s].s : data.k[s - 1].e;
          for (u = c.length, l = 0; l < u; l += 1)
            o[l] = c[l], o.value[l] = c[l];
          return o;
        }
        function framesToTime(s, o) {
          return o || (o = elem.comp.globalData.frameRate), s / o;
        }
        function timeToFrames(s, o) {
          return !s && s !== 0 && (s = time), o || (o = elem.comp.globalData.frameRate), s * o;
        }
        function seedRandom(s) {
          BMMath.seedrandom(randSeed + s);
        }
        function sourceRectAtTime() {
          return elem.sourceRectAtTime();
        }
        function substring(s, o) {
          return typeof value == "string" ? o === void 0 ? value.substring(s) : value.substring(s, o) : "";
        }
        function substr(s, o) {
          return typeof value == "string" ? o === void 0 ? value.substr(s) : value.substr(s, o) : "";
        }
        function posterizeTime(s) {
          time = s === 0 ? 0 : Math.floor(time * s) / s, value = valueAtTime(time);
        }
        var time, velocity, value, text, textIndex, textTotal, selectorValue, index = elem.data.ind, hasParent = !!(elem.hierarchy && elem.hierarchy.length), parent, randSeed = Math.floor(Math.random() * 1e6), globalData = elem.globalData;
        function executeExpression(s) {
          return value = s, this.frameExpressionId === elem.globalData.frameId && this.propType !== "textSelector" ? value : (this.propType === "textSelector" && (textIndex = this.textIndex, textTotal = this.textTotal, selectorValue = this.selectorValue), thisLayer || (text = elem.layerInterface.text, thisLayer = elem.layerInterface, thisComp = elem.comp.compInterface, toWorld = thisLayer.toWorld.bind(thisLayer), fromWorld = thisLayer.fromWorld.bind(thisLayer), fromComp = thisLayer.fromComp.bind(thisLayer), toComp = thisLayer.toComp.bind(thisLayer), mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null, fromCompToSurface = fromComp), transform || (transform = elem.layerInterface("ADBE Transform Group"), $bm_transform = transform, transform && (anchorPoint = transform.anchorPoint)), elemType === 4 && !content && (content = thisLayer("ADBE Root Vectors Group")), effect || (effect = thisLayer(4)), hasParent = !!(elem.hierarchy && elem.hierarchy.length), hasParent && !parent && (parent = elem.hierarchy[0].layerInterface), time = this.comp.renderedFrame / this.comp.globalData.frameRate, _needsRandom && seedRandom(randSeed + time), needsVelocity && (velocity = velocityAtTime(time)), expression_function(), this.frameExpressionId = elem.globalData.frameId, scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt, scoped_bm_rt);
        }
        return executeExpression.__preventDeadCodeRemoval = [$bm_transform, anchorPoint, time, velocity, inPoint, outPoint, width, height, name, loop_in, loop_out, smooth, toComp, fromCompToSurface, toWorld, fromWorld, mask, position, rotation, scale, thisComp, numKeys, active, wiggle, loopInDuration, loopOutDuration, comp, lookAt, easeOut, easeIn, ease, nearestKey, key, text, textIndex, textTotal, selectorValue, framesToTime, timeToFrames, sourceRectAtTime, substring, substr, posterizeTime, index, globalData], executeExpression;
      }
      return ob.initiateExpression = initiateExpression, ob.__preventDeadCodeRemoval = [window, document, XMLHttpRequest, fetch, frames, $bm_neg, add, $bm_sum, $bm_sub, $bm_mul, $bm_div, $bm_mod, clamp, radians_to_degrees, degreesToRadians, degrees_to_radians, normalize, rgbToHsl, hslToRgb, linear, random, createPath, _lottieGlobal], ob.resetFrame = resetFrame, ob;
    }(), Expressions = function() {
      var s = {};
      s.initExpressions = o, s.resetFrame = ExpressionManager.resetFrame;
      function o(l) {
        var u = 0, c = [];
        function m() {
          u += 1;
        }
        function g() {
          u -= 1, u === 0 && b();
        }
        function v(S) {
          c.indexOf(S) === -1 && c.push(S);
        }
        function b() {
          var S, E = c.length;
          for (S = 0; S < E; S += 1)
            c[S].release();
          c.length = 0;
        }
        l.renderer.compInterface = CompExpressionInterface(l.renderer), l.renderer.globalData.projectInterface.registerComposition(l.renderer), l.renderer.globalData.pushExpression = m, l.renderer.globalData.popExpression = g, l.renderer.globalData.registerExpressionProperty = v;
      }
      return s;
    }(), MaskManagerInterface = function() {
      function s(l, u) {
        this._mask = l, this._data = u;
      }
      Object.defineProperty(s.prototype, "maskPath", {
        get: function() {
          return this._mask.prop.k && this._mask.prop.getValue(), this._mask.prop;
        }
      }), Object.defineProperty(s.prototype, "maskOpacity", {
        get: function() {
          return this._mask.op.k && this._mask.op.getValue(), this._mask.op.v * 100;
        }
      });
      var o = function(u) {
        var c = createSizedArray(u.viewData.length), m, g = u.viewData.length;
        for (m = 0; m < g; m += 1)
          c[m] = new s(u.viewData[m], u.masksProperties[m]);
        var v = function(S) {
          for (m = 0; m < g; ) {
            if (u.masksProperties[m].nm === S)
              return c[m];
            m += 1;
          }
          return null;
        };
        return v;
      };
      return o;
    }(), ExpressionPropertyInterface = /* @__PURE__ */ function() {
      var s = {
        pv: 0,
        v: 0,
        mult: 1
      }, o = {
        pv: [0, 0, 0],
        v: [0, 0, 0],
        mult: 1
      };
      function l(g, v, b) {
        Object.defineProperty(g, "velocity", {
          get: function() {
            return v.getVelocityAtTime(v.comp.currentFrame);
          }
        }), g.numKeys = v.keyframes ? v.keyframes.length : 0, g.key = function(S) {
          if (!g.numKeys)
            return 0;
          var E = "";
          "s" in v.keyframes[S - 1] ? E = v.keyframes[S - 1].s : "e" in v.keyframes[S - 2] ? E = v.keyframes[S - 2].e : E = v.keyframes[S - 2].s;
          var P = b === "unidimensional" ? new Number(E) : Object.assign({}, E);
          return P.time = v.keyframes[S - 1].t / v.elem.comp.globalData.frameRate, P.value = b === "unidimensional" ? E[0] : E, P;
        }, g.valueAtTime = v.getValueAtTime, g.speedAtTime = v.getSpeedAtTime, g.velocityAtTime = v.getVelocityAtTime, g.propertyGroup = v.propertyGroup;
      }
      function u(g) {
        (!g || !("pv" in g)) && (g = s);
        var v = 1 / g.mult, b = g.pv * v, S = new Number(b);
        return S.value = b, l(S, g, "unidimensional"), function() {
          return g.k && g.getValue(), b = g.v * v, S.value !== b && (S = new Number(b), S.value = b, l(S, g, "unidimensional")), S;
        };
      }
      function c(g) {
        (!g || !("pv" in g)) && (g = o);
        var v = 1 / g.mult, b = g.data && g.data.l || g.pv.length, S = createTypedArray("float32", b), E = createTypedArray("float32", b);
        return S.value = E, l(S, g, "multidimensional"), function() {
          g.k && g.getValue();
          for (var P = 0; P < b; P += 1)
            E[P] = g.v[P] * v, S[P] = E[P];
          return S;
        };
      }
      function m() {
        return s;
      }
      return function(g) {
        return g ? g.propType === "unidimensional" ? u(g) : c(g) : m;
      };
    }(), TransformExpressionInterface = /* @__PURE__ */ function() {
      return function(s) {
        function o(g) {
          switch (g) {
            case "scale":
            case "Scale":
            case "ADBE Scale":
            case 6:
              return o.scale;
            case "rotation":
            case "Rotation":
            case "ADBE Rotation":
            case "ADBE Rotate Z":
            case 10:
              return o.rotation;
            case "ADBE Rotate X":
              return o.xRotation;
            case "ADBE Rotate Y":
              return o.yRotation;
            case "position":
            case "Position":
            case "ADBE Position":
            case 2:
              return o.position;
            case "ADBE Position_0":
              return o.xPosition;
            case "ADBE Position_1":
              return o.yPosition;
            case "ADBE Position_2":
              return o.zPosition;
            case "anchorPoint":
            case "AnchorPoint":
            case "Anchor Point":
            case "ADBE AnchorPoint":
            case 1:
              return o.anchorPoint;
            case "opacity":
            case "Opacity":
            case 11:
              return o.opacity;
            default:
              return null;
          }
        }
        Object.defineProperty(o, "rotation", {
          get: ExpressionPropertyInterface(s.r || s.rz)
        }), Object.defineProperty(o, "zRotation", {
          get: ExpressionPropertyInterface(s.rz || s.r)
        }), Object.defineProperty(o, "xRotation", {
          get: ExpressionPropertyInterface(s.rx)
        }), Object.defineProperty(o, "yRotation", {
          get: ExpressionPropertyInterface(s.ry)
        }), Object.defineProperty(o, "scale", {
          get: ExpressionPropertyInterface(s.s)
        });
        var l, u, c, m;
        return s.p ? m = ExpressionPropertyInterface(s.p) : (l = ExpressionPropertyInterface(s.px), u = ExpressionPropertyInterface(s.py), s.pz && (c = ExpressionPropertyInterface(s.pz))), Object.defineProperty(o, "position", {
          get: function() {
            return s.p ? m() : [l(), u(), c ? c() : 0];
          }
        }), Object.defineProperty(o, "xPosition", {
          get: ExpressionPropertyInterface(s.px)
        }), Object.defineProperty(o, "yPosition", {
          get: ExpressionPropertyInterface(s.py)
        }), Object.defineProperty(o, "zPosition", {
          get: ExpressionPropertyInterface(s.pz)
        }), Object.defineProperty(o, "anchorPoint", {
          get: ExpressionPropertyInterface(s.a)
        }), Object.defineProperty(o, "opacity", {
          get: ExpressionPropertyInterface(s.o)
        }), Object.defineProperty(o, "skew", {
          get: ExpressionPropertyInterface(s.sk)
        }), Object.defineProperty(o, "skewAxis", {
          get: ExpressionPropertyInterface(s.sa)
        }), Object.defineProperty(o, "orientation", {
          get: ExpressionPropertyInterface(s.or)
        }), o;
      };
    }(), LayerExpressionInterface = /* @__PURE__ */ function() {
      function s(S) {
        var E = new Matrix();
        if (S !== void 0) {
          var P = this._elem.finalTransform.mProp.getValueAtTime(S);
          P.clone(E);
        } else {
          var T = this._elem.finalTransform.mProp;
          T.applyToMatrix(E);
        }
        return E;
      }
      function o(S, E) {
        var P = this.getMatrix(E);
        return P.props[12] = 0, P.props[13] = 0, P.props[14] = 0, this.applyPoint(P, S);
      }
      function l(S, E) {
        var P = this.getMatrix(E);
        return this.applyPoint(P, S);
      }
      function u(S, E) {
        var P = this.getMatrix(E);
        return P.props[12] = 0, P.props[13] = 0, P.props[14] = 0, this.invertPoint(P, S);
      }
      function c(S, E) {
        var P = this.getMatrix(E);
        return this.invertPoint(P, S);
      }
      function m(S, E) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var P, T = this._elem.hierarchy.length;
          for (P = 0; P < T; P += 1)
            this._elem.hierarchy[P].finalTransform.mProp.applyToMatrix(S);
        }
        return S.applyToPointArray(E[0], E[1], E[2] || 0);
      }
      function g(S, E) {
        if (this._elem.hierarchy && this._elem.hierarchy.length) {
          var P, T = this._elem.hierarchy.length;
          for (P = 0; P < T; P += 1)
            this._elem.hierarchy[P].finalTransform.mProp.applyToMatrix(S);
        }
        return S.inversePoint(E);
      }
      function v(S) {
        var E = new Matrix();
        if (E.reset(), this._elem.finalTransform.mProp.applyToMatrix(E), this._elem.hierarchy && this._elem.hierarchy.length) {
          var P, T = this._elem.hierarchy.length;
          for (P = 0; P < T; P += 1)
            this._elem.hierarchy[P].finalTransform.mProp.applyToMatrix(E);
          return E.inversePoint(S);
        }
        return E.inversePoint(S);
      }
      function b() {
        return [1, 1, 1, 1];
      }
      return function(S) {
        var E;
        function P(z) {
          N.mask = new MaskManagerInterface(z, S);
        }
        function T(z) {
          N.effect = z;
        }
        function N(z) {
          switch (z) {
            case "ADBE Root Vectors Group":
            case "Contents":
            case 2:
              return N.shapeInterface;
            case 1:
            case 6:
            case "Transform":
            case "transform":
            case "ADBE Transform Group":
              return E;
            case 4:
            case "ADBE Effect Parade":
            case "effects":
            case "Effects":
              return N.effect;
            case "ADBE Text Properties":
              return N.textInterface;
            default:
              return null;
          }
        }
        N.getMatrix = s, N.invertPoint = g, N.applyPoint = m, N.toWorld = l, N.toWorldVec = o, N.fromWorld = c, N.fromWorldVec = u, N.toComp = l, N.fromComp = v, N.sampleImage = b, N.sourceRectAtTime = S.sourceRectAtTime.bind(S), N._elem = S, E = TransformExpressionInterface(S.finalTransform.mProp);
        var O = getDescriptor(E, "anchorPoint");
        return Object.defineProperties(N, {
          hasParent: {
            get: function() {
              return S.hierarchy.length;
            }
          },
          parent: {
            get: function() {
              return S.hierarchy[0].layerInterface;
            }
          },
          rotation: getDescriptor(E, "rotation"),
          scale: getDescriptor(E, "scale"),
          position: getDescriptor(E, "position"),
          opacity: getDescriptor(E, "opacity"),
          anchorPoint: O,
          anchor_point: O,
          transform: {
            get: function() {
              return E;
            }
          },
          active: {
            get: function() {
              return S.isInRange;
            }
          }
        }), N.startTime = S.data.st, N.index = S.data.ind, N.source = S.data.refId, N.height = S.data.ty === 0 ? S.data.h : 100, N.width = S.data.ty === 0 ? S.data.w : 100, N.inPoint = S.data.ip / S.comp.globalData.frameRate, N.outPoint = S.data.op / S.comp.globalData.frameRate, N._name = S.data.nm, N.registerMaskInterface = P, N.registerEffectsInterface = T, N;
      };
    }(), propertyGroupFactory = /* @__PURE__ */ function() {
      return function(s, o) {
        return function(l) {
          return l = l === void 0 ? 1 : l, l <= 0 ? s : o(l - 1);
        };
      };
    }(), PropertyInterface = /* @__PURE__ */ function() {
      return function(s, o) {
        var l = {
          _name: s
        };
        function u(c) {
          return c = c === void 0 ? 1 : c, c <= 0 ? l : o(c - 1);
        }
        return u;
      };
    }(), EffectsExpressionInterface = /* @__PURE__ */ function() {
      var s = {
        createEffectsInterface: o
      };
      function o(c, m) {
        if (c.effectsManager) {
          var g = [], v = c.data.ef, b, S = c.effectsManager.effectElements.length;
          for (b = 0; b < S; b += 1)
            g.push(l(v[b], c.effectsManager.effectElements[b], m, c));
          var E = c.data.ef || [], P = function(N) {
            for (b = 0, S = E.length; b < S; ) {
              if (N === E[b].nm || N === E[b].mn || N === E[b].ix)
                return g[b];
              b += 1;
            }
            return null;
          };
          return Object.defineProperty(P, "numProperties", {
            get: function() {
              return E.length;
            }
          }), P;
        }
        return null;
      }
      function l(c, m, g, v) {
        function b(N) {
          for (var O = c.ef, z = 0, Q = O.length; z < Q; ) {
            if (N === O[z].nm || N === O[z].mn || N === O[z].ix)
              return O[z].ty === 5 ? E[z] : E[z]();
            z += 1;
          }
          throw new Error();
        }
        var S = propertyGroupFactory(b, g), E = [], P, T = c.ef.length;
        for (P = 0; P < T; P += 1)
          c.ef[P].ty === 5 ? E.push(l(c.ef[P], m.effectElements[P], m.effectElements[P].propertyGroup, v)) : E.push(u(m.effectElements[P], c.ef[P].ty, v, S));
        return c.mn === "ADBE Color Control" && Object.defineProperty(b, "color", {
          get: function() {
            return E[0]();
          }
        }), Object.defineProperties(b, {
          numProperties: {
            get: function() {
              return c.np;
            }
          },
          _name: {
            value: c.nm
          },
          propertyGroup: {
            value: S
          }
        }), b.enabled = c.en !== 0, b.active = b.enabled, b;
      }
      function u(c, m, g, v) {
        var b = ExpressionPropertyInterface(c.p);
        function S() {
          return m === 10 ? g.comp.compInterface(c.p.v) : b();
        }
        return c.p.setGroupProperty && c.p.setGroupProperty(PropertyInterface("", v)), S;
      }
      return s;
    }(), ShapePathInterface = /* @__PURE__ */ function() {
      return function(o, l, u) {
        var c = l.sh;
        function m(v) {
          return v === "Shape" || v === "shape" || v === "Path" || v === "path" || v === "ADBE Vector Shape" || v === 2 ? m.path : null;
        }
        var g = propertyGroupFactory(m, u);
        return c.setGroupProperty(PropertyInterface("Path", g)), Object.defineProperties(m, {
          path: {
            get: function() {
              return c.k && c.getValue(), c;
            }
          },
          shape: {
            get: function() {
              return c.k && c.getValue(), c;
            }
          },
          _name: {
            value: o.nm
          },
          ix: {
            value: o.ix
          },
          propertyIndex: {
            value: o.ix
          },
          mn: {
            value: o.mn
          },
          propertyGroup: {
            value: u
          }
        }), m;
      };
    }(), ShapeExpressionInterface = /* @__PURE__ */ function() {
      function s(O, z, Q) {
        var W = [], ue, te = O ? O.length : 0;
        for (ue = 0; ue < te; ue += 1)
          O[ue].ty === "gr" ? W.push(l(O[ue], z[ue], Q)) : O[ue].ty === "fl" ? W.push(u(O[ue], z[ue], Q)) : O[ue].ty === "st" ? W.push(g(O[ue], z[ue], Q)) : O[ue].ty === "tm" ? W.push(v(O[ue], z[ue], Q)) : O[ue].ty === "tr" || (O[ue].ty === "el" ? W.push(S(O[ue], z[ue], Q)) : O[ue].ty === "sr" ? W.push(E(O[ue], z[ue], Q)) : O[ue].ty === "sh" ? W.push(ShapePathInterface(O[ue], z[ue], Q)) : O[ue].ty === "rc" ? W.push(P(O[ue], z[ue], Q)) : O[ue].ty === "rd" ? W.push(T(O[ue], z[ue], Q)) : O[ue].ty === "rp" ? W.push(N(O[ue], z[ue], Q)) : O[ue].ty === "gf" ? W.push(c(O[ue], z[ue], Q)) : W.push(m(O[ue], z[ue])));
        return W;
      }
      function o(O, z, Q) {
        var W, ue = function(ve) {
          for (var ee = 0, Re = W.length; ee < Re; ) {
            if (W[ee]._name === ve || W[ee].mn === ve || W[ee].propertyIndex === ve || W[ee].ix === ve || W[ee].ind === ve)
              return W[ee];
            ee += 1;
          }
          return typeof ve == "number" ? W[ve - 1] : null;
        };
        ue.propertyGroup = propertyGroupFactory(ue, Q), W = s(O.it, z.it, ue.propertyGroup), ue.numProperties = W.length;
        var te = b(O.it[O.it.length - 1], z.it[z.it.length - 1], ue.propertyGroup);
        return ue.transform = te, ue.propertyIndex = O.cix, ue._name = O.nm, ue;
      }
      function l(O, z, Q) {
        var W = function(ve) {
          switch (ve) {
            case "ADBE Vectors Group":
            case "Contents":
            case 2:
              return W.content;
            default:
              return W.transform;
          }
        };
        W.propertyGroup = propertyGroupFactory(W, Q);
        var ue = o(O, z, W.propertyGroup), te = b(O.it[O.it.length - 1], z.it[z.it.length - 1], W.propertyGroup);
        return W.content = ue, W.transform = te, Object.defineProperty(W, "_name", {
          get: function() {
            return O.nm;
          }
        }), W.numProperties = O.np, W.propertyIndex = O.ix, W.nm = O.nm, W.mn = O.mn, W;
      }
      function u(O, z, Q) {
        function W(ue) {
          return ue === "Color" || ue === "color" ? W.color : ue === "Opacity" || ue === "opacity" ? W.opacity : null;
        }
        return Object.defineProperties(W, {
          color: {
            get: ExpressionPropertyInterface(z.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(z.o)
          },
          _name: {
            value: O.nm
          },
          mn: {
            value: O.mn
          }
        }), z.c.setGroupProperty(PropertyInterface("Color", Q)), z.o.setGroupProperty(PropertyInterface("Opacity", Q)), W;
      }
      function c(O, z, Q) {
        function W(ue) {
          return ue === "Start Point" || ue === "start point" ? W.startPoint : ue === "End Point" || ue === "end point" ? W.endPoint : ue === "Opacity" || ue === "opacity" ? W.opacity : null;
        }
        return Object.defineProperties(W, {
          startPoint: {
            get: ExpressionPropertyInterface(z.s)
          },
          endPoint: {
            get: ExpressionPropertyInterface(z.e)
          },
          opacity: {
            get: ExpressionPropertyInterface(z.o)
          },
          type: {
            get: function() {
              return "a";
            }
          },
          _name: {
            value: O.nm
          },
          mn: {
            value: O.mn
          }
        }), z.s.setGroupProperty(PropertyInterface("Start Point", Q)), z.e.setGroupProperty(PropertyInterface("End Point", Q)), z.o.setGroupProperty(PropertyInterface("Opacity", Q)), W;
      }
      function m() {
        function O() {
          return null;
        }
        return O;
      }
      function g(O, z, Q) {
        var W = propertyGroupFactory(Re, Q), ue = propertyGroupFactory(ee, W);
        function te(wt) {
          Object.defineProperty(ee, O.d[wt].nm, {
            get: ExpressionPropertyInterface(z.d.dataProps[wt].p)
          });
        }
        var K, ve = O.d ? O.d.length : 0, ee = {};
        for (K = 0; K < ve; K += 1)
          te(K), z.d.dataProps[K].p.setGroupProperty(ue);
        function Re(wt) {
          return wt === "Color" || wt === "color" ? Re.color : wt === "Opacity" || wt === "opacity" ? Re.opacity : wt === "Stroke Width" || wt === "stroke width" ? Re.strokeWidth : null;
        }
        return Object.defineProperties(Re, {
          color: {
            get: ExpressionPropertyInterface(z.c)
          },
          opacity: {
            get: ExpressionPropertyInterface(z.o)
          },
          strokeWidth: {
            get: ExpressionPropertyInterface(z.w)
          },
          dash: {
            get: function() {
              return ee;
            }
          },
          _name: {
            value: O.nm
          },
          mn: {
            value: O.mn
          }
        }), z.c.setGroupProperty(PropertyInterface("Color", W)), z.o.setGroupProperty(PropertyInterface("Opacity", W)), z.w.setGroupProperty(PropertyInterface("Stroke Width", W)), Re;
      }
      function v(O, z, Q) {
        function W(te) {
          return te === O.e.ix || te === "End" || te === "end" ? W.end : te === O.s.ix ? W.start : te === O.o.ix ? W.offset : null;
        }
        var ue = propertyGroupFactory(W, Q);
        return W.propertyIndex = O.ix, z.s.setGroupProperty(PropertyInterface("Start", ue)), z.e.setGroupProperty(PropertyInterface("End", ue)), z.o.setGroupProperty(PropertyInterface("Offset", ue)), W.propertyIndex = O.ix, W.propertyGroup = Q, Object.defineProperties(W, {
          start: {
            get: ExpressionPropertyInterface(z.s)
          },
          end: {
            get: ExpressionPropertyInterface(z.e)
          },
          offset: {
            get: ExpressionPropertyInterface(z.o)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      function b(O, z, Q) {
        function W(te) {
          return O.a.ix === te || te === "Anchor Point" ? W.anchorPoint : O.o.ix === te || te === "Opacity" ? W.opacity : O.p.ix === te || te === "Position" ? W.position : O.r.ix === te || te === "Rotation" || te === "ADBE Vector Rotation" ? W.rotation : O.s.ix === te || te === "Scale" ? W.scale : O.sk && O.sk.ix === te || te === "Skew" ? W.skew : O.sa && O.sa.ix === te || te === "Skew Axis" ? W.skewAxis : null;
        }
        var ue = propertyGroupFactory(W, Q);
        return z.transform.mProps.o.setGroupProperty(PropertyInterface("Opacity", ue)), z.transform.mProps.p.setGroupProperty(PropertyInterface("Position", ue)), z.transform.mProps.a.setGroupProperty(PropertyInterface("Anchor Point", ue)), z.transform.mProps.s.setGroupProperty(PropertyInterface("Scale", ue)), z.transform.mProps.r.setGroupProperty(PropertyInterface("Rotation", ue)), z.transform.mProps.sk && (z.transform.mProps.sk.setGroupProperty(PropertyInterface("Skew", ue)), z.transform.mProps.sa.setGroupProperty(PropertyInterface("Skew Angle", ue))), z.transform.op.setGroupProperty(PropertyInterface("Opacity", ue)), Object.defineProperties(W, {
          opacity: {
            get: ExpressionPropertyInterface(z.transform.mProps.o)
          },
          position: {
            get: ExpressionPropertyInterface(z.transform.mProps.p)
          },
          anchorPoint: {
            get: ExpressionPropertyInterface(z.transform.mProps.a)
          },
          scale: {
            get: ExpressionPropertyInterface(z.transform.mProps.s)
          },
          rotation: {
            get: ExpressionPropertyInterface(z.transform.mProps.r)
          },
          skew: {
            get: ExpressionPropertyInterface(z.transform.mProps.sk)
          },
          skewAxis: {
            get: ExpressionPropertyInterface(z.transform.mProps.sa)
          },
          _name: {
            value: O.nm
          }
        }), W.ty = "tr", W.mn = O.mn, W.propertyGroup = Q, W;
      }
      function S(O, z, Q) {
        function W(K) {
          return O.p.ix === K ? W.position : O.s.ix === K ? W.size : null;
        }
        var ue = propertyGroupFactory(W, Q);
        W.propertyIndex = O.ix;
        var te = z.sh.ty === "tm" ? z.sh.prop : z.sh;
        return te.s.setGroupProperty(PropertyInterface("Size", ue)), te.p.setGroupProperty(PropertyInterface("Position", ue)), Object.defineProperties(W, {
          size: {
            get: ExpressionPropertyInterface(te.s)
          },
          position: {
            get: ExpressionPropertyInterface(te.p)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      function E(O, z, Q) {
        function W(K) {
          return O.p.ix === K ? W.position : O.r.ix === K ? W.rotation : O.pt.ix === K ? W.points : O.or.ix === K || K === "ADBE Vector Star Outer Radius" ? W.outerRadius : O.os.ix === K ? W.outerRoundness : O.ir && (O.ir.ix === K || K === "ADBE Vector Star Inner Radius") ? W.innerRadius : O.is && O.is.ix === K ? W.innerRoundness : null;
        }
        var ue = propertyGroupFactory(W, Q), te = z.sh.ty === "tm" ? z.sh.prop : z.sh;
        return W.propertyIndex = O.ix, te.or.setGroupProperty(PropertyInterface("Outer Radius", ue)), te.os.setGroupProperty(PropertyInterface("Outer Roundness", ue)), te.pt.setGroupProperty(PropertyInterface("Points", ue)), te.p.setGroupProperty(PropertyInterface("Position", ue)), te.r.setGroupProperty(PropertyInterface("Rotation", ue)), O.ir && (te.ir.setGroupProperty(PropertyInterface("Inner Radius", ue)), te.is.setGroupProperty(PropertyInterface("Inner Roundness", ue))), Object.defineProperties(W, {
          position: {
            get: ExpressionPropertyInterface(te.p)
          },
          rotation: {
            get: ExpressionPropertyInterface(te.r)
          },
          points: {
            get: ExpressionPropertyInterface(te.pt)
          },
          outerRadius: {
            get: ExpressionPropertyInterface(te.or)
          },
          outerRoundness: {
            get: ExpressionPropertyInterface(te.os)
          },
          innerRadius: {
            get: ExpressionPropertyInterface(te.ir)
          },
          innerRoundness: {
            get: ExpressionPropertyInterface(te.is)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      function P(O, z, Q) {
        function W(K) {
          return O.p.ix === K ? W.position : O.r.ix === K ? W.roundness : O.s.ix === K || K === "Size" || K === "ADBE Vector Rect Size" ? W.size : null;
        }
        var ue = propertyGroupFactory(W, Q), te = z.sh.ty === "tm" ? z.sh.prop : z.sh;
        return W.propertyIndex = O.ix, te.p.setGroupProperty(PropertyInterface("Position", ue)), te.s.setGroupProperty(PropertyInterface("Size", ue)), te.r.setGroupProperty(PropertyInterface("Rotation", ue)), Object.defineProperties(W, {
          position: {
            get: ExpressionPropertyInterface(te.p)
          },
          roundness: {
            get: ExpressionPropertyInterface(te.r)
          },
          size: {
            get: ExpressionPropertyInterface(te.s)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      function T(O, z, Q) {
        function W(K) {
          return O.r.ix === K || K === "Round Corners 1" ? W.radius : null;
        }
        var ue = propertyGroupFactory(W, Q), te = z;
        return W.propertyIndex = O.ix, te.rd.setGroupProperty(PropertyInterface("Radius", ue)), Object.defineProperties(W, {
          radius: {
            get: ExpressionPropertyInterface(te.rd)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      function N(O, z, Q) {
        function W(K) {
          return O.c.ix === K || K === "Copies" ? W.copies : O.o.ix === K || K === "Offset" ? W.offset : null;
        }
        var ue = propertyGroupFactory(W, Q), te = z;
        return W.propertyIndex = O.ix, te.c.setGroupProperty(PropertyInterface("Copies", ue)), te.o.setGroupProperty(PropertyInterface("Offset", ue)), Object.defineProperties(W, {
          copies: {
            get: ExpressionPropertyInterface(te.c)
          },
          offset: {
            get: ExpressionPropertyInterface(te.o)
          },
          _name: {
            value: O.nm
          }
        }), W.mn = O.mn, W;
      }
      return function(O, z, Q) {
        var W;
        function ue(K) {
          if (typeof K == "number")
            return K = K === void 0 ? 1 : K, K === 0 ? Q : W[K - 1];
          for (var ve = 0, ee = W.length; ve < ee; ) {
            if (W[ve]._name === K)
              return W[ve];
            ve += 1;
          }
          return null;
        }
        function te() {
          return Q;
        }
        return ue.propertyGroup = propertyGroupFactory(ue, te), W = s(O, z, ue.propertyGroup), ue.numProperties = W.length, ue._name = "Contents", ue;
      };
    }(), TextExpressionInterface = /* @__PURE__ */ function() {
      return function(s) {
        var o;
        function l(u) {
          switch (u) {
            case "ADBE Text Document":
              return l.sourceText;
            default:
              return null;
          }
        }
        return Object.defineProperty(l, "sourceText", {
          get: function() {
            s.textProperty.getValue();
            var c = s.textProperty.currentData.t;
            return (!o || c !== o.value) && (o = new String(c), o.value = c || new String(c), Object.defineProperty(o, "style", {
              get: function() {
                return {
                  fillColor: s.textProperty.currentData.fc
                };
              }
            })), o;
          }
        }), l;
      };
    }();
    function _typeof(s) {
      "@babel/helpers - typeof";
      return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? _typeof = function(l) {
        return typeof l;
      } : _typeof = function(l) {
        return l && typeof Symbol == "function" && l.constructor === Symbol && l !== Symbol.prototype ? "symbol" : typeof l;
      }, _typeof(s);
    }
    var FootageInterface = /* @__PURE__ */ function() {
      var s = function(u) {
        var c = "", m = u.getFootageData();
        function g() {
          return c = "", m = u.getFootageData(), v;
        }
        function v(b) {
          if (m[b])
            return c = b, m = m[b], _typeof(m) === "object" ? v : m;
          var S = b.indexOf(c);
          if (S !== -1) {
            var E = parseInt(b.substr(S + c.length), 10);
            return m = m[E], _typeof(m) === "object" ? v : m;
          }
          return "";
        }
        return g;
      }, o = function(u) {
        function c(m) {
          return m === "Outline" ? c.outlineInterface() : null;
        }
        return c._name = "Outline", c.outlineInterface = s(u), c;
      };
      return function(l) {
        function u(c) {
          return c === "Data" ? u.dataInterface : null;
        }
        return u._name = "Data", u.dataInterface = o(l), u;
      };
    }(), interfaces = {
      layer: LayerExpressionInterface,
      effects: EffectsExpressionInterface,
      comp: CompExpressionInterface,
      shape: ShapeExpressionInterface,
      text: TextExpressionInterface,
      footage: FootageInterface
    };
    function getInterface(s) {
      return interfaces[s] || null;
    }
    var expressionHelpers = /* @__PURE__ */ function() {
      function s(g, v, b) {
        v.x && (b.k = !0, b.x = !0, b.initiateExpression = ExpressionManager.initiateExpression, b.effectsSequence.push(b.initiateExpression(g, v, b).bind(b)));
      }
      function o(g) {
        return g *= this.elem.globalData.frameRate, g -= this.offsetTime, g !== this._cachingAtTime.lastFrame && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < g ? this._cachingAtTime.lastIndex : 0, this._cachingAtTime.value = this.interpolateValue(g, this._cachingAtTime), this._cachingAtTime.lastFrame = g), this._cachingAtTime.value;
      }
      function l(g) {
        var v = -0.01, b = this.getValueAtTime(g), S = this.getValueAtTime(g + v), E = 0;
        if (b.length) {
          var P;
          for (P = 0; P < b.length; P += 1)
            E += Math.pow(S[P] - b[P], 2);
          E = Math.sqrt(E) * 100;
        } else
          E = 0;
        return E;
      }
      function u(g) {
        if (this.vel !== void 0)
          return this.vel;
        var v = -1e-3, b = this.getValueAtTime(g), S = this.getValueAtTime(g + v), E;
        if (b.length) {
          E = createTypedArray("float32", b.length);
          var P;
          for (P = 0; P < b.length; P += 1)
            E[P] = (S[P] - b[P]) / v;
        } else
          E = (S - b) / v;
        return E;
      }
      function c() {
        return this.pv;
      }
      function m(g) {
        this.propertyGroup = g;
      }
      return {
        searchExpressions: s,
        getSpeedAtTime: l,
        getVelocityAtTime: u,
        getValueAtTime: o,
        getStaticValueAtTime: c,
        setGroupProperty: m
      };
    }();
    function addPropertyDecorator() {
      function s(T, N, O) {
        if (!this.k || !this.keyframes)
          return this.pv;
        T = T ? T.toLowerCase() : "";
        var z = this.comp.renderedFrame, Q = this.keyframes, W = Q[Q.length - 1].t;
        if (z <= W)
          return this.pv;
        var ue, te;
        O ? (N ? ue = Math.abs(W - this.elem.comp.globalData.frameRate * N) : ue = Math.max(0, W - this.elem.data.ip), te = W - ue) : ((!N || N > Q.length - 1) && (N = Q.length - 1), te = Q[Q.length - 1 - N].t, ue = W - te);
        var K, ve, ee;
        if (T === "pingpong") {
          var Re = Math.floor((z - te) / ue);
          if (Re % 2 !== 0)
            return this.getValueAtTime((ue - (z - te) % ue + te) / this.comp.globalData.frameRate, 0);
        } else if (T === "offset") {
          var wt = this.getValueAtTime(te / this.comp.globalData.frameRate, 0), yt = this.getValueAtTime(W / this.comp.globalData.frameRate, 0), xt = this.getValueAtTime(((z - te) % ue + te) / this.comp.globalData.frameRate, 0), Kt = Math.floor((z - te) / ue);
          if (this.pv.length) {
            for (ee = new Array(wt.length), ve = ee.length, K = 0; K < ve; K += 1)
              ee[K] = (yt[K] - wt[K]) * Kt + xt[K];
            return ee;
          }
          return (yt - wt) * Kt + xt;
        } else if (T === "continue") {
          var tn = this.getValueAtTime(W / this.comp.globalData.frameRate, 0), ln = this.getValueAtTime((W - 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (ee = new Array(tn.length), ve = ee.length, K = 0; K < ve; K += 1)
              ee[K] = tn[K] + (tn[K] - ln[K]) * ((z - W) / this.comp.globalData.frameRate) / 5e-4;
            return ee;
          }
          return tn + (tn - ln) * ((z - W) / 1e-3);
        }
        return this.getValueAtTime(((z - te) % ue + te) / this.comp.globalData.frameRate, 0);
      }
      function o(T, N, O) {
        if (!this.k)
          return this.pv;
        T = T ? T.toLowerCase() : "";
        var z = this.comp.renderedFrame, Q = this.keyframes, W = Q[0].t;
        if (z >= W)
          return this.pv;
        var ue, te;
        O ? (N ? ue = Math.abs(this.elem.comp.globalData.frameRate * N) : ue = Math.max(0, this.elem.data.op - W), te = W + ue) : ((!N || N > Q.length - 1) && (N = Q.length - 1), te = Q[N].t, ue = te - W);
        var K, ve, ee;
        if (T === "pingpong") {
          var Re = Math.floor((W - z) / ue);
          if (Re % 2 === 0)
            return this.getValueAtTime(((W - z) % ue + W) / this.comp.globalData.frameRate, 0);
        } else if (T === "offset") {
          var wt = this.getValueAtTime(W / this.comp.globalData.frameRate, 0), yt = this.getValueAtTime(te / this.comp.globalData.frameRate, 0), xt = this.getValueAtTime((ue - (W - z) % ue + W) / this.comp.globalData.frameRate, 0), Kt = Math.floor((W - z) / ue) + 1;
          if (this.pv.length) {
            for (ee = new Array(wt.length), ve = ee.length, K = 0; K < ve; K += 1)
              ee[K] = xt[K] - (yt[K] - wt[K]) * Kt;
            return ee;
          }
          return xt - (yt - wt) * Kt;
        } else if (T === "continue") {
          var tn = this.getValueAtTime(W / this.comp.globalData.frameRate, 0), ln = this.getValueAtTime((W + 1e-3) / this.comp.globalData.frameRate, 0);
          if (this.pv.length) {
            for (ee = new Array(tn.length), ve = ee.length, K = 0; K < ve; K += 1)
              ee[K] = tn[K] + (tn[K] - ln[K]) * (W - z) / 1e-3;
            return ee;
          }
          return tn + (tn - ln) * (W - z) / 1e-3;
        }
        return this.getValueAtTime((ue - ((W - z) % ue + W)) / this.comp.globalData.frameRate, 0);
      }
      function l(T, N) {
        if (!this.k)
          return this.pv;
        if (T = (T || 0.4) * 0.5, N = Math.floor(N || 5), N <= 1)
          return this.pv;
        var O = this.comp.renderedFrame / this.comp.globalData.frameRate, z = O - T, Q = O + T, W = N > 1 ? (Q - z) / (N - 1) : 1, ue = 0, te = 0, K;
        this.pv.length ? K = createTypedArray("float32", this.pv.length) : K = 0;
        for (var ve; ue < N; ) {
          if (ve = this.getValueAtTime(z + ue * W), this.pv.length)
            for (te = 0; te < this.pv.length; te += 1)
              K[te] += ve[te];
          else
            K += ve;
          ue += 1;
        }
        if (this.pv.length)
          for (te = 0; te < this.pv.length; te += 1)
            K[te] /= N;
        else
          K /= N;
        return K;
      }
      function u(T) {
        this._transformCachingAtTime || (this._transformCachingAtTime = {
          v: new Matrix()
        });
        var N = this._transformCachingAtTime.v;
        if (N.cloneFromProps(this.pre.props), this.appliedTransformations < 1) {
          var O = this.a.getValueAtTime(T);
          N.translate(-O[0] * this.a.mult, -O[1] * this.a.mult, O[2] * this.a.mult);
        }
        if (this.appliedTransformations < 2) {
          var z = this.s.getValueAtTime(T);
          N.scale(z[0] * this.s.mult, z[1] * this.s.mult, z[2] * this.s.mult);
        }
        if (this.sk && this.appliedTransformations < 3) {
          var Q = this.sk.getValueAtTime(T), W = this.sa.getValueAtTime(T);
          N.skewFromAxis(-Q * this.sk.mult, W * this.sa.mult);
        }
        if (this.r && this.appliedTransformations < 4) {
          var ue = this.r.getValueAtTime(T);
          N.rotate(-ue * this.r.mult);
        } else if (!this.r && this.appliedTransformations < 4) {
          var te = this.rz.getValueAtTime(T), K = this.ry.getValueAtTime(T), ve = this.rx.getValueAtTime(T), ee = this.or.getValueAtTime(T);
          N.rotateZ(-te * this.rz.mult).rotateY(K * this.ry.mult).rotateX(ve * this.rx.mult).rotateZ(-ee[2] * this.or.mult).rotateY(ee[1] * this.or.mult).rotateX(ee[0] * this.or.mult);
        }
        if (this.data.p && this.data.p.s) {
          var Re = this.px.getValueAtTime(T), wt = this.py.getValueAtTime(T);
          if (this.data.p.z) {
            var yt = this.pz.getValueAtTime(T);
            N.translate(Re * this.px.mult, wt * this.py.mult, -yt * this.pz.mult);
          } else
            N.translate(Re * this.px.mult, wt * this.py.mult, 0);
        } else {
          var xt = this.p.getValueAtTime(T);
          N.translate(xt[0] * this.p.mult, xt[1] * this.p.mult, -xt[2] * this.p.mult);
        }
        return N;
      }
      function c() {
        return this.v.clone(new Matrix());
      }
      var m = TransformPropertyFactory.getTransformProperty;
      TransformPropertyFactory.getTransformProperty = function(T, N, O) {
        var z = m(T, N, O);
        return z.dynamicProperties.length ? z.getValueAtTime = u.bind(z) : z.getValueAtTime = c.bind(z), z.setGroupProperty = expressionHelpers.setGroupProperty, z;
      };
      var g = PropertyFactory.getProp;
      PropertyFactory.getProp = function(T, N, O, z, Q) {
        var W = g(T, N, O, z, Q);
        W.kf ? W.getValueAtTime = expressionHelpers.getValueAtTime.bind(W) : W.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(W), W.setGroupProperty = expressionHelpers.setGroupProperty, W.loopOut = s, W.loopIn = o, W.smooth = l, W.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(W), W.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(W), W.numKeys = N.a === 1 ? N.k.length : 0, W.propertyIndex = N.ix;
        var ue = 0;
        return O !== 0 && (ue = createTypedArray("float32", N.a === 1 ? N.k[0].s.length : N.k.length)), W._cachingAtTime = {
          lastFrame: initialDefaultFrame,
          lastIndex: 0,
          value: ue
        }, expressionHelpers.searchExpressions(T, N, W), W.k && Q.addDynamicProperty(W), W;
      };
      function v(T) {
        return this._cachingAtTime || (this._cachingAtTime = {
          shapeValue: shapePool.clone(this.pv),
          lastIndex: 0,
          lastTime: initialDefaultFrame
        }), T *= this.elem.globalData.frameRate, T -= this.offsetTime, T !== this._cachingAtTime.lastTime && (this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < T ? this._caching.lastIndex : 0, this._cachingAtTime.lastTime = T, this.interpolateShape(T, this._cachingAtTime.shapeValue, this._cachingAtTime)), this._cachingAtTime.shapeValue;
      }
      var b = ShapePropertyFactory.getConstructorFunction(), S = ShapePropertyFactory.getKeyframedConstructorFunction();
      function E() {
      }
      E.prototype = {
        vertices: function(N, O) {
          this.k && this.getValue();
          var z = this.v;
          O !== void 0 && (z = this.getValueAtTime(O, 0));
          var Q, W = z._length, ue = z[N], te = z.v, K = createSizedArray(W);
          for (Q = 0; Q < W; Q += 1)
            N === "i" || N === "o" ? K[Q] = [ue[Q][0] - te[Q][0], ue[Q][1] - te[Q][1]] : K[Q] = [ue[Q][0], ue[Q][1]];
          return K;
        },
        points: function(N) {
          return this.vertices("v", N);
        },
        inTangents: function(N) {
          return this.vertices("i", N);
        },
        outTangents: function(N) {
          return this.vertices("o", N);
        },
        isClosed: function() {
          return this.v.c;
        },
        pointOnPath: function(N, O) {
          var z = this.v;
          O !== void 0 && (z = this.getValueAtTime(O, 0)), this._segmentsLength || (this._segmentsLength = bez.getSegmentsLength(z));
          for (var Q = this._segmentsLength, W = Q.lengths, ue = Q.totalLength * N, te = 0, K = W.length, ve = 0, ee; te < K; ) {
            if (ve + W[te].addedLength > ue) {
              var Re = te, wt = z.c && te === K - 1 ? 0 : te + 1, yt = (ue - ve) / W[te].addedLength;
              ee = bez.getPointInSegment(z.v[Re], z.v[wt], z.o[Re], z.i[wt], yt, W[te]);
              break;
            } else
              ve += W[te].addedLength;
            te += 1;
          }
          return ee || (ee = z.c ? [z.v[0][0], z.v[0][1]] : [z.v[z._length - 1][0], z.v[z._length - 1][1]]), ee;
        },
        vectorOnPath: function(N, O, z) {
          N == 1 ? N = this.v.c : N == 0 && (N = 0.999);
          var Q = this.pointOnPath(N, O), W = this.pointOnPath(N + 1e-3, O), ue = W[0] - Q[0], te = W[1] - Q[1], K = Math.sqrt(Math.pow(ue, 2) + Math.pow(te, 2));
          if (K === 0)
            return [0, 0];
          var ve = z === "tangent" ? [ue / K, te / K] : [-te / K, ue / K];
          return ve;
        },
        tangentOnPath: function(N, O) {
          return this.vectorOnPath(N, O, "tangent");
        },
        normalOnPath: function(N, O) {
          return this.vectorOnPath(N, O, "normal");
        },
        setGroupProperty: expressionHelpers.setGroupProperty,
        getValueAtTime: expressionHelpers.getStaticValueAtTime
      }, extendPrototype([E], b), extendPrototype([E], S), S.prototype.getValueAtTime = v, S.prototype.initiateExpression = ExpressionManager.initiateExpression;
      var P = ShapePropertyFactory.getShapeProp;
      ShapePropertyFactory.getShapeProp = function(T, N, O, z, Q) {
        var W = P(T, N, O, z, Q);
        return W.propertyIndex = N.ix, W.lock = !1, O === 3 ? expressionHelpers.searchExpressions(T, N.pt, W) : O === 4 && expressionHelpers.searchExpressions(T, N.ks, W), W.k && T.addDynamicProperty(W), W;
      };
    }
    function initialize$1() {
      addPropertyDecorator();
    }
    function addDecorator() {
      function s() {
        return this.data.d.x ? (this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this), this.addEffect(this.getExpressionValue.bind(this)), !0) : null;
      }
      TextProperty.prototype.getExpressionValue = function(o, l) {
        var u = this.calculateExpression(l);
        if (o.t !== u) {
          var c = {};
          return this.copyData(c, o), c.t = u.toString(), c.__complete = !1, c;
        }
        return o;
      }, TextProperty.prototype.searchProperty = function() {
        var o = this.searchKeyframes(), l = this.searchExpressions();
        return this.kf = o || l, this.kf;
      }, TextProperty.prototype.searchExpressions = s;
    }
    function initialize() {
      addDecorator();
    }
    function SVGComposableEffect() {
    }
    SVGComposableEffect.prototype = {
      createMergeNode: function s(o, l) {
        var u = createNS("feMerge");
        u.setAttribute("result", o);
        var c, m;
        for (m = 0; m < l.length; m += 1)
          c = createNS("feMergeNode"), c.setAttribute("in", l[m]), u.appendChild(c), u.appendChild(c);
        return u;
      }
    };
    var linearFilterValue = "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0";
    function SVGTintFilter(s, o, l, u, c) {
      this.filterManager = o;
      var m = createNS("feColorMatrix");
      m.setAttribute("type", "matrix"), m.setAttribute("color-interpolation-filters", "linearRGB"), m.setAttribute("values", linearFilterValue + " 1 0"), this.linearFilter = m, m.setAttribute("result", u + "_tint_1"), s.appendChild(m), m = createNS("feColorMatrix"), m.setAttribute("type", "matrix"), m.setAttribute("color-interpolation-filters", "sRGB"), m.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), m.setAttribute("result", u + "_tint_2"), s.appendChild(m), this.matrixFilter = m;
      var g = this.createMergeNode(u, [c, u + "_tint_1", u + "_tint_2"]);
      s.appendChild(g);
    }
    extendPrototype([SVGComposableEffect], SVGTintFilter), SVGTintFilter.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        var o = this.filterManager.effectElements[0].p.v, l = this.filterManager.effectElements[1].p.v, u = this.filterManager.effectElements[2].p.v / 100;
        this.linearFilter.setAttribute("values", linearFilterValue + " " + u + " 0"), this.matrixFilter.setAttribute("values", l[0] - o[0] + " 0 0 0 " + o[0] + " " + (l[1] - o[1]) + " 0 0 0 " + o[1] + " " + (l[2] - o[2]) + " 0 0 0 " + o[2] + " 0 0 0 1 0");
      }
    };
    function SVGFillFilter(s, o, l, u) {
      this.filterManager = o;
      var c = createNS("feColorMatrix");
      c.setAttribute("type", "matrix"), c.setAttribute("color-interpolation-filters", "sRGB"), c.setAttribute("values", "1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0"), c.setAttribute("result", u), s.appendChild(c), this.matrixFilter = c;
    }
    SVGFillFilter.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        var o = this.filterManager.effectElements[2].p.v, l = this.filterManager.effectElements[6].p.v;
        this.matrixFilter.setAttribute("values", "0 0 0 0 " + o[0] + " 0 0 0 0 " + o[1] + " 0 0 0 0 " + o[2] + " 0 0 0 " + l + " 0");
      }
    };
    function SVGStrokeEffect(s, o, l) {
      this.initialized = !1, this.filterManager = o, this.elem = l, this.paths = [];
    }
    SVGStrokeEffect.prototype.initialize = function() {
      var s = this.elem.layerElement.children || this.elem.layerElement.childNodes, o, l, u, c;
      for (this.filterManager.effectElements[1].p.v === 1 ? (c = this.elem.maskManager.masksProperties.length, u = 0) : (u = this.filterManager.effectElements[0].p.v - 1, c = u + 1), l = createNS("g"), l.setAttribute("fill", "none"), l.setAttribute("stroke-linecap", "round"), l.setAttribute("stroke-dashoffset", 1), u; u < c; u += 1)
        o = createNS("path"), l.appendChild(o), this.paths.push({
          p: o,
          m: u
        });
      if (this.filterManager.effectElements[10].p.v === 3) {
        var m = createNS("mask"), g = createElementID();
        m.setAttribute("id", g), m.setAttribute("mask-type", "alpha"), m.appendChild(l), this.elem.globalData.defs.appendChild(m);
        var v = createNS("g");
        for (v.setAttribute("mask", "url(" + getLocationHref() + "#" + g + ")"); s[0]; )
          v.appendChild(s[0]);
        this.elem.layerElement.appendChild(v), this.masker = m, l.setAttribute("stroke", "#fff");
      } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {
        if (this.filterManager.effectElements[10].p.v === 2)
          for (s = this.elem.layerElement.children || this.elem.layerElement.childNodes; s.length; )
            this.elem.layerElement.removeChild(s[0]);
        this.elem.layerElement.appendChild(l), this.elem.layerElement.removeAttribute("mask"), l.setAttribute("stroke", "#fff");
      }
      this.initialized = !0, this.pathMasker = l;
    }, SVGStrokeEffect.prototype.renderFrame = function(s) {
      this.initialized || this.initialize();
      var o, l = this.paths.length, u, c;
      for (o = 0; o < l; o += 1)
        if (this.paths[o].m !== -1 && (u = this.elem.maskManager.viewData[this.paths[o].m], c = this.paths[o].p, (s || this.filterManager._mdf || u.prop._mdf) && c.setAttribute("d", u.lastPath), s || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || u.prop._mdf)) {
          var m;
          if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {
            var g = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, v = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01, b = c.getTotalLength();
            m = "0 0 0 " + b * g + " ";
            var S = b * (v - g), E = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01, P = Math.floor(S / E), T;
            for (T = 0; T < P; T += 1)
              m += "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + " ";
            m += "0 " + b * 10 + " 0 0";
          } else
            m = "1 " + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;
          c.setAttribute("stroke-dasharray", m);
        }
      if ((s || this.filterManager.effectElements[4].p._mdf) && this.pathMasker.setAttribute("stroke-width", this.filterManager.effectElements[4].p.v * 2), (s || this.filterManager.effectElements[6].p._mdf) && this.pathMasker.setAttribute("opacity", this.filterManager.effectElements[6].p.v), (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) && (s || this.filterManager.effectElements[3].p._mdf)) {
        var N = this.filterManager.effectElements[3].p.v;
        this.pathMasker.setAttribute("stroke", "rgb(" + bmFloor(N[0] * 255) + "," + bmFloor(N[1] * 255) + "," + bmFloor(N[2] * 255) + ")");
      }
    };
    function SVGTritoneFilter(s, o, l, u) {
      this.filterManager = o;
      var c = createNS("feColorMatrix");
      c.setAttribute("type", "matrix"), c.setAttribute("color-interpolation-filters", "linearRGB"), c.setAttribute("values", "0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0"), s.appendChild(c);
      var m = createNS("feComponentTransfer");
      m.setAttribute("color-interpolation-filters", "sRGB"), m.setAttribute("result", u), this.matrixFilter = m;
      var g = createNS("feFuncR");
      g.setAttribute("type", "table"), m.appendChild(g), this.feFuncR = g;
      var v = createNS("feFuncG");
      v.setAttribute("type", "table"), m.appendChild(v), this.feFuncG = v;
      var b = createNS("feFuncB");
      b.setAttribute("type", "table"), m.appendChild(b), this.feFuncB = b, s.appendChild(m);
    }
    SVGTritoneFilter.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        var o = this.filterManager.effectElements[0].p.v, l = this.filterManager.effectElements[1].p.v, u = this.filterManager.effectElements[2].p.v, c = u[0] + " " + l[0] + " " + o[0], m = u[1] + " " + l[1] + " " + o[1], g = u[2] + " " + l[2] + " " + o[2];
        this.feFuncR.setAttribute("tableValues", c), this.feFuncG.setAttribute("tableValues", m), this.feFuncB.setAttribute("tableValues", g);
      }
    };
    function SVGProLevelsFilter(s, o, l, u) {
      this.filterManager = o;
      var c = this.filterManager.effectElements, m = createNS("feComponentTransfer");
      (c[10].p.k || c[10].p.v !== 0 || c[11].p.k || c[11].p.v !== 1 || c[12].p.k || c[12].p.v !== 1 || c[13].p.k || c[13].p.v !== 0 || c[14].p.k || c[14].p.v !== 1) && (this.feFuncR = this.createFeFunc("feFuncR", m)), (c[17].p.k || c[17].p.v !== 0 || c[18].p.k || c[18].p.v !== 1 || c[19].p.k || c[19].p.v !== 1 || c[20].p.k || c[20].p.v !== 0 || c[21].p.k || c[21].p.v !== 1) && (this.feFuncG = this.createFeFunc("feFuncG", m)), (c[24].p.k || c[24].p.v !== 0 || c[25].p.k || c[25].p.v !== 1 || c[26].p.k || c[26].p.v !== 1 || c[27].p.k || c[27].p.v !== 0 || c[28].p.k || c[28].p.v !== 1) && (this.feFuncB = this.createFeFunc("feFuncB", m)), (c[31].p.k || c[31].p.v !== 0 || c[32].p.k || c[32].p.v !== 1 || c[33].p.k || c[33].p.v !== 1 || c[34].p.k || c[34].p.v !== 0 || c[35].p.k || c[35].p.v !== 1) && (this.feFuncA = this.createFeFunc("feFuncA", m)), (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) && (m.setAttribute("color-interpolation-filters", "sRGB"), s.appendChild(m)), (c[3].p.k || c[3].p.v !== 0 || c[4].p.k || c[4].p.v !== 1 || c[5].p.k || c[5].p.v !== 1 || c[6].p.k || c[6].p.v !== 0 || c[7].p.k || c[7].p.v !== 1) && (m = createNS("feComponentTransfer"), m.setAttribute("color-interpolation-filters", "sRGB"), m.setAttribute("result", u), s.appendChild(m), this.feFuncRComposed = this.createFeFunc("feFuncR", m), this.feFuncGComposed = this.createFeFunc("feFuncG", m), this.feFuncBComposed = this.createFeFunc("feFuncB", m));
    }
    SVGProLevelsFilter.prototype.createFeFunc = function(s, o) {
      var l = createNS(s);
      return l.setAttribute("type", "table"), o.appendChild(l), l;
    }, SVGProLevelsFilter.prototype.getTableValue = function(s, o, l, u, c) {
      for (var m = 0, g = 256, v, b = Math.min(s, o), S = Math.max(s, o), E = Array.call(null, {
        length: g
      }), P, T = 0, N = c - u, O = o - s; m <= 256; )
        v = m / 256, v <= b ? P = O < 0 ? c : u : v >= S ? P = O < 0 ? u : c : P = u + N * Math.pow((v - s) / O, 1 / l), E[T] = P, T += 1, m += 256 / (g - 1);
      return E.join(" ");
    }, SVGProLevelsFilter.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        var o, l = this.filterManager.effectElements;
        this.feFuncRComposed && (s || l[3].p._mdf || l[4].p._mdf || l[5].p._mdf || l[6].p._mdf || l[7].p._mdf) && (o = this.getTableValue(l[3].p.v, l[4].p.v, l[5].p.v, l[6].p.v, l[7].p.v), this.feFuncRComposed.setAttribute("tableValues", o), this.feFuncGComposed.setAttribute("tableValues", o), this.feFuncBComposed.setAttribute("tableValues", o)), this.feFuncR && (s || l[10].p._mdf || l[11].p._mdf || l[12].p._mdf || l[13].p._mdf || l[14].p._mdf) && (o = this.getTableValue(l[10].p.v, l[11].p.v, l[12].p.v, l[13].p.v, l[14].p.v), this.feFuncR.setAttribute("tableValues", o)), this.feFuncG && (s || l[17].p._mdf || l[18].p._mdf || l[19].p._mdf || l[20].p._mdf || l[21].p._mdf) && (o = this.getTableValue(l[17].p.v, l[18].p.v, l[19].p.v, l[20].p.v, l[21].p.v), this.feFuncG.setAttribute("tableValues", o)), this.feFuncB && (s || l[24].p._mdf || l[25].p._mdf || l[26].p._mdf || l[27].p._mdf || l[28].p._mdf) && (o = this.getTableValue(l[24].p.v, l[25].p.v, l[26].p.v, l[27].p.v, l[28].p.v), this.feFuncB.setAttribute("tableValues", o)), this.feFuncA && (s || l[31].p._mdf || l[32].p._mdf || l[33].p._mdf || l[34].p._mdf || l[35].p._mdf) && (o = this.getTableValue(l[31].p.v, l[32].p.v, l[33].p.v, l[34].p.v, l[35].p.v), this.feFuncA.setAttribute("tableValues", o));
      }
    };
    function SVGDropShadowEffect(s, o, l, u, c) {
      var m = o.container.globalData.renderConfig.filterSize, g = o.data.fs || m;
      s.setAttribute("x", g.x || m.x), s.setAttribute("y", g.y || m.y), s.setAttribute("width", g.width || m.width), s.setAttribute("height", g.height || m.height), this.filterManager = o;
      var v = createNS("feGaussianBlur");
      v.setAttribute("in", "SourceAlpha"), v.setAttribute("result", u + "_drop_shadow_1"), v.setAttribute("stdDeviation", "0"), this.feGaussianBlur = v, s.appendChild(v);
      var b = createNS("feOffset");
      b.setAttribute("dx", "25"), b.setAttribute("dy", "0"), b.setAttribute("in", u + "_drop_shadow_1"), b.setAttribute("result", u + "_drop_shadow_2"), this.feOffset = b, s.appendChild(b);
      var S = createNS("feFlood");
      S.setAttribute("flood-color", "#00ff00"), S.setAttribute("flood-opacity", "1"), S.setAttribute("result", u + "_drop_shadow_3"), this.feFlood = S, s.appendChild(S);
      var E = createNS("feComposite");
      E.setAttribute("in", u + "_drop_shadow_3"), E.setAttribute("in2", u + "_drop_shadow_2"), E.setAttribute("operator", "in"), E.setAttribute("result", u + "_drop_shadow_4"), s.appendChild(E);
      var P = this.createMergeNode(u, [u + "_drop_shadow_4", c]);
      s.appendChild(P);
    }
    extendPrototype([SVGComposableEffect], SVGDropShadowEffect), SVGDropShadowEffect.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        if ((s || this.filterManager.effectElements[4].p._mdf) && this.feGaussianBlur.setAttribute("stdDeviation", this.filterManager.effectElements[4].p.v / 4), s || this.filterManager.effectElements[0].p._mdf) {
          var o = this.filterManager.effectElements[0].p.v;
          this.feFlood.setAttribute("flood-color", rgbToHex(Math.round(o[0] * 255), Math.round(o[1] * 255), Math.round(o[2] * 255)));
        }
        if ((s || this.filterManager.effectElements[1].p._mdf) && this.feFlood.setAttribute("flood-opacity", this.filterManager.effectElements[1].p.v / 255), s || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {
          var l = this.filterManager.effectElements[3].p.v, u = (this.filterManager.effectElements[2].p.v - 90) * degToRads, c = l * Math.cos(u), m = l * Math.sin(u);
          this.feOffset.setAttribute("dx", c), this.feOffset.setAttribute("dy", m);
        }
      }
    };
    var _svgMatteSymbols = [];
    function SVGMatte3Effect(s, o, l) {
      this.initialized = !1, this.filterManager = o, this.filterElem = s, this.elem = l, l.matteElement = createNS("g"), l.matteElement.appendChild(l.layerElement), l.matteElement.appendChild(l.transformedElement), l.baseElement = l.matteElement;
    }
    SVGMatte3Effect.prototype.findSymbol = function(s) {
      for (var o = 0, l = _svgMatteSymbols.length; o < l; ) {
        if (_svgMatteSymbols[o] === s)
          return _svgMatteSymbols[o];
        o += 1;
      }
      return null;
    }, SVGMatte3Effect.prototype.replaceInParent = function(s, o) {
      var l = s.layerElement.parentNode;
      if (l) {
        for (var u = l.children, c = 0, m = u.length; c < m && u[c] !== s.layerElement; )
          c += 1;
        var g;
        c <= m - 2 && (g = u[c + 1]);
        var v = createNS("use");
        v.setAttribute("href", "#" + o), g ? l.insertBefore(v, g) : l.appendChild(v);
      }
    }, SVGMatte3Effect.prototype.setElementAsMask = function(s, o) {
      if (!this.findSymbol(o)) {
        var l = createElementID(), u = createNS("mask");
        u.setAttribute("id", o.layerId), u.setAttribute("mask-type", "alpha"), _svgMatteSymbols.push(o);
        var c = s.globalData.defs;
        c.appendChild(u);
        var m = createNS("symbol");
        m.setAttribute("id", l), this.replaceInParent(o, l), m.appendChild(o.layerElement), c.appendChild(m);
        var g = createNS("use");
        g.setAttribute("href", "#" + l), u.appendChild(g), o.data.hd = !1, o.show();
      }
      s.setMatte(o.layerId);
    }, SVGMatte3Effect.prototype.initialize = function() {
      for (var s = this.filterManager.effectElements[0].p.v, o = this.elem.comp.elements, l = 0, u = o.length; l < u; )
        o[l] && o[l].data.ind === s && this.setElementAsMask(this.elem, o[l]), l += 1;
      this.initialized = !0;
    }, SVGMatte3Effect.prototype.renderFrame = function() {
      this.initialized || this.initialize();
    };
    function SVGGaussianBlurEffect(s, o, l, u) {
      s.setAttribute("x", "-100%"), s.setAttribute("y", "-100%"), s.setAttribute("width", "300%"), s.setAttribute("height", "300%"), this.filterManager = o;
      var c = createNS("feGaussianBlur");
      c.setAttribute("result", u), s.appendChild(c), this.feGaussianBlur = c;
    }
    SVGGaussianBlurEffect.prototype.renderFrame = function(s) {
      if (s || this.filterManager._mdf) {
        var o = 0.3, l = this.filterManager.effectElements[0].p.v * o, u = this.filterManager.effectElements[1].p.v, c = u == 3 ? 0 : l, m = u == 2 ? 0 : l;
        this.feGaussianBlur.setAttribute("stdDeviation", c + " " + m);
        var g = this.filterManager.effectElements[2].p.v == 1 ? "wrap" : "duplicate";
        this.feGaussianBlur.setAttribute("edgeMode", g);
      }
    };
    function TransformEffect() {
    }
    TransformEffect.prototype.init = function(s) {
      this.effectsManager = s, this.type = effectTypes.TRANSFORM_EFFECT, this.matrix = new Matrix(), this.opacity = -1, this._mdf = !1, this._opMdf = !1;
    }, TransformEffect.prototype.renderFrame = function(s) {
      if (this._opMdf = !1, this._mdf = !1, s || this.effectsManager._mdf) {
        var o = this.effectsManager.effectElements, l = o[0].p.v, u = o[1].p.v, c = o[2].p.v === 1, m = o[3].p.v, g = c ? m : o[4].p.v, v = o[5].p.v, b = o[6].p.v, S = o[7].p.v;
        this.matrix.reset(), this.matrix.translate(-l[0], -l[1], l[2]), this.matrix.scale(g * 0.01, m * 0.01, 1), this.matrix.rotate(-S * degToRads), this.matrix.skewFromAxis(-v * degToRads, (b + 90) * degToRads), this.matrix.translate(u[0], u[1], 0), this._mdf = !0, this.opacity !== o[8].p.v && (this.opacity = o[8].p.v, this._opMdf = !0);
      }
    };
    function SVGTransformEffect(s, o) {
      this.init(o);
    }
    extendPrototype([TransformEffect], SVGTransformEffect);
    function CVTransformEffect(s) {
      this.init(s);
    }
    return extendPrototype([TransformEffect], CVTransformEffect), registerRenderer("canvas", CanvasRenderer), registerRenderer("html", HybridRenderer), registerRenderer("svg", SVGRenderer), ShapeModifiers.registerModifier("tm", TrimModifier), ShapeModifiers.registerModifier("pb", PuckerAndBloatModifier), ShapeModifiers.registerModifier("rp", RepeaterModifier), ShapeModifiers.registerModifier("rd", RoundCornersModifier), ShapeModifiers.registerModifier("zz", ZigZagModifier), ShapeModifiers.registerModifier("op", OffsetPathModifier), setExpressionsPlugin(Expressions), setExpressionInterfaces(getInterface), initialize$1(), initialize(), registerEffect$1(20, SVGTintFilter, !0), registerEffect$1(21, SVGFillFilter, !0), registerEffect$1(22, SVGStrokeEffect, !1), registerEffect$1(23, SVGTritoneFilter, !0), registerEffect$1(24, SVGProLevelsFilter, !0), registerEffect$1(25, SVGDropShadowEffect, !0), registerEffect$1(28, SVGMatte3Effect, !1), registerEffect$1(29, SVGGaussianBlurEffect, !0), registerEffect$1(35, SVGTransformEffect, !1), registerEffect(35, CVTransformEffect), lottie;
  });
})(lottie$1, lottie$1.exports);
var lottieExports = lottie$1.exports;
const lottie = /* @__PURE__ */ getDefaultExportFromCjs(lottieExports), Cx = class Cx extends BaseFoundation$1 {
  constructor(o) {
    super({ ...Cx.defaultAdapter, ...o }), this.animation = null, this.handleParamsUpdate = () => {
      var l;
      this.animation.destroy(), this.animation = lottie.loadAnimation(this._adapter.getLoadParams()), (l = this.getProp("getAnimationInstance")) == null || l(this.animation);
    };
  }
  init(o) {
    var l, u;
    super.init(o), this.animation = lottie.loadAnimation(this._adapter.getLoadParams()), (l = this.getProp("getAnimationInstance")) == null || l(this.animation), (u = this.getProp("getLottie")) == null || u(Cx.getLottie());
  }
  destroy() {
    super.destroy(), this.animation.destroy();
  }
};
Cx.getLottie = () => lottie;
let LottieFoundation = Cx;
const cssClasses$2 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-lottie`
}, propTypes$2 = {
  className: string$3,
  style: object$1,
  width: string$3,
  height: string$3,
  params: {
    type: object$1,
    required: !0
  },
  getAnimationInstance: func,
  getLottie: func
}, defaultProps$2 = {
  count: 6,
  format: "number",
  autoFocus: !0
}, vuePropsType$2 = vuePropsMake(propTypes$2, defaultProps$2), index$4 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$2
  },
  name: "Lottie",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = shallowRef(), u = reactive({}), {
      adapter: c,
      getDataAttr: m
    } = useBaseComponent(s, u);
    function g() {
      const P = () => s.params.container ?? l.value;
      return {
        ...c(),
        getContainer: P,
        getLoadParams: () => ({
          container: P(),
          renderer: "svg",
          loop: !0,
          autoplay: !0,
          ...s.params
        })
      };
    }
    const v = g(), b = new LottieFoundation(v);
    onMounted(() => {
      var P;
      b.init(), (P = s.getAnimationInstance) == null || P.call(s, b.animation);
    }), onUnmounted(() => {
      b.destroy();
    }), watch(() => s.params, (P, T, N) => {
      lodashExports.isEqual(P, T) || b.handleParamsUpdate();
    });
    function S() {
      return {
        width: s.width,
        height: s.height,
        ...s.style
      };
    }
    function E() {
      return cls(cssClasses$2.PREFIX, s.className);
    }
    return () => s.params.container ? null : createVNode("div", mergeProps$1({
      ref: l,
      style: S(),
      class: E()
    }, m()), null);
  }
}), index$5 = index$4;
var prism = { exports: {} };
(function(s) {
  var o = typeof window < "u" ? window : typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope ? self : {};
  /**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   */
  var l = function(u) {
    var c = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i, m = 0, g = {}, v = {
      /**
       * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
       * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
       * additional languages or plugins yourself.
       *
       * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
       *
       * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.manual = true;
       * // add a new <script> to load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      manual: u.Prism && u.Prism.manual,
      /**
       * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
       * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
       * own worker, you don't want it to do this.
       *
       * By setting this value to `true`, Prism will not add its own listeners to the worker.
       *
       * You obviously have to change this value before Prism executes. To do this, you can add an
       * empty Prism object into the global scope before loading the Prism script like this:
       *
       * ```js
       * window.Prism = window.Prism || {};
       * Prism.disableWorkerMessageHandler = true;
       * // Load Prism's script
       * ```
       *
       * @default false
       * @type {boolean}
       * @memberof Prism
       * @public
       */
      disableWorkerMessageHandler: u.Prism && u.Prism.disableWorkerMessageHandler,
      /**
       * A namespace for utility methods.
       *
       * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
       * change or disappear at any time.
       *
       * @namespace
       * @memberof Prism
       */
      util: {
        encode: function ue(te) {
          return te instanceof b ? new b(te.type, ue(te.content), te.alias) : Array.isArray(te) ? te.map(ue) : te.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
        },
        /**
         * Returns the name of the type of the given value.
         *
         * @param {any} o
         * @returns {string}
         * @example
         * type(null)      === 'Null'
         * type(undefined) === 'Undefined'
         * type(123)       === 'Number'
         * type('foo')     === 'String'
         * type(true)      === 'Boolean'
         * type([1, 2])    === 'Array'
         * type({})        === 'Object'
         * type(String)    === 'Function'
         * type(/abc+/)    === 'RegExp'
         */
        type: function(ue) {
          return Object.prototype.toString.call(ue).slice(8, -1);
        },
        /**
         * Returns a unique number for the given object. Later calls will still return the same number.
         *
         * @param {Object} obj
         * @returns {number}
         */
        objId: function(ue) {
          return ue.__id || Object.defineProperty(ue, "__id", { value: ++m }), ue.__id;
        },
        /**
         * Creates a deep clone of the given object.
         *
         * The main intended use of this function is to clone language definitions.
         *
         * @param {T} o
         * @param {Record<number, any>} [visited]
         * @returns {T}
         * @template T
         */
        clone: function ue(te, K) {
          K = K || {};
          var ve, ee;
          switch (v.util.type(te)) {
            case "Object":
              if (ee = v.util.objId(te), K[ee])
                return K[ee];
              ve = /** @type {Record<string, any>} */
              {}, K[ee] = ve;
              for (var Re in te)
                te.hasOwnProperty(Re) && (ve[Re] = ue(te[Re], K));
              return (
                /** @type {any} */
                ve
              );
            case "Array":
              return ee = v.util.objId(te), K[ee] ? K[ee] : (ve = [], K[ee] = ve, /** @type {Array} */
              /** @type {any} */
              te.forEach(function(wt, yt) {
                ve[yt] = ue(wt, K);
              }), /** @type {any} */
              ve);
            default:
              return te;
          }
        },
        /**
         * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
         *
         * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
         *
         * @param {Element} element
         * @returns {string}
         */
        getLanguage: function(ue) {
          for (; ue; ) {
            var te = c.exec(ue.className);
            if (te)
              return te[1].toLowerCase();
            ue = ue.parentElement;
          }
          return "none";
        },
        /**
         * Sets the Prism `language-xxxx` class of the given element.
         *
         * @param {Element} element
         * @param {string} language
         * @returns {void}
         */
        setLanguage: function(ue, te) {
          ue.className = ue.className.replace(RegExp(c, "gi"), ""), ue.classList.add("language-" + te);
        },
        /**
         * Returns the script element that is currently executing.
         *
         * This does __not__ work for line script element.
         *
         * @returns {HTMLScriptElement | null}
         */
        currentScript: function() {
          if (typeof document > "u")
            return null;
          if ("currentScript" in document)
            return (
              /** @type {any} */
              document.currentScript
            );
          try {
            throw new Error();
          } catch (ve) {
            var ue = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(ve.stack) || [])[1];
            if (ue) {
              var te = document.getElementsByTagName("script");
              for (var K in te)
                if (te[K].src == ue)
                  return te[K];
            }
            return null;
          }
        },
        /**
         * Returns whether a given class is active for `element`.
         *
         * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
         * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
         * given class is just the given class with a `no-` prefix.
         *
         * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
         * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
         * ancestors have the given class or the negated version of it, then the default activation will be returned.
         *
         * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
         * version of it, the class is considered active.
         *
         * @param {Element} element
         * @param {string} className
         * @param {boolean} [defaultActivation=false]
         * @returns {boolean}
         */
        isActive: function(ue, te, K) {
          for (var ve = "no-" + te; ue; ) {
            var ee = ue.classList;
            if (ee.contains(te))
              return !0;
            if (ee.contains(ve))
              return !1;
            ue = ue.parentElement;
          }
          return !!K;
        }
      },
      /**
       * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
       *
       * @namespace
       * @memberof Prism
       * @public
       */
      languages: {
        /**
         * The grammar for plain, unformatted text.
         */
        plain: g,
        plaintext: g,
        text: g,
        txt: g,
        /**
         * Creates a deep copy of the language with the given id and appends the given tokens.
         *
         * If a token in `redef` also appears in the copied language, then the existing token in the copied language
         * will be overwritten at its original position.
         *
         * ## Best practices
         *
         * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
         * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
         * understand the language definition because, normally, the order of tokens matters in Prism grammars.
         *
         * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
         * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
         *
         * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
         * @param {Grammar} redef The new tokens to append.
         * @returns {Grammar} The new language created.
         * @public
         * @example
         * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
         *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
         *     // at its original position
         *     'comment': { ... },
         *     // CSS doesn't have a 'color' token, so this token will be appended
         *     'color': /\b(?:red|green|blue)\b/
         * });
         */
        extend: function(ue, te) {
          var K = v.util.clone(v.languages[ue]);
          for (var ve in te)
            K[ve] = te[ve];
          return K;
        },
        /**
         * Inserts tokens _before_ another token in a language definition or any other grammar.
         *
         * ## Usage
         *
         * This helper method makes it easy to modify existing languages. For example, the CSS language definition
         * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
         * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
         * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
         * this:
         *
         * ```js
         * Prism.languages.markup.style = {
         *     // token
         * };
         * ```
         *
         * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
         * before existing tokens. For the CSS example above, you would use it like this:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'cdata', {
         *     'style': {
         *         // token
         *     }
         * });
         * ```
         *
         * ## Special cases
         *
         * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
         * will be ignored.
         *
         * This behavior can be used to insert tokens after `before`:
         *
         * ```js
         * Prism.languages.insertBefore('markup', 'comment', {
         *     'comment': Prism.languages.markup.comment,
         *     // tokens after 'comment'
         * });
         * ```
         *
         * ## Limitations
         *
         * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
         * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
         * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
         * deleting properties which is necessary to insert at arbitrary positions.
         *
         * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
         * Instead, it will create a new object and replace all references to the target object with the new one. This
         * can be done without temporarily deleting properties, so the iteration order is well-defined.
         *
         * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
         * you hold the target object in a variable, then the value of the variable will not change.
         *
         * ```js
         * var oldMarkup = Prism.languages.markup;
         * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
         *
         * assert(oldMarkup !== Prism.languages.markup);
         * assert(newMarkup === Prism.languages.markup);
         * ```
         *
         * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
         * object to be modified.
         * @param {string} before The key to insert before.
         * @param {Grammar} insert An object containing the key-value pairs to be inserted.
         * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
         * object to be modified.
         *
         * Defaults to `Prism.languages`.
         * @returns {Grammar} The new grammar object.
         * @public
         */
        insertBefore: function(ue, te, K, ve) {
          ve = ve || /** @type {any} */
          v.languages;
          var ee = ve[ue], Re = {};
          for (var wt in ee)
            if (ee.hasOwnProperty(wt)) {
              if (wt == te)
                for (var yt in K)
                  K.hasOwnProperty(yt) && (Re[yt] = K[yt]);
              K.hasOwnProperty(wt) || (Re[wt] = ee[wt]);
            }
          var xt = ve[ue];
          return ve[ue] = Re, v.languages.DFS(v.languages, function(Kt, tn) {
            tn === xt && Kt != ue && (this[Kt] = Re);
          }), Re;
        },
        // Traverse a language definition with Depth First Search
        DFS: function ue(te, K, ve, ee) {
          ee = ee || {};
          var Re = v.util.objId;
          for (var wt in te)
            if (te.hasOwnProperty(wt)) {
              K.call(te, wt, te[wt], ve || wt);
              var yt = te[wt], xt = v.util.type(yt);
              xt === "Object" && !ee[Re(yt)] ? (ee[Re(yt)] = !0, ue(yt, K, null, ee)) : xt === "Array" && !ee[Re(yt)] && (ee[Re(yt)] = !0, ue(yt, K, wt, ee));
            }
        }
      },
      plugins: {},
      /**
       * This is the most high-level function in Prism’s API.
       * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
       * each one of them.
       *
       * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
       *
       * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
       * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
       * @memberof Prism
       * @public
       */
      highlightAll: function(ue, te) {
        v.highlightAllUnder(document, ue, te);
      },
      /**
       * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
       * {@link Prism.highlightElement} on each one of them.
       *
       * The following hooks will be run:
       * 1. `before-highlightall`
       * 2. `before-all-elements-highlight`
       * 3. All hooks of {@link Prism.highlightElement} for each element.
       *
       * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
       * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
       * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
       * @memberof Prism
       * @public
       */
      highlightAllUnder: function(ue, te, K) {
        var ve = {
          callback: K,
          container: ue,
          selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
        };
        v.hooks.run("before-highlightall", ve), ve.elements = Array.prototype.slice.apply(ve.container.querySelectorAll(ve.selector)), v.hooks.run("before-all-elements-highlight", ve);
        for (var ee = 0, Re; Re = ve.elements[ee++]; )
          v.highlightElement(Re, te === !0, ve.callback);
      },
      /**
       * Highlights the code inside a single element.
       *
       * The following hooks will be run:
       * 1. `before-sanity-check`
       * 2. `before-highlight`
       * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
       * 4. `before-insert`
       * 5. `after-highlight`
       * 6. `complete`
       *
       * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
       * the element's language.
       *
       * @param {Element} element The element containing the code.
       * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
       * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
       * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
       * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
       *
       * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
       * asynchronous highlighting to work. You can build your own bundle on the
       * [Download page](https://prismjs.com/download.html).
       * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
       * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
       * @memberof Prism
       * @public
       */
      highlightElement: function(ue, te, K) {
        var ve = v.util.getLanguage(ue), ee = v.languages[ve];
        v.util.setLanguage(ue, ve);
        var Re = ue.parentElement;
        Re && Re.nodeName.toLowerCase() === "pre" && v.util.setLanguage(Re, ve);
        var wt = ue.textContent, yt = {
          element: ue,
          language: ve,
          grammar: ee,
          code: wt
        };
        function xt(tn) {
          yt.highlightedCode = tn, v.hooks.run("before-insert", yt), yt.element.innerHTML = yt.highlightedCode, v.hooks.run("after-highlight", yt), v.hooks.run("complete", yt), K && K.call(yt.element);
        }
        if (v.hooks.run("before-sanity-check", yt), Re = yt.element.parentElement, Re && Re.nodeName.toLowerCase() === "pre" && !Re.hasAttribute("tabindex") && Re.setAttribute("tabindex", "0"), !yt.code) {
          v.hooks.run("complete", yt), K && K.call(yt.element);
          return;
        }
        if (v.hooks.run("before-highlight", yt), !yt.grammar) {
          xt(v.util.encode(yt.code));
          return;
        }
        if (te && u.Worker) {
          var Kt = new Worker(v.filename);
          Kt.onmessage = function(tn) {
            xt(tn.data);
          }, Kt.postMessage(JSON.stringify({
            language: yt.language,
            code: yt.code,
            immediateClose: !0
          }));
        } else
          xt(v.highlight(yt.code, yt.grammar, yt.language));
      },
      /**
       * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
       * and the language definitions to use, and returns a string with the HTML produced.
       *
       * The following hooks will be run:
       * 1. `before-tokenize`
       * 2. `after-tokenize`
       * 3. `wrap`: On each {@link Token}.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @param {string} language The name of the language definition passed to `grammar`.
       * @returns {string} The highlighted HTML.
       * @memberof Prism
       * @public
       * @example
       * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
       */
      highlight: function(ue, te, K) {
        var ve = {
          code: ue,
          grammar: te,
          language: K
        };
        if (v.hooks.run("before-tokenize", ve), !ve.grammar)
          throw new Error('The language "' + ve.language + '" has no grammar.');
        return ve.tokens = v.tokenize(ve.code, ve.grammar), v.hooks.run("after-tokenize", ve), b.stringify(v.util.encode(ve.tokens), ve.language);
      },
      /**
       * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
       * and the language definitions to use, and returns an array with the tokenized code.
       *
       * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
       *
       * This method could be useful in other contexts as well, as a very crude parser.
       *
       * @param {string} text A string with the code to be highlighted.
       * @param {Grammar} grammar An object containing the tokens to use.
       *
       * Usually a language definition like `Prism.languages.markup`.
       * @returns {TokenStream} An array of strings and tokens, a token stream.
       * @memberof Prism
       * @public
       * @example
       * let code = `var foo = 0;`;
       * let tokens = Prism.tokenize(code, Prism.languages.javascript);
       * tokens.forEach(token => {
       *     if (token instanceof Prism.Token && token.type === 'number') {
       *         console.log(`Found numeric literal: ${token.content}`);
       *     }
       * });
       */
      tokenize: function(ue, te) {
        var K = te.rest;
        if (K) {
          for (var ve in K)
            te[ve] = K[ve];
          delete te.rest;
        }
        var ee = new P();
        return T(ee, ee.head, ue), E(ue, ee, te, ee.head, 0), O(ee);
      },
      /**
       * @namespace
       * @memberof Prism
       * @public
       */
      hooks: {
        all: {},
        /**
         * Adds the given callback to the list of callbacks for the given hook.
         *
         * The callback will be invoked when the hook it is registered for is run.
         * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
         *
         * One callback function can be registered to multiple hooks and the same hook multiple times.
         *
         * @param {string} name The name of the hook.
         * @param {HookCallback} callback The callback function which is given environment variables.
         * @public
         */
        add: function(ue, te) {
          var K = v.hooks.all;
          K[ue] = K[ue] || [], K[ue].push(te);
        },
        /**
         * Runs a hook invoking all registered callbacks with the given environment variables.
         *
         * Callbacks will be invoked synchronously and in the order in which they were registered.
         *
         * @param {string} name The name of the hook.
         * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
         * @public
         */
        run: function(ue, te) {
          var K = v.hooks.all[ue];
          if (!(!K || !K.length))
            for (var ve = 0, ee; ee = K[ve++]; )
              ee(te);
        }
      },
      Token: b
    };
    u.Prism = v;
    function b(ue, te, K, ve) {
      this.type = ue, this.content = te, this.alias = K, this.length = (ve || "").length | 0;
    }
    b.stringify = function ue(te, K) {
      if (typeof te == "string")
        return te;
      if (Array.isArray(te)) {
        var ve = "";
        return te.forEach(function(xt) {
          ve += ue(xt, K);
        }), ve;
      }
      var ee = {
        type: te.type,
        content: ue(te.content, K),
        tag: "span",
        classes: ["token", te.type],
        attributes: {},
        language: K
      }, Re = te.alias;
      Re && (Array.isArray(Re) ? Array.prototype.push.apply(ee.classes, Re) : ee.classes.push(Re)), v.hooks.run("wrap", ee);
      var wt = "";
      for (var yt in ee.attributes)
        wt += " " + yt + '="' + (ee.attributes[yt] || "").replace(/"/g, "&quot;") + '"';
      return "<" + ee.tag + ' class="' + ee.classes.join(" ") + '"' + wt + ">" + ee.content + "</" + ee.tag + ">";
    };
    function S(ue, te, K, ve) {
      ue.lastIndex = te;
      var ee = ue.exec(K);
      if (ee && ve && ee[1]) {
        var Re = ee[1].length;
        ee.index += Re, ee[0] = ee[0].slice(Re);
      }
      return ee;
    }
    function E(ue, te, K, ve, ee, Re) {
      for (var wt in K)
        if (!(!K.hasOwnProperty(wt) || !K[wt])) {
          var yt = K[wt];
          yt = Array.isArray(yt) ? yt : [yt];
          for (var xt = 0; xt < yt.length; ++xt) {
            if (Re && Re.cause == wt + "," + xt)
              return;
            var Kt = yt[xt], tn = Kt.inside, ln = !!Kt.lookbehind, rn = !!Kt.greedy, an = Kt.alias;
            if (rn && !Kt.pattern.global) {
              var Gt = Kt.pattern.toString().match(/[imsuy]*$/)[0];
              Kt.pattern = RegExp(Kt.pattern.source, Gt + "g");
            }
            for (var nn = Kt.pattern || Kt, vt = ve.next, Et = ee; vt !== te.tail && !(Re && Et >= Re.reach); Et += vt.value.length, vt = vt.next) {
              var Qt = vt.value;
              if (te.length > ue.length)
                return;
              if (!(Qt instanceof b)) {
                var un = 1, gn;
                if (rn) {
                  if (gn = S(nn, Et, ue, ln), !gn || gn.index >= ue.length)
                    break;
                  var Pn = gn.index, dn = gn.index + gn[0].length, yn = Et;
                  for (yn += vt.value.length; Pn >= yn; )
                    vt = vt.next, yn += vt.value.length;
                  if (yn -= vt.value.length, Et = yn, vt.value instanceof b)
                    continue;
                  for (var vn = vt; vn !== te.tail && (yn < dn || typeof vn.value == "string"); vn = vn.next)
                    un++, yn += vn.value.length;
                  un--, Qt = ue.slice(Et, yn), gn.index -= Et;
                } else if (gn = S(nn, 0, Qt, ln), !gn)
                  continue;
                var Pn = gn.index, On = gn[0], _n = Qt.slice(0, Pn), Nn = Qt.slice(Pn + On.length), Un = Et + Qt.length;
                Re && Un > Re.reach && (Re.reach = Un);
                var Xn = vt.prev;
                _n && (Xn = T(te, Xn, _n), Et += _n.length), N(te, Xn, un);
                var zn = new b(wt, tn ? v.tokenize(On, tn) : On, an, On);
                if (vt = T(te, Xn, zn), Nn && T(te, vt, Nn), un > 1) {
                  var jn = {
                    cause: wt + "," + xt,
                    reach: Un
                  };
                  E(ue, te, K, vt.prev, Et, jn), Re && jn.reach > Re.reach && (Re.reach = jn.reach);
                }
              }
            }
          }
        }
    }
    function P() {
      var ue = { value: null, prev: null, next: null }, te = { value: null, prev: ue, next: null };
      ue.next = te, this.head = ue, this.tail = te, this.length = 0;
    }
    function T(ue, te, K) {
      var ve = te.next, ee = { value: K, prev: te, next: ve };
      return te.next = ee, ve.prev = ee, ue.length++, ee;
    }
    function N(ue, te, K) {
      for (var ve = te.next, ee = 0; ee < K && ve !== ue.tail; ee++)
        ve = ve.next;
      te.next = ve, ve.prev = te, ue.length -= ee;
    }
    function O(ue) {
      for (var te = [], K = ue.head.next; K !== ue.tail; )
        te.push(K.value), K = K.next;
      return te;
    }
    if (!u.document)
      return u.addEventListener && (v.disableWorkerMessageHandler || u.addEventListener("message", function(ue) {
        var te = JSON.parse(ue.data), K = te.language, ve = te.code, ee = te.immediateClose;
        u.postMessage(v.highlight(ve, v.languages[K], K)), ee && u.close();
      }, !1)), v;
    var z = v.util.currentScript();
    z && (v.filename = z.src, z.hasAttribute("data-manual") && (v.manual = !0));
    function Q() {
      v.manual || v.highlightAll();
    }
    if (!v.manual) {
      var W = document.readyState;
      W === "loading" || W === "interactive" && z && z.defer ? document.addEventListener("DOMContentLoaded", Q) : window.requestAnimationFrame ? window.requestAnimationFrame(Q) : window.setTimeout(Q, 16);
    }
    return v;
  }(o);
  s.exports && (s.exports = l), typeof commonjsGlobal < "u" && (commonjsGlobal.Prism = l), l.languages.markup = {
    comment: {
      pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
      greedy: !0
    },
    prolog: {
      pattern: /<\?[\s\S]+?\?>/,
      greedy: !0
    },
    doctype: {
      // https://www.w3.org/TR/xml/#NT-doctypedecl
      pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
      greedy: !0,
      inside: {
        "internal-subset": {
          pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
          lookbehind: !0,
          greedy: !0,
          inside: null
          // see below
        },
        string: {
          pattern: /"[^"]*"|'[^']*'/,
          greedy: !0
        },
        punctuation: /^<!|>$|[[\]]/,
        "doctype-tag": /^DOCTYPE/i,
        name: /[^\s<>'"]+/
      }
    },
    cdata: {
      pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
      greedy: !0
    },
    tag: {
      pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
      greedy: !0,
      inside: {
        tag: {
          pattern: /^<\/?[^\s>\/]+/,
          inside: {
            punctuation: /^<\/?/,
            namespace: /^[^\s>\/:]+:/
          }
        },
        "special-attr": [],
        "attr-value": {
          pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
          inside: {
            punctuation: [
              {
                pattern: /^=/,
                alias: "attr-equals"
              },
              {
                pattern: /^(\s*)["']|["']$/,
                lookbehind: !0
              }
            ]
          }
        },
        punctuation: /\/?>/,
        "attr-name": {
          pattern: /[^\s>\/]+/,
          inside: {
            namespace: /^[^\s>\/:]+:/
          }
        }
      }
    },
    entity: [
      {
        pattern: /&[\da-z]{1,8};/i,
        alias: "named-entity"
      },
      /&#x?[\da-f]{1,8};/i
    ]
  }, l.languages.markup.tag.inside["attr-value"].inside.entity = l.languages.markup.entity, l.languages.markup.doctype.inside["internal-subset"].inside = l.languages.markup, l.hooks.add("wrap", function(u) {
    u.type === "entity" && (u.attributes.title = u.content.replace(/&amp;/, "&"));
  }), Object.defineProperty(l.languages.markup.tag, "addInlined", {
    /**
     * Adds an inlined language to markup.
     *
     * An example of an inlined language is CSS with `<style>` tags.
     *
     * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addInlined('style', 'css');
     */
    value: function(c, m) {
      var g = {};
      g["language-" + m] = {
        pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
        lookbehind: !0,
        inside: l.languages[m]
      }, g.cdata = /^<!\[CDATA\[|\]\]>$/i;
      var v = {
        "included-cdata": {
          pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
          inside: g
        }
      };
      v["language-" + m] = {
        pattern: /[\s\S]+/,
        inside: l.languages[m]
      };
      var b = {};
      b[c] = {
        pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
          return c;
        }), "i"),
        lookbehind: !0,
        greedy: !0,
        inside: v
      }, l.languages.insertBefore("markup", "cdata", b);
    }
  }), Object.defineProperty(l.languages.markup.tag, "addAttribute", {
    /**
     * Adds an pattern to highlight languages embedded in HTML attributes.
     *
     * An example of an inlined language is CSS with `style` attributes.
     *
     * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
     * case insensitive.
     * @param {string} lang The language key.
     * @example
     * addAttribute('style', 'css');
     */
    value: function(u, c) {
      l.languages.markup.tag.inside["special-attr"].push({
        pattern: RegExp(
          /(^|["'\s])/.source + "(?:" + u + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
          "i"
        ),
        lookbehind: !0,
        inside: {
          "attr-name": /^[^\s=]+/,
          "attr-value": {
            pattern: /=[\s\S]+/,
            inside: {
              value: {
                pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                lookbehind: !0,
                alias: [c, "language-" + c],
                inside: l.languages[c]
              },
              punctuation: [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                /"|'/
              ]
            }
          }
        }
      });
    }
  }), l.languages.html = l.languages.markup, l.languages.mathml = l.languages.markup, l.languages.svg = l.languages.markup, l.languages.xml = l.languages.extend("markup", {}), l.languages.ssml = l.languages.xml, l.languages.atom = l.languages.xml, l.languages.rss = l.languages.xml, function(u) {
    var c = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
    u.languages.css = {
      comment: /\/\*[\s\S]*?\*\//,
      atrule: {
        pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + c.source + ")*?" + /(?:;|(?=\s*\{))/.source),
        inside: {
          rule: /^@[\w-]+/,
          "selector-function-argument": {
            pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
            lookbehind: !0,
            alias: "selector"
          },
          keyword: {
            pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
            lookbehind: !0
          }
          // See rest below
        }
      },
      url: {
        // https://drafts.csswg.org/css-values-3/#urls
        pattern: RegExp("\\burl\\((?:" + c.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
        greedy: !0,
        inside: {
          function: /^url/i,
          punctuation: /^\(|\)$/,
          string: {
            pattern: RegExp("^" + c.source + "$"),
            alias: "url"
          }
        }
      },
      selector: {
        pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + c.source + ")*(?=\\s*\\{)"),
        lookbehind: !0
      },
      string: {
        pattern: c,
        greedy: !0
      },
      property: {
        pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
        lookbehind: !0
      },
      important: /!important\b/i,
      function: {
        pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
        lookbehind: !0
      },
      punctuation: /[(){};:,]/
    }, u.languages.css.atrule.inside.rest = u.languages.css;
    var m = u.languages.markup;
    m && (m.tag.addInlined("style", "css"), m.tag.addAttribute("style", "css"));
  }(l), l.languages.clike = {
    comment: [
      {
        pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
        lookbehind: !0,
        greedy: !0
      },
      {
        pattern: /(^|[^\\:])\/\/.*/,
        lookbehind: !0,
        greedy: !0
      }
    ],
    string: {
      pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
      greedy: !0
    },
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
      lookbehind: !0,
      inside: {
        punctuation: /[.\\]/
      }
    },
    keyword: /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
    boolean: /\b(?:false|true)\b/,
    function: /\b\w+(?=\()/,
    number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
    operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
    punctuation: /[{}[\];(),.:]/
  }, l.languages.javascript = l.languages.extend("clike", {
    "class-name": [
      l.languages.clike["class-name"],
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
        lookbehind: !0
      }
    ],
    keyword: [
      {
        pattern: /((?:^|\})\s*)catch\b/,
        lookbehind: !0
      },
      {
        pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
        lookbehind: !0
      }
    ],
    // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
    function: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
    number: {
      pattern: RegExp(
        /(^|[^\w$])/.source + "(?:" + // constant
        (/NaN|Infinity/.source + "|" + // binary integer
        /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
        /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
        /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
        /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
        /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
      ),
      lookbehind: !0
    },
    operator: /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
  }), l.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/, l.languages.insertBefore("javascript", "keyword", {
    regex: {
      pattern: RegExp(
        // lookbehind
        // eslint-disable-next-line regexp/no-dupe-characters-character-class
        /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
        // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
        // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
        // with the only syntax, so we have to define 2 different regex patterns.
        /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
        /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
        /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
      ),
      lookbehind: !0,
      greedy: !0,
      inside: {
        "regex-source": {
          pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
          lookbehind: !0,
          alias: "language-regex",
          inside: l.languages.regex
        },
        "regex-delimiter": /^\/|\/$/,
        "regex-flags": /^[a-z]+$/
      }
    },
    // This must be declared before keyword because we use "function" inside the look-forward
    "function-variable": {
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
      alias: "function"
    },
    parameter: [
      {
        pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
        lookbehind: !0,
        inside: l.languages.javascript
      },
      {
        pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
        lookbehind: !0,
        inside: l.languages.javascript
      },
      {
        pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
        lookbehind: !0,
        inside: l.languages.javascript
      },
      {
        pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
        lookbehind: !0,
        inside: l.languages.javascript
      }
    ],
    constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
  }), l.languages.insertBefore("javascript", "string", {
    hashbang: {
      pattern: /^#!.*/,
      greedy: !0,
      alias: "comment"
    },
    "template-string": {
      pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
      greedy: !0,
      inside: {
        "template-punctuation": {
          pattern: /^`|`$/,
          alias: "string"
        },
        interpolation: {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
          lookbehind: !0,
          inside: {
            "interpolation-punctuation": {
              pattern: /^\$\{|\}$/,
              alias: "punctuation"
            },
            rest: l.languages.javascript
          }
        },
        string: /[\s\S]+/
      }
    },
    "string-property": {
      pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
      lookbehind: !0,
      greedy: !0,
      alias: "property"
    }
  }), l.languages.insertBefore("javascript", "operator", {
    "literal-property": {
      pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
      lookbehind: !0,
      alias: "property"
    }
  }), l.languages.markup && (l.languages.markup.tag.addInlined("script", "javascript"), l.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  )), l.languages.js = l.languages.javascript, function() {
    if (typeof l > "u" || typeof document > "u")
      return;
    Element.prototype.matches || (Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector);
    var u = "Loading…", c = function(z, Q) {
      return "✖ Error " + z + " while fetching file: " + Q;
    }, m = "✖ Error: File does not exist or is empty", g = {
      js: "javascript",
      py: "python",
      rb: "ruby",
      ps1: "powershell",
      psm1: "powershell",
      sh: "bash",
      bat: "batch",
      h: "c",
      tex: "latex"
    }, v = "data-src-status", b = "loading", S = "loaded", E = "failed", P = "pre[data-src]:not([" + v + '="' + S + '"]):not([' + v + '="' + b + '"])';
    function T(z, Q, W) {
      var ue = new XMLHttpRequest();
      ue.open("GET", z, !0), ue.onreadystatechange = function() {
        ue.readyState == 4 && (ue.status < 400 && ue.responseText ? Q(ue.responseText) : ue.status >= 400 ? W(c(ue.status, ue.statusText)) : W(m));
      }, ue.send(null);
    }
    function N(z) {
      var Q = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(z || "");
      if (Q) {
        var W = Number(Q[1]), ue = Q[2], te = Q[3];
        return ue ? te ? [W, Number(te)] : [W, void 0] : [W, W];
      }
    }
    l.hooks.add("before-highlightall", function(z) {
      z.selector += ", " + P;
    }), l.hooks.add("before-sanity-check", function(z) {
      var Q = (
        /** @type {HTMLPreElement} */
        z.element
      );
      if (Q.matches(P)) {
        z.code = "", Q.setAttribute(v, b);
        var W = Q.appendChild(document.createElement("CODE"));
        W.textContent = u;
        var ue = Q.getAttribute("data-src"), te = z.language;
        if (te === "none") {
          var K = (/\.(\w+)$/.exec(ue) || [, "none"])[1];
          te = g[K] || K;
        }
        l.util.setLanguage(W, te), l.util.setLanguage(Q, te);
        var ve = l.plugins.autoloader;
        ve && ve.loadLanguages(te), T(
          ue,
          function(ee) {
            Q.setAttribute(v, S);
            var Re = N(Q.getAttribute("data-range"));
            if (Re) {
              var wt = ee.split(/\r\n?|\n/g), yt = Re[0], xt = Re[1] == null ? wt.length : Re[1];
              yt < 0 && (yt += wt.length), yt = Math.max(0, Math.min(yt - 1, wt.length)), xt < 0 && (xt += wt.length), xt = Math.max(0, Math.min(xt, wt.length)), ee = wt.slice(yt, xt).join(`
`), Q.hasAttribute("data-start") || Q.setAttribute("data-start", String(yt + 1));
            }
            W.textContent = ee, l.highlightElement(W);
          },
          function(ee) {
            Q.setAttribute(v, E), W.textContent = ee;
          }
        );
      }
    }), l.plugins.fileHighlight = {
      /**
       * Executes the File Highlight plugin for all matching `pre` elements under the given container.
       *
       * Note: Elements which are already loaded or currently loading will not be touched by this method.
       *
       * @param {ParentNode} [container=document]
       */
      highlight: function(Q) {
        for (var W = (Q || document).querySelectorAll(P), ue = 0, te; te = W[ue++]; )
          l.highlightElement(te);
      }
    };
    var O = !1;
    l.fileHighlight = function() {
      O || (console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead."), O = !0), l.plugins.fileHighlight.highlight.apply(this, arguments);
    };
  }();
})(prism);
var prismExports = prism.exports;
const Prism$1 = /* @__PURE__ */ getDefaultExportFromCjs(prismExports);
(function() {
  if (typeof Prism < "u" && typeof document < "u") {
    var s = "line-numbers", o = /\n(?!$)/g, l = Prism.plugins.lineNumbers = { getLine: function(m, g) {
      if (m.tagName === "PRE" && m.classList.contains(s)) {
        var v = m.querySelector(".line-numbers-rows");
        if (v) {
          var b = parseInt(m.getAttribute("data-start"), 10) || 1, S = b + (v.children.length - 1);
          g < b && (g = b), g > S && (g = S);
          var E = g - b;
          return v.children[E];
        }
      }
    }, resize: function(m) {
      c([m]);
    }, assumeViewportIndependence: !0 }, u = void 0;
    window.addEventListener("resize", function() {
      l.assumeViewportIndependence && u === window.innerWidth || (u = window.innerWidth, c(Array.prototype.slice.call(document.querySelectorAll("pre.line-numbers"))));
    }), Prism.hooks.add("complete", function(m) {
      if (m.code) {
        var g = m.element, v = g.parentNode;
        if (v && /pre/i.test(v.nodeName) && !g.querySelector(".line-numbers-rows") && Prism.util.isActive(g, s)) {
          g.classList.remove(s), v.classList.add(s);
          var b, S = m.code.match(o), E = S ? S.length + 1 : 1, P = new Array(E + 1).join("<span></span>");
          (b = document.createElement("span")).setAttribute("aria-hidden", "true"), b.className = "line-numbers-rows", b.innerHTML = P, v.hasAttribute("data-start") && (v.style.counterReset = "linenumber " + (parseInt(v.getAttribute("data-start"), 10) - 1)), m.element.appendChild(b), c([v]), Prism.hooks.run("line-numbers", m);
        }
      }
    }), Prism.hooks.add("line-numbers", function(m) {
      m.plugins = m.plugins || {}, m.plugins.lineNumbers = !0;
    });
  }
  function c(m) {
    if ((m = m.filter(function(v) {
      var b, S = (b = v, b ? window.getComputedStyle ? getComputedStyle(b) : b.currentStyle || null : null)["white-space"];
      return S === "pre-wrap" || S === "pre-line";
    })).length != 0) {
      var g = m.map(function(v) {
        var b = v.querySelector("code"), S = v.querySelector(".line-numbers-rows");
        if (b && S) {
          var E = v.querySelector(".line-numbers-sizer"), P = b.textContent.split(o);
          E || ((E = document.createElement("span")).className = "line-numbers-sizer", b.appendChild(E)), E.innerHTML = "0", E.style.display = "block";
          var T = E.getBoundingClientRect().height;
          return E.innerHTML = "", { element: v, lines: P, lineHeights: [], oneLinerHeight: T, sizer: E };
        }
      }).filter(Boolean);
      g.forEach(function(v) {
        var b = v.sizer, S = v.lines, E = v.lineHeights, P = v.oneLinerHeight;
        E[S.length - 1] = void 0, S.forEach(function(T, N) {
          if (T && T.length > 1) {
            var O = b.appendChild(document.createElement("span"));
            O.style.display = "block", O.textContent = T;
          } else E[N] = P;
        });
      }), g.forEach(function(v) {
        for (var b = v.sizer, S = v.lineHeights, E = 0, P = 0; P < S.length; P++) S[P] === void 0 && (S[P] = b.children[E++].getBoundingClientRect().height);
      }), g.forEach(function(v) {
        var b = v.sizer, S = v.element.querySelector(".line-numbers-rows");
        b.style.display = "none", b.innerHTML = "", v.lineHeights.forEach(function(E, P) {
          S.children[P].style.height = E + "px";
        });
      });
    }
  }
})();
Prism$1.manual = !0;
class CodeHighlightFoundation extends BaseFoundation$1 {
  constructor(o) {
    super({ ...o }), this.highlightCode = (l, u) => {
      let c = l.className;
      const m = `language-${u}`;
      c.includes(m) || (c = cls(c, m)), this.getProp("lineNumber") && (c = cls(c, "line-numbers")), l.className = c, Prism$1.highlightElement(l, !1);
    };
  }
}
const cssClasses$1 = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-codeHighlight`
}, propTypes$1 = {
  className: string$3,
  style: object$1,
  code: {
    type: string$3,
    required: !0
  },
  language: {
    type: string$3,
    required: !0
  },
  lineNumber: {
    type: bool,
    required: !0
  },
  defaultTheme: bool
}, defaultProps$1 = {
  lineNumber: !0,
  defaultTheme: !0
}, vuePropsType$1 = vuePropsMake(propTypes$1, defaultProps$1), index$3 = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType$1
  },
  name: "index",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = shallowRef(), u = reactive({}), {
      adapter: c,
      getDataAttr: m
    } = useBaseComponent(s, u);
    function g() {
      return {
        ...c()
      };
    }
    const v = g(), b = new CodeHighlightFoundation(v);
    return onMounted(() => {
      l.value && b.highlightCode(l.value, s.language);
    }), watch([() => s.code, () => s.language], (S, [E, P], T) => {
      (l.value && E !== s.code || P !== s.language) && b.highlightCode(l.value, s.language);
    }), () => createVNode("div", mergeProps$1({
      style: s.style,
      class: cls(s.className, cssClasses$1.PREFIX, "semi-light-scrollbar", {
        [`${cssClasses$1.PREFIX}-defaultTheme`]: s.defaultTheme
      })
    }, m()), [createVNode("pre", null, [createVNode("code", {
      ref: l
    }, [s.code])])]);
  }
}), CodeHighlight = index$3, cssClasses = {
  PREFIX: `${BASE_CLASS_PREFIX$1}-markdownRender`
}, h1 = (s) => (console.log(s), createVNode(Typography.Title, mergeProps$1({
  heading: 1,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null)), h1$1 = h1, h2 = (s) => createVNode(Typography.Title, mergeProps$1({
  heading: 2,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null), h2$1 = h2, h3 = (s) => createVNode(Typography.Title, mergeProps$1({
  heading: 3,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null), h3$1 = h3, h4 = (s) => createVNode(Typography.Title, mergeProps$1({
  heading: 4,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null), h4$1 = h4, h5 = (s) => createVNode(Typography.Title, mergeProps$1({
  heading: 5,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null), h5$1 = h5, h6 = (s) => createVNode(Typography.Title, mergeProps$1({
  heading: 6,
  className: `${cssClasses.PREFIX}-component-header`
}, s), null), h6$1 = h6, a = (s) => createVNode(Typography.Text, {
  link: {
    ...lodashExports.omit(s, "children")
  }
}, {
  default: () => [s.children]
}), a$1 = a, img = (s) => createVNode("div", {
  class: `${cssClasses.PREFIX}-component-image`
}, [createVNode(Image$1, mergeProps$1({
  fallback: createVNode(IconComponent$1, null, null),
  width: "100%"
}, lodashExports.omit(s, "children")), null), createVNode("div", {
  class: `${cssClasses.PREFIX}-component-image-alt`
}, [s.alt])]), img$1 = img, table$1 = (s) => {
  const {
    children: o
  } = s, l = (v) => Array.isArray(v) ? v : [v], u = l(lodashExports.get(o[0], "children[0].children")), c = l(lodashExports.get(o[1], "children")), m = u.map((v) => (v == null ? void 0 : v.children) || ""), g = [];
  for (let v = 0; v < c.length; v++) {
    let b = {
      key: String(v)
    };
    c[v].children.forEach((S, E) => {
      b[m[E]] = (S == null ? void 0 : S.children) ?? "";
    }), g.push(b);
  }
  return createVNode(Table$1, mergeProps$1({
    dataSource: g,
    columns: m.map((v) => ({
      title: v,
      dataIndex: v
    }))
  }, lodashExports.omit(s, "children")), null);
}, table$2 = table$1, p = (s) => createVNode(Typography.Paragraph, mergeProps$1({
  className: `${cssClasses.PREFIX}-component-p`
}, s), null), p$1 = p, pre = (s) => {
  var l;
  const o = lodashExports.nth((l = s.className) == null ? void 0 : l.split("-"), -1);
  return o ? createVNode(CodeHighlight, {
    code: s.children,
    language: o,
    lineNumber: !0
  }, null) : createVNode("span", {
    class: `${cssClasses.PREFIX}-simple-code`
  }, [s.children]);
}, pre$1 = pre, SemiMarkdownComponents = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  a: a$1,
  code: pre$1,
  h1: h1$1,
  h2: h2$1,
  h3: h3$1,
  h4: h4$1,
  h5: h5$1,
  h6: h6$1,
  img: img$1,
  p: p$1,
  table: table$2
}, Symbol.toStringTag, { value: "Module" }));
function stringifyPosition(s) {
  return !s || typeof s != "object" ? "" : "position" in s || "type" in s ? position$1(s.position) : "start" in s || "end" in s ? position$1(s) : "line" in s || "column" in s ? point$2(s) : "";
}
function point$2(s) {
  return index$2(s && s.line) + ":" + index$2(s && s.column);
}
function position$1(s) {
  return point$2(s && s.start) + "-" + point$2(s && s.end);
}
function index$2(s) {
  return s && typeof s == "number" ? s : 1;
}
class VFileMessage extends Error {
  /**
   * Create a message for `reason`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {Options | null | undefined} [options]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | Options | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns
   *   Instance of `VFileMessage`.
   */
  // eslint-disable-next-line complexity
  constructor(o, l, u) {
    super(), typeof l == "string" && (u = l, l = void 0);
    let c = "", m = {}, g = !1;
    if (l && ("line" in l && "column" in l ? m = { place: l } : "start" in l && "end" in l ? m = { place: l } : "type" in l ? m = {
      ancestors: [l],
      place: l.position
    } : m = { ...l }), typeof o == "string" ? c = o : !m.cause && o && (g = !0, c = o.message, m.cause = o), !m.ruleId && !m.source && typeof u == "string") {
      const b = u.indexOf(":");
      b === -1 ? m.ruleId = u : (m.source = u.slice(0, b), m.ruleId = u.slice(b + 1));
    }
    if (!m.place && m.ancestors && m.ancestors) {
      const b = m.ancestors[m.ancestors.length - 1];
      b && (m.place = b.position);
    }
    const v = m.place && "start" in m.place ? m.place.start : m.place;
    this.ancestors = m.ancestors || void 0, this.cause = m.cause || void 0, this.column = v ? v.column : void 0, this.fatal = void 0, this.file, this.message = c, this.line = v ? v.line : void 0, this.name = stringifyPosition(m.place) || "1:1", this.place = m.place || void 0, this.reason = this.message, this.ruleId = m.ruleId || void 0, this.source = m.source || void 0, this.stack = g && m.cause && typeof m.cause.stack == "string" ? m.cause.stack : "", this.actual, this.expected, this.note, this.url;
  }
}
VFileMessage.prototype.file = "";
VFileMessage.prototype.name = "";
VFileMessage.prototype.reason = "";
VFileMessage.prototype.message = "";
VFileMessage.prototype.stack = "";
VFileMessage.prototype.column = void 0;
VFileMessage.prototype.line = void 0;
VFileMessage.prototype.ancestors = void 0;
VFileMessage.prototype.cause = void 0;
VFileMessage.prototype.fatal = void 0;
VFileMessage.prototype.place = void 0;
VFileMessage.prototype.ruleId = void 0;
VFileMessage.prototype.source = void 0;
const path$1 = { basename, dirname, extname, join, sep: "/" };
function basename(s, o) {
  if (o !== void 0 && typeof o != "string")
    throw new TypeError('"ext" argument must be a string');
  assertPath$1(s);
  let l = 0, u = -1, c = s.length, m;
  if (o === void 0 || o.length === 0 || o.length > s.length) {
    for (; c--; )
      if (s.codePointAt(c) === 47) {
        if (m) {
          l = c + 1;
          break;
        }
      } else u < 0 && (m = !0, u = c + 1);
    return u < 0 ? "" : s.slice(l, u);
  }
  if (o === s)
    return "";
  let g = -1, v = o.length - 1;
  for (; c--; )
    if (s.codePointAt(c) === 47) {
      if (m) {
        l = c + 1;
        break;
      }
    } else
      g < 0 && (m = !0, g = c + 1), v > -1 && (s.codePointAt(c) === o.codePointAt(v--) ? v < 0 && (u = c) : (v = -1, u = g));
  return l === u ? u = g : u < 0 && (u = s.length), s.slice(l, u);
}
function dirname(s) {
  if (assertPath$1(s), s.length === 0)
    return ".";
  let o = -1, l = s.length, u;
  for (; --l; )
    if (s.codePointAt(l) === 47) {
      if (u) {
        o = l;
        break;
      }
    } else u || (u = !0);
  return o < 0 ? s.codePointAt(0) === 47 ? "/" : "." : o === 1 && s.codePointAt(0) === 47 ? "//" : s.slice(0, o);
}
function extname(s) {
  assertPath$1(s);
  let o = s.length, l = -1, u = 0, c = -1, m = 0, g;
  for (; o--; ) {
    const v = s.codePointAt(o);
    if (v === 47) {
      if (g) {
        u = o + 1;
        break;
      }
      continue;
    }
    l < 0 && (g = !0, l = o + 1), v === 46 ? c < 0 ? c = o : m !== 1 && (m = 1) : c > -1 && (m = -1);
  }
  return c < 0 || l < 0 || // We saw a non-dot character immediately before the dot.
  m === 0 || // The (right-most) trimmed path component is exactly `..`.
  m === 1 && c === l - 1 && c === u + 1 ? "" : s.slice(c, l);
}
function join(...s) {
  let o = -1, l;
  for (; ++o < s.length; )
    assertPath$1(s[o]), s[o] && (l = l === void 0 ? s[o] : l + "/" + s[o]);
  return l === void 0 ? "." : normalize$1(l);
}
function normalize$1(s) {
  assertPath$1(s);
  const o = s.codePointAt(0) === 47;
  let l = normalizeString(s, !o);
  return l.length === 0 && !o && (l = "."), l.length > 0 && s.codePointAt(s.length - 1) === 47 && (l += "/"), o ? "/" + l : l;
}
function normalizeString(s, o) {
  let l = "", u = 0, c = -1, m = 0, g = -1, v, b;
  for (; ++g <= s.length; ) {
    if (g < s.length)
      v = s.codePointAt(g);
    else {
      if (v === 47)
        break;
      v = 47;
    }
    if (v === 47) {
      if (!(c === g - 1 || m === 1)) if (c !== g - 1 && m === 2) {
        if (l.length < 2 || u !== 2 || l.codePointAt(l.length - 1) !== 46 || l.codePointAt(l.length - 2) !== 46) {
          if (l.length > 2) {
            if (b = l.lastIndexOf("/"), b !== l.length - 1) {
              b < 0 ? (l = "", u = 0) : (l = l.slice(0, b), u = l.length - 1 - l.lastIndexOf("/")), c = g, m = 0;
              continue;
            }
          } else if (l.length > 0) {
            l = "", u = 0, c = g, m = 0;
            continue;
          }
        }
        o && (l = l.length > 0 ? l + "/.." : "..", u = 2);
      } else
        l.length > 0 ? l += "/" + s.slice(c + 1, g) : l = s.slice(c + 1, g), u = g - c - 1;
      c = g, m = 0;
    } else v === 46 && m > -1 ? m++ : m = -1;
  }
  return l;
}
function assertPath$1(s) {
  if (typeof s != "string")
    throw new TypeError(
      "Path must be a string. Received " + JSON.stringify(s)
    );
}
const proc = { cwd };
function cwd() {
  return "/";
}
function isUrl(s) {
  return !!(s !== null && typeof s == "object" && "href" in s && s.href && "protocol" in s && s.protocol && // @ts-expect-error: indexing is fine.
  s.auth === void 0);
}
function urlToPath(s) {
  if (typeof s == "string")
    s = new URL(s);
  else if (!isUrl(s)) {
    const o = new TypeError(
      'The "path" argument must be of type string or an instance of URL. Received `' + s + "`"
    );
    throw o.code = "ERR_INVALID_ARG_TYPE", o;
  }
  if (s.protocol !== "file:") {
    const o = new TypeError("The URL must be of scheme file");
    throw o.code = "ERR_INVALID_URL_SCHEME", o;
  }
  return getPathFromURLPosix(s);
}
function getPathFromURLPosix(s) {
  if (s.hostname !== "") {
    const u = new TypeError(
      'File URL host must be "localhost" or empty on darwin'
    );
    throw u.code = "ERR_INVALID_FILE_URL_HOST", u;
  }
  const o = s.pathname;
  let l = -1;
  for (; ++l < o.length; )
    if (o.codePointAt(l) === 37 && o.codePointAt(l + 1) === 50) {
      const u = o.codePointAt(l + 2);
      if (u === 70 || u === 102) {
        const c = new TypeError(
          "File URL path must not include encoded / characters"
        );
        throw c.code = "ERR_INVALID_FILE_URL_PATH", c;
      }
    }
  return decodeURIComponent(o);
}
const order = (
  /** @type {const} */
  [
    "history",
    "path",
    "basename",
    "stem",
    "extname",
    "dirname"
  ]
);
class VFile {
  /**
   * Create a new virtual file.
   *
   * `options` is treated as:
   *
   * *   `string` or `Uint8Array` — `{value: options}`
   * *   `URL` — `{path: options}`
   * *   `VFile` — shallow copies its data over to the new file
   * *   `object` — all fields are shallow copied over to the new file
   *
   * Path related fields are set in the following order (least specific to
   * most specific): `history`, `path`, `basename`, `stem`, `extname`,
   * `dirname`.
   *
   * You cannot set `dirname` or `extname` without setting either `history`,
   * `path`, `basename`, or `stem` too.
   *
   * @param {Compatible | null | undefined} [value]
   *   File value.
   * @returns
   *   New instance.
   */
  constructor(o) {
    let l;
    o ? isUrl(o) ? l = { path: o } : typeof o == "string" || isUint8Array$1(o) ? l = { value: o } : l = o : l = {}, this.cwd = proc.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored;
    let u = -1;
    for (; ++u < order.length; ) {
      const m = order[u];
      m in l && l[m] !== void 0 && l[m] !== null && (this[m] = m === "history" ? [...l[m]] : l[m]);
    }
    let c;
    for (c in l)
      order.includes(c) || (this[c] = l[c]);
  }
  /**
   * Get the basename (including extname) (example: `'index.min.js'`).
   *
   * @returns {string | undefined}
   *   Basename.
   */
  get basename() {
    return typeof this.path == "string" ? path$1.basename(this.path) : void 0;
  }
  /**
   * Set basename (including extname) (`'index.min.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} basename
   *   Basename.
   * @returns {undefined}
   *   Nothing.
   */
  set basename(o) {
    assertNonEmpty(o, "basename"), assertPart(o, "basename"), this.path = path$1.join(this.dirname || "", o);
  }
  /**
   * Get the parent path (example: `'~'`).
   *
   * @returns {string | undefined}
   *   Dirname.
   */
  get dirname() {
    return typeof this.path == "string" ? path$1.dirname(this.path) : void 0;
  }
  /**
   * Set the parent path (example: `'~'`).
   *
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} dirname
   *   Dirname.
   * @returns {undefined}
   *   Nothing.
   */
  set dirname(o) {
    assertPath(this.basename, "dirname"), this.path = path$1.join(o || "", this.basename);
  }
  /**
   * Get the extname (including dot) (example: `'.js'`).
   *
   * @returns {string | undefined}
   *   Extname.
   */
  get extname() {
    return typeof this.path == "string" ? path$1.extname(this.path) : void 0;
  }
  /**
   * Set the extname (including dot) (example: `'.js'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be set if there’s no `path` yet.
   *
   * @param {string | undefined} extname
   *   Extname.
   * @returns {undefined}
   *   Nothing.
   */
  set extname(o) {
    if (assertPart(o, "extname"), assertPath(this.dirname, "extname"), o) {
      if (o.codePointAt(0) !== 46)
        throw new Error("`extname` must start with `.`");
      if (o.includes(".", 1))
        throw new Error("`extname` cannot contain multiple dots");
    }
    this.path = path$1.join(this.dirname, this.stem + (o || ""));
  }
  /**
   * Get the full path (example: `'~/index.min.js'`).
   *
   * @returns {string}
   *   Path.
   */
  get path() {
    return this.history[this.history.length - 1];
  }
  /**
   * Set the full path (example: `'~/index.min.js'`).
   *
   * Cannot be nullified.
   * You can set a file URL (a `URL` object with a `file:` protocol) which will
   * be turned into a path with `url.fileURLToPath`.
   *
   * @param {URL | string} path
   *   Path.
   * @returns {undefined}
   *   Nothing.
   */
  set path(o) {
    isUrl(o) && (o = urlToPath(o)), assertNonEmpty(o, "path"), this.path !== o && this.history.push(o);
  }
  /**
   * Get the stem (basename w/o extname) (example: `'index.min'`).
   *
   * @returns {string | undefined}
   *   Stem.
   */
  get stem() {
    return typeof this.path == "string" ? path$1.basename(this.path, this.extname) : void 0;
  }
  /**
   * Set the stem (basename w/o extname) (example: `'index.min'`).
   *
   * Cannot contain path separators (`'/'` on unix, macOS, and browsers, `'\'`
   * on windows).
   * Cannot be nullified (use `file.path = file.dirname` instead).
   *
   * @param {string} stem
   *   Stem.
   * @returns {undefined}
   *   Nothing.
   */
  set stem(o) {
    assertNonEmpty(o, "stem"), assertPart(o, "stem"), this.path = path$1.join(this.dirname || "", o + (this.extname || ""));
  }
  // Normal prototypal methods.
  /**
   * Create a fatal message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `true` (error; file not usable)
   * and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {never}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {never}
   *   Never.
   * @throws {VFileMessage}
   *   Message.
   */
  fail(o, l, u) {
    const c = this.message(o, l, u);
    throw c.fatal = !0, c;
  }
  /**
   * Create an info message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `undefined` (info; change
   * likely not needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  info(o, l, u) {
    const c = this.message(o, l, u);
    return c.fatal = void 0, c;
  }
  /**
   * Create a message for `reason` associated with the file.
   *
   * The `fatal` field of the message is set to `false` (warning; change may be
   * needed) and the `file` field is set to the current file path.
   * The message is added to the `messages` field on `file`.
   *
   * > 🪦 **Note**: also has obsolete signatures.
   *
   * @overload
   * @param {string} reason
   * @param {MessageOptions | null | undefined} [options]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {string} reason
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Node | NodeLike | null | undefined} parent
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {Point | Position | null | undefined} place
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @overload
   * @param {Error | VFileMessage} cause
   * @param {string | null | undefined} [origin]
   * @returns {VFileMessage}
   *
   * @param {Error | VFileMessage | string} causeOrReason
   *   Reason for message, should use markdown.
   * @param {Node | NodeLike | MessageOptions | Point | Position | string | null | undefined} [optionsOrParentOrPlace]
   *   Configuration (optional).
   * @param {string | null | undefined} [origin]
   *   Place in code where the message originates (example:
   *   `'my-package:my-rule'` or `'my-rule'`).
   * @returns {VFileMessage}
   *   Message.
   */
  message(o, l, u) {
    const c = new VFileMessage(
      // @ts-expect-error: the overloads are fine.
      o,
      l,
      u
    );
    return this.path && (c.name = this.path + ":" + c.name, c.file = this.path), c.fatal = !1, this.messages.push(c), c;
  }
  /**
   * Serialize the file.
   *
   * > **Note**: which encodings are supported depends on the engine.
   * > For info on Node.js, see:
   * > <https://nodejs.org/api/util.html#whatwg-supported-encodings>.
   *
   * @param {string | null | undefined} [encoding='utf8']
   *   Character encoding to understand `value` as when it’s a `Uint8Array`
   *   (default: `'utf-8'`).
   * @returns {string}
   *   Serialized file.
   */
  toString(o) {
    return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(o || void 0).decode(this.value);
  }
}
function assertPart(s, o) {
  if (s && s.includes(path$1.sep))
    throw new Error(
      "`" + o + "` cannot be a path: did not expect `" + path$1.sep + "`"
    );
}
function assertNonEmpty(s, o) {
  if (!s)
    throw new Error("`" + o + "` cannot be empty");
}
function assertPath(s, o) {
  if (!s)
    throw new Error("Setting `" + o + "` requires `path` to be set too");
}
function isUint8Array$1(s) {
  return !!(s && typeof s == "object" && "byteLength" in s && "byteOffset" in s);
}
const markdownExtension = [
  "md",
  "markdown",
  "mdown",
  "mkdn",
  "mkd",
  "mdwn",
  "mkdown",
  "ron"
], md = markdownExtension.map(function(s) {
  return "." + s;
});
function resolveFileAndOptions(s, o) {
  const l = looksLikeAVFile$1(s) ? s : new VFile(s), { format: u, ...c } = o || {};
  return {
    file: l,
    options: {
      format: u === "md" || u === "mdx" ? u : l.extname && (c.mdExtensions || md).includes(l.extname) ? "md" : "mdx",
      ...c
    }
  };
}
function looksLikeAVFile$1(s) {
  return !!(s && typeof s == "object" && "message" in s && "messages" in s);
}
function ok$1() {
}
function mdxExpressionFromMarkdown() {
  return {
    enter: {
      mdxFlowExpression: enterMdxFlowExpression,
      mdxTextExpression: enterMdxTextExpression
    },
    exit: {
      mdxFlowExpression: exitMdxExpression,
      mdxFlowExpressionChunk: exitMdxExpressionData,
      mdxTextExpression: exitMdxExpression,
      mdxTextExpressionChunk: exitMdxExpressionData
    }
  };
}
function mdxExpressionToMarkdown() {
  return {
    handlers: {
      mdxFlowExpression: handleMdxExpression,
      mdxTextExpression: handleMdxExpression
    },
    unsafe: [
      { character: "{", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "{" }
    ]
  };
}
function enterMdxFlowExpression(s) {
  this.enter({ type: "mdxFlowExpression", value: "" }, s), this.buffer();
}
function enterMdxTextExpression(s) {
  this.enter({ type: "mdxTextExpression", value: "" }, s), this.buffer();
}
function exitMdxExpression(s) {
  const o = this.resume(), l = s.estree, u = this.stack[this.stack.length - 1];
  u.type === "mdxFlowExpression" || u.type, this.exit(s), u.value = o, l && (u.data = { estree: l });
}
function exitMdxExpressionData(s) {
  this.config.enter.data.call(this, s), this.config.exit.data.call(this, s);
}
function handleMdxExpression(s) {
  return "{" + (s.value || "") + "}";
}
function ccount(s, o) {
  const l = String(s);
  if (typeof o != "string")
    throw new TypeError("Expected character");
  let u = 0, c = l.indexOf(o);
  for (; c !== -1; )
    u++, c = l.indexOf(o, c + o.length);
  return u;
}
const characterEntitiesLegacy = [
  "AElig",
  "AMP",
  "Aacute",
  "Acirc",
  "Agrave",
  "Aring",
  "Atilde",
  "Auml",
  "COPY",
  "Ccedil",
  "ETH",
  "Eacute",
  "Ecirc",
  "Egrave",
  "Euml",
  "GT",
  "Iacute",
  "Icirc",
  "Igrave",
  "Iuml",
  "LT",
  "Ntilde",
  "Oacute",
  "Ocirc",
  "Ograve",
  "Oslash",
  "Otilde",
  "Ouml",
  "QUOT",
  "REG",
  "THORN",
  "Uacute",
  "Ucirc",
  "Ugrave",
  "Uuml",
  "Yacute",
  "aacute",
  "acirc",
  "acute",
  "aelig",
  "agrave",
  "amp",
  "aring",
  "atilde",
  "auml",
  "brvbar",
  "ccedil",
  "cedil",
  "cent",
  "copy",
  "curren",
  "deg",
  "divide",
  "eacute",
  "ecirc",
  "egrave",
  "eth",
  "euml",
  "frac12",
  "frac14",
  "frac34",
  "gt",
  "iacute",
  "icirc",
  "iexcl",
  "igrave",
  "iquest",
  "iuml",
  "laquo",
  "lt",
  "macr",
  "micro",
  "middot",
  "nbsp",
  "not",
  "ntilde",
  "oacute",
  "ocirc",
  "ograve",
  "ordf",
  "ordm",
  "oslash",
  "otilde",
  "ouml",
  "para",
  "plusmn",
  "pound",
  "quot",
  "raquo",
  "reg",
  "sect",
  "shy",
  "sup1",
  "sup2",
  "sup3",
  "szlig",
  "thorn",
  "times",
  "uacute",
  "ucirc",
  "ugrave",
  "uml",
  "uuml",
  "yacute",
  "yen",
  "yuml"
], characterReferenceInvalid = {
  0: "�",
  128: "€",
  130: "‚",
  131: "ƒ",
  132: "„",
  133: "…",
  134: "†",
  135: "‡",
  136: "ˆ",
  137: "‰",
  138: "Š",
  139: "‹",
  140: "Œ",
  142: "Ž",
  145: "‘",
  146: "’",
  147: "“",
  148: "”",
  149: "•",
  150: "–",
  151: "—",
  152: "˜",
  153: "™",
  154: "š",
  155: "›",
  156: "œ",
  158: "ž",
  159: "Ÿ"
};
function isDecimal(s) {
  const o = typeof s == "string" ? s.charCodeAt(0) : s;
  return o >= 48 && o <= 57;
}
function isHexadecimal(s) {
  const o = typeof s == "string" ? s.charCodeAt(0) : s;
  return o >= 97 && o <= 102 || o >= 65 && o <= 70 || o >= 48 && o <= 57;
}
function isAlphabetical(s) {
  const o = typeof s == "string" ? s.charCodeAt(0) : s;
  return o >= 97 && o <= 122 || o >= 65 && o <= 90;
}
function isAlphanumerical(s) {
  return isAlphabetical(s) || isDecimal(s);
}
const element$1 = document.createElement("i");
function decodeNamedCharacterReference(s) {
  const o = "&" + s + ";";
  element$1.innerHTML = o;
  const l = element$1.textContent;
  return l.charCodeAt(l.length - 1) === 59 && s !== "semi" || l === o ? !1 : l;
}
const fromCharCode = String.fromCharCode, messages = [
  "",
  /* 1: Non terminated (named) */
  "Named character references must be terminated by a semicolon",
  /* 2: Non terminated (numeric) */
  "Numeric character references must be terminated by a semicolon",
  /* 3: Empty (named) */
  "Named character references cannot be empty",
  /* 4: Empty (numeric) */
  "Numeric character references cannot be empty",
  /* 5: Unknown (named) */
  "Named character references must be known",
  /* 6: Disallowed (numeric) */
  "Numeric character references cannot be disallowed",
  /* 7: Prohibited (numeric) */
  "Numeric character references cannot be outside the permissible Unicode range"
];
function parseEntities(s, o = {}) {
  const l = typeof o.additional == "string" ? o.additional.charCodeAt(0) : o.additional, u = [];
  let c = 0, m = -1, g = "", v, b;
  o.position && ("start" in o.position || "indent" in o.position ? (b = o.position.indent, v = o.position.start) : v = o.position);
  let S = (v ? v.line : 0) || 1, E = (v ? v.column : 0) || 1, P = N(), T;
  for (c--; ++c <= s.length; )
    if (T === 10 && (E = (b ? b[m] : 0) || 1), T = s.charCodeAt(c), T === 38) {
      const Q = s.charCodeAt(c + 1);
      if (Q === 9 || Q === 10 || Q === 12 || Q === 32 || Q === 38 || Q === 60 || Number.isNaN(Q) || l && Q === l) {
        g += fromCharCode(T), E++;
        continue;
      }
      const W = c + 1;
      let ue = W, te = W, K;
      if (Q === 35) {
        te = ++ue;
        const tn = s.charCodeAt(te);
        tn === 88 || tn === 120 ? (K = "hexadecimal", te = ++ue) : K = "decimal";
      } else
        K = "named";
      let ve = "", ee = "", Re = "";
      const wt = K === "named" ? isAlphanumerical : K === "decimal" ? isDecimal : isHexadecimal;
      for (te--; ++te <= s.length; ) {
        const tn = s.charCodeAt(te);
        if (!wt(tn))
          break;
        Re += fromCharCode(tn), K === "named" && characterEntitiesLegacy.includes(Re) && (ve = Re, ee = decodeNamedCharacterReference(Re));
      }
      let yt = s.charCodeAt(te) === 59;
      if (yt) {
        te++;
        const tn = K === "named" ? decodeNamedCharacterReference(Re) : !1;
        tn && (ve = Re, ee = tn);
      }
      let xt = 1 + te - W, Kt = "";
      if (!(!yt && o.nonTerminated === !1)) if (!Re)
        K !== "named" && O(4, xt);
      else if (K === "named") {
        if (yt && !ee)
          O(5, 1);
        else if (ve !== Re && (te = ue + ve.length, xt = 1 + te - ue, yt = !1), !yt) {
          const tn = ve ? 1 : 3;
          if (o.attribute) {
            const ln = s.charCodeAt(te);
            ln === 61 ? (O(tn, xt), ee = "") : isAlphanumerical(ln) ? ee = "" : O(tn, xt);
          } else
            O(tn, xt);
        }
        Kt = ee;
      } else {
        yt || O(2, xt);
        let tn = Number.parseInt(
          Re,
          K === "hexadecimal" ? 16 : 10
        );
        if (prohibited(tn))
          O(7, xt), Kt = fromCharCode(
            65533
            /* `�` */
          );
        else if (tn in characterReferenceInvalid)
          O(6, xt), Kt = characterReferenceInvalid[tn];
        else {
          let ln = "";
          disallowed(tn) && O(6, xt), tn > 65535 && (tn -= 65536, ln += fromCharCode(tn >>> 10 | 55296), tn = 56320 | tn & 1023), Kt = ln + fromCharCode(tn);
        }
      }
      if (Kt) {
        z(), P = N(), c = te - 1, E += te - W + 1, u.push(Kt);
        const tn = N();
        tn.offset++, o.reference && o.reference.call(
          o.referenceContext,
          Kt,
          { start: P, end: tn },
          s.slice(W - 1, te)
        ), P = tn;
      } else
        Re = s.slice(W - 1, te), g += Re, E += Re.length, c = te - 1;
    } else
      T === 10 && (S++, m++, E = 0), Number.isNaN(T) ? z() : (g += fromCharCode(T), E++);
  return u.join("");
  function N() {
    return {
      line: S,
      column: E,
      offset: c + ((v ? v.offset : 0) || 0)
    };
  }
  function O(Q, W) {
    let ue;
    o.warning && (ue = N(), ue.column += W, ue.offset += W, o.warning.call(
      o.warningContext,
      messages[Q],
      ue,
      Q
    ));
  }
  function z() {
    g && (u.push(g), o.text && o.text.call(o.textContext, g, {
      start: P,
      end: N()
    }), g = "");
  }
}
function prohibited(s) {
  return s >= 55296 && s <= 57343 || s > 1114111;
}
function disallowed(s) {
  return s >= 1 && s <= 8 || s === 11 || s >= 13 && s <= 31 || s >= 127 && s <= 159 || s >= 64976 && s <= 65007 || (s & 65535) === 65535 || (s & 65535) === 65534;
}
const defaultSubsetRegex = /["&'<>`]/g, surrogatePairsRegex = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, controlCharactersRegex = (
  // eslint-disable-next-line no-control-regex, unicorn/no-hex-escape
  /[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g
), regexEscapeRegex = /[|\\{}()[\]^$+*?.]/g, subsetToRegexCache = /* @__PURE__ */ new WeakMap();
function core(s, o) {
  if (s = s.replace(
    o.subset ? charactersToExpressionCached(o.subset) : defaultSubsetRegex,
    u
  ), o.subset || o.escapeOnly)
    return s;
  return s.replace(surrogatePairsRegex, l).replace(controlCharactersRegex, u);
  function l(c, m, g) {
    return o.format(
      (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536,
      g.charCodeAt(m + 2),
      o
    );
  }
  function u(c, m, g) {
    return o.format(
      c.charCodeAt(0),
      g.charCodeAt(m + 1),
      o
    );
  }
}
function charactersToExpressionCached(s) {
  let o = subsetToRegexCache.get(s);
  return o || (o = charactersToExpression(s), subsetToRegexCache.set(s, o)), o;
}
function charactersToExpression(s) {
  const o = [];
  let l = -1;
  for (; ++l < s.length; )
    o.push(s[l].replace(regexEscapeRegex, "\\$&"));
  return new RegExp("(?:" + o.join("|") + ")", "g");
}
function formatBasic(s) {
  return "&#x" + s.toString(16).toUpperCase() + ";";
}
function stringifyEntitiesLight(s, o) {
  return core(s, Object.assign({ format: formatBasic }, o));
}
const indent$1 = "  ";
function mdxJsxFromMarkdown() {
  return {
    canContainEols: ["mdxJsxTextElement"],
    enter: {
      mdxJsxFlowTag: u,
      mdxJsxFlowTagClosingMarker: c,
      mdxJsxFlowTagAttribute: P,
      mdxJsxFlowTagExpressionAttribute: T,
      mdxJsxFlowTagAttributeValueLiteral: s,
      mdxJsxFlowTagAttributeValueExpression: s,
      mdxJsxFlowTagSelfClosingMarker: g,
      mdxJsxTextTag: u,
      mdxJsxTextTagClosingMarker: c,
      mdxJsxTextTagAttribute: P,
      mdxJsxTextTagExpressionAttribute: T,
      mdxJsxTextTagAttributeValueLiteral: s,
      mdxJsxTextTagAttributeValueExpression: s,
      mdxJsxTextTagSelfClosingMarker: g
    },
    exit: {
      mdxJsxFlowTagClosingMarker: v,
      mdxJsxFlowTagNamePrimary: b,
      mdxJsxFlowTagNameMember: S,
      mdxJsxFlowTagNameLocal: E,
      mdxJsxFlowTagExpressionAttribute: N,
      mdxJsxFlowTagExpressionAttributeValue: l,
      mdxJsxFlowTagAttributeNamePrimary: O,
      mdxJsxFlowTagAttributeNameLocal: z,
      mdxJsxFlowTagAttributeValueLiteral: Q,
      mdxJsxFlowTagAttributeValueLiteralValue: l,
      mdxJsxFlowTagAttributeValueExpression: W,
      mdxJsxFlowTagAttributeValueExpressionValue: l,
      mdxJsxFlowTagSelfClosingMarker: ue,
      mdxJsxFlowTag: te,
      mdxJsxTextTagClosingMarker: v,
      mdxJsxTextTagNamePrimary: b,
      mdxJsxTextTagNameMember: S,
      mdxJsxTextTagNameLocal: E,
      mdxJsxTextTagExpressionAttribute: N,
      mdxJsxTextTagExpressionAttributeValue: l,
      mdxJsxTextTagAttributeNamePrimary: O,
      mdxJsxTextTagAttributeNameLocal: z,
      mdxJsxTextTagAttributeValueLiteral: Q,
      mdxJsxTextTagAttributeValueLiteralValue: l,
      mdxJsxTextTagAttributeValueExpression: W,
      mdxJsxTextTagAttributeValueExpressionValue: l,
      mdxJsxTextTagSelfClosingMarker: ue,
      mdxJsxTextTag: te
    }
  };
  function s() {
    this.buffer();
  }
  function o(Re) {
    return { line: Re.line, column: Re.column, offset: Re.offset };
  }
  function l(Re) {
    this.config.enter.data.call(this, Re), this.config.exit.data.call(this, Re);
  }
  function u(Re) {
    const wt = {
      name: void 0,
      attributes: [],
      close: !1,
      selfClosing: !1,
      start: Re.start,
      end: Re.end
    };
    this.data.mdxJsxTagStack || (this.data.mdxJsxTagStack = []), this.data.mdxJsxTag = wt, this.buffer();
  }
  function c(Re) {
    if (this.data.mdxJsxTagStack.length === 0)
      throw new VFileMessage(
        "Unexpected closing slash `/` in tag, expected an open tag first",
        { start: Re.start, end: Re.end },
        "mdast-util-mdx-jsx:unexpected-closing-slash"
      );
  }
  function m(Re) {
    if (this.data.mdxJsxTag.close)
      throw new VFileMessage(
        "Unexpected attribute in closing tag, expected the end of the tag",
        { start: Re.start, end: Re.end },
        "mdast-util-mdx-jsx:unexpected-attribute"
      );
  }
  function g(Re) {
    if (this.data.mdxJsxTag.close)
      throw new VFileMessage(
        "Unexpected self-closing slash `/` in closing tag, expected the end of the tag",
        { start: Re.start, end: Re.end },
        "mdast-util-mdx-jsx:unexpected-self-closing-slash"
      );
  }
  function v() {
    const Re = this.data.mdxJsxTag;
    Re.close = !0;
  }
  function b(Re) {
    const wt = this.data.mdxJsxTag;
    wt.name = this.sliceSerialize(Re);
  }
  function S(Re) {
    const wt = this.data.mdxJsxTag;
    wt.name += "." + this.sliceSerialize(Re);
  }
  function E(Re) {
    const wt = this.data.mdxJsxTag;
    wt.name += ":" + this.sliceSerialize(Re);
  }
  function P(Re) {
    const wt = this.data.mdxJsxTag;
    m.call(this, Re), wt.attributes.push({
      type: "mdxJsxAttribute",
      name: "",
      value: null,
      position: {
        start: o(Re.start),
        // @ts-expect-error: `end` will be patched later.
        end: void 0
      }
    });
  }
  function T(Re) {
    const wt = this.data.mdxJsxTag;
    m.call(this, Re), wt.attributes.push({ type: "mdxJsxExpressionAttribute", value: "" }), this.buffer();
  }
  function N(Re) {
    const wt = this.data.mdxJsxTag, yt = wt.attributes[wt.attributes.length - 1];
    yt.type;
    const xt = Re.estree;
    yt.value = this.resume(), xt && (yt.data = { estree: xt });
  }
  function O(Re) {
    const wt = this.data.mdxJsxTag, yt = wt.attributes[wt.attributes.length - 1];
    yt.type, yt.name = this.sliceSerialize(Re), yt.position, yt.position.end = o(Re.end);
  }
  function z(Re) {
    const wt = this.data.mdxJsxTag, yt = wt.attributes[wt.attributes.length - 1];
    yt.type, yt.name += ":" + this.sliceSerialize(Re), yt.position, yt.position.end = o(Re.end);
  }
  function Q(Re) {
    const wt = this.data.mdxJsxTag, yt = wt.attributes[wt.attributes.length - 1];
    yt.value = parseEntities(this.resume(), { nonTerminated: !1 }), yt.position, yt.position.end = o(Re.end);
  }
  function W(Re) {
    const wt = this.data.mdxJsxTag, yt = wt.attributes[wt.attributes.length - 1];
    yt.type;
    const xt = { type: "mdxJsxAttributeValueExpression", value: this.resume() }, Kt = Re.estree;
    Kt && (xt.data = { estree: Kt }), yt.value = xt, yt.position, yt.position.end = o(Re.end);
  }
  function ue() {
    const Re = this.data.mdxJsxTag;
    Re.selfClosing = !0;
  }
  function te(Re) {
    const wt = this.data.mdxJsxTag, yt = this.data.mdxJsxTagStack, xt = yt[yt.length - 1];
    if (wt.close && xt.name !== wt.name)
      throw new VFileMessage(
        "Unexpected closing tag `" + ee(wt) + "`, expected corresponding closing tag for `" + ee(xt) + "` (" + stringifyPosition(xt) + ")",
        { start: Re.start, end: Re.end },
        "mdast-util-mdx-jsx:end-tag-mismatch"
      );
    this.resume(), wt.close ? yt.pop() : this.enter(
      {
        type: Re.type === "mdxJsxTextTag" ? "mdxJsxTextElement" : "mdxJsxFlowElement",
        name: wt.name || null,
        attributes: wt.attributes,
        children: []
      },
      Re,
      K
    ), wt.selfClosing || wt.close ? this.exit(Re, ve) : yt.push(wt);
  }
  function K(Re, wt) {
    const yt = this.data.mdxJsxTagStack, xt = yt[yt.length - 1], Kt = Re ? " before the end of `" + Re.type + "`" : "", tn = Re ? { start: Re.start, end: Re.end } : void 0;
    throw new VFileMessage(
      "Expected a closing tag for `" + ee(xt) + "` (" + stringifyPosition({ start: wt.start, end: wt.end }) + ")" + Kt,
      tn,
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function ve(Re, wt) {
    const yt = this.data.mdxJsxTag;
    throw new VFileMessage(
      "Expected the closing tag `" + ee(yt) + "` either after the end of `" + wt.type + "` (" + stringifyPosition(wt.end) + ") or another opening tag after the start of `" + wt.type + "` (" + stringifyPosition(wt.start) + ")",
      { start: Re.start, end: Re.end },
      "mdast-util-mdx-jsx:end-tag-mismatch"
    );
  }
  function ee(Re) {
    return "<" + (Re.close ? "/" : "") + (Re.name || "") + ">";
  }
}
function mdxJsxToMarkdown(s) {
  const o = s || {}, l = o.quote || '"', u = o.quoteSmart || !1, c = o.tightSelfClosing || !1, m = o.printWidth || Number.POSITIVE_INFINITY, g = l === '"' ? "'" : '"';
  if (l !== '"' && l !== "'")
    throw new Error(
      "Cannot serialize attribute values with `" + l + "` for `options.quote`, expected `\"`, or `'`"
    );
  return v.peek = peekElement, {
    handlers: {
      mdxJsxFlowElement: v,
      mdxJsxTextElement: v
    },
    unsafe: [
      { character: "<", inConstruct: ["phrasing"] },
      { atBreak: !0, character: "<" }
    ],
    // Always generate fenced code (never indented code).
    fences: !0,
    // Always generate links with resources (never autolinks).
    resourceLink: !0
  };
  function v(b, S, E, P) {
    const T = b.type === "mdxJsxFlowElement", N = b.name ? !b.children || b.children.length === 0 : !1, O = inferDepth(E), z = createIndent(O), Q = E.createTracker(P), W = E.createTracker(P), ue = [], te = (T ? z : "") + "<" + (b.name || ""), K = E.enter(b.type);
    if (Q.move(te), W.move(te), b.attributes && b.attributes.length > 0) {
      if (!b.name)
        throw new Error("Cannot serialize fragment w/ attributes");
      let yt = -1;
      for (; ++yt < b.attributes.length; ) {
        const xt = b.attributes[yt];
        let Kt;
        if (xt.type === "mdxJsxExpressionAttribute")
          Kt = "{" + (xt.value || "") + "}";
        else {
          if (!xt.name)
            throw new Error("Cannot serialize attribute w/o name");
          const tn = xt.value, ln = xt.name;
          let rn = "";
          if (tn != null) if (typeof tn == "object")
            rn = "{" + (tn.value || "") + "}";
          else {
            const an = u && ccount(tn, l) > ccount(tn, g) ? g : l;
            rn = an + stringifyEntitiesLight(tn, { subset: [an] }) + an;
          }
          Kt = ln + (rn ? "=" : "") + rn;
        }
        ue.push(Kt);
      }
    }
    let ve = !1;
    const ee = ue.join(" ");
    // Block:
    T && // Including a line ending (expressions).
    (/\r?\n|\r/.test(ee) || // Current position (including `<tag`).
    Q.current().now.column + // -1 because columns, +1 for ` ` before attributes.
    // Attributes joined by spaces.
    ee.length + // ` />`.
    (N ? c ? 2 : 3 : 1) > m) && (ve = !0);
    let Re = Q, wt = te;
    if (ve) {
      Re = W;
      let yt = -1;
      for (; ++yt < ue.length; )
        ue[yt] = z + indent$1 + ue[yt];
      wt += Re.move(
        `
` + ue.join(`
`) + `
` + z
      );
    } else ee && (wt += Re.move(" " + ee));
    return N && (wt += Re.move(
      (c || ve ? "" : " ") + "/"
    )), wt += Re.move(">"), b.children && b.children.length > 0 && (b.type === "mdxJsxTextElement" ? wt += Re.move(
      // @ts-expect-error: `containerPhrasing` is typed correctly, but TS
      // generates *hardcoded* types, which means that our dynamically added
      // directives are not present.
      // At some point, TS should fix that, and `from-markdown` should be fine.
      E.containerPhrasing(b, {
        ...Re.current(),
        before: ">",
        after: "<"
      })
    ) : (Re.shift(2), wt += Re.move(`
`), wt += Re.move(containerFlow(b, E, Re.current())), wt += Re.move(`
`))), N || (wt += Re.move(
      (T ? z : "") + "</" + (b.name || "") + ">"
    )), K(), wt;
  }
}
function containerFlow(s, o, l) {
  const u = o.indexStack, c = s.children, m = o.createTracker(l), g = createIndent(inferDepth(o)), v = [];
  let b = -1;
  for (u.push(-1); ++b < c.length; ) {
    const S = c[b];
    u[u.length - 1] = b;
    const E = { before: `
`, after: `
`, ...m.current() }, P = o.handle(S, s, o, E), T = S.type === "mdxJsxFlowElement" ? P : o.indentLines(P, function(N, O, z) {
      return (z ? "" : g) + N;
    });
    v.push(m.move(T)), S.type !== "list" && (o.bulletLastUsed = void 0), b < c.length - 1 && v.push(m.move(`

`));
  }
  return u.pop(), v.join("");
}
function inferDepth(s) {
  let o = 0, l = s.stack.length;
  for (; --l > -1; ) {
    const u = s.stack[l];
    if (u === "blockquote" || u === "listItem") break;
    u === "mdxJsxFlowElement" && o++;
  }
  return o;
}
function createIndent(s) {
  return indent$1.repeat(s);
}
function peekElement() {
  return "<";
}
function mdxjsEsmFromMarkdown() {
  return {
    enter: { mdxjsEsm: enterMdxjsEsm },
    exit: { mdxjsEsm: exitMdxjsEsm, mdxjsEsmData: exitMdxjsEsmData }
  };
}
function mdxjsEsmToMarkdown() {
  return { handlers: { mdxjsEsm: handleMdxjsEsm } };
}
function enterMdxjsEsm(s) {
  this.enter({ type: "mdxjsEsm", value: "" }, s), this.buffer();
}
function exitMdxjsEsm(s) {
  const o = this.resume(), l = this.stack[this.stack.length - 1];
  l.type, this.exit(s);
  const u = s.estree;
  l.value = o, u && (l.data = { estree: u });
}
function exitMdxjsEsmData(s) {
  this.config.enter.data.call(this, s), this.config.exit.data.call(this, s);
}
function handleMdxjsEsm(s) {
  return s.value || "";
}
function mdxFromMarkdown() {
  return [
    mdxExpressionFromMarkdown(),
    mdxJsxFromMarkdown(),
    mdxjsEsmFromMarkdown()
  ];
}
function mdxToMarkdown(s) {
  return {
    extensions: [
      mdxExpressionToMarkdown(),
      mdxJsxToMarkdown(s),
      mdxjsEsmToMarkdown()
    ]
  };
}
var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], nonASCIIidentifierChars = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", nonASCIIidentifierStartChars = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", reservedWords = {
  3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
  5: "class enum extends super const export import",
  6: "enum",
  strict: "implements interface let package private protected public static yield",
  strictBind: "eval arguments"
}, ecma5AndLessKeywords = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", keywords$1 = {
  5: ecma5AndLessKeywords,
  "5module": ecma5AndLessKeywords + " export import",
  6: ecma5AndLessKeywords + " const class extends export import super"
}, keywordRelationalOperator = /^in(stanceof)?$/, nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]"), nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
function isInAstralSet(s, o) {
  for (var l = 65536, u = 0; u < o.length; u += 2) {
    if (l += o[u], l > s)
      return !1;
    if (l += o[u + 1], l >= s)
      return !0;
  }
  return !1;
}
function isIdentifierStart(s, o) {
  return s < 65 ? s === 36 : s < 91 ? !0 : s < 97 ? s === 95 : s < 123 ? !0 : s <= 65535 ? s >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(s)) : o === !1 ? !1 : isInAstralSet(s, astralIdentifierStartCodes);
}
function isIdentifierChar(s, o) {
  return s < 48 ? s === 36 : s < 58 ? !0 : s < 65 ? !1 : s < 91 ? !0 : s < 97 ? s === 95 : s < 123 ? !0 : s <= 65535 ? s >= 170 && nonASCIIidentifier.test(String.fromCharCode(s)) : o === !1 ? !1 : isInAstralSet(s, astralIdentifierStartCodes) || isInAstralSet(s, astralIdentifierCodes);
}
var TokenType = function s(o, l) {
  l === void 0 && (l = {}), this.label = o, this.keyword = l.keyword, this.beforeExpr = !!l.beforeExpr, this.startsExpr = !!l.startsExpr, this.isLoop = !!l.isLoop, this.isAssign = !!l.isAssign, this.prefix = !!l.prefix, this.postfix = !!l.postfix, this.binop = l.binop || null, this.updateContext = null;
};
function binop(s, o) {
  return new TokenType(s, { beforeExpr: !0, binop: o });
}
var beforeExpr = { beforeExpr: !0 }, startsExpr = { startsExpr: !0 }, keywords = {};
function kw(s, o) {
  return o === void 0 && (o = {}), o.keyword = s, keywords[s] = new TokenType(s, o);
}
var types$1 = {
  num: new TokenType("num", startsExpr),
  regexp: new TokenType("regexp", startsExpr),
  string: new TokenType("string", startsExpr),
  name: new TokenType("name", startsExpr),
  privateId: new TokenType("privateId", startsExpr),
  eof: new TokenType("eof"),
  // Punctuation token types.
  bracketL: new TokenType("[", { beforeExpr: !0, startsExpr: !0 }),
  bracketR: new TokenType("]"),
  braceL: new TokenType("{", { beforeExpr: !0, startsExpr: !0 }),
  braceR: new TokenType("}"),
  parenL: new TokenType("(", { beforeExpr: !0, startsExpr: !0 }),
  parenR: new TokenType(")"),
  comma: new TokenType(",", beforeExpr),
  semi: new TokenType(";", beforeExpr),
  colon: new TokenType(":", beforeExpr),
  dot: new TokenType("."),
  question: new TokenType("?", beforeExpr),
  questionDot: new TokenType("?."),
  arrow: new TokenType("=>", beforeExpr),
  template: new TokenType("template"),
  invalidTemplate: new TokenType("invalidTemplate"),
  ellipsis: new TokenType("...", beforeExpr),
  backQuote: new TokenType("`", startsExpr),
  dollarBraceL: new TokenType("${", { beforeExpr: !0, startsExpr: !0 }),
  // Operators. These carry several kinds of properties to help the
  // parser use them properly (the presence of these properties is
  // what categorizes them as operators).
  //
  // `binop`, when present, specifies that this operator is a binary
  // operator, and will refer to its precedence.
  //
  // `prefix` and `postfix` mark the operator as a prefix or postfix
  // unary operator.
  //
  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
  // binary operators with a very low precedence, that should result
  // in AssignmentExpression nodes.
  eq: new TokenType("=", { beforeExpr: !0, isAssign: !0 }),
  assign: new TokenType("_=", { beforeExpr: !0, isAssign: !0 }),
  incDec: new TokenType("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
  prefix: new TokenType("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  logicalOR: binop("||", 1),
  logicalAND: binop("&&", 2),
  bitwiseOR: binop("|", 3),
  bitwiseXOR: binop("^", 4),
  bitwiseAND: binop("&", 5),
  equality: binop("==/!=/===/!==", 6),
  relational: binop("</>/<=/>=", 7),
  bitShift: binop("<</>>/>>>", 8),
  plusMin: new TokenType("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
  modulo: binop("%", 10),
  star: binop("*", 10),
  slash: binop("/", 10),
  starstar: new TokenType("**", { beforeExpr: !0 }),
  coalesce: binop("??", 1),
  // Keyword token types.
  _break: kw("break"),
  _case: kw("case", beforeExpr),
  _catch: kw("catch"),
  _continue: kw("continue"),
  _debugger: kw("debugger"),
  _default: kw("default", beforeExpr),
  _do: kw("do", { isLoop: !0, beforeExpr: !0 }),
  _else: kw("else", beforeExpr),
  _finally: kw("finally"),
  _for: kw("for", { isLoop: !0 }),
  _function: kw("function", startsExpr),
  _if: kw("if"),
  _return: kw("return", beforeExpr),
  _switch: kw("switch"),
  _throw: kw("throw", beforeExpr),
  _try: kw("try"),
  _var: kw("var"),
  _const: kw("const"),
  _while: kw("while", { isLoop: !0 }),
  _with: kw("with"),
  _new: kw("new", { beforeExpr: !0, startsExpr: !0 }),
  _this: kw("this", startsExpr),
  _super: kw("super", startsExpr),
  _class: kw("class", startsExpr),
  _extends: kw("extends", beforeExpr),
  _export: kw("export"),
  _import: kw("import", startsExpr),
  _null: kw("null", startsExpr),
  _true: kw("true", startsExpr),
  _false: kw("false", startsExpr),
  _in: kw("in", { beforeExpr: !0, binop: 7 }),
  _instanceof: kw("instanceof", { beforeExpr: !0, binop: 7 }),
  _typeof: kw("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _void: kw("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
  _delete: kw("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
}, lineBreak = /\r\n?|\n|\u2028|\u2029/, lineBreakG = new RegExp(lineBreak.source, "g");
function isNewLine(s) {
  return s === 10 || s === 13 || s === 8232 || s === 8233;
}
function nextLineBreak(s, o, l) {
  l === void 0 && (l = s.length);
  for (var u = o; u < l; u++) {
    var c = s.charCodeAt(u);
    if (isNewLine(c))
      return u < l - 1 && c === 13 && s.charCodeAt(u + 1) === 10 ? u + 2 : u + 1;
  }
  return -1;
}
var nonASCIIwhitespace = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ref = Object.prototype, hasOwnProperty$1 = ref.hasOwnProperty, toString$2 = ref.toString, hasOwn$1 = Object.hasOwn || function(s, o) {
  return hasOwnProperty$1.call(s, o);
}, isArray$1 = Array.isArray || function(s) {
  return toString$2.call(s) === "[object Array]";
}, regexpCache = /* @__PURE__ */ Object.create(null);
function wordsRegexp(s) {
  return regexpCache[s] || (regexpCache[s] = new RegExp("^(?:" + s.replace(/ /g, "|") + ")$"));
}
function codePointToString(s) {
  return s <= 65535 ? String.fromCharCode(s) : (s -= 65536, String.fromCharCode((s >> 10) + 55296, (s & 1023) + 56320));
}
var loneSurrogate = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, Position = function s(o, l) {
  this.line = o, this.column = l;
};
Position.prototype.offset = function s(o) {
  return new Position(this.line, this.column + o);
};
var SourceLocation = function s(o, l, u) {
  this.start = l, this.end = u, o.sourceFile !== null && (this.source = o.sourceFile);
};
function getLineInfo(s, o) {
  for (var l = 1, u = 0; ; ) {
    var c = nextLineBreak(s, u, o);
    if (c < 0)
      return new Position(l, o - u);
    ++l, u = c;
  }
}
var defaultOptions = {
  // `ecmaVersion` indicates the ECMAScript version to parse. Must be
  // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
  // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
  // (the latest version the library supports). This influences
  // support for strict mode, the set of reserved words, and support
  // for new syntax features.
  ecmaVersion: null,
  // `sourceType` indicates the mode the code should be parsed in.
  // Can be either `"script"` or `"module"`. This influences global
  // strict mode and parsing of `import` and `export` declarations.
  sourceType: "script",
  // `onInsertedSemicolon` can be a callback that will be called when
  // a semicolon is automatically inserted. It will be passed the
  // position of the inserted semicolon as an offset, and if
  // `locations` is enabled, it is given the location as a `{line,
  // column}` object as second argument.
  onInsertedSemicolon: null,
  // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
  // trailing commas.
  onTrailingComma: null,
  // By default, reserved words are only enforced if ecmaVersion >= 5.
  // Set `allowReserved` to a boolean value to explicitly turn this on
  // an off. When this option has the value "never", reserved words
  // and keywords can also not be used as property names.
  allowReserved: null,
  // When enabled, a return at the top level is not considered an
  // error.
  allowReturnOutsideFunction: !1,
  // When enabled, import/export statements are not constrained to
  // appearing at the top of the program, and an import.meta expression
  // in a script isn't considered an error.
  allowImportExportEverywhere: !1,
  // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
  // When enabled, await identifiers are allowed to appear at the top-level scope,
  // but they are still not allowed in non-async functions.
  allowAwaitOutsideFunction: null,
  // When enabled, super identifiers are not constrained to
  // appearing in methods and do not raise an error when they appear elsewhere.
  allowSuperOutsideMethod: null,
  // When enabled, hashbang directive in the beginning of file is
  // allowed and treated as a line comment. Enabled by default when
  // `ecmaVersion` >= 2023.
  allowHashBang: !1,
  // By default, the parser will verify that private properties are
  // only used in places where they are valid and have been declared.
  // Set this to false to turn such checks off.
  checkPrivateFields: !0,
  // When `locations` is on, `loc` properties holding objects with
  // `start` and `end` properties in `{line, column}` form (with
  // line being 1-based and column 0-based) will be attached to the
  // nodes.
  locations: !1,
  // A function can be passed as `onToken` option, which will
  // cause Acorn to call that function with object in the same
  // format as tokens returned from `tokenizer().getToken()`. Note
  // that you are not allowed to call the parser from the
  // callback—that will corrupt its internal state.
  onToken: null,
  // A function can be passed as `onComment` option, which will
  // cause Acorn to call that function with `(block, text, start,
  // end)` parameters whenever a comment is skipped. `block` is a
  // boolean indicating whether this is a block (`/* */`) comment,
  // `text` is the content of the comment, and `start` and `end` are
  // character offsets that denote the start and end of the comment.
  // When the `locations` option is on, two more parameters are
  // passed, the full `{line, column}` locations of the start and
  // end of the comments. Note that you are not allowed to call the
  // parser from the callback—that will corrupt its internal state.
  // When this option has an array as value, objects representing the
  // comments are pushed to it.
  onComment: null,
  // Nodes have their start and end characters offsets recorded in
  // `start` and `end` properties (directly on the node, rather than
  // the `loc` object, which holds line/column data. To also add a
  // [semi-standardized][range] `range` property holding a `[start,
  // end]` array with the same numbers, set the `ranges` option to
  // `true`.
  //
  // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
  ranges: !1,
  // It is possible to parse multiple files into a single AST by
  // passing the tree produced by parsing the first file as
  // `program` option in subsequent parses. This will add the
  // toplevel forms of the parsed file to the `Program` (top) node
  // of an existing parse tree.
  program: null,
  // When `locations` is on, you can pass this to record the source
  // file in every node's `loc` object.
  sourceFile: null,
  // This value, if given, is stored in every node, whether
  // `locations` is on or off.
  directSourceFile: null,
  // When enabled, parenthesized expressions are represented by
  // (non-standard) ParenthesizedExpression nodes
  preserveParens: !1
}, warnedAboutEcmaVersion = !1;
function getOptions(s) {
  var o = {};
  for (var l in defaultOptions)
    o[l] = s && hasOwn$1(s, l) ? s[l] : defaultOptions[l];
  if (o.ecmaVersion === "latest" ? o.ecmaVersion = 1e8 : o.ecmaVersion == null ? (!warnedAboutEcmaVersion && typeof console == "object" && console.warn && (warnedAboutEcmaVersion = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), o.ecmaVersion = 11) : o.ecmaVersion >= 2015 && (o.ecmaVersion -= 2009), o.allowReserved == null && (o.allowReserved = o.ecmaVersion < 5), (!s || s.allowHashBang == null) && (o.allowHashBang = o.ecmaVersion >= 14), isArray$1(o.onToken)) {
    var u = o.onToken;
    o.onToken = function(c) {
      return u.push(c);
    };
  }
  return isArray$1(o.onComment) && (o.onComment = pushComment(o, o.onComment)), o;
}
function pushComment(s, o) {
  return function(l, u, c, m, g, v) {
    var b = {
      type: l ? "Block" : "Line",
      value: u,
      start: c,
      end: m
    };
    s.locations && (b.loc = new SourceLocation(this, g, v)), s.ranges && (b.range = [c, m]), o.push(b);
  };
}
var SCOPE_TOP = 1, SCOPE_FUNCTION = 2, SCOPE_ASYNC = 4, SCOPE_GENERATOR = 8, SCOPE_ARROW = 16, SCOPE_SIMPLE_CATCH = 32, SCOPE_SUPER = 64, SCOPE_DIRECT_SUPER = 128, SCOPE_CLASS_STATIC_BLOCK = 256, SCOPE_VAR = SCOPE_TOP | SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK;
function functionFlags(s, o) {
  return SCOPE_FUNCTION | (s ? SCOPE_ASYNC : 0) | (o ? SCOPE_GENERATOR : 0);
}
var BIND_NONE = 0, BIND_VAR = 1, BIND_LEXICAL = 2, BIND_FUNCTION = 3, BIND_SIMPLE_CATCH = 4, BIND_OUTSIDE = 5, Parser = function s(o, l, u) {
  this.options = o = getOptions(o), this.sourceFile = o.sourceFile, this.keywords = wordsRegexp(keywords$1[o.ecmaVersion >= 6 ? 6 : o.sourceType === "module" ? "5module" : 5]);
  var c = "";
  o.allowReserved !== !0 && (c = reservedWords[o.ecmaVersion >= 6 ? 6 : o.ecmaVersion === 5 ? 5 : 3], o.sourceType === "module" && (c += " await")), this.reservedWords = wordsRegexp(c);
  var m = (c ? c + " " : "") + reservedWords.strict;
  this.reservedWordsStrict = wordsRegexp(m), this.reservedWordsStrictBind = wordsRegexp(m + " " + reservedWords.strictBind), this.input = String(l), this.containsEsc = !1, u ? (this.pos = u, this.lineStart = this.input.lastIndexOf(`
`, u - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = types$1.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = o.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && o.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(SCOPE_TOP), this.regexpState = null, this.privateNameStack = [];
}, prototypeAccessors = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
Parser.prototype.parse = function s() {
  var o = this.options.program || this.startNode();
  return this.nextToken(), this.parseTopLevel(o);
};
prototypeAccessors.inFunction.get = function() {
  return (this.currentVarScope().flags & SCOPE_FUNCTION) > 0;
};
prototypeAccessors.inGenerator.get = function() {
  return (this.currentVarScope().flags & SCOPE_GENERATOR) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.inAsync.get = function() {
  return (this.currentVarScope().flags & SCOPE_ASYNC) > 0 && !this.currentVarScope().inClassFieldInit;
};
prototypeAccessors.canAwait.get = function() {
  for (var s = this.scopeStack.length - 1; s >= 0; s--) {
    var o = this.scopeStack[s];
    if (o.inClassFieldInit || o.flags & SCOPE_CLASS_STATIC_BLOCK)
      return !1;
    if (o.flags & SCOPE_FUNCTION)
      return (o.flags & SCOPE_ASYNC) > 0;
  }
  return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
};
prototypeAccessors.allowSuper.get = function() {
  var s = this.currentThisScope(), o = s.flags, l = s.inClassFieldInit;
  return (o & SCOPE_SUPER) > 0 || l || this.options.allowSuperOutsideMethod;
};
prototypeAccessors.allowDirectSuper.get = function() {
  return (this.currentThisScope().flags & SCOPE_DIRECT_SUPER) > 0;
};
prototypeAccessors.treatFunctionsAsVar.get = function() {
  return this.treatFunctionsAsVarInScope(this.currentScope());
};
prototypeAccessors.allowNewDotTarget.get = function() {
  var s = this.currentThisScope(), o = s.flags, l = s.inClassFieldInit;
  return (o & (SCOPE_FUNCTION | SCOPE_CLASS_STATIC_BLOCK)) > 0 || l;
};
prototypeAccessors.inClassStaticBlock.get = function() {
  return (this.currentVarScope().flags & SCOPE_CLASS_STATIC_BLOCK) > 0;
};
Parser.extend = function s() {
  for (var o = [], l = arguments.length; l--; ) o[l] = arguments[l];
  for (var u = this, c = 0; c < o.length; c++)
    u = o[c](u);
  return u;
};
Parser.parse = function s(o, l) {
  return new this(l, o).parse();
};
Parser.parseExpressionAt = function s(o, l, u) {
  var c = new this(u, o, l);
  return c.nextToken(), c.parseExpression();
};
Parser.tokenizer = function s(o, l) {
  return new this(l, o);
};
Object.defineProperties(Parser.prototype, prototypeAccessors);
var pp$9 = Parser.prototype, literal = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
pp$9.strictDirective = function(s) {
  if (this.options.ecmaVersion < 5)
    return !1;
  for (; ; ) {
    skipWhiteSpace.lastIndex = s, s += skipWhiteSpace.exec(this.input)[0].length;
    var o = literal.exec(this.input.slice(s));
    if (!o)
      return !1;
    if ((o[1] || o[2]) === "use strict") {
      skipWhiteSpace.lastIndex = s + o[0].length;
      var l = skipWhiteSpace.exec(this.input), u = l.index + l[0].length, c = this.input.charAt(u);
      return c === ";" || c === "}" || lineBreak.test(l[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(c) || c === "!" && this.input.charAt(u + 1) === "=");
    }
    s += o[0].length, skipWhiteSpace.lastIndex = s, s += skipWhiteSpace.exec(this.input)[0].length, this.input[s] === ";" && s++;
  }
};
pp$9.eat = function(s) {
  return this.type === s ? (this.next(), !0) : !1;
};
pp$9.isContextual = function(s) {
  return this.type === types$1.name && this.value === s && !this.containsEsc;
};
pp$9.eatContextual = function(s) {
  return this.isContextual(s) ? (this.next(), !0) : !1;
};
pp$9.expectContextual = function(s) {
  this.eatContextual(s) || this.unexpected();
};
pp$9.canInsertSemicolon = function() {
  return this.type === types$1.eof || this.type === types$1.braceR || lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$9.insertSemicolon = function() {
  if (this.canInsertSemicolon())
    return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
};
pp$9.semicolon = function() {
  !this.eat(types$1.semi) && !this.insertSemicolon() && this.unexpected();
};
pp$9.afterTrailingComma = function(s, o) {
  if (this.type === s)
    return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), o || this.next(), !0;
};
pp$9.expect = function(s) {
  this.eat(s) || this.unexpected();
};
pp$9.unexpected = function(s) {
  this.raise(s ?? this.start, "Unexpected token");
};
var DestructuringErrors = function s() {
  this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
};
pp$9.checkPatternErrors = function(s, o) {
  if (s) {
    s.trailingComma > -1 && this.raiseRecoverable(s.trailingComma, "Comma is not permitted after the rest element");
    var l = o ? s.parenthesizedAssign : s.parenthesizedBind;
    l > -1 && this.raiseRecoverable(l, o ? "Assigning to rvalue" : "Parenthesized pattern");
  }
};
pp$9.checkExpressionErrors = function(s, o) {
  if (!s)
    return !1;
  var l = s.shorthandAssign, u = s.doubleProto;
  if (!o)
    return l >= 0 || u >= 0;
  l >= 0 && this.raise(l, "Shorthand property assignments are valid only in destructuring patterns"), u >= 0 && this.raiseRecoverable(u, "Redefinition of __proto__ property");
};
pp$9.checkYieldAwaitInDefaultParams = function() {
  this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
};
pp$9.isSimpleAssignTarget = function(s) {
  return s.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(s.expression) : s.type === "Identifier" || s.type === "MemberExpression";
};
var pp$8 = Parser.prototype;
pp$8.parseTopLevel = function(s) {
  var o = /* @__PURE__ */ Object.create(null);
  for (s.body || (s.body = []); this.type !== types$1.eof; ) {
    var l = this.parseStatement(null, !0, o);
    s.body.push(l);
  }
  if (this.inModule)
    for (var u = 0, c = Object.keys(this.undefinedExports); u < c.length; u += 1) {
      var m = c[u];
      this.raiseRecoverable(this.undefinedExports[m].start, "Export '" + m + "' is not defined");
    }
  return this.adaptDirectivePrologue(s.body), this.next(), s.sourceType = this.options.sourceType, this.finishNode(s, "Program");
};
var loopLabel = { kind: "loop" }, switchLabel = { kind: "switch" };
pp$8.isLet = function(s) {
  if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
    return !1;
  skipWhiteSpace.lastIndex = this.pos;
  var o = skipWhiteSpace.exec(this.input), l = this.pos + o[0].length, u = this.input.charCodeAt(l);
  if (u === 91 || u === 92)
    return !0;
  if (s)
    return !1;
  if (u === 123 || u > 55295 && u < 56320)
    return !0;
  if (isIdentifierStart(u, !0)) {
    for (var c = l + 1; isIdentifierChar(u = this.input.charCodeAt(c), !0); )
      ++c;
    if (u === 92 || u > 55295 && u < 56320)
      return !0;
    var m = this.input.slice(l, c);
    if (!keywordRelationalOperator.test(m))
      return !0;
  }
  return !1;
};
pp$8.isAsyncFunction = function() {
  if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
    return !1;
  skipWhiteSpace.lastIndex = this.pos;
  var s = skipWhiteSpace.exec(this.input), o = this.pos + s[0].length, l;
  return !lineBreak.test(this.input.slice(this.pos, o)) && this.input.slice(o, o + 8) === "function" && (o + 8 === this.input.length || !(isIdentifierChar(l = this.input.charCodeAt(o + 8)) || l > 55295 && l < 56320));
};
pp$8.parseStatement = function(s, o, l) {
  var u = this.type, c = this.startNode(), m;
  switch (this.isLet(s) && (u = types$1._var, m = "let"), u) {
    case types$1._break:
    case types$1._continue:
      return this.parseBreakContinueStatement(c, u.keyword);
    case types$1._debugger:
      return this.parseDebuggerStatement(c);
    case types$1._do:
      return this.parseDoStatement(c);
    case types$1._for:
      return this.parseForStatement(c);
    case types$1._function:
      return s && (this.strict || s !== "if" && s !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(c, !1, !s);
    case types$1._class:
      return s && this.unexpected(), this.parseClass(c, !0);
    case types$1._if:
      return this.parseIfStatement(c);
    case types$1._return:
      return this.parseReturnStatement(c);
    case types$1._switch:
      return this.parseSwitchStatement(c);
    case types$1._throw:
      return this.parseThrowStatement(c);
    case types$1._try:
      return this.parseTryStatement(c);
    case types$1._const:
    case types$1._var:
      return m = m || this.value, s && m !== "var" && this.unexpected(), this.parseVarStatement(c, m);
    case types$1._while:
      return this.parseWhileStatement(c);
    case types$1._with:
      return this.parseWithStatement(c);
    case types$1.braceL:
      return this.parseBlock(!0, c);
    case types$1.semi:
      return this.parseEmptyStatement(c);
    case types$1._export:
    case types$1._import:
      if (this.options.ecmaVersion > 10 && u === types$1._import) {
        skipWhiteSpace.lastIndex = this.pos;
        var g = skipWhiteSpace.exec(this.input), v = this.pos + g[0].length, b = this.input.charCodeAt(v);
        if (b === 40 || b === 46)
          return this.parseExpressionStatement(c, this.parseExpression());
      }
      return this.options.allowImportExportEverywhere || (o || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), u === types$1._import ? this.parseImport(c) : this.parseExport(c, l);
    default:
      if (this.isAsyncFunction())
        return s && this.unexpected(), this.next(), this.parseFunctionStatement(c, !0, !s);
      var S = this.value, E = this.parseExpression();
      return u === types$1.name && E.type === "Identifier" && this.eat(types$1.colon) ? this.parseLabeledStatement(c, S, E, s) : this.parseExpressionStatement(c, E);
  }
};
pp$8.parseBreakContinueStatement = function(s, o) {
  var l = o === "break";
  this.next(), this.eat(types$1.semi) || this.insertSemicolon() ? s.label = null : this.type !== types$1.name ? this.unexpected() : (s.label = this.parseIdent(), this.semicolon());
  for (var u = 0; u < this.labels.length; ++u) {
    var c = this.labels[u];
    if ((s.label == null || c.name === s.label.name) && (c.kind != null && (l || c.kind === "loop") || s.label && l))
      break;
  }
  return u === this.labels.length && this.raise(s.start, "Unsyntactic " + o), this.finishNode(s, l ? "BreakStatement" : "ContinueStatement");
};
pp$8.parseDebuggerStatement = function(s) {
  return this.next(), this.semicolon(), this.finishNode(s, "DebuggerStatement");
};
pp$8.parseDoStatement = function(s) {
  return this.next(), this.labels.push(loopLabel), s.body = this.parseStatement("do"), this.labels.pop(), this.expect(types$1._while), s.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(types$1.semi) : this.semicolon(), this.finishNode(s, "DoWhileStatement");
};
pp$8.parseForStatement = function(s) {
  this.next();
  var o = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
  if (this.labels.push(loopLabel), this.enterScope(0), this.expect(types$1.parenL), this.type === types$1.semi)
    return o > -1 && this.unexpected(o), this.parseFor(s, null);
  var l = this.isLet();
  if (this.type === types$1._var || this.type === types$1._const || l) {
    var u = this.startNode(), c = l ? "let" : this.value;
    return this.next(), this.parseVar(u, !0, c), this.finishNode(u, "VariableDeclaration"), (this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && u.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === types$1._in ? o > -1 && this.unexpected(o) : s.await = o > -1), this.parseForIn(s, u)) : (o > -1 && this.unexpected(o), this.parseFor(s, u));
  }
  var m = this.isContextual("let"), g = !1, v = new DestructuringErrors(), b = this.parseExpression(o > -1 ? "await" : !0, v);
  return this.type === types$1._in || (g = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === types$1._in ? o > -1 && this.unexpected(o) : s.await = o > -1), m && g && this.raise(b.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(b, !1, v), this.checkLValPattern(b), this.parseForIn(s, b)) : (this.checkExpressionErrors(v, !0), o > -1 && this.unexpected(o), this.parseFor(s, b));
};
pp$8.parseFunctionStatement = function(s, o, l) {
  return this.next(), this.parseFunction(s, FUNC_STATEMENT | (l ? 0 : FUNC_HANGING_STATEMENT), !1, o);
};
pp$8.parseIfStatement = function(s) {
  return this.next(), s.test = this.parseParenExpression(), s.consequent = this.parseStatement("if"), s.alternate = this.eat(types$1._else) ? this.parseStatement("if") : null, this.finishNode(s, "IfStatement");
};
pp$8.parseReturnStatement = function(s) {
  return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(types$1.semi) || this.insertSemicolon() ? s.argument = null : (s.argument = this.parseExpression(), this.semicolon()), this.finishNode(s, "ReturnStatement");
};
pp$8.parseSwitchStatement = function(s) {
  this.next(), s.discriminant = this.parseParenExpression(), s.cases = [], this.expect(types$1.braceL), this.labels.push(switchLabel), this.enterScope(0);
  for (var o, l = !1; this.type !== types$1.braceR; )
    if (this.type === types$1._case || this.type === types$1._default) {
      var u = this.type === types$1._case;
      o && this.finishNode(o, "SwitchCase"), s.cases.push(o = this.startNode()), o.consequent = [], this.next(), u ? o.test = this.parseExpression() : (l && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), l = !0, o.test = null), this.expect(types$1.colon);
    } else
      o || this.unexpected(), o.consequent.push(this.parseStatement(null));
  return this.exitScope(), o && this.finishNode(o, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(s, "SwitchStatement");
};
pp$8.parseThrowStatement = function(s) {
  return this.next(), lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), s.argument = this.parseExpression(), this.semicolon(), this.finishNode(s, "ThrowStatement");
};
var empty$1$1 = [];
pp$8.parseCatchClauseParam = function() {
  var s = this.parseBindingAtom(), o = s.type === "Identifier";
  return this.enterScope(o ? SCOPE_SIMPLE_CATCH : 0), this.checkLValPattern(s, o ? BIND_SIMPLE_CATCH : BIND_LEXICAL), this.expect(types$1.parenR), s;
};
pp$8.parseTryStatement = function(s) {
  if (this.next(), s.block = this.parseBlock(), s.handler = null, this.type === types$1._catch) {
    var o = this.startNode();
    this.next(), this.eat(types$1.parenL) ? o.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), o.param = null, this.enterScope(0)), o.body = this.parseBlock(!1), this.exitScope(), s.handler = this.finishNode(o, "CatchClause");
  }
  return s.finalizer = this.eat(types$1._finally) ? this.parseBlock() : null, !s.handler && !s.finalizer && this.raise(s.start, "Missing catch or finally clause"), this.finishNode(s, "TryStatement");
};
pp$8.parseVarStatement = function(s, o, l) {
  return this.next(), this.parseVar(s, !1, o, l), this.semicolon(), this.finishNode(s, "VariableDeclaration");
};
pp$8.parseWhileStatement = function(s) {
  return this.next(), s.test = this.parseParenExpression(), this.labels.push(loopLabel), s.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(s, "WhileStatement");
};
pp$8.parseWithStatement = function(s) {
  return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), s.object = this.parseParenExpression(), s.body = this.parseStatement("with"), this.finishNode(s, "WithStatement");
};
pp$8.parseEmptyStatement = function(s) {
  return this.next(), this.finishNode(s, "EmptyStatement");
};
pp$8.parseLabeledStatement = function(s, o, l, u) {
  for (var c = 0, m = this.labels; c < m.length; c += 1) {
    var g = m[c];
    g.name === o && this.raise(l.start, "Label '" + o + "' is already declared");
  }
  for (var v = this.type.isLoop ? "loop" : this.type === types$1._switch ? "switch" : null, b = this.labels.length - 1; b >= 0; b--) {
    var S = this.labels[b];
    if (S.statementStart === s.start)
      S.statementStart = this.start, S.kind = v;
    else
      break;
  }
  return this.labels.push({ name: o, kind: v, statementStart: this.start }), s.body = this.parseStatement(u ? u.indexOf("label") === -1 ? u + "label" : u : "label"), this.labels.pop(), s.label = l, this.finishNode(s, "LabeledStatement");
};
pp$8.parseExpressionStatement = function(s, o) {
  return s.expression = o, this.semicolon(), this.finishNode(s, "ExpressionStatement");
};
pp$8.parseBlock = function(s, o, l) {
  for (s === void 0 && (s = !0), o === void 0 && (o = this.startNode()), o.body = [], this.expect(types$1.braceL), s && this.enterScope(0); this.type !== types$1.braceR; ) {
    var u = this.parseStatement(null);
    o.body.push(u);
  }
  return l && (this.strict = !1), this.next(), s && this.exitScope(), this.finishNode(o, "BlockStatement");
};
pp$8.parseFor = function(s, o) {
  return s.init = o, this.expect(types$1.semi), s.test = this.type === types$1.semi ? null : this.parseExpression(), this.expect(types$1.semi), s.update = this.type === types$1.parenR ? null : this.parseExpression(), this.expect(types$1.parenR), s.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(s, "ForStatement");
};
pp$8.parseForIn = function(s, o) {
  var l = this.type === types$1._in;
  return this.next(), o.type === "VariableDeclaration" && o.declarations[0].init != null && (!l || this.options.ecmaVersion < 8 || this.strict || o.kind !== "var" || o.declarations[0].id.type !== "Identifier") && this.raise(
    o.start,
    (l ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
  ), s.left = o, s.right = l ? this.parseExpression() : this.parseMaybeAssign(), this.expect(types$1.parenR), s.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(s, l ? "ForInStatement" : "ForOfStatement");
};
pp$8.parseVar = function(s, o, l, u) {
  for (s.declarations = [], s.kind = l; ; ) {
    var c = this.startNode();
    if (this.parseVarId(c, l), this.eat(types$1.eq) ? c.init = this.parseMaybeAssign(o) : !u && l === "const" && !(this.type === types$1._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !u && c.id.type !== "Identifier" && !(o && (this.type === types$1._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : c.init = null, s.declarations.push(this.finishNode(c, "VariableDeclarator")), !this.eat(types$1.comma))
      break;
  }
  return s;
};
pp$8.parseVarId = function(s, o) {
  s.id = this.parseBindingAtom(), this.checkLValPattern(s.id, o === "var" ? BIND_VAR : BIND_LEXICAL, !1);
};
var FUNC_STATEMENT = 1, FUNC_HANGING_STATEMENT = 2, FUNC_NULLABLE_ID = 4;
pp$8.parseFunction = function(s, o, l, u, c) {
  this.initFunction(s), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !u) && (this.type === types$1.star && o & FUNC_HANGING_STATEMENT && this.unexpected(), s.generator = this.eat(types$1.star)), this.options.ecmaVersion >= 8 && (s.async = !!u), o & FUNC_STATEMENT && (s.id = o & FUNC_NULLABLE_ID && this.type !== types$1.name ? null : this.parseIdent(), s.id && !(o & FUNC_HANGING_STATEMENT) && this.checkLValSimple(s.id, this.strict || s.generator || s.async ? this.treatFunctionsAsVar ? BIND_VAR : BIND_LEXICAL : BIND_FUNCTION));
  var m = this.yieldPos, g = this.awaitPos, v = this.awaitIdentPos;
  return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(s.async, s.generator)), o & FUNC_STATEMENT || (s.id = this.type === types$1.name ? this.parseIdent() : null), this.parseFunctionParams(s), this.parseFunctionBody(s, l, !1, c), this.yieldPos = m, this.awaitPos = g, this.awaitIdentPos = v, this.finishNode(s, o & FUNC_STATEMENT ? "FunctionDeclaration" : "FunctionExpression");
};
pp$8.parseFunctionParams = function(s) {
  this.expect(types$1.parenL), s.params = this.parseBindingList(types$1.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
};
pp$8.parseClass = function(s, o) {
  this.next();
  var l = this.strict;
  this.strict = !0, this.parseClassId(s, o), this.parseClassSuper(s);
  var u = this.enterClassBody(), c = this.startNode(), m = !1;
  for (c.body = [], this.expect(types$1.braceL); this.type !== types$1.braceR; ) {
    var g = this.parseClassElement(s.superClass !== null);
    g && (c.body.push(g), g.type === "MethodDefinition" && g.kind === "constructor" ? (m && this.raiseRecoverable(g.start, "Duplicate constructor in the same class"), m = !0) : g.key && g.key.type === "PrivateIdentifier" && isPrivateNameConflicted(u, g) && this.raiseRecoverable(g.key.start, "Identifier '#" + g.key.name + "' has already been declared"));
  }
  return this.strict = l, this.next(), s.body = this.finishNode(c, "ClassBody"), this.exitClassBody(), this.finishNode(s, o ? "ClassDeclaration" : "ClassExpression");
};
pp$8.parseClassElement = function(s) {
  if (this.eat(types$1.semi))
    return null;
  var o = this.options.ecmaVersion, l = this.startNode(), u = "", c = !1, m = !1, g = "method", v = !1;
  if (this.eatContextual("static")) {
    if (o >= 13 && this.eat(types$1.braceL))
      return this.parseClassStaticBlock(l), l;
    this.isClassElementNameStart() || this.type === types$1.star ? v = !0 : u = "static";
  }
  if (l.static = v, !u && o >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === types$1.star) && !this.canInsertSemicolon() ? m = !0 : u = "async"), !u && (o >= 9 || !m) && this.eat(types$1.star) && (c = !0), !u && !m && !c) {
    var b = this.value;
    (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? g = b : u = b);
  }
  if (u ? (l.computed = !1, l.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), l.key.name = u, this.finishNode(l.key, "Identifier")) : this.parseClassElementName(l), o < 13 || this.type === types$1.parenL || g !== "method" || c || m) {
    var S = !l.static && checkKeyName(l, "constructor"), E = S && s;
    S && g !== "method" && this.raise(l.key.start, "Constructor can't have get/set modifier"), l.kind = S ? "constructor" : g, this.parseClassMethod(l, c, m, E);
  } else
    this.parseClassField(l);
  return l;
};
pp$8.isClassElementNameStart = function() {
  return this.type === types$1.name || this.type === types$1.privateId || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword;
};
pp$8.parseClassElementName = function(s) {
  this.type === types$1.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), s.computed = !1, s.key = this.parsePrivateIdent()) : this.parsePropertyName(s);
};
pp$8.parseClassMethod = function(s, o, l, u) {
  var c = s.key;
  s.kind === "constructor" ? (o && this.raise(c.start, "Constructor can't be a generator"), l && this.raise(c.start, "Constructor can't be an async method")) : s.static && checkKeyName(s, "prototype") && this.raise(c.start, "Classes may not have a static property named prototype");
  var m = s.value = this.parseMethod(o, l, u);
  return s.kind === "get" && m.params.length !== 0 && this.raiseRecoverable(m.start, "getter should have no params"), s.kind === "set" && m.params.length !== 1 && this.raiseRecoverable(m.start, "setter should have exactly one param"), s.kind === "set" && m.params[0].type === "RestElement" && this.raiseRecoverable(m.params[0].start, "Setter cannot use rest params"), this.finishNode(s, "MethodDefinition");
};
pp$8.parseClassField = function(s) {
  if (checkKeyName(s, "constructor") ? this.raise(s.key.start, "Classes can't have a field named 'constructor'") : s.static && checkKeyName(s, "prototype") && this.raise(s.key.start, "Classes can't have a static field named 'prototype'"), this.eat(types$1.eq)) {
    var o = this.currentThisScope(), l = o.inClassFieldInit;
    o.inClassFieldInit = !0, s.value = this.parseMaybeAssign(), o.inClassFieldInit = l;
  } else
    s.value = null;
  return this.semicolon(), this.finishNode(s, "PropertyDefinition");
};
pp$8.parseClassStaticBlock = function(s) {
  s.body = [];
  var o = this.labels;
  for (this.labels = [], this.enterScope(SCOPE_CLASS_STATIC_BLOCK | SCOPE_SUPER); this.type !== types$1.braceR; ) {
    var l = this.parseStatement(null);
    s.body.push(l);
  }
  return this.next(), this.exitScope(), this.labels = o, this.finishNode(s, "StaticBlock");
};
pp$8.parseClassId = function(s, o) {
  this.type === types$1.name ? (s.id = this.parseIdent(), o && this.checkLValSimple(s.id, BIND_LEXICAL, !1)) : (o === !0 && this.unexpected(), s.id = null);
};
pp$8.parseClassSuper = function(s) {
  s.superClass = this.eat(types$1._extends) ? this.parseExprSubscripts(null, !1) : null;
};
pp$8.enterClassBody = function() {
  var s = { declared: /* @__PURE__ */ Object.create(null), used: [] };
  return this.privateNameStack.push(s), s.declared;
};
pp$8.exitClassBody = function() {
  var s = this.privateNameStack.pop(), o = s.declared, l = s.used;
  if (this.options.checkPrivateFields)
    for (var u = this.privateNameStack.length, c = u === 0 ? null : this.privateNameStack[u - 1], m = 0; m < l.length; ++m) {
      var g = l[m];
      hasOwn$1(o, g.name) || (c ? c.used.push(g) : this.raiseRecoverable(g.start, "Private field '#" + g.name + "' must be declared in an enclosing class"));
    }
};
function isPrivateNameConflicted(s, o) {
  var l = o.key.name, u = s[l], c = "true";
  return o.type === "MethodDefinition" && (o.kind === "get" || o.kind === "set") && (c = (o.static ? "s" : "i") + o.kind), u === "iget" && c === "iset" || u === "iset" && c === "iget" || u === "sget" && c === "sset" || u === "sset" && c === "sget" ? (s[l] = "true", !1) : u ? !0 : (s[l] = c, !1);
}
function checkKeyName(s, o) {
  var l = s.computed, u = s.key;
  return !l && (u.type === "Identifier" && u.name === o || u.type === "Literal" && u.value === o);
}
pp$8.parseExportAllDeclaration = function(s, o) {
  return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (s.exported = this.parseModuleExportName(), this.checkExport(o, s.exported, this.lastTokStart)) : s.exported = null), this.expectContextual("from"), this.type !== types$1.string && this.unexpected(), s.source = this.parseExprAtom(), this.semicolon(), this.finishNode(s, "ExportAllDeclaration");
};
pp$8.parseExport = function(s, o) {
  if (this.next(), this.eat(types$1.star))
    return this.parseExportAllDeclaration(s, o);
  if (this.eat(types$1._default))
    return this.checkExport(o, "default", this.lastTokStart), s.declaration = this.parseExportDefaultDeclaration(), this.finishNode(s, "ExportDefaultDeclaration");
  if (this.shouldParseExportStatement())
    s.declaration = this.parseExportDeclaration(s), s.declaration.type === "VariableDeclaration" ? this.checkVariableExport(o, s.declaration.declarations) : this.checkExport(o, s.declaration.id, s.declaration.id.start), s.specifiers = [], s.source = null;
  else {
    if (s.declaration = null, s.specifiers = this.parseExportSpecifiers(o), this.eatContextual("from"))
      this.type !== types$1.string && this.unexpected(), s.source = this.parseExprAtom();
    else {
      for (var l = 0, u = s.specifiers; l < u.length; l += 1) {
        var c = u[l];
        this.checkUnreserved(c.local), this.checkLocalExport(c.local), c.local.type === "Literal" && this.raise(c.local.start, "A string literal cannot be used as an exported binding without `from`.");
      }
      s.source = null;
    }
    this.semicolon();
  }
  return this.finishNode(s, "ExportNamedDeclaration");
};
pp$8.parseExportDeclaration = function(s) {
  return this.parseStatement(null);
};
pp$8.parseExportDefaultDeclaration = function() {
  var s;
  if (this.type === types$1._function || (s = this.isAsyncFunction())) {
    var o = this.startNode();
    return this.next(), s && this.next(), this.parseFunction(o, FUNC_STATEMENT | FUNC_NULLABLE_ID, !1, s);
  } else if (this.type === types$1._class) {
    var l = this.startNode();
    return this.parseClass(l, "nullableID");
  } else {
    var u = this.parseMaybeAssign();
    return this.semicolon(), u;
  }
};
pp$8.checkExport = function(s, o, l) {
  s && (typeof o != "string" && (o = o.type === "Identifier" ? o.name : o.value), hasOwn$1(s, o) && this.raiseRecoverable(l, "Duplicate export '" + o + "'"), s[o] = !0);
};
pp$8.checkPatternExport = function(s, o) {
  var l = o.type;
  if (l === "Identifier")
    this.checkExport(s, o, o.start);
  else if (l === "ObjectPattern")
    for (var u = 0, c = o.properties; u < c.length; u += 1) {
      var m = c[u];
      this.checkPatternExport(s, m);
    }
  else if (l === "ArrayPattern")
    for (var g = 0, v = o.elements; g < v.length; g += 1) {
      var b = v[g];
      b && this.checkPatternExport(s, b);
    }
  else l === "Property" ? this.checkPatternExport(s, o.value) : l === "AssignmentPattern" ? this.checkPatternExport(s, o.left) : l === "RestElement" && this.checkPatternExport(s, o.argument);
};
pp$8.checkVariableExport = function(s, o) {
  if (s)
    for (var l = 0, u = o; l < u.length; l += 1) {
      var c = u[l];
      this.checkPatternExport(s, c.id);
    }
};
pp$8.shouldParseExportStatement = function() {
  return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
};
pp$8.parseExportSpecifier = function(s) {
  var o = this.startNode();
  return o.local = this.parseModuleExportName(), o.exported = this.eatContextual("as") ? this.parseModuleExportName() : o.local, this.checkExport(
    s,
    o.exported,
    o.exported.start
  ), this.finishNode(o, "ExportSpecifier");
};
pp$8.parseExportSpecifiers = function(s) {
  var o = [], l = !0;
  for (this.expect(types$1.braceL); !this.eat(types$1.braceR); ) {
    if (l)
      l = !1;
    else if (this.expect(types$1.comma), this.afterTrailingComma(types$1.braceR))
      break;
    o.push(this.parseExportSpecifier(s));
  }
  return o;
};
pp$8.parseImport = function(s) {
  return this.next(), this.type === types$1.string ? (s.specifiers = empty$1$1, s.source = this.parseExprAtom()) : (s.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), s.source = this.type === types$1.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(s, "ImportDeclaration");
};
pp$8.parseImportSpecifier = function() {
  var s = this.startNode();
  return s.imported = this.parseModuleExportName(), this.eatContextual("as") ? s.local = this.parseIdent() : (this.checkUnreserved(s.imported), s.local = s.imported), this.checkLValSimple(s.local, BIND_LEXICAL), this.finishNode(s, "ImportSpecifier");
};
pp$8.parseImportDefaultSpecifier = function() {
  var s = this.startNode();
  return s.local = this.parseIdent(), this.checkLValSimple(s.local, BIND_LEXICAL), this.finishNode(s, "ImportDefaultSpecifier");
};
pp$8.parseImportNamespaceSpecifier = function() {
  var s = this.startNode();
  return this.next(), this.expectContextual("as"), s.local = this.parseIdent(), this.checkLValSimple(s.local, BIND_LEXICAL), this.finishNode(s, "ImportNamespaceSpecifier");
};
pp$8.parseImportSpecifiers = function() {
  var s = [], o = !0;
  if (this.type === types$1.name && (s.push(this.parseImportDefaultSpecifier()), !this.eat(types$1.comma)))
    return s;
  if (this.type === types$1.star)
    return s.push(this.parseImportNamespaceSpecifier()), s;
  for (this.expect(types$1.braceL); !this.eat(types$1.braceR); ) {
    if (o)
      o = !1;
    else if (this.expect(types$1.comma), this.afterTrailingComma(types$1.braceR))
      break;
    s.push(this.parseImportSpecifier());
  }
  return s;
};
pp$8.parseModuleExportName = function() {
  if (this.options.ecmaVersion >= 13 && this.type === types$1.string) {
    var s = this.parseLiteral(this.value);
    return loneSurrogate.test(s.value) && this.raise(s.start, "An export name cannot include a lone surrogate."), s;
  }
  return this.parseIdent(!0);
};
pp$8.adaptDirectivePrologue = function(s) {
  for (var o = 0; o < s.length && this.isDirectiveCandidate(s[o]); ++o)
    s[o].directive = s[o].expression.raw.slice(1, -1);
};
pp$8.isDirectiveCandidate = function(s) {
  return this.options.ecmaVersion >= 5 && s.type === "ExpressionStatement" && s.expression.type === "Literal" && typeof s.expression.value == "string" && // Reject parenthesized strings.
  (this.input[s.start] === '"' || this.input[s.start] === "'");
};
var pp$7 = Parser.prototype;
pp$7.toAssignable = function(s, o, l) {
  if (this.options.ecmaVersion >= 6 && s)
    switch (s.type) {
      case "Identifier":
        this.inAsync && s.name === "await" && this.raise(s.start, "Cannot use 'await' as identifier inside an async function");
        break;
      case "ObjectPattern":
      case "ArrayPattern":
      case "AssignmentPattern":
      case "RestElement":
        break;
      case "ObjectExpression":
        s.type = "ObjectPattern", l && this.checkPatternErrors(l, !0);
        for (var u = 0, c = s.properties; u < c.length; u += 1) {
          var m = c[u];
          this.toAssignable(m, o), m.type === "RestElement" && (m.argument.type === "ArrayPattern" || m.argument.type === "ObjectPattern") && this.raise(m.argument.start, "Unexpected token");
        }
        break;
      case "Property":
        s.kind !== "init" && this.raise(s.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(s.value, o);
        break;
      case "ArrayExpression":
        s.type = "ArrayPattern", l && this.checkPatternErrors(l, !0), this.toAssignableList(s.elements, o);
        break;
      case "SpreadElement":
        s.type = "RestElement", this.toAssignable(s.argument, o), s.argument.type === "AssignmentPattern" && this.raise(s.argument.start, "Rest elements cannot have a default value");
        break;
      case "AssignmentExpression":
        s.operator !== "=" && this.raise(s.left.end, "Only '=' operator can be used for specifying default value."), s.type = "AssignmentPattern", delete s.operator, this.toAssignable(s.left, o);
        break;
      case "ParenthesizedExpression":
        this.toAssignable(s.expression, o, l);
        break;
      case "ChainExpression":
        this.raiseRecoverable(s.start, "Optional chaining cannot appear in left-hand side");
        break;
      case "MemberExpression":
        if (!o)
          break;
      default:
        this.raise(s.start, "Assigning to rvalue");
    }
  else l && this.checkPatternErrors(l, !0);
  return s;
};
pp$7.toAssignableList = function(s, o) {
  for (var l = s.length, u = 0; u < l; u++) {
    var c = s[u];
    c && this.toAssignable(c, o);
  }
  if (l) {
    var m = s[l - 1];
    this.options.ecmaVersion === 6 && o && m && m.type === "RestElement" && m.argument.type !== "Identifier" && this.unexpected(m.argument.start);
  }
  return s;
};
pp$7.parseSpread = function(s) {
  var o = this.startNode();
  return this.next(), o.argument = this.parseMaybeAssign(!1, s), this.finishNode(o, "SpreadElement");
};
pp$7.parseRestBinding = function() {
  var s = this.startNode();
  return this.next(), this.options.ecmaVersion === 6 && this.type !== types$1.name && this.unexpected(), s.argument = this.parseBindingAtom(), this.finishNode(s, "RestElement");
};
pp$7.parseBindingAtom = function() {
  if (this.options.ecmaVersion >= 6)
    switch (this.type) {
      case types$1.bracketL:
        var s = this.startNode();
        return this.next(), s.elements = this.parseBindingList(types$1.bracketR, !0, !0), this.finishNode(s, "ArrayPattern");
      case types$1.braceL:
        return this.parseObj(!0);
    }
  return this.parseIdent();
};
pp$7.parseBindingList = function(s, o, l, u) {
  for (var c = [], m = !0; !this.eat(s); )
    if (m ? m = !1 : this.expect(types$1.comma), o && this.type === types$1.comma)
      c.push(null);
    else {
      if (l && this.afterTrailingComma(s))
        break;
      if (this.type === types$1.ellipsis) {
        var g = this.parseRestBinding();
        this.parseBindingListItem(g), c.push(g), this.type === types$1.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(s);
        break;
      } else
        c.push(this.parseAssignableListItem(u));
    }
  return c;
};
pp$7.parseAssignableListItem = function(s) {
  var o = this.parseMaybeDefault(this.start, this.startLoc);
  return this.parseBindingListItem(o), o;
};
pp$7.parseBindingListItem = function(s) {
  return s;
};
pp$7.parseMaybeDefault = function(s, o, l) {
  if (l = l || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(types$1.eq))
    return l;
  var u = this.startNodeAt(s, o);
  return u.left = l, u.right = this.parseMaybeAssign(), this.finishNode(u, "AssignmentPattern");
};
pp$7.checkLValSimple = function(s, o, l) {
  o === void 0 && (o = BIND_NONE);
  var u = o !== BIND_NONE;
  switch (s.type) {
    case "Identifier":
      this.strict && this.reservedWordsStrictBind.test(s.name) && this.raiseRecoverable(s.start, (u ? "Binding " : "Assigning to ") + s.name + " in strict mode"), u && (o === BIND_LEXICAL && s.name === "let" && this.raiseRecoverable(s.start, "let is disallowed as a lexically bound name"), l && (hasOwn$1(l, s.name) && this.raiseRecoverable(s.start, "Argument name clash"), l[s.name] = !0), o !== BIND_OUTSIDE && this.declareName(s.name, o, s.start));
      break;
    case "ChainExpression":
      this.raiseRecoverable(s.start, "Optional chaining cannot appear in left-hand side");
      break;
    case "MemberExpression":
      u && this.raiseRecoverable(s.start, "Binding member expression");
      break;
    case "ParenthesizedExpression":
      return u && this.raiseRecoverable(s.start, "Binding parenthesized expression"), this.checkLValSimple(s.expression, o, l);
    default:
      this.raise(s.start, (u ? "Binding" : "Assigning to") + " rvalue");
  }
};
pp$7.checkLValPattern = function(s, o, l) {
  switch (o === void 0 && (o = BIND_NONE), s.type) {
    case "ObjectPattern":
      for (var u = 0, c = s.properties; u < c.length; u += 1) {
        var m = c[u];
        this.checkLValInnerPattern(m, o, l);
      }
      break;
    case "ArrayPattern":
      for (var g = 0, v = s.elements; g < v.length; g += 1) {
        var b = v[g];
        b && this.checkLValInnerPattern(b, o, l);
      }
      break;
    default:
      this.checkLValSimple(s, o, l);
  }
};
pp$7.checkLValInnerPattern = function(s, o, l) {
  switch (o === void 0 && (o = BIND_NONE), s.type) {
    case "Property":
      this.checkLValInnerPattern(s.value, o, l);
      break;
    case "AssignmentPattern":
      this.checkLValPattern(s.left, o, l);
      break;
    case "RestElement":
      this.checkLValPattern(s.argument, o, l);
      break;
    default:
      this.checkLValPattern(s, o, l);
  }
};
var TokContext = function s(o, l, u, c, m) {
  this.token = o, this.isExpr = !!l, this.preserveSpace = !!u, this.override = c, this.generator = !!m;
}, types$2 = {
  b_stat: new TokContext("{", !1),
  b_expr: new TokContext("{", !0),
  b_tmpl: new TokContext("${", !1),
  p_stat: new TokContext("(", !1),
  p_expr: new TokContext("(", !0),
  q_tmpl: new TokContext("`", !0, !0, function(s) {
    return s.tryReadTemplateToken();
  }),
  f_stat: new TokContext("function", !1),
  f_expr: new TokContext("function", !0),
  f_expr_gen: new TokContext("function", !0, !1, null, !0),
  f_gen: new TokContext("function", !1, !1, null, !0)
}, pp$6 = Parser.prototype;
pp$6.initialContext = function() {
  return [types$2.b_stat];
};
pp$6.curContext = function() {
  return this.context[this.context.length - 1];
};
pp$6.braceIsBlock = function(s) {
  var o = this.curContext();
  return o === types$2.f_expr || o === types$2.f_stat ? !0 : s === types$1.colon && (o === types$2.b_stat || o === types$2.b_expr) ? !o.isExpr : s === types$1._return || s === types$1.name && this.exprAllowed ? lineBreak.test(this.input.slice(this.lastTokEnd, this.start)) : s === types$1._else || s === types$1.semi || s === types$1.eof || s === types$1.parenR || s === types$1.arrow ? !0 : s === types$1.braceL ? o === types$2.b_stat : s === types$1._var || s === types$1._const || s === types$1.name ? !1 : !this.exprAllowed;
};
pp$6.inGeneratorContext = function() {
  for (var s = this.context.length - 1; s >= 1; s--) {
    var o = this.context[s];
    if (o.token === "function")
      return o.generator;
  }
  return !1;
};
pp$6.updateContext = function(s) {
  var o, l = this.type;
  l.keyword && s === types$1.dot ? this.exprAllowed = !1 : (o = l.updateContext) ? o.call(this, s) : this.exprAllowed = l.beforeExpr;
};
pp$6.overrideContext = function(s) {
  this.curContext() !== s && (this.context[this.context.length - 1] = s);
};
types$1.parenR.updateContext = types$1.braceR.updateContext = function() {
  if (this.context.length === 1) {
    this.exprAllowed = !0;
    return;
  }
  var s = this.context.pop();
  s === types$2.b_stat && this.curContext().token === "function" && (s = this.context.pop()), this.exprAllowed = !s.isExpr;
};
types$1.braceL.updateContext = function(s) {
  this.context.push(this.braceIsBlock(s) ? types$2.b_stat : types$2.b_expr), this.exprAllowed = !0;
};
types$1.dollarBraceL.updateContext = function() {
  this.context.push(types$2.b_tmpl), this.exprAllowed = !0;
};
types$1.parenL.updateContext = function(s) {
  var o = s === types$1._if || s === types$1._for || s === types$1._with || s === types$1._while;
  this.context.push(o ? types$2.p_stat : types$2.p_expr), this.exprAllowed = !0;
};
types$1.incDec.updateContext = function() {
};
types$1._function.updateContext = types$1._class.updateContext = function(s) {
  s.beforeExpr && s !== types$1._else && !(s === types$1.semi && this.curContext() !== types$2.p_stat) && !(s === types$1._return && lineBreak.test(this.input.slice(this.lastTokEnd, this.start))) && !((s === types$1.colon || s === types$1.braceL) && this.curContext() === types$2.b_stat) ? this.context.push(types$2.f_expr) : this.context.push(types$2.f_stat), this.exprAllowed = !1;
};
types$1.colon.updateContext = function() {
  this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
};
types$1.backQuote.updateContext = function() {
  this.curContext() === types$2.q_tmpl ? this.context.pop() : this.context.push(types$2.q_tmpl), this.exprAllowed = !1;
};
types$1.star.updateContext = function(s) {
  if (s === types$1._function) {
    var o = this.context.length - 1;
    this.context[o] === types$2.f_expr ? this.context[o] = types$2.f_expr_gen : this.context[o] = types$2.f_gen;
  }
  this.exprAllowed = !0;
};
types$1.name.updateContext = function(s) {
  var o = !1;
  this.options.ecmaVersion >= 6 && s !== types$1.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (o = !0), this.exprAllowed = o;
};
var pp$5 = Parser.prototype;
pp$5.checkPropClash = function(s, o, l) {
  if (!(this.options.ecmaVersion >= 9 && s.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (s.computed || s.method || s.shorthand))) {
    var u = s.key, c;
    switch (u.type) {
      case "Identifier":
        c = u.name;
        break;
      case "Literal":
        c = String(u.value);
        break;
      default:
        return;
    }
    var m = s.kind;
    if (this.options.ecmaVersion >= 6) {
      c === "__proto__" && m === "init" && (o.proto && (l ? l.doubleProto < 0 && (l.doubleProto = u.start) : this.raiseRecoverable(u.start, "Redefinition of __proto__ property")), o.proto = !0);
      return;
    }
    c = "$" + c;
    var g = o[c];
    if (g) {
      var v;
      m === "init" ? v = this.strict && g.init || g.get || g.set : v = g.init || g[m], v && this.raiseRecoverable(u.start, "Redefinition of property");
    } else
      g = o[c] = {
        init: !1,
        get: !1,
        set: !1
      };
    g[m] = !0;
  }
};
pp$5.parseExpression = function(s, o) {
  var l = this.start, u = this.startLoc, c = this.parseMaybeAssign(s, o);
  if (this.type === types$1.comma) {
    var m = this.startNodeAt(l, u);
    for (m.expressions = [c]; this.eat(types$1.comma); )
      m.expressions.push(this.parseMaybeAssign(s, o));
    return this.finishNode(m, "SequenceExpression");
  }
  return c;
};
pp$5.parseMaybeAssign = function(s, o, l) {
  if (this.isContextual("yield")) {
    if (this.inGenerator)
      return this.parseYield(s);
    this.exprAllowed = !1;
  }
  var u = !1, c = -1, m = -1, g = -1;
  o ? (c = o.parenthesizedAssign, m = o.trailingComma, g = o.doubleProto, o.parenthesizedAssign = o.trailingComma = -1) : (o = new DestructuringErrors(), u = !0);
  var v = this.start, b = this.startLoc;
  (this.type === types$1.parenL || this.type === types$1.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = s === "await");
  var S = this.parseMaybeConditional(s, o);
  if (l && (S = l.call(this, S, v, b)), this.type.isAssign) {
    var E = this.startNodeAt(v, b);
    return E.operator = this.value, this.type === types$1.eq && (S = this.toAssignable(S, !1, o)), u || (o.parenthesizedAssign = o.trailingComma = o.doubleProto = -1), o.shorthandAssign >= S.start && (o.shorthandAssign = -1), this.type === types$1.eq ? this.checkLValPattern(S) : this.checkLValSimple(S), E.left = S, this.next(), E.right = this.parseMaybeAssign(s), g > -1 && (o.doubleProto = g), this.finishNode(E, "AssignmentExpression");
  } else
    u && this.checkExpressionErrors(o, !0);
  return c > -1 && (o.parenthesizedAssign = c), m > -1 && (o.trailingComma = m), S;
};
pp$5.parseMaybeConditional = function(s, o) {
  var l = this.start, u = this.startLoc, c = this.parseExprOps(s, o);
  if (this.checkExpressionErrors(o))
    return c;
  if (this.eat(types$1.question)) {
    var m = this.startNodeAt(l, u);
    return m.test = c, m.consequent = this.parseMaybeAssign(), this.expect(types$1.colon), m.alternate = this.parseMaybeAssign(s), this.finishNode(m, "ConditionalExpression");
  }
  return c;
};
pp$5.parseExprOps = function(s, o) {
  var l = this.start, u = this.startLoc, c = this.parseMaybeUnary(o, !1, !1, s);
  return this.checkExpressionErrors(o) || c.start === l && c.type === "ArrowFunctionExpression" ? c : this.parseExprOp(c, l, u, -1, s);
};
pp$5.parseExprOp = function(s, o, l, u, c) {
  var m = this.type.binop;
  if (m != null && (!c || this.type !== types$1._in) && m > u) {
    var g = this.type === types$1.logicalOR || this.type === types$1.logicalAND, v = this.type === types$1.coalesce;
    v && (m = types$1.logicalAND.binop);
    var b = this.value;
    this.next();
    var S = this.start, E = this.startLoc, P = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, c), S, E, m, c), T = this.buildBinary(o, l, s, P, b, g || v);
    return (g && this.type === types$1.coalesce || v && (this.type === types$1.logicalOR || this.type === types$1.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(T, o, l, u, c);
  }
  return s;
};
pp$5.buildBinary = function(s, o, l, u, c, m) {
  u.type === "PrivateIdentifier" && this.raise(u.start, "Private identifier can only be left side of binary expression");
  var g = this.startNodeAt(s, o);
  return g.left = l, g.operator = c, g.right = u, this.finishNode(g, m ? "LogicalExpression" : "BinaryExpression");
};
pp$5.parseMaybeUnary = function(s, o, l, u) {
  var c = this.start, m = this.startLoc, g;
  if (this.isContextual("await") && this.canAwait)
    g = this.parseAwait(u), o = !0;
  else if (this.type.prefix) {
    var v = this.startNode(), b = this.type === types$1.incDec;
    v.operator = this.value, v.prefix = !0, this.next(), v.argument = this.parseMaybeUnary(null, !0, b, u), this.checkExpressionErrors(s, !0), b ? this.checkLValSimple(v.argument) : this.strict && v.operator === "delete" && v.argument.type === "Identifier" ? this.raiseRecoverable(v.start, "Deleting local variable in strict mode") : v.operator === "delete" && isPrivateFieldAccess(v.argument) ? this.raiseRecoverable(v.start, "Private fields can not be deleted") : o = !0, g = this.finishNode(v, b ? "UpdateExpression" : "UnaryExpression");
  } else if (!o && this.type === types$1.privateId)
    (u || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), g = this.parsePrivateIdent(), this.type !== types$1._in && this.unexpected();
  else {
    if (g = this.parseExprSubscripts(s, u), this.checkExpressionErrors(s))
      return g;
    for (; this.type.postfix && !this.canInsertSemicolon(); ) {
      var S = this.startNodeAt(c, m);
      S.operator = this.value, S.prefix = !1, S.argument = g, this.checkLValSimple(g), this.next(), g = this.finishNode(S, "UpdateExpression");
    }
  }
  if (!l && this.eat(types$1.starstar))
    if (o)
      this.unexpected(this.lastTokStart);
    else
      return this.buildBinary(c, m, g, this.parseMaybeUnary(null, !1, !1, u), "**", !1);
  else
    return g;
};
function isPrivateFieldAccess(s) {
  return s.type === "MemberExpression" && s.property.type === "PrivateIdentifier" || s.type === "ChainExpression" && isPrivateFieldAccess(s.expression);
}
pp$5.parseExprSubscripts = function(s, o) {
  var l = this.start, u = this.startLoc, c = this.parseExprAtom(s, o);
  if (c.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
    return c;
  var m = this.parseSubscripts(c, l, u, !1, o);
  return s && m.type === "MemberExpression" && (s.parenthesizedAssign >= m.start && (s.parenthesizedAssign = -1), s.parenthesizedBind >= m.start && (s.parenthesizedBind = -1), s.trailingComma >= m.start && (s.trailingComma = -1)), m;
};
pp$5.parseSubscripts = function(s, o, l, u, c) {
  for (var m = this.options.ecmaVersion >= 8 && s.type === "Identifier" && s.name === "async" && this.lastTokEnd === s.end && !this.canInsertSemicolon() && s.end - s.start === 5 && this.potentialArrowAt === s.start, g = !1; ; ) {
    var v = this.parseSubscript(s, o, l, u, m, g, c);
    if (v.optional && (g = !0), v === s || v.type === "ArrowFunctionExpression") {
      if (g) {
        var b = this.startNodeAt(o, l);
        b.expression = v, v = this.finishNode(b, "ChainExpression");
      }
      return v;
    }
    s = v;
  }
};
pp$5.shouldParseAsyncArrow = function() {
  return !this.canInsertSemicolon() && this.eat(types$1.arrow);
};
pp$5.parseSubscriptAsyncArrow = function(s, o, l, u) {
  return this.parseArrowExpression(this.startNodeAt(s, o), l, !0, u);
};
pp$5.parseSubscript = function(s, o, l, u, c, m, g) {
  var v = this.options.ecmaVersion >= 11, b = v && this.eat(types$1.questionDot);
  u && b && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
  var S = this.eat(types$1.bracketL);
  if (S || b && this.type !== types$1.parenL && this.type !== types$1.backQuote || this.eat(types$1.dot)) {
    var E = this.startNodeAt(o, l);
    E.object = s, S ? (E.property = this.parseExpression(), this.expect(types$1.bracketR)) : this.type === types$1.privateId && s.type !== "Super" ? E.property = this.parsePrivateIdent() : E.property = this.parseIdent(this.options.allowReserved !== "never"), E.computed = !!S, v && (E.optional = b), s = this.finishNode(E, "MemberExpression");
  } else if (!u && this.eat(types$1.parenL)) {
    var P = new DestructuringErrors(), T = this.yieldPos, N = this.awaitPos, O = this.awaitIdentPos;
    this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
    var z = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, !1, P);
    if (c && !b && this.shouldParseAsyncArrow())
      return this.checkPatternErrors(P, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = T, this.awaitPos = N, this.awaitIdentPos = O, this.parseSubscriptAsyncArrow(o, l, z, g);
    this.checkExpressionErrors(P, !0), this.yieldPos = T || this.yieldPos, this.awaitPos = N || this.awaitPos, this.awaitIdentPos = O || this.awaitIdentPos;
    var Q = this.startNodeAt(o, l);
    Q.callee = s, Q.arguments = z, v && (Q.optional = b), s = this.finishNode(Q, "CallExpression");
  } else if (this.type === types$1.backQuote) {
    (b || m) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
    var W = this.startNodeAt(o, l);
    W.tag = s, W.quasi = this.parseTemplate({ isTagged: !0 }), s = this.finishNode(W, "TaggedTemplateExpression");
  }
  return s;
};
pp$5.parseExprAtom = function(s, o, l) {
  this.type === types$1.slash && this.readRegexp();
  var u, c = this.potentialArrowAt === this.start;
  switch (this.type) {
    case types$1._super:
      return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), u = this.startNode(), this.next(), this.type === types$1.parenL && !this.allowDirectSuper && this.raise(u.start, "super() call outside constructor of a subclass"), this.type !== types$1.dot && this.type !== types$1.bracketL && this.type !== types$1.parenL && this.unexpected(), this.finishNode(u, "Super");
    case types$1._this:
      return u = this.startNode(), this.next(), this.finishNode(u, "ThisExpression");
    case types$1.name:
      var m = this.start, g = this.startLoc, v = this.containsEsc, b = this.parseIdent(!1);
      if (this.options.ecmaVersion >= 8 && !v && b.name === "async" && !this.canInsertSemicolon() && this.eat(types$1._function))
        return this.overrideContext(types$2.f_expr), this.parseFunction(this.startNodeAt(m, g), 0, !1, !0, o);
      if (c && !this.canInsertSemicolon()) {
        if (this.eat(types$1.arrow))
          return this.parseArrowExpression(this.startNodeAt(m, g), [b], !1, o);
        if (this.options.ecmaVersion >= 8 && b.name === "async" && this.type === types$1.name && !v && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
          return b = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(types$1.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(m, g), [b], !0, o);
      }
      return b;
    case types$1.regexp:
      var S = this.value;
      return u = this.parseLiteral(S.value), u.regex = { pattern: S.pattern, flags: S.flags }, u;
    case types$1.num:
    case types$1.string:
      return this.parseLiteral(this.value);
    case types$1._null:
    case types$1._true:
    case types$1._false:
      return u = this.startNode(), u.value = this.type === types$1._null ? null : this.type === types$1._true, u.raw = this.type.keyword, this.next(), this.finishNode(u, "Literal");
    case types$1.parenL:
      var E = this.start, P = this.parseParenAndDistinguishExpression(c, o);
      return s && (s.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(P) && (s.parenthesizedAssign = E), s.parenthesizedBind < 0 && (s.parenthesizedBind = E)), P;
    case types$1.bracketL:
      return u = this.startNode(), this.next(), u.elements = this.parseExprList(types$1.bracketR, !0, !0, s), this.finishNode(u, "ArrayExpression");
    case types$1.braceL:
      return this.overrideContext(types$2.b_expr), this.parseObj(!1, s);
    case types$1._function:
      return u = this.startNode(), this.next(), this.parseFunction(u, 0);
    case types$1._class:
      return this.parseClass(this.startNode(), !1);
    case types$1._new:
      return this.parseNew();
    case types$1.backQuote:
      return this.parseTemplate();
    case types$1._import:
      return this.options.ecmaVersion >= 11 ? this.parseExprImport(l) : this.unexpected();
    default:
      return this.parseExprAtomDefault();
  }
};
pp$5.parseExprAtomDefault = function() {
  this.unexpected();
};
pp$5.parseExprImport = function(s) {
  var o = this.startNode();
  if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === types$1.parenL && !s)
    return this.parseDynamicImport(o);
  if (this.type === types$1.dot) {
    var l = this.startNodeAt(o.start, o.loc && o.loc.start);
    return l.name = "import", o.meta = this.finishNode(l, "Identifier"), this.parseImportMeta(o);
  } else
    this.unexpected();
};
pp$5.parseDynamicImport = function(s) {
  if (this.next(), s.source = this.parseMaybeAssign(), !this.eat(types$1.parenR)) {
    var o = this.start;
    this.eat(types$1.comma) && this.eat(types$1.parenR) ? this.raiseRecoverable(o, "Trailing comma is not allowed in import()") : this.unexpected(o);
  }
  return this.finishNode(s, "ImportExpression");
};
pp$5.parseImportMeta = function(s) {
  this.next();
  var o = this.containsEsc;
  return s.property = this.parseIdent(!0), s.property.name !== "meta" && this.raiseRecoverable(s.property.start, "The only valid meta property for import is 'import.meta'"), o && this.raiseRecoverable(s.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(s.start, "Cannot use 'import.meta' outside a module"), this.finishNode(s, "MetaProperty");
};
pp$5.parseLiteral = function(s) {
  var o = this.startNode();
  return o.value = s, o.raw = this.input.slice(this.start, this.end), o.raw.charCodeAt(o.raw.length - 1) === 110 && (o.bigint = o.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(o, "Literal");
};
pp$5.parseParenExpression = function() {
  this.expect(types$1.parenL);
  var s = this.parseExpression();
  return this.expect(types$1.parenR), s;
};
pp$5.shouldParseArrow = function(s) {
  return !this.canInsertSemicolon();
};
pp$5.parseParenAndDistinguishExpression = function(s, o) {
  var l = this.start, u = this.startLoc, c, m = this.options.ecmaVersion >= 8;
  if (this.options.ecmaVersion >= 6) {
    this.next();
    var g = this.start, v = this.startLoc, b = [], S = !0, E = !1, P = new DestructuringErrors(), T = this.yieldPos, N = this.awaitPos, O;
    for (this.yieldPos = 0, this.awaitPos = 0; this.type !== types$1.parenR; )
      if (S ? S = !1 : this.expect(types$1.comma), m && this.afterTrailingComma(types$1.parenR, !0)) {
        E = !0;
        break;
      } else if (this.type === types$1.ellipsis) {
        O = this.start, b.push(this.parseParenItem(this.parseRestBinding())), this.type === types$1.comma && this.raiseRecoverable(
          this.start,
          "Comma is not permitted after the rest element"
        );
        break;
      } else
        b.push(this.parseMaybeAssign(!1, P, this.parseParenItem));
    var z = this.lastTokEnd, Q = this.lastTokEndLoc;
    if (this.expect(types$1.parenR), s && this.shouldParseArrow(b) && this.eat(types$1.arrow))
      return this.checkPatternErrors(P, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = T, this.awaitPos = N, this.parseParenArrowList(l, u, b, o);
    (!b.length || E) && this.unexpected(this.lastTokStart), O && this.unexpected(O), this.checkExpressionErrors(P, !0), this.yieldPos = T || this.yieldPos, this.awaitPos = N || this.awaitPos, b.length > 1 ? (c = this.startNodeAt(g, v), c.expressions = b, this.finishNodeAt(c, "SequenceExpression", z, Q)) : c = b[0];
  } else
    c = this.parseParenExpression();
  if (this.options.preserveParens) {
    var W = this.startNodeAt(l, u);
    return W.expression = c, this.finishNode(W, "ParenthesizedExpression");
  } else
    return c;
};
pp$5.parseParenItem = function(s) {
  return s;
};
pp$5.parseParenArrowList = function(s, o, l, u) {
  return this.parseArrowExpression(this.startNodeAt(s, o), l, !1, u);
};
var empty$3 = [];
pp$5.parseNew = function() {
  this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
  var s = this.startNode();
  if (this.next(), this.options.ecmaVersion >= 6 && this.type === types$1.dot) {
    var o = this.startNodeAt(s.start, s.loc && s.loc.start);
    o.name = "new", s.meta = this.finishNode(o, "Identifier"), this.next();
    var l = this.containsEsc;
    return s.property = this.parseIdent(!0), s.property.name !== "target" && this.raiseRecoverable(s.property.start, "The only valid meta property for new is 'new.target'"), l && this.raiseRecoverable(s.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(s.start, "'new.target' can only be used in functions and class static block"), this.finishNode(s, "MetaProperty");
  }
  var u = this.start, c = this.startLoc;
  return s.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), u, c, !0, !1), this.eat(types$1.parenL) ? s.arguments = this.parseExprList(types$1.parenR, this.options.ecmaVersion >= 8, !1) : s.arguments = empty$3, this.finishNode(s, "NewExpression");
};
pp$5.parseTemplateElement = function(s) {
  var o = s.isTagged, l = this.startNode();
  return this.type === types$1.invalidTemplate ? (o || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), l.value = {
    raw: this.value,
    cooked: null
  }) : l.value = {
    raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
    cooked: this.value
  }, this.next(), l.tail = this.type === types$1.backQuote, this.finishNode(l, "TemplateElement");
};
pp$5.parseTemplate = function(s) {
  s === void 0 && (s = {});
  var o = s.isTagged;
  o === void 0 && (o = !1);
  var l = this.startNode();
  this.next(), l.expressions = [];
  var u = this.parseTemplateElement({ isTagged: o });
  for (l.quasis = [u]; !u.tail; )
    this.type === types$1.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(types$1.dollarBraceL), l.expressions.push(this.parseExpression()), this.expect(types$1.braceR), l.quasis.push(u = this.parseTemplateElement({ isTagged: o }));
  return this.next(), this.finishNode(l, "TemplateLiteral");
};
pp$5.isAsyncProp = function(s) {
  return !s.computed && s.key.type === "Identifier" && s.key.name === "async" && (this.type === types$1.name || this.type === types$1.num || this.type === types$1.string || this.type === types$1.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === types$1.star) && !lineBreak.test(this.input.slice(this.lastTokEnd, this.start));
};
pp$5.parseObj = function(s, o) {
  var l = this.startNode(), u = !0, c = {};
  for (l.properties = [], this.next(); !this.eat(types$1.braceR); ) {
    if (u)
      u = !1;
    else if (this.expect(types$1.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(types$1.braceR))
      break;
    var m = this.parseProperty(s, o);
    s || this.checkPropClash(m, c, o), l.properties.push(m);
  }
  return this.finishNode(l, s ? "ObjectPattern" : "ObjectExpression");
};
pp$5.parseProperty = function(s, o) {
  var l = this.startNode(), u, c, m, g;
  if (this.options.ecmaVersion >= 9 && this.eat(types$1.ellipsis))
    return s ? (l.argument = this.parseIdent(!1), this.type === types$1.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(l, "RestElement")) : (l.argument = this.parseMaybeAssign(!1, o), this.type === types$1.comma && o && o.trailingComma < 0 && (o.trailingComma = this.start), this.finishNode(l, "SpreadElement"));
  this.options.ecmaVersion >= 6 && (l.method = !1, l.shorthand = !1, (s || o) && (m = this.start, g = this.startLoc), s || (u = this.eat(types$1.star)));
  var v = this.containsEsc;
  return this.parsePropertyName(l), !s && !v && this.options.ecmaVersion >= 8 && !u && this.isAsyncProp(l) ? (c = !0, u = this.options.ecmaVersion >= 9 && this.eat(types$1.star), this.parsePropertyName(l)) : c = !1, this.parsePropertyValue(l, s, u, c, m, g, o, v), this.finishNode(l, "Property");
};
pp$5.parseGetterSetter = function(s) {
  s.kind = s.key.name, this.parsePropertyName(s), s.value = this.parseMethod(!1);
  var o = s.kind === "get" ? 0 : 1;
  if (s.value.params.length !== o) {
    var l = s.value.start;
    s.kind === "get" ? this.raiseRecoverable(l, "getter should have no params") : this.raiseRecoverable(l, "setter should have exactly one param");
  } else
    s.kind === "set" && s.value.params[0].type === "RestElement" && this.raiseRecoverable(s.value.params[0].start, "Setter cannot use rest params");
};
pp$5.parsePropertyValue = function(s, o, l, u, c, m, g, v) {
  (l || u) && this.type === types$1.colon && this.unexpected(), this.eat(types$1.colon) ? (s.value = o ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, g), s.kind = "init") : this.options.ecmaVersion >= 6 && this.type === types$1.parenL ? (o && this.unexpected(), s.kind = "init", s.method = !0, s.value = this.parseMethod(l, u)) : !o && !v && this.options.ecmaVersion >= 5 && !s.computed && s.key.type === "Identifier" && (s.key.name === "get" || s.key.name === "set") && this.type !== types$1.comma && this.type !== types$1.braceR && this.type !== types$1.eq ? ((l || u) && this.unexpected(), this.parseGetterSetter(s)) : this.options.ecmaVersion >= 6 && !s.computed && s.key.type === "Identifier" ? ((l || u) && this.unexpected(), this.checkUnreserved(s.key), s.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = c), s.kind = "init", o ? s.value = this.parseMaybeDefault(c, m, this.copyNode(s.key)) : this.type === types$1.eq && g ? (g.shorthandAssign < 0 && (g.shorthandAssign = this.start), s.value = this.parseMaybeDefault(c, m, this.copyNode(s.key))) : s.value = this.copyNode(s.key), s.shorthand = !0) : this.unexpected();
};
pp$5.parsePropertyName = function(s) {
  if (this.options.ecmaVersion >= 6) {
    if (this.eat(types$1.bracketL))
      return s.computed = !0, s.key = this.parseMaybeAssign(), this.expect(types$1.bracketR), s.key;
    s.computed = !1;
  }
  return s.key = this.type === types$1.num || this.type === types$1.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
};
pp$5.initFunction = function(s) {
  s.id = null, this.options.ecmaVersion >= 6 && (s.generator = s.expression = !1), this.options.ecmaVersion >= 8 && (s.async = !1);
};
pp$5.parseMethod = function(s, o, l) {
  var u = this.startNode(), c = this.yieldPos, m = this.awaitPos, g = this.awaitIdentPos;
  return this.initFunction(u), this.options.ecmaVersion >= 6 && (u.generator = s), this.options.ecmaVersion >= 8 && (u.async = !!o), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(functionFlags(o, u.generator) | SCOPE_SUPER | (l ? SCOPE_DIRECT_SUPER : 0)), this.expect(types$1.parenL), u.params = this.parseBindingList(types$1.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody(u, !1, !0, !1), this.yieldPos = c, this.awaitPos = m, this.awaitIdentPos = g, this.finishNode(u, "FunctionExpression");
};
pp$5.parseArrowExpression = function(s, o, l, u) {
  var c = this.yieldPos, m = this.awaitPos, g = this.awaitIdentPos;
  return this.enterScope(functionFlags(l, !1) | SCOPE_ARROW), this.initFunction(s), this.options.ecmaVersion >= 8 && (s.async = !!l), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, s.params = this.toAssignableList(o, !0), this.parseFunctionBody(s, !0, !1, u), this.yieldPos = c, this.awaitPos = m, this.awaitIdentPos = g, this.finishNode(s, "ArrowFunctionExpression");
};
pp$5.parseFunctionBody = function(s, o, l, u) {
  var c = o && this.type !== types$1.braceL, m = this.strict, g = !1;
  if (c)
    s.body = this.parseMaybeAssign(u), s.expression = !0, this.checkParams(s, !1);
  else {
    var v = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(s.params);
    (!m || v) && (g = this.strictDirective(this.end), g && v && this.raiseRecoverable(s.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
    var b = this.labels;
    this.labels = [], g && (this.strict = !0), this.checkParams(s, !m && !g && !o && !l && this.isSimpleParamList(s.params)), this.strict && s.id && this.checkLValSimple(s.id, BIND_OUTSIDE), s.body = this.parseBlock(!1, void 0, g && !m), s.expression = !1, this.adaptDirectivePrologue(s.body.body), this.labels = b;
  }
  this.exitScope();
};
pp$5.isSimpleParamList = function(s) {
  for (var o = 0, l = s; o < l.length; o += 1) {
    var u = l[o];
    if (u.type !== "Identifier")
      return !1;
  }
  return !0;
};
pp$5.checkParams = function(s, o) {
  for (var l = /* @__PURE__ */ Object.create(null), u = 0, c = s.params; u < c.length; u += 1) {
    var m = c[u];
    this.checkLValInnerPattern(m, BIND_VAR, o ? null : l);
  }
};
pp$5.parseExprList = function(s, o, l, u) {
  for (var c = [], m = !0; !this.eat(s); ) {
    if (m)
      m = !1;
    else if (this.expect(types$1.comma), o && this.afterTrailingComma(s))
      break;
    var g = void 0;
    l && this.type === types$1.comma ? g = null : this.type === types$1.ellipsis ? (g = this.parseSpread(u), u && this.type === types$1.comma && u.trailingComma < 0 && (u.trailingComma = this.start)) : g = this.parseMaybeAssign(!1, u), c.push(g);
  }
  return c;
};
pp$5.checkUnreserved = function(s) {
  var o = s.start, l = s.end, u = s.name;
  if (this.inGenerator && u === "yield" && this.raiseRecoverable(o, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && u === "await" && this.raiseRecoverable(o, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && u === "arguments" && this.raiseRecoverable(o, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && (u === "arguments" || u === "await") && this.raise(o, "Cannot use " + u + " in class static initialization block"), this.keywords.test(u) && this.raise(o, "Unexpected keyword '" + u + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(o, l).indexOf("\\") !== -1)) {
    var c = this.strict ? this.reservedWordsStrict : this.reservedWords;
    c.test(u) && (!this.inAsync && u === "await" && this.raiseRecoverable(o, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(o, "The keyword '" + u + "' is reserved"));
  }
};
pp$5.parseIdent = function(s) {
  var o = this.parseIdentNode();
  return this.next(!!s), this.finishNode(o, "Identifier"), s || (this.checkUnreserved(o), o.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = o.start)), o;
};
pp$5.parseIdentNode = function() {
  var s = this.startNode();
  return this.type === types$1.name ? s.name = this.value : this.type.keyword ? (s.name = this.type.keyword, (s.name === "class" || s.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = types$1.name) : this.unexpected(), s;
};
pp$5.parsePrivateIdent = function() {
  var s = this.startNode();
  return this.type === types$1.privateId ? s.name = this.value : this.unexpected(), this.next(), this.finishNode(s, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(s.start, "Private field '#" + s.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(s)), s;
};
pp$5.parseYield = function(s) {
  this.yieldPos || (this.yieldPos = this.start);
  var o = this.startNode();
  return this.next(), this.type === types$1.semi || this.canInsertSemicolon() || this.type !== types$1.star && !this.type.startsExpr ? (o.delegate = !1, o.argument = null) : (o.delegate = this.eat(types$1.star), o.argument = this.parseMaybeAssign(s)), this.finishNode(o, "YieldExpression");
};
pp$5.parseAwait = function(s) {
  this.awaitPos || (this.awaitPos = this.start);
  var o = this.startNode();
  return this.next(), o.argument = this.parseMaybeUnary(null, !0, !1, s), this.finishNode(o, "AwaitExpression");
};
var pp$4 = Parser.prototype;
pp$4.raise = function(s, o) {
  var l = getLineInfo(this.input, s);
  o += " (" + l.line + ":" + l.column + ")";
  var u = new SyntaxError(o);
  throw u.pos = s, u.loc = l, u.raisedAt = this.pos, u;
};
pp$4.raiseRecoverable = pp$4.raise;
pp$4.curPosition = function() {
  if (this.options.locations)
    return new Position(this.curLine, this.pos - this.lineStart);
};
var pp$3 = Parser.prototype, Scope$1 = function s(o) {
  this.flags = o, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
};
pp$3.enterScope = function(s) {
  this.scopeStack.push(new Scope$1(s));
};
pp$3.exitScope = function() {
  this.scopeStack.pop();
};
pp$3.treatFunctionsAsVarInScope = function(s) {
  return s.flags & SCOPE_FUNCTION || !this.inModule && s.flags & SCOPE_TOP;
};
pp$3.declareName = function(s, o, l) {
  var u = !1;
  if (o === BIND_LEXICAL) {
    var c = this.currentScope();
    u = c.lexical.indexOf(s) > -1 || c.functions.indexOf(s) > -1 || c.var.indexOf(s) > -1, c.lexical.push(s), this.inModule && c.flags & SCOPE_TOP && delete this.undefinedExports[s];
  } else if (o === BIND_SIMPLE_CATCH) {
    var m = this.currentScope();
    m.lexical.push(s);
  } else if (o === BIND_FUNCTION) {
    var g = this.currentScope();
    this.treatFunctionsAsVar ? u = g.lexical.indexOf(s) > -1 : u = g.lexical.indexOf(s) > -1 || g.var.indexOf(s) > -1, g.functions.push(s);
  } else
    for (var v = this.scopeStack.length - 1; v >= 0; --v) {
      var b = this.scopeStack[v];
      if (b.lexical.indexOf(s) > -1 && !(b.flags & SCOPE_SIMPLE_CATCH && b.lexical[0] === s) || !this.treatFunctionsAsVarInScope(b) && b.functions.indexOf(s) > -1) {
        u = !0;
        break;
      }
      if (b.var.push(s), this.inModule && b.flags & SCOPE_TOP && delete this.undefinedExports[s], b.flags & SCOPE_VAR)
        break;
    }
  u && this.raiseRecoverable(l, "Identifier '" + s + "' has already been declared");
};
pp$3.checkLocalExport = function(s) {
  this.scopeStack[0].lexical.indexOf(s.name) === -1 && this.scopeStack[0].var.indexOf(s.name) === -1 && (this.undefinedExports[s.name] = s);
};
pp$3.currentScope = function() {
  return this.scopeStack[this.scopeStack.length - 1];
};
pp$3.currentVarScope = function() {
  for (var s = this.scopeStack.length - 1; ; s--) {
    var o = this.scopeStack[s];
    if (o.flags & SCOPE_VAR)
      return o;
  }
};
pp$3.currentThisScope = function() {
  for (var s = this.scopeStack.length - 1; ; s--) {
    var o = this.scopeStack[s];
    if (o.flags & SCOPE_VAR && !(o.flags & SCOPE_ARROW))
      return o;
  }
};
var Node = function s(o, l, u) {
  this.type = "", this.start = l, this.end = 0, o.options.locations && (this.loc = new SourceLocation(o, u)), o.options.directSourceFile && (this.sourceFile = o.options.directSourceFile), o.options.ranges && (this.range = [l, 0]);
}, pp$2 = Parser.prototype;
pp$2.startNode = function() {
  return new Node(this, this.start, this.startLoc);
};
pp$2.startNodeAt = function(s, o) {
  return new Node(this, s, o);
};
function finishNodeAt(s, o, l, u) {
  return s.type = o, s.end = l, this.options.locations && (s.loc.end = u), this.options.ranges && (s.range[1] = l), s;
}
pp$2.finishNode = function(s, o) {
  return finishNodeAt.call(this, s, o, this.lastTokEnd, this.lastTokEndLoc);
};
pp$2.finishNodeAt = function(s, o, l, u) {
  return finishNodeAt.call(this, s, o, l, u);
};
pp$2.copyNode = function(s) {
  var o = new Node(this, s.start, this.startLoc);
  for (var l in s)
    o[l] = s[l];
  return o;
};
var ecma9BinaryProperties = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", ecma10BinaryProperties = ecma9BinaryProperties + " Extended_Pictographic", ecma11BinaryProperties = ecma10BinaryProperties, ecma12BinaryProperties = ecma11BinaryProperties + " EBase EComp EMod EPres ExtPict", ecma13BinaryProperties = ecma12BinaryProperties, ecma14BinaryProperties = ecma13BinaryProperties, unicodeBinaryProperties = {
  9: ecma9BinaryProperties,
  10: ecma10BinaryProperties,
  11: ecma11BinaryProperties,
  12: ecma12BinaryProperties,
  13: ecma13BinaryProperties,
  14: ecma14BinaryProperties
}, ecma14BinaryPropertiesOfStrings = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", unicodeBinaryPropertiesOfStrings = {
  9: "",
  10: "",
  11: "",
  12: "",
  13: "",
  14: ecma14BinaryPropertiesOfStrings
}, unicodeGeneralCategoryValues = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", ecma9ScriptValues = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", ecma10ScriptValues = ecma9ScriptValues + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", ecma11ScriptValues = ecma10ScriptValues + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", ecma12ScriptValues = ecma11ScriptValues + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", ecma13ScriptValues = ecma12ScriptValues + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", ecma14ScriptValues = ecma13ScriptValues + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", unicodeScriptValues = {
  9: ecma9ScriptValues,
  10: ecma10ScriptValues,
  11: ecma11ScriptValues,
  12: ecma12ScriptValues,
  13: ecma13ScriptValues,
  14: ecma14ScriptValues
}, data = {};
function buildUnicodeData(s) {
  var o = data[s] = {
    binary: wordsRegexp(unicodeBinaryProperties[s] + " " + unicodeGeneralCategoryValues),
    binaryOfStrings: wordsRegexp(unicodeBinaryPropertiesOfStrings[s]),
    nonBinary: {
      General_Category: wordsRegexp(unicodeGeneralCategoryValues),
      Script: wordsRegexp(unicodeScriptValues[s])
    }
  };
  o.nonBinary.Script_Extensions = o.nonBinary.Script, o.nonBinary.gc = o.nonBinary.General_Category, o.nonBinary.sc = o.nonBinary.Script, o.nonBinary.scx = o.nonBinary.Script_Extensions;
}
for (var i = 0, list$3 = [9, 10, 11, 12, 13, 14]; i < list$3.length; i += 1) {
  var ecmaVersion = list$3[i];
  buildUnicodeData(ecmaVersion);
}
var pp$1 = Parser.prototype, RegExpValidationState = function s(o) {
  this.parser = o, this.validFlags = "gim" + (o.options.ecmaVersion >= 6 ? "uy" : "") + (o.options.ecmaVersion >= 9 ? "s" : "") + (o.options.ecmaVersion >= 13 ? "d" : "") + (o.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = data[o.options.ecmaVersion >= 14 ? 14 : o.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
};
RegExpValidationState.prototype.reset = function s(o, l, u) {
  var c = u.indexOf("v") !== -1, m = u.indexOf("u") !== -1;
  this.start = o | 0, this.source = l + "", this.flags = u, c && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = m && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = m && this.parser.options.ecmaVersion >= 9);
};
RegExpValidationState.prototype.raise = function s(o) {
  this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + o);
};
RegExpValidationState.prototype.at = function s(o, l) {
  l === void 0 && (l = !1);
  var u = this.source, c = u.length;
  if (o >= c)
    return -1;
  var m = u.charCodeAt(o);
  if (!(l || this.switchU) || m <= 55295 || m >= 57344 || o + 1 >= c)
    return m;
  var g = u.charCodeAt(o + 1);
  return g >= 56320 && g <= 57343 ? (m << 10) + g - 56613888 : m;
};
RegExpValidationState.prototype.nextIndex = function s(o, l) {
  l === void 0 && (l = !1);
  var u = this.source, c = u.length;
  if (o >= c)
    return c;
  var m = u.charCodeAt(o), g;
  return !(l || this.switchU) || m <= 55295 || m >= 57344 || o + 1 >= c || (g = u.charCodeAt(o + 1)) < 56320 || g > 57343 ? o + 1 : o + 2;
};
RegExpValidationState.prototype.current = function s(o) {
  return o === void 0 && (o = !1), this.at(this.pos, o);
};
RegExpValidationState.prototype.lookahead = function s(o) {
  return o === void 0 && (o = !1), this.at(this.nextIndex(this.pos, o), o);
};
RegExpValidationState.prototype.advance = function s(o) {
  o === void 0 && (o = !1), this.pos = this.nextIndex(this.pos, o);
};
RegExpValidationState.prototype.eat = function s(o, l) {
  return l === void 0 && (l = !1), this.current(l) === o ? (this.advance(l), !0) : !1;
};
RegExpValidationState.prototype.eatChars = function s(o, l) {
  l === void 0 && (l = !1);
  for (var u = this.pos, c = 0, m = o; c < m.length; c += 1) {
    var g = m[c], v = this.at(u, l);
    if (v === -1 || v !== g)
      return !1;
    u = this.nextIndex(u, l);
  }
  return this.pos = u, !0;
};
pp$1.validateRegExpFlags = function(s) {
  for (var o = s.validFlags, l = s.flags, u = !1, c = !1, m = 0; m < l.length; m++) {
    var g = l.charAt(m);
    o.indexOf(g) === -1 && this.raise(s.start, "Invalid regular expression flag"), l.indexOf(g, m + 1) > -1 && this.raise(s.start, "Duplicate regular expression flag"), g === "u" && (u = !0), g === "v" && (c = !0);
  }
  this.options.ecmaVersion >= 15 && u && c && this.raise(s.start, "Invalid regular expression flag");
};
pp$1.validateRegExpPattern = function(s) {
  this.regexp_pattern(s), !s.switchN && this.options.ecmaVersion >= 9 && s.groupNames.length > 0 && (s.switchN = !0, this.regexp_pattern(s));
};
pp$1.regexp_pattern = function(s) {
  s.pos = 0, s.lastIntValue = 0, s.lastStringValue = "", s.lastAssertionIsQuantifiable = !1, s.numCapturingParens = 0, s.maxBackReference = 0, s.groupNames.length = 0, s.backReferenceNames.length = 0, this.regexp_disjunction(s), s.pos !== s.source.length && (s.eat(
    41
    /* ) */
  ) && s.raise("Unmatched ')'"), (s.eat(
    93
    /* ] */
  ) || s.eat(
    125
    /* } */
  )) && s.raise("Lone quantifier brackets")), s.maxBackReference > s.numCapturingParens && s.raise("Invalid escape");
  for (var o = 0, l = s.backReferenceNames; o < l.length; o += 1) {
    var u = l[o];
    s.groupNames.indexOf(u) === -1 && s.raise("Invalid named capture referenced");
  }
};
pp$1.regexp_disjunction = function(s) {
  for (this.regexp_alternative(s); s.eat(
    124
    /* | */
  ); )
    this.regexp_alternative(s);
  this.regexp_eatQuantifier(s, !0) && s.raise("Nothing to repeat"), s.eat(
    123
    /* { */
  ) && s.raise("Lone quantifier brackets");
};
pp$1.regexp_alternative = function(s) {
  for (; s.pos < s.source.length && this.regexp_eatTerm(s); )
    ;
};
pp$1.regexp_eatTerm = function(s) {
  return this.regexp_eatAssertion(s) ? (s.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(s) && s.switchU && s.raise("Invalid quantifier"), !0) : (s.switchU ? this.regexp_eatAtom(s) : this.regexp_eatExtendedAtom(s)) ? (this.regexp_eatQuantifier(s), !0) : !1;
};
pp$1.regexp_eatAssertion = function(s) {
  var o = s.pos;
  if (s.lastAssertionIsQuantifiable = !1, s.eat(
    94
    /* ^ */
  ) || s.eat(
    36
    /* $ */
  ))
    return !0;
  if (s.eat(
    92
    /* \ */
  )) {
    if (s.eat(
      66
      /* B */
    ) || s.eat(
      98
      /* b */
    ))
      return !0;
    s.pos = o;
  }
  if (s.eat(
    40
    /* ( */
  ) && s.eat(
    63
    /* ? */
  )) {
    var l = !1;
    if (this.options.ecmaVersion >= 9 && (l = s.eat(
      60
      /* < */
    )), s.eat(
      61
      /* = */
    ) || s.eat(
      33
      /* ! */
    ))
      return this.regexp_disjunction(s), s.eat(
        41
        /* ) */
      ) || s.raise("Unterminated group"), s.lastAssertionIsQuantifiable = !l, !0;
  }
  return s.pos = o, !1;
};
pp$1.regexp_eatQuantifier = function(s, o) {
  return o === void 0 && (o = !1), this.regexp_eatQuantifierPrefix(s, o) ? (s.eat(
    63
    /* ? */
  ), !0) : !1;
};
pp$1.regexp_eatQuantifierPrefix = function(s, o) {
  return s.eat(
    42
    /* * */
  ) || s.eat(
    43
    /* + */
  ) || s.eat(
    63
    /* ? */
  ) || this.regexp_eatBracedQuantifier(s, o);
};
pp$1.regexp_eatBracedQuantifier = function(s, o) {
  var l = s.pos;
  if (s.eat(
    123
    /* { */
  )) {
    var u = 0, c = -1;
    if (this.regexp_eatDecimalDigits(s) && (u = s.lastIntValue, s.eat(
      44
      /* , */
    ) && this.regexp_eatDecimalDigits(s) && (c = s.lastIntValue), s.eat(
      125
      /* } */
    )))
      return c !== -1 && c < u && !o && s.raise("numbers out of order in {} quantifier"), !0;
    s.switchU && !o && s.raise("Incomplete quantifier"), s.pos = l;
  }
  return !1;
};
pp$1.regexp_eatAtom = function(s) {
  return this.regexp_eatPatternCharacters(s) || s.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(s) || this.regexp_eatCharacterClass(s) || this.regexp_eatUncapturingGroup(s) || this.regexp_eatCapturingGroup(s);
};
pp$1.regexp_eatReverseSolidusAtomEscape = function(s) {
  var o = s.pos;
  if (s.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatAtomEscape(s))
      return !0;
    s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatUncapturingGroup = function(s) {
  var o = s.pos;
  if (s.eat(
    40
    /* ( */
  )) {
    if (s.eat(
      63
      /* ? */
    ) && s.eat(
      58
      /* : */
    )) {
      if (this.regexp_disjunction(s), s.eat(
        41
        /* ) */
      ))
        return !0;
      s.raise("Unterminated group");
    }
    s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatCapturingGroup = function(s) {
  if (s.eat(
    40
    /* ( */
  )) {
    if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(s) : s.current() === 63 && s.raise("Invalid group"), this.regexp_disjunction(s), s.eat(
      41
      /* ) */
    ))
      return s.numCapturingParens += 1, !0;
    s.raise("Unterminated group");
  }
  return !1;
};
pp$1.regexp_eatExtendedAtom = function(s) {
  return s.eat(
    46
    /* . */
  ) || this.regexp_eatReverseSolidusAtomEscape(s) || this.regexp_eatCharacterClass(s) || this.regexp_eatUncapturingGroup(s) || this.regexp_eatCapturingGroup(s) || this.regexp_eatInvalidBracedQuantifier(s) || this.regexp_eatExtendedPatternCharacter(s);
};
pp$1.regexp_eatInvalidBracedQuantifier = function(s) {
  return this.regexp_eatBracedQuantifier(s, !0) && s.raise("Nothing to repeat"), !1;
};
pp$1.regexp_eatSyntaxCharacter = function(s) {
  var o = s.current();
  return isSyntaxCharacter(o) ? (s.lastIntValue = o, s.advance(), !0) : !1;
};
function isSyntaxCharacter(s) {
  return s === 36 || s >= 40 && s <= 43 || s === 46 || s === 63 || s >= 91 && s <= 94 || s >= 123 && s <= 125;
}
pp$1.regexp_eatPatternCharacters = function(s) {
  for (var o = s.pos, l = 0; (l = s.current()) !== -1 && !isSyntaxCharacter(l); )
    s.advance();
  return s.pos !== o;
};
pp$1.regexp_eatExtendedPatternCharacter = function(s) {
  var o = s.current();
  return o !== -1 && o !== 36 && !(o >= 40 && o <= 43) && o !== 46 && o !== 63 && o !== 91 && o !== 94 && o !== 124 ? (s.advance(), !0) : !1;
};
pp$1.regexp_groupSpecifier = function(s) {
  if (s.eat(
    63
    /* ? */
  )) {
    if (this.regexp_eatGroupName(s)) {
      s.groupNames.indexOf(s.lastStringValue) !== -1 && s.raise("Duplicate capture group name"), s.groupNames.push(s.lastStringValue);
      return;
    }
    s.raise("Invalid group");
  }
};
pp$1.regexp_eatGroupName = function(s) {
  if (s.lastStringValue = "", s.eat(
    60
    /* < */
  )) {
    if (this.regexp_eatRegExpIdentifierName(s) && s.eat(
      62
      /* > */
    ))
      return !0;
    s.raise("Invalid capture group name");
  }
  return !1;
};
pp$1.regexp_eatRegExpIdentifierName = function(s) {
  if (s.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(s)) {
    for (s.lastStringValue += codePointToString(s.lastIntValue); this.regexp_eatRegExpIdentifierPart(s); )
      s.lastStringValue += codePointToString(s.lastIntValue);
    return !0;
  }
  return !1;
};
pp$1.regexp_eatRegExpIdentifierStart = function(s) {
  var o = s.pos, l = this.options.ecmaVersion >= 11, u = s.current(l);
  return s.advance(l), u === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(s, l) && (u = s.lastIntValue), isRegExpIdentifierStart(u) ? (s.lastIntValue = u, !0) : (s.pos = o, !1);
};
function isRegExpIdentifierStart(s) {
  return isIdentifierStart(s, !0) || s === 36 || s === 95;
}
pp$1.regexp_eatRegExpIdentifierPart = function(s) {
  var o = s.pos, l = this.options.ecmaVersion >= 11, u = s.current(l);
  return s.advance(l), u === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(s, l) && (u = s.lastIntValue), isRegExpIdentifierPart(u) ? (s.lastIntValue = u, !0) : (s.pos = o, !1);
};
function isRegExpIdentifierPart(s) {
  return isIdentifierChar(s, !0) || s === 36 || s === 95 || s === 8204 || s === 8205;
}
pp$1.regexp_eatAtomEscape = function(s) {
  return this.regexp_eatBackReference(s) || this.regexp_eatCharacterClassEscape(s) || this.regexp_eatCharacterEscape(s) || s.switchN && this.regexp_eatKGroupName(s) ? !0 : (s.switchU && (s.current() === 99 && s.raise("Invalid unicode escape"), s.raise("Invalid escape")), !1);
};
pp$1.regexp_eatBackReference = function(s) {
  var o = s.pos;
  if (this.regexp_eatDecimalEscape(s)) {
    var l = s.lastIntValue;
    if (s.switchU)
      return l > s.maxBackReference && (s.maxBackReference = l), !0;
    if (l <= s.numCapturingParens)
      return !0;
    s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatKGroupName = function(s) {
  if (s.eat(
    107
    /* k */
  )) {
    if (this.regexp_eatGroupName(s))
      return s.backReferenceNames.push(s.lastStringValue), !0;
    s.raise("Invalid named reference");
  }
  return !1;
};
pp$1.regexp_eatCharacterEscape = function(s) {
  return this.regexp_eatControlEscape(s) || this.regexp_eatCControlLetter(s) || this.regexp_eatZero(s) || this.regexp_eatHexEscapeSequence(s) || this.regexp_eatRegExpUnicodeEscapeSequence(s, !1) || !s.switchU && this.regexp_eatLegacyOctalEscapeSequence(s) || this.regexp_eatIdentityEscape(s);
};
pp$1.regexp_eatCControlLetter = function(s) {
  var o = s.pos;
  if (s.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatControlLetter(s))
      return !0;
    s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatZero = function(s) {
  return s.current() === 48 && !isDecimalDigit(s.lookahead()) ? (s.lastIntValue = 0, s.advance(), !0) : !1;
};
pp$1.regexp_eatControlEscape = function(s) {
  var o = s.current();
  return o === 116 ? (s.lastIntValue = 9, s.advance(), !0) : o === 110 ? (s.lastIntValue = 10, s.advance(), !0) : o === 118 ? (s.lastIntValue = 11, s.advance(), !0) : o === 102 ? (s.lastIntValue = 12, s.advance(), !0) : o === 114 ? (s.lastIntValue = 13, s.advance(), !0) : !1;
};
pp$1.regexp_eatControlLetter = function(s) {
  var o = s.current();
  return isControlLetter(o) ? (s.lastIntValue = o % 32, s.advance(), !0) : !1;
};
function isControlLetter(s) {
  return s >= 65 && s <= 90 || s >= 97 && s <= 122;
}
pp$1.regexp_eatRegExpUnicodeEscapeSequence = function(s, o) {
  o === void 0 && (o = !1);
  var l = s.pos, u = o || s.switchU;
  if (s.eat(
    117
    /* u */
  )) {
    if (this.regexp_eatFixedHexDigits(s, 4)) {
      var c = s.lastIntValue;
      if (u && c >= 55296 && c <= 56319) {
        var m = s.pos;
        if (s.eat(
          92
          /* \ */
        ) && s.eat(
          117
          /* u */
        ) && this.regexp_eatFixedHexDigits(s, 4)) {
          var g = s.lastIntValue;
          if (g >= 56320 && g <= 57343)
            return s.lastIntValue = (c - 55296) * 1024 + (g - 56320) + 65536, !0;
        }
        s.pos = m, s.lastIntValue = c;
      }
      return !0;
    }
    if (u && s.eat(
      123
      /* { */
    ) && this.regexp_eatHexDigits(s) && s.eat(
      125
      /* } */
    ) && isValidUnicode(s.lastIntValue))
      return !0;
    u && s.raise("Invalid unicode escape"), s.pos = l;
  }
  return !1;
};
function isValidUnicode(s) {
  return s >= 0 && s <= 1114111;
}
pp$1.regexp_eatIdentityEscape = function(s) {
  if (s.switchU)
    return this.regexp_eatSyntaxCharacter(s) ? !0 : s.eat(
      47
      /* / */
    ) ? (s.lastIntValue = 47, !0) : !1;
  var o = s.current();
  return o !== 99 && (!s.switchN || o !== 107) ? (s.lastIntValue = o, s.advance(), !0) : !1;
};
pp$1.regexp_eatDecimalEscape = function(s) {
  s.lastIntValue = 0;
  var o = s.current();
  if (o >= 49 && o <= 57) {
    do
      s.lastIntValue = 10 * s.lastIntValue + (o - 48), s.advance();
    while ((o = s.current()) >= 48 && o <= 57);
    return !0;
  }
  return !1;
};
var CharSetNone = 0, CharSetOk = 1, CharSetString = 2;
pp$1.regexp_eatCharacterClassEscape = function(s) {
  var o = s.current();
  if (isCharacterClassEscape(o))
    return s.lastIntValue = -1, s.advance(), CharSetOk;
  var l = !1;
  if (s.switchU && this.options.ecmaVersion >= 9 && ((l = o === 80) || o === 112)) {
    s.lastIntValue = -1, s.advance();
    var u;
    if (s.eat(
      123
      /* { */
    ) && (u = this.regexp_eatUnicodePropertyValueExpression(s)) && s.eat(
      125
      /* } */
    ))
      return l && u === CharSetString && s.raise("Invalid property name"), u;
    s.raise("Invalid property name");
  }
  return CharSetNone;
};
function isCharacterClassEscape(s) {
  return s === 100 || s === 68 || s === 115 || s === 83 || s === 119 || s === 87;
}
pp$1.regexp_eatUnicodePropertyValueExpression = function(s) {
  var o = s.pos;
  if (this.regexp_eatUnicodePropertyName(s) && s.eat(
    61
    /* = */
  )) {
    var l = s.lastStringValue;
    if (this.regexp_eatUnicodePropertyValue(s)) {
      var u = s.lastStringValue;
      return this.regexp_validateUnicodePropertyNameAndValue(s, l, u), CharSetOk;
    }
  }
  if (s.pos = o, this.regexp_eatLoneUnicodePropertyNameOrValue(s)) {
    var c = s.lastStringValue;
    return this.regexp_validateUnicodePropertyNameOrValue(s, c);
  }
  return CharSetNone;
};
pp$1.regexp_validateUnicodePropertyNameAndValue = function(s, o, l) {
  hasOwn$1(s.unicodeProperties.nonBinary, o) || s.raise("Invalid property name"), s.unicodeProperties.nonBinary[o].test(l) || s.raise("Invalid property value");
};
pp$1.regexp_validateUnicodePropertyNameOrValue = function(s, o) {
  if (s.unicodeProperties.binary.test(o))
    return CharSetOk;
  if (s.switchV && s.unicodeProperties.binaryOfStrings.test(o))
    return CharSetString;
  s.raise("Invalid property name");
};
pp$1.regexp_eatUnicodePropertyName = function(s) {
  var o = 0;
  for (s.lastStringValue = ""; isUnicodePropertyNameCharacter(o = s.current()); )
    s.lastStringValue += codePointToString(o), s.advance();
  return s.lastStringValue !== "";
};
function isUnicodePropertyNameCharacter(s) {
  return isControlLetter(s) || s === 95;
}
pp$1.regexp_eatUnicodePropertyValue = function(s) {
  var o = 0;
  for (s.lastStringValue = ""; isUnicodePropertyValueCharacter(o = s.current()); )
    s.lastStringValue += codePointToString(o), s.advance();
  return s.lastStringValue !== "";
};
function isUnicodePropertyValueCharacter(s) {
  return isUnicodePropertyNameCharacter(s) || isDecimalDigit(s);
}
pp$1.regexp_eatLoneUnicodePropertyNameOrValue = function(s) {
  return this.regexp_eatUnicodePropertyValue(s);
};
pp$1.regexp_eatCharacterClass = function(s) {
  if (s.eat(
    91
    /* [ */
  )) {
    var o = s.eat(
      94
      /* ^ */
    ), l = this.regexp_classContents(s);
    return s.eat(
      93
      /* ] */
    ) || s.raise("Unterminated character class"), o && l === CharSetString && s.raise("Negated character class may contain strings"), !0;
  }
  return !1;
};
pp$1.regexp_classContents = function(s) {
  return s.current() === 93 ? CharSetOk : s.switchV ? this.regexp_classSetExpression(s) : (this.regexp_nonEmptyClassRanges(s), CharSetOk);
};
pp$1.regexp_nonEmptyClassRanges = function(s) {
  for (; this.regexp_eatClassAtom(s); ) {
    var o = s.lastIntValue;
    if (s.eat(
      45
      /* - */
    ) && this.regexp_eatClassAtom(s)) {
      var l = s.lastIntValue;
      s.switchU && (o === -1 || l === -1) && s.raise("Invalid character class"), o !== -1 && l !== -1 && o > l && s.raise("Range out of order in character class");
    }
  }
};
pp$1.regexp_eatClassAtom = function(s) {
  var o = s.pos;
  if (s.eat(
    92
    /* \ */
  )) {
    if (this.regexp_eatClassEscape(s))
      return !0;
    if (s.switchU) {
      var l = s.current();
      (l === 99 || isOctalDigit(l)) && s.raise("Invalid class escape"), s.raise("Invalid escape");
    }
    s.pos = o;
  }
  var u = s.current();
  return u !== 93 ? (s.lastIntValue = u, s.advance(), !0) : !1;
};
pp$1.regexp_eatClassEscape = function(s) {
  var o = s.pos;
  if (s.eat(
    98
    /* b */
  ))
    return s.lastIntValue = 8, !0;
  if (s.switchU && s.eat(
    45
    /* - */
  ))
    return s.lastIntValue = 45, !0;
  if (!s.switchU && s.eat(
    99
    /* c */
  )) {
    if (this.regexp_eatClassControlLetter(s))
      return !0;
    s.pos = o;
  }
  return this.regexp_eatCharacterClassEscape(s) || this.regexp_eatCharacterEscape(s);
};
pp$1.regexp_classSetExpression = function(s) {
  var o = CharSetOk, l;
  if (!this.regexp_eatClassSetRange(s)) if (l = this.regexp_eatClassSetOperand(s)) {
    l === CharSetString && (o = CharSetString);
    for (var u = s.pos; s.eatChars(
      [38, 38]
      /* && */
    ); ) {
      if (s.current() !== 38 && (l = this.regexp_eatClassSetOperand(s))) {
        l !== CharSetString && (o = CharSetOk);
        continue;
      }
      s.raise("Invalid character in character class");
    }
    if (u !== s.pos)
      return o;
    for (; s.eatChars(
      [45, 45]
      /* -- */
    ); )
      this.regexp_eatClassSetOperand(s) || s.raise("Invalid character in character class");
    if (u !== s.pos)
      return o;
  } else
    s.raise("Invalid character in character class");
  for (; ; )
    if (!this.regexp_eatClassSetRange(s)) {
      if (l = this.regexp_eatClassSetOperand(s), !l)
        return o;
      l === CharSetString && (o = CharSetString);
    }
};
pp$1.regexp_eatClassSetRange = function(s) {
  var o = s.pos;
  if (this.regexp_eatClassSetCharacter(s)) {
    var l = s.lastIntValue;
    if (s.eat(
      45
      /* - */
    ) && this.regexp_eatClassSetCharacter(s)) {
      var u = s.lastIntValue;
      return l !== -1 && u !== -1 && l > u && s.raise("Range out of order in character class"), !0;
    }
    s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatClassSetOperand = function(s) {
  return this.regexp_eatClassSetCharacter(s) ? CharSetOk : this.regexp_eatClassStringDisjunction(s) || this.regexp_eatNestedClass(s);
};
pp$1.regexp_eatNestedClass = function(s) {
  var o = s.pos;
  if (s.eat(
    91
    /* [ */
  )) {
    var l = s.eat(
      94
      /* ^ */
    ), u = this.regexp_classContents(s);
    if (s.eat(
      93
      /* ] */
    ))
      return l && u === CharSetString && s.raise("Negated character class may contain strings"), u;
    s.pos = o;
  }
  if (s.eat(
    92
    /* \ */
  )) {
    var c = this.regexp_eatCharacterClassEscape(s);
    if (c)
      return c;
    s.pos = o;
  }
  return null;
};
pp$1.regexp_eatClassStringDisjunction = function(s) {
  var o = s.pos;
  if (s.eatChars(
    [92, 113]
    /* \q */
  )) {
    if (s.eat(
      123
      /* { */
    )) {
      var l = this.regexp_classStringDisjunctionContents(s);
      if (s.eat(
        125
        /* } */
      ))
        return l;
    } else
      s.raise("Invalid escape");
    s.pos = o;
  }
  return null;
};
pp$1.regexp_classStringDisjunctionContents = function(s) {
  for (var o = this.regexp_classString(s); s.eat(
    124
    /* | */
  ); )
    this.regexp_classString(s) === CharSetString && (o = CharSetString);
  return o;
};
pp$1.regexp_classString = function(s) {
  for (var o = 0; this.regexp_eatClassSetCharacter(s); )
    o++;
  return o === 1 ? CharSetOk : CharSetString;
};
pp$1.regexp_eatClassSetCharacter = function(s) {
  var o = s.pos;
  if (s.eat(
    92
    /* \ */
  ))
    return this.regexp_eatCharacterEscape(s) || this.regexp_eatClassSetReservedPunctuator(s) ? !0 : s.eat(
      98
      /* b */
    ) ? (s.lastIntValue = 8, !0) : (s.pos = o, !1);
  var l = s.current();
  return l < 0 || l === s.lookahead() && isClassSetReservedDoublePunctuatorCharacter(l) || isClassSetSyntaxCharacter(l) ? !1 : (s.advance(), s.lastIntValue = l, !0);
};
function isClassSetReservedDoublePunctuatorCharacter(s) {
  return s === 33 || s >= 35 && s <= 38 || s >= 42 && s <= 44 || s === 46 || s >= 58 && s <= 64 || s === 94 || s === 96 || s === 126;
}
function isClassSetSyntaxCharacter(s) {
  return s === 40 || s === 41 || s === 45 || s === 47 || s >= 91 && s <= 93 || s >= 123 && s <= 125;
}
pp$1.regexp_eatClassSetReservedPunctuator = function(s) {
  var o = s.current();
  return isClassSetReservedPunctuator(o) ? (s.lastIntValue = o, s.advance(), !0) : !1;
};
function isClassSetReservedPunctuator(s) {
  return s === 33 || s === 35 || s === 37 || s === 38 || s === 44 || s === 45 || s >= 58 && s <= 62 || s === 64 || s === 96 || s === 126;
}
pp$1.regexp_eatClassControlLetter = function(s) {
  var o = s.current();
  return isDecimalDigit(o) || o === 95 ? (s.lastIntValue = o % 32, s.advance(), !0) : !1;
};
pp$1.regexp_eatHexEscapeSequence = function(s) {
  var o = s.pos;
  if (s.eat(
    120
    /* x */
  )) {
    if (this.regexp_eatFixedHexDigits(s, 2))
      return !0;
    s.switchU && s.raise("Invalid escape"), s.pos = o;
  }
  return !1;
};
pp$1.regexp_eatDecimalDigits = function(s) {
  var o = s.pos, l = 0;
  for (s.lastIntValue = 0; isDecimalDigit(l = s.current()); )
    s.lastIntValue = 10 * s.lastIntValue + (l - 48), s.advance();
  return s.pos !== o;
};
function isDecimalDigit(s) {
  return s >= 48 && s <= 57;
}
pp$1.regexp_eatHexDigits = function(s) {
  var o = s.pos, l = 0;
  for (s.lastIntValue = 0; isHexDigit(l = s.current()); )
    s.lastIntValue = 16 * s.lastIntValue + hexToInt(l), s.advance();
  return s.pos !== o;
};
function isHexDigit(s) {
  return s >= 48 && s <= 57 || s >= 65 && s <= 70 || s >= 97 && s <= 102;
}
function hexToInt(s) {
  return s >= 65 && s <= 70 ? 10 + (s - 65) : s >= 97 && s <= 102 ? 10 + (s - 97) : s - 48;
}
pp$1.regexp_eatLegacyOctalEscapeSequence = function(s) {
  if (this.regexp_eatOctalDigit(s)) {
    var o = s.lastIntValue;
    if (this.regexp_eatOctalDigit(s)) {
      var l = s.lastIntValue;
      o <= 3 && this.regexp_eatOctalDigit(s) ? s.lastIntValue = o * 64 + l * 8 + s.lastIntValue : s.lastIntValue = o * 8 + l;
    } else
      s.lastIntValue = o;
    return !0;
  }
  return !1;
};
pp$1.regexp_eatOctalDigit = function(s) {
  var o = s.current();
  return isOctalDigit(o) ? (s.lastIntValue = o - 48, s.advance(), !0) : (s.lastIntValue = 0, !1);
};
function isOctalDigit(s) {
  return s >= 48 && s <= 55;
}
pp$1.regexp_eatFixedHexDigits = function(s, o) {
  var l = s.pos;
  s.lastIntValue = 0;
  for (var u = 0; u < o; ++u) {
    var c = s.current();
    if (!isHexDigit(c))
      return s.pos = l, !1;
    s.lastIntValue = 16 * s.lastIntValue + hexToInt(c), s.advance();
  }
  return !0;
};
var Token = function s(o) {
  this.type = o.type, this.value = o.value, this.start = o.start, this.end = o.end, o.options.locations && (this.loc = new SourceLocation(o, o.startLoc, o.endLoc)), o.options.ranges && (this.range = [o.start, o.end]);
}, pp = Parser.prototype;
pp.next = function(s) {
  !s && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Token(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
};
pp.getToken = function() {
  return this.next(), new Token(this);
};
typeof Symbol < "u" && (pp[Symbol.iterator] = function() {
  var s = this;
  return {
    next: function() {
      var o = s.getToken();
      return {
        done: o.type === types$1.eof,
        value: o
      };
    }
  };
});
pp.nextToken = function() {
  var s = this.curContext();
  if ((!s || !s.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
    return this.finishToken(types$1.eof);
  if (s.override)
    return s.override(this);
  this.readToken(this.fullCharCodeAtPos());
};
pp.readToken = function(s) {
  return isIdentifierStart(s, this.options.ecmaVersion >= 6) || s === 92 ? this.readWord() : this.getTokenFromCode(s);
};
pp.fullCharCodeAtPos = function() {
  var s = this.input.charCodeAt(this.pos);
  if (s <= 55295 || s >= 56320)
    return s;
  var o = this.input.charCodeAt(this.pos + 1);
  return o <= 56319 || o >= 57344 ? s : (s << 10) + o - 56613888;
};
pp.skipBlockComment = function() {
  var s = this.options.onComment && this.curPosition(), o = this.pos, l = this.input.indexOf("*/", this.pos += 2);
  if (l === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = l + 2, this.options.locations)
    for (var u = void 0, c = o; (u = nextLineBreak(this.input, c, this.pos)) > -1; )
      ++this.curLine, c = this.lineStart = u;
  this.options.onComment && this.options.onComment(
    !0,
    this.input.slice(o + 2, l),
    o,
    this.pos,
    s,
    this.curPosition()
  );
};
pp.skipLineComment = function(s) {
  for (var o = this.pos, l = this.options.onComment && this.curPosition(), u = this.input.charCodeAt(this.pos += s); this.pos < this.input.length && !isNewLine(u); )
    u = this.input.charCodeAt(++this.pos);
  this.options.onComment && this.options.onComment(
    !1,
    this.input.slice(o + s, this.pos),
    o,
    this.pos,
    l,
    this.curPosition()
  );
};
pp.skipSpace = function() {
  e: for (; this.pos < this.input.length; ) {
    var s = this.input.charCodeAt(this.pos);
    switch (s) {
      case 32:
      case 160:
        ++this.pos;
        break;
      case 13:
        this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
      case 10:
      case 8232:
      case 8233:
        ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
        break;
      case 47:
        switch (this.input.charCodeAt(this.pos + 1)) {
          case 42:
            this.skipBlockComment();
            break;
          case 47:
            this.skipLineComment(2);
            break;
          default:
            break e;
        }
        break;
      default:
        if (s > 8 && s < 14 || s >= 5760 && nonASCIIwhitespace.test(String.fromCharCode(s)))
          ++this.pos;
        else
          break e;
    }
  }
};
pp.finishToken = function(s, o) {
  this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
  var l = this.type;
  this.type = s, this.value = o, this.updateContext(l);
};
pp.readToken_dot = function() {
  var s = this.input.charCodeAt(this.pos + 1);
  if (s >= 48 && s <= 57)
    return this.readNumber(!0);
  var o = this.input.charCodeAt(this.pos + 2);
  return this.options.ecmaVersion >= 6 && s === 46 && o === 46 ? (this.pos += 3, this.finishToken(types$1.ellipsis)) : (++this.pos, this.finishToken(types$1.dot));
};
pp.readToken_slash = function() {
  var s = this.input.charCodeAt(this.pos + 1);
  return this.exprAllowed ? (++this.pos, this.readRegexp()) : s === 61 ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.slash, 1);
};
pp.readToken_mult_modulo_exp = function(s) {
  var o = this.input.charCodeAt(this.pos + 1), l = 1, u = s === 42 ? types$1.star : types$1.modulo;
  return this.options.ecmaVersion >= 7 && s === 42 && o === 42 && (++l, u = types$1.starstar, o = this.input.charCodeAt(this.pos + 2)), o === 61 ? this.finishOp(types$1.assign, l + 1) : this.finishOp(u, l);
};
pp.readToken_pipe_amp = function(s) {
  var o = this.input.charCodeAt(this.pos + 1);
  if (o === s) {
    if (this.options.ecmaVersion >= 12) {
      var l = this.input.charCodeAt(this.pos + 2);
      if (l === 61)
        return this.finishOp(types$1.assign, 3);
    }
    return this.finishOp(s === 124 ? types$1.logicalOR : types$1.logicalAND, 2);
  }
  return o === 61 ? this.finishOp(types$1.assign, 2) : this.finishOp(s === 124 ? types$1.bitwiseOR : types$1.bitwiseAND, 1);
};
pp.readToken_caret = function() {
  var s = this.input.charCodeAt(this.pos + 1);
  return s === 61 ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.bitwiseXOR, 1);
};
pp.readToken_plus_min = function(s) {
  var o = this.input.charCodeAt(this.pos + 1);
  return o === s ? o === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || lineBreak.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(types$1.incDec, 2) : o === 61 ? this.finishOp(types$1.assign, 2) : this.finishOp(types$1.plusMin, 1);
};
pp.readToken_lt_gt = function(s) {
  var o = this.input.charCodeAt(this.pos + 1), l = 1;
  return o === s ? (l = s === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + l) === 61 ? this.finishOp(types$1.assign, l + 1) : this.finishOp(types$1.bitShift, l)) : o === 33 && s === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (o === 61 && (l = 2), this.finishOp(types$1.relational, l));
};
pp.readToken_eq_excl = function(s) {
  var o = this.input.charCodeAt(this.pos + 1);
  return o === 61 ? this.finishOp(types$1.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : s === 61 && o === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(types$1.arrow)) : this.finishOp(s === 61 ? types$1.eq : types$1.prefix, 1);
};
pp.readToken_question = function() {
  var s = this.options.ecmaVersion;
  if (s >= 11) {
    var o = this.input.charCodeAt(this.pos + 1);
    if (o === 46) {
      var l = this.input.charCodeAt(this.pos + 2);
      if (l < 48 || l > 57)
        return this.finishOp(types$1.questionDot, 2);
    }
    if (o === 63) {
      if (s >= 12) {
        var u = this.input.charCodeAt(this.pos + 2);
        if (u === 61)
          return this.finishOp(types$1.assign, 3);
      }
      return this.finishOp(types$1.coalesce, 2);
    }
  }
  return this.finishOp(types$1.question, 1);
};
pp.readToken_numberSign = function() {
  var s = this.options.ecmaVersion, o = 35;
  if (s >= 13 && (++this.pos, o = this.fullCharCodeAtPos(), isIdentifierStart(o, !0) || o === 92))
    return this.finishToken(types$1.privateId, this.readWord1());
  this.raise(this.pos, "Unexpected character '" + codePointToString(o) + "'");
};
pp.getTokenFromCode = function(s) {
  switch (s) {
    case 46:
      return this.readToken_dot();
    case 40:
      return ++this.pos, this.finishToken(types$1.parenL);
    case 41:
      return ++this.pos, this.finishToken(types$1.parenR);
    case 59:
      return ++this.pos, this.finishToken(types$1.semi);
    case 44:
      return ++this.pos, this.finishToken(types$1.comma);
    case 91:
      return ++this.pos, this.finishToken(types$1.bracketL);
    case 93:
      return ++this.pos, this.finishToken(types$1.bracketR);
    case 123:
      return ++this.pos, this.finishToken(types$1.braceL);
    case 125:
      return ++this.pos, this.finishToken(types$1.braceR);
    case 58:
      return ++this.pos, this.finishToken(types$1.colon);
    case 96:
      if (this.options.ecmaVersion < 6)
        break;
      return ++this.pos, this.finishToken(types$1.backQuote);
    case 48:
      var o = this.input.charCodeAt(this.pos + 1);
      if (o === 120 || o === 88)
        return this.readRadixNumber(16);
      if (this.options.ecmaVersion >= 6) {
        if (o === 111 || o === 79)
          return this.readRadixNumber(8);
        if (o === 98 || o === 66)
          return this.readRadixNumber(2);
      }
    case 49:
    case 50:
    case 51:
    case 52:
    case 53:
    case 54:
    case 55:
    case 56:
    case 57:
      return this.readNumber(!1);
    case 34:
    case 39:
      return this.readString(s);
    case 47:
      return this.readToken_slash();
    case 37:
    case 42:
      return this.readToken_mult_modulo_exp(s);
    case 124:
    case 38:
      return this.readToken_pipe_amp(s);
    case 94:
      return this.readToken_caret();
    case 43:
    case 45:
      return this.readToken_plus_min(s);
    case 60:
    case 62:
      return this.readToken_lt_gt(s);
    case 61:
    case 33:
      return this.readToken_eq_excl(s);
    case 63:
      return this.readToken_question();
    case 126:
      return this.finishOp(types$1.prefix, 1);
    case 35:
      return this.readToken_numberSign();
  }
  this.raise(this.pos, "Unexpected character '" + codePointToString(s) + "'");
};
pp.finishOp = function(s, o) {
  var l = this.input.slice(this.pos, this.pos + o);
  return this.pos += o, this.finishToken(s, l);
};
pp.readRegexp = function() {
  for (var s, o, l = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(l, "Unterminated regular expression");
    var u = this.input.charAt(this.pos);
    if (lineBreak.test(u) && this.raise(l, "Unterminated regular expression"), s)
      s = !1;
    else {
      if (u === "[")
        o = !0;
      else if (u === "]" && o)
        o = !1;
      else if (u === "/" && !o)
        break;
      s = u === "\\";
    }
    ++this.pos;
  }
  var c = this.input.slice(l, this.pos);
  ++this.pos;
  var m = this.pos, g = this.readWord1();
  this.containsEsc && this.unexpected(m);
  var v = this.regexpState || (this.regexpState = new RegExpValidationState(this));
  v.reset(l, c, g), this.validateRegExpFlags(v), this.validateRegExpPattern(v);
  var b = null;
  try {
    b = new RegExp(c, g);
  } catch {
  }
  return this.finishToken(types$1.regexp, { pattern: c, flags: g, value: b });
};
pp.readInt = function(s, o, l) {
  for (var u = this.options.ecmaVersion >= 12 && o === void 0, c = l && this.input.charCodeAt(this.pos) === 48, m = this.pos, g = 0, v = 0, b = 0, S = o ?? 1 / 0; b < S; ++b, ++this.pos) {
    var E = this.input.charCodeAt(this.pos), P = void 0;
    if (u && E === 95) {
      c && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), v === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), b === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), v = E;
      continue;
    }
    if (E >= 97 ? P = E - 97 + 10 : E >= 65 ? P = E - 65 + 10 : E >= 48 && E <= 57 ? P = E - 48 : P = 1 / 0, P >= s)
      break;
    v = E, g = g * s + P;
  }
  return u && v === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === m || o != null && this.pos - m !== o ? null : g;
};
function stringToNumber(s, o) {
  return o ? parseInt(s, 8) : parseFloat(s.replace(/_/g, ""));
}
function stringToBigInt(s) {
  return typeof BigInt != "function" ? null : BigInt(s.replace(/_/g, ""));
}
pp.readRadixNumber = function(s) {
  var o = this.pos;
  this.pos += 2;
  var l = this.readInt(s);
  return l == null && this.raise(this.start + 2, "Expected number in radix " + s), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (l = stringToBigInt(this.input.slice(o, this.pos)), ++this.pos) : isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types$1.num, l);
};
pp.readNumber = function(s) {
  var o = this.pos;
  !s && this.readInt(10, void 0, !0) === null && this.raise(o, "Invalid number");
  var l = this.pos - o >= 2 && this.input.charCodeAt(o) === 48;
  l && this.strict && this.raise(o, "Invalid number");
  var u = this.input.charCodeAt(this.pos);
  if (!l && !s && this.options.ecmaVersion >= 11 && u === 110) {
    var c = stringToBigInt(this.input.slice(o, this.pos));
    return ++this.pos, isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(types$1.num, c);
  }
  l && /[89]/.test(this.input.slice(o, this.pos)) && (l = !1), u === 46 && !l && (++this.pos, this.readInt(10), u = this.input.charCodeAt(this.pos)), (u === 69 || u === 101) && !l && (u = this.input.charCodeAt(++this.pos), (u === 43 || u === 45) && ++this.pos, this.readInt(10) === null && this.raise(o, "Invalid number")), isIdentifierStart(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
  var m = stringToNumber(this.input.slice(o, this.pos), l);
  return this.finishToken(types$1.num, m);
};
pp.readCodePoint = function() {
  var s = this.input.charCodeAt(this.pos), o;
  if (s === 123) {
    this.options.ecmaVersion < 6 && this.unexpected();
    var l = ++this.pos;
    o = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, o > 1114111 && this.invalidStringToken(l, "Code point out of bounds");
  } else
    o = this.readHexChar(4);
  return o;
};
pp.readString = function(s) {
  for (var o = "", l = ++this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
    var u = this.input.charCodeAt(this.pos);
    if (u === s)
      break;
    u === 92 ? (o += this.input.slice(l, this.pos), o += this.readEscapedChar(!1), l = this.pos) : u === 8232 || u === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (isNewLine(u) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
  }
  return o += this.input.slice(l, this.pos++), this.finishToken(types$1.string, o);
};
var INVALID_TEMPLATE_ESCAPE_ERROR = {};
pp.tryReadTemplateToken = function() {
  this.inTemplateElement = !0;
  try {
    this.readTmplToken();
  } catch (s) {
    if (s === INVALID_TEMPLATE_ESCAPE_ERROR)
      this.readInvalidTemplateToken();
    else
      throw s;
  }
  this.inTemplateElement = !1;
};
pp.invalidStringToken = function(s, o) {
  if (this.inTemplateElement && this.options.ecmaVersion >= 9)
    throw INVALID_TEMPLATE_ESCAPE_ERROR;
  this.raise(s, o);
};
pp.readTmplToken = function() {
  for (var s = "", o = this.pos; ; ) {
    this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
    var l = this.input.charCodeAt(this.pos);
    if (l === 96 || l === 36 && this.input.charCodeAt(this.pos + 1) === 123)
      return this.pos === this.start && (this.type === types$1.template || this.type === types$1.invalidTemplate) ? l === 36 ? (this.pos += 2, this.finishToken(types$1.dollarBraceL)) : (++this.pos, this.finishToken(types$1.backQuote)) : (s += this.input.slice(o, this.pos), this.finishToken(types$1.template, s));
    if (l === 92)
      s += this.input.slice(o, this.pos), s += this.readEscapedChar(!0), o = this.pos;
    else if (isNewLine(l)) {
      switch (s += this.input.slice(o, this.pos), ++this.pos, l) {
        case 13:
          this.input.charCodeAt(this.pos) === 10 && ++this.pos;
        case 10:
          s += `
`;
          break;
        default:
          s += String.fromCharCode(l);
          break;
      }
      this.options.locations && (++this.curLine, this.lineStart = this.pos), o = this.pos;
    } else
      ++this.pos;
  }
};
pp.readInvalidTemplateToken = function() {
  for (; this.pos < this.input.length; this.pos++)
    switch (this.input[this.pos]) {
      case "\\":
        ++this.pos;
        break;
      case "$":
        if (this.input[this.pos + 1] !== "{")
          break;
      case "`":
        return this.finishToken(types$1.invalidTemplate, this.input.slice(this.start, this.pos));
    }
  this.raise(this.start, "Unterminated template");
};
pp.readEscapedChar = function(s) {
  var o = this.input.charCodeAt(++this.pos);
  switch (++this.pos, o) {
    case 110:
      return `
`;
    case 114:
      return "\r";
    case 120:
      return String.fromCharCode(this.readHexChar(2));
    case 117:
      return codePointToString(this.readCodePoint());
    case 116:
      return "	";
    case 98:
      return "\b";
    case 118:
      return "\v";
    case 102:
      return "\f";
    case 13:
      this.input.charCodeAt(this.pos) === 10 && ++this.pos;
    case 10:
      return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
    case 56:
    case 57:
      if (this.strict && this.invalidStringToken(
        this.pos - 1,
        "Invalid escape sequence"
      ), s) {
        var l = this.pos - 1;
        this.invalidStringToken(
          l,
          "Invalid escape sequence in template string"
        );
      }
    default:
      if (o >= 48 && o <= 55) {
        var u = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], c = parseInt(u, 8);
        return c > 255 && (u = u.slice(0, -1), c = parseInt(u, 8)), this.pos += u.length - 1, o = this.input.charCodeAt(this.pos), (u !== "0" || o === 56 || o === 57) && (this.strict || s) && this.invalidStringToken(
          this.pos - 1 - u.length,
          s ? "Octal literal in template string" : "Octal literal in strict mode"
        ), String.fromCharCode(c);
      }
      return isNewLine(o) ? "" : String.fromCharCode(o);
  }
};
pp.readHexChar = function(s) {
  var o = this.pos, l = this.readInt(16, s);
  return l === null && this.invalidStringToken(o, "Bad character escape sequence"), l;
};
pp.readWord1 = function() {
  this.containsEsc = !1;
  for (var s = "", o = !0, l = this.pos, u = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
    var c = this.fullCharCodeAtPos();
    if (isIdentifierChar(c, u))
      this.pos += c <= 65535 ? 1 : 2;
    else if (c === 92) {
      this.containsEsc = !0, s += this.input.slice(l, this.pos);
      var m = this.pos;
      this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
      var g = this.readCodePoint();
      (o ? isIdentifierStart : isIdentifierChar)(g, u) || this.invalidStringToken(m, "Invalid Unicode escape"), s += codePointToString(g), l = this.pos;
    } else
      break;
    o = !1;
  }
  return s + this.input.slice(l, this.pos);
};
pp.readWord = function() {
  var s = this.readWord1(), o = types$1.name;
  return this.keywords.test(s) && (o = keywords[s]), this.finishToken(o, s);
};
var version = "8.11.3";
Parser.acorn = {
  Parser,
  version,
  defaultOptions,
  Position,
  SourceLocation,
  getLineInfo,
  Node,
  TokenType,
  tokTypes: types$1,
  keywordTypes: keywords,
  TokContext,
  tokContexts: types$2,
  isIdentifierChar,
  isIdentifierStart,
  Token,
  isNewLine,
  lineBreak,
  lineBreakG,
  nonASCIIwhitespace
};
var acornJsx$1 = { exports: {} }, xhtml = {
  quot: '"',
  amp: "&",
  apos: "'",
  lt: "<",
  gt: ">",
  nbsp: " ",
  iexcl: "¡",
  cent: "¢",
  pound: "£",
  curren: "¤",
  yen: "¥",
  brvbar: "¦",
  sect: "§",
  uml: "¨",
  copy: "©",
  ordf: "ª",
  laquo: "«",
  not: "¬",
  shy: "­",
  reg: "®",
  macr: "¯",
  deg: "°",
  plusmn: "±",
  sup2: "²",
  sup3: "³",
  acute: "´",
  micro: "µ",
  para: "¶",
  middot: "·",
  cedil: "¸",
  sup1: "¹",
  ordm: "º",
  raquo: "»",
  frac14: "¼",
  frac12: "½",
  frac34: "¾",
  iquest: "¿",
  Agrave: "À",
  Aacute: "Á",
  Acirc: "Â",
  Atilde: "Ã",
  Auml: "Ä",
  Aring: "Å",
  AElig: "Æ",
  Ccedil: "Ç",
  Egrave: "È",
  Eacute: "É",
  Ecirc: "Ê",
  Euml: "Ë",
  Igrave: "Ì",
  Iacute: "Í",
  Icirc: "Î",
  Iuml: "Ï",
  ETH: "Ð",
  Ntilde: "Ñ",
  Ograve: "Ò",
  Oacute: "Ó",
  Ocirc: "Ô",
  Otilde: "Õ",
  Ouml: "Ö",
  times: "×",
  Oslash: "Ø",
  Ugrave: "Ù",
  Uacute: "Ú",
  Ucirc: "Û",
  Uuml: "Ü",
  Yacute: "Ý",
  THORN: "Þ",
  szlig: "ß",
  agrave: "à",
  aacute: "á",
  acirc: "â",
  atilde: "ã",
  auml: "ä",
  aring: "å",
  aelig: "æ",
  ccedil: "ç",
  egrave: "è",
  eacute: "é",
  ecirc: "ê",
  euml: "ë",
  igrave: "ì",
  iacute: "í",
  icirc: "î",
  iuml: "ï",
  eth: "ð",
  ntilde: "ñ",
  ograve: "ò",
  oacute: "ó",
  ocirc: "ô",
  otilde: "õ",
  ouml: "ö",
  divide: "÷",
  oslash: "ø",
  ugrave: "ù",
  uacute: "ú",
  ucirc: "û",
  uuml: "ü",
  yacute: "ý",
  thorn: "þ",
  yuml: "ÿ",
  OElig: "Œ",
  oelig: "œ",
  Scaron: "Š",
  scaron: "š",
  Yuml: "Ÿ",
  fnof: "ƒ",
  circ: "ˆ",
  tilde: "˜",
  Alpha: "Α",
  Beta: "Β",
  Gamma: "Γ",
  Delta: "Δ",
  Epsilon: "Ε",
  Zeta: "Ζ",
  Eta: "Η",
  Theta: "Θ",
  Iota: "Ι",
  Kappa: "Κ",
  Lambda: "Λ",
  Mu: "Μ",
  Nu: "Ν",
  Xi: "Ξ",
  Omicron: "Ο",
  Pi: "Π",
  Rho: "Ρ",
  Sigma: "Σ",
  Tau: "Τ",
  Upsilon: "Υ",
  Phi: "Φ",
  Chi: "Χ",
  Psi: "Ψ",
  Omega: "Ω",
  alpha: "α",
  beta: "β",
  gamma: "γ",
  delta: "δ",
  epsilon: "ε",
  zeta: "ζ",
  eta: "η",
  theta: "θ",
  iota: "ι",
  kappa: "κ",
  lambda: "λ",
  mu: "μ",
  nu: "ν",
  xi: "ξ",
  omicron: "ο",
  pi: "π",
  rho: "ρ",
  sigmaf: "ς",
  sigma: "σ",
  tau: "τ",
  upsilon: "υ",
  phi: "φ",
  chi: "χ",
  psi: "ψ",
  omega: "ω",
  thetasym: "ϑ",
  upsih: "ϒ",
  piv: "ϖ",
  ensp: " ",
  emsp: " ",
  thinsp: " ",
  zwnj: "‌",
  zwj: "‍",
  lrm: "‎",
  rlm: "‏",
  ndash: "–",
  mdash: "—",
  lsquo: "‘",
  rsquo: "’",
  sbquo: "‚",
  ldquo: "“",
  rdquo: "”",
  bdquo: "„",
  dagger: "†",
  Dagger: "‡",
  bull: "•",
  hellip: "…",
  permil: "‰",
  prime: "′",
  Prime: "″",
  lsaquo: "‹",
  rsaquo: "›",
  oline: "‾",
  frasl: "⁄",
  euro: "€",
  image: "ℑ",
  weierp: "℘",
  real: "ℜ",
  trade: "™",
  alefsym: "ℵ",
  larr: "←",
  uarr: "↑",
  rarr: "→",
  darr: "↓",
  harr: "↔",
  crarr: "↵",
  lArr: "⇐",
  uArr: "⇑",
  rArr: "⇒",
  dArr: "⇓",
  hArr: "⇔",
  forall: "∀",
  part: "∂",
  exist: "∃",
  empty: "∅",
  nabla: "∇",
  isin: "∈",
  notin: "∉",
  ni: "∋",
  prod: "∏",
  sum: "∑",
  minus: "−",
  lowast: "∗",
  radic: "√",
  prop: "∝",
  infin: "∞",
  ang: "∠",
  and: "∧",
  or: "∨",
  cap: "∩",
  cup: "∪",
  int: "∫",
  there4: "∴",
  sim: "∼",
  cong: "≅",
  asymp: "≈",
  ne: "≠",
  equiv: "≡",
  le: "≤",
  ge: "≥",
  sub: "⊂",
  sup: "⊃",
  nsub: "⊄",
  sube: "⊆",
  supe: "⊇",
  oplus: "⊕",
  otimes: "⊗",
  perp: "⊥",
  sdot: "⋅",
  lceil: "⌈",
  rceil: "⌉",
  lfloor: "⌊",
  rfloor: "⌋",
  lang: "〈",
  rang: "〉",
  loz: "◊",
  spades: "♠",
  clubs: "♣",
  hearts: "♥",
  diams: "♦"
}, acorn = { exports: {} }, hasRequiredAcorn;
function requireAcorn() {
  return hasRequiredAcorn || (hasRequiredAcorn = 1, function(s, o) {
    (function(l, u) {
      u(o);
    })(commonjsGlobal, function(l) {
      var u = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239], c = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191], m = "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‌‍‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯・꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿･", g = "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ", v = {
        3: "abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile",
        5: "class enum extends super const export import",
        6: "enum",
        strict: "implements interface let package private protected public static yield",
        strictBind: "eval arguments"
      }, b = "break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this", S = {
        5: b,
        "5module": b + " export import",
        6: b + " const class extends export import super"
      }, E = /^in(stanceof)?$/, P = new RegExp("[" + g + "]"), T = new RegExp("[" + g + m + "]");
      function N(de, en) {
        for (var mn = 65536, $n = 0; $n < en.length; $n += 2) {
          if (mn += en[$n], mn > de)
            return !1;
          if (mn += en[$n + 1], mn >= de)
            return !0;
        }
        return !1;
      }
      function O(de, en) {
        return de < 65 ? de === 36 : de < 91 ? !0 : de < 97 ? de === 95 : de < 123 ? !0 : de <= 65535 ? de >= 170 && P.test(String.fromCharCode(de)) : en === !1 ? !1 : N(de, c);
      }
      function z(de, en) {
        return de < 48 ? de === 36 : de < 58 ? !0 : de < 65 ? !1 : de < 91 ? !0 : de < 97 ? de === 95 : de < 123 ? !0 : de <= 65535 ? de >= 170 && T.test(String.fromCharCode(de)) : en === !1 ? !1 : N(de, c) || N(de, u);
      }
      var Q = function(en, mn) {
        mn === void 0 && (mn = {}), this.label = en, this.keyword = mn.keyword, this.beforeExpr = !!mn.beforeExpr, this.startsExpr = !!mn.startsExpr, this.isLoop = !!mn.isLoop, this.isAssign = !!mn.isAssign, this.prefix = !!mn.prefix, this.postfix = !!mn.postfix, this.binop = mn.binop || null, this.updateContext = null;
      };
      function W(de, en) {
        return new Q(de, { beforeExpr: !0, binop: en });
      }
      var ue = { beforeExpr: !0 }, te = { startsExpr: !0 }, K = {};
      function ve(de, en) {
        return en === void 0 && (en = {}), en.keyword = de, K[de] = new Q(de, en);
      }
      var ee = {
        num: new Q("num", te),
        regexp: new Q("regexp", te),
        string: new Q("string", te),
        name: new Q("name", te),
        privateId: new Q("privateId", te),
        eof: new Q("eof"),
        // Punctuation token types.
        bracketL: new Q("[", { beforeExpr: !0, startsExpr: !0 }),
        bracketR: new Q("]"),
        braceL: new Q("{", { beforeExpr: !0, startsExpr: !0 }),
        braceR: new Q("}"),
        parenL: new Q("(", { beforeExpr: !0, startsExpr: !0 }),
        parenR: new Q(")"),
        comma: new Q(",", ue),
        semi: new Q(";", ue),
        colon: new Q(":", ue),
        dot: new Q("."),
        question: new Q("?", ue),
        questionDot: new Q("?."),
        arrow: new Q("=>", ue),
        template: new Q("template"),
        invalidTemplate: new Q("invalidTemplate"),
        ellipsis: new Q("...", ue),
        backQuote: new Q("`", te),
        dollarBraceL: new Q("${", { beforeExpr: !0, startsExpr: !0 }),
        // Operators. These carry several kinds of properties to help the
        // parser use them properly (the presence of these properties is
        // what categorizes them as operators).
        //
        // `binop`, when present, specifies that this operator is a binary
        // operator, and will refer to its precedence.
        //
        // `prefix` and `postfix` mark the operator as a prefix or postfix
        // unary operator.
        //
        // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as
        // binary operators with a very low precedence, that should result
        // in AssignmentExpression nodes.
        eq: new Q("=", { beforeExpr: !0, isAssign: !0 }),
        assign: new Q("_=", { beforeExpr: !0, isAssign: !0 }),
        incDec: new Q("++/--", { prefix: !0, postfix: !0, startsExpr: !0 }),
        prefix: new Q("!/~", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        logicalOR: W("||", 1),
        logicalAND: W("&&", 2),
        bitwiseOR: W("|", 3),
        bitwiseXOR: W("^", 4),
        bitwiseAND: W("&", 5),
        equality: W("==/!=/===/!==", 6),
        relational: W("</>/<=/>=", 7),
        bitShift: W("<</>>/>>>", 8),
        plusMin: new Q("+/-", { beforeExpr: !0, binop: 9, prefix: !0, startsExpr: !0 }),
        modulo: W("%", 10),
        star: W("*", 10),
        slash: W("/", 10),
        starstar: new Q("**", { beforeExpr: !0 }),
        coalesce: W("??", 1),
        // Keyword token types.
        _break: ve("break"),
        _case: ve("case", ue),
        _catch: ve("catch"),
        _continue: ve("continue"),
        _debugger: ve("debugger"),
        _default: ve("default", ue),
        _do: ve("do", { isLoop: !0, beforeExpr: !0 }),
        _else: ve("else", ue),
        _finally: ve("finally"),
        _for: ve("for", { isLoop: !0 }),
        _function: ve("function", te),
        _if: ve("if"),
        _return: ve("return", ue),
        _switch: ve("switch"),
        _throw: ve("throw", ue),
        _try: ve("try"),
        _var: ve("var"),
        _const: ve("const"),
        _while: ve("while", { isLoop: !0 }),
        _with: ve("with"),
        _new: ve("new", { beforeExpr: !0, startsExpr: !0 }),
        _this: ve("this", te),
        _super: ve("super", te),
        _class: ve("class", te),
        _extends: ve("extends", ue),
        _export: ve("export"),
        _import: ve("import", te),
        _null: ve("null", te),
        _true: ve("true", te),
        _false: ve("false", te),
        _in: ve("in", { beforeExpr: !0, binop: 7 }),
        _instanceof: ve("instanceof", { beforeExpr: !0, binop: 7 }),
        _typeof: ve("typeof", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _void: ve("void", { beforeExpr: !0, prefix: !0, startsExpr: !0 }),
        _delete: ve("delete", { beforeExpr: !0, prefix: !0, startsExpr: !0 })
      }, Re = /\r\n?|\n|\u2028|\u2029/, wt = new RegExp(Re.source, "g");
      function yt(de) {
        return de === 10 || de === 13 || de === 8232 || de === 8233;
      }
      function xt(de, en, mn) {
        mn === void 0 && (mn = de.length);
        for (var $n = en; $n < mn; $n++) {
          var Vn = de.charCodeAt($n);
          if (yt(Vn))
            return $n < mn - 1 && Vn === 13 && de.charCodeAt($n + 1) === 10 ? $n + 2 : $n + 1;
        }
        return -1;
      }
      var Kt = /[\u1680\u2000-\u200a\u202f\u205f\u3000\ufeff]/, tn = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g, ln = Object.prototype, rn = ln.hasOwnProperty, an = ln.toString, Gt = Object.hasOwn || function(de, en) {
        return rn.call(de, en);
      }, nn = Array.isArray || function(de) {
        return an.call(de) === "[object Array]";
      }, vt = /* @__PURE__ */ Object.create(null);
      function Et(de) {
        return vt[de] || (vt[de] = new RegExp("^(?:" + de.replace(/ /g, "|") + ")$"));
      }
      function Qt(de) {
        return de <= 65535 ? String.fromCharCode(de) : (de -= 65536, String.fromCharCode((de >> 10) + 55296, (de & 1023) + 56320));
      }
      var un = /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/, gn = function(en, mn) {
        this.line = en, this.column = mn;
      };
      gn.prototype.offset = function(en) {
        return new gn(this.line, this.column + en);
      };
      var dn = function(en, mn, $n) {
        this.start = mn, this.end = $n, en.sourceFile !== null && (this.source = en.sourceFile);
      };
      function yn(de, en) {
        for (var mn = 1, $n = 0; ; ) {
          var Vn = xt(de, $n, en);
          if (Vn < 0)
            return new gn(mn, en - $n);
          ++mn, $n = Vn;
        }
      }
      var vn = {
        // `ecmaVersion` indicates the ECMAScript version to parse. Must be
        // either 3, 5, 6 (or 2015), 7 (2016), 8 (2017), 9 (2018), 10
        // (2019), 11 (2020), 12 (2021), 13 (2022), 14 (2023), or `"latest"`
        // (the latest version the library supports). This influences
        // support for strict mode, the set of reserved words, and support
        // for new syntax features.
        ecmaVersion: null,
        // `sourceType` indicates the mode the code should be parsed in.
        // Can be either `"script"` or `"module"`. This influences global
        // strict mode and parsing of `import` and `export` declarations.
        sourceType: "script",
        // `onInsertedSemicolon` can be a callback that will be called when
        // a semicolon is automatically inserted. It will be passed the
        // position of the inserted semicolon as an offset, and if
        // `locations` is enabled, it is given the location as a `{line,
        // column}` object as second argument.
        onInsertedSemicolon: null,
        // `onTrailingComma` is similar to `onInsertedSemicolon`, but for
        // trailing commas.
        onTrailingComma: null,
        // By default, reserved words are only enforced if ecmaVersion >= 5.
        // Set `allowReserved` to a boolean value to explicitly turn this on
        // an off. When this option has the value "never", reserved words
        // and keywords can also not be used as property names.
        allowReserved: null,
        // When enabled, a return at the top level is not considered an
        // error.
        allowReturnOutsideFunction: !1,
        // When enabled, import/export statements are not constrained to
        // appearing at the top of the program, and an import.meta expression
        // in a script isn't considered an error.
        allowImportExportEverywhere: !1,
        // By default, await identifiers are allowed to appear at the top-level scope only if ecmaVersion >= 2022.
        // When enabled, await identifiers are allowed to appear at the top-level scope,
        // but they are still not allowed in non-async functions.
        allowAwaitOutsideFunction: null,
        // When enabled, super identifiers are not constrained to
        // appearing in methods and do not raise an error when they appear elsewhere.
        allowSuperOutsideMethod: null,
        // When enabled, hashbang directive in the beginning of file is
        // allowed and treated as a line comment. Enabled by default when
        // `ecmaVersion` >= 2023.
        allowHashBang: !1,
        // By default, the parser will verify that private properties are
        // only used in places where they are valid and have been declared.
        // Set this to false to turn such checks off.
        checkPrivateFields: !0,
        // When `locations` is on, `loc` properties holding objects with
        // `start` and `end` properties in `{line, column}` form (with
        // line being 1-based and column 0-based) will be attached to the
        // nodes.
        locations: !1,
        // A function can be passed as `onToken` option, which will
        // cause Acorn to call that function with object in the same
        // format as tokens returned from `tokenizer().getToken()`. Note
        // that you are not allowed to call the parser from the
        // callback—that will corrupt its internal state.
        onToken: null,
        // A function can be passed as `onComment` option, which will
        // cause Acorn to call that function with `(block, text, start,
        // end)` parameters whenever a comment is skipped. `block` is a
        // boolean indicating whether this is a block (`/* */`) comment,
        // `text` is the content of the comment, and `start` and `end` are
        // character offsets that denote the start and end of the comment.
        // When the `locations` option is on, two more parameters are
        // passed, the full `{line, column}` locations of the start and
        // end of the comments. Note that you are not allowed to call the
        // parser from the callback—that will corrupt its internal state.
        // When this option has an array as value, objects representing the
        // comments are pushed to it.
        onComment: null,
        // Nodes have their start and end characters offsets recorded in
        // `start` and `end` properties (directly on the node, rather than
        // the `loc` object, which holds line/column data. To also add a
        // [semi-standardized][range] `range` property holding a `[start,
        // end]` array with the same numbers, set the `ranges` option to
        // `true`.
        //
        // [range]: https://bugzilla.mozilla.org/show_bug.cgi?id=745678
        ranges: !1,
        // It is possible to parse multiple files into a single AST by
        // passing the tree produced by parsing the first file as
        // `program` option in subsequent parses. This will add the
        // toplevel forms of the parsed file to the `Program` (top) node
        // of an existing parse tree.
        program: null,
        // When `locations` is on, you can pass this to record the source
        // file in every node's `loc` object.
        sourceFile: null,
        // This value, if given, is stored in every node, whether
        // `locations` is on or off.
        directSourceFile: null,
        // When enabled, parenthesized expressions are represented by
        // (non-standard) ParenthesizedExpression nodes
        preserveParens: !1
      }, Pn = !1;
      function On(de) {
        var en = {};
        for (var mn in vn)
          en[mn] = de && Gt(de, mn) ? de[mn] : vn[mn];
        if (en.ecmaVersion === "latest" ? en.ecmaVersion = 1e8 : en.ecmaVersion == null ? (!Pn && typeof console == "object" && console.warn && (Pn = !0, console.warn(`Since Acorn 8.0.0, options.ecmaVersion is required.
Defaulting to 2020, but this will stop working in the future.`)), en.ecmaVersion = 11) : en.ecmaVersion >= 2015 && (en.ecmaVersion -= 2009), en.allowReserved == null && (en.allowReserved = en.ecmaVersion < 5), (!de || de.allowHashBang == null) && (en.allowHashBang = en.ecmaVersion >= 14), nn(en.onToken)) {
          var $n = en.onToken;
          en.onToken = function(Vn) {
            return $n.push(Vn);
          };
        }
        return nn(en.onComment) && (en.onComment = _n(en, en.onComment)), en;
      }
      function _n(de, en) {
        return function(mn, $n, Vn, sr, cr, Br) {
          var Kr = {
            type: mn ? "Block" : "Line",
            value: $n,
            start: Vn,
            end: sr
          };
          de.locations && (Kr.loc = new dn(this, cr, Br)), de.ranges && (Kr.range = [Vn, sr]), en.push(Kr);
        };
      }
      var Nn = 1, Un = 2, Xn = 4, zn = 8, jn = 16, kn = 32, Yn = 64, Zn = 128, er = 256, bn = Nn | Un | er;
      function Ln(de, en) {
        return Un | (de ? Xn : 0) | (en ? zn : 0);
      }
      var Kn = 0, Bn = 1, Fn = 2, Gn = 3, Wn = 4, Mn = 5, Tn = function(en, mn, $n) {
        this.options = en = On(en), this.sourceFile = en.sourceFile, this.keywords = Et(S[en.ecmaVersion >= 6 ? 6 : en.sourceType === "module" ? "5module" : 5]);
        var Vn = "";
        en.allowReserved !== !0 && (Vn = v[en.ecmaVersion >= 6 ? 6 : en.ecmaVersion === 5 ? 5 : 3], en.sourceType === "module" && (Vn += " await")), this.reservedWords = Et(Vn);
        var sr = (Vn ? Vn + " " : "") + v.strict;
        this.reservedWordsStrict = Et(sr), this.reservedWordsStrictBind = Et(sr + " " + v.strictBind), this.input = String(mn), this.containsEsc = !1, $n ? (this.pos = $n, this.lineStart = this.input.lastIndexOf(`
`, $n - 1) + 1, this.curLine = this.input.slice(0, this.lineStart).split(Re).length) : (this.pos = this.lineStart = 0, this.curLine = 1), this.type = ee.eof, this.value = null, this.start = this.end = this.pos, this.startLoc = this.endLoc = this.curPosition(), this.lastTokEndLoc = this.lastTokStartLoc = null, this.lastTokStart = this.lastTokEnd = this.pos, this.context = this.initialContext(), this.exprAllowed = !0, this.inModule = en.sourceType === "module", this.strict = this.inModule || this.strictDirective(this.pos), this.potentialArrowAt = -1, this.potentialArrowInForAwait = !1, this.yieldPos = this.awaitPos = this.awaitIdentPos = 0, this.labels = [], this.undefinedExports = /* @__PURE__ */ Object.create(null), this.pos === 0 && en.allowHashBang && this.input.slice(0, 2) === "#!" && this.skipLineComment(2), this.scopeStack = [], this.enterScope(Nn), this.regexpState = null, this.privateNameStack = [];
      }, Rn = { inFunction: { configurable: !0 }, inGenerator: { configurable: !0 }, inAsync: { configurable: !0 }, canAwait: { configurable: !0 }, allowSuper: { configurable: !0 }, allowDirectSuper: { configurable: !0 }, treatFunctionsAsVar: { configurable: !0 }, allowNewDotTarget: { configurable: !0 }, inClassStaticBlock: { configurable: !0 } };
      Tn.prototype.parse = function() {
        var en = this.options.program || this.startNode();
        return this.nextToken(), this.parseTopLevel(en);
      }, Rn.inFunction.get = function() {
        return (this.currentVarScope().flags & Un) > 0;
      }, Rn.inGenerator.get = function() {
        return (this.currentVarScope().flags & zn) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Rn.inAsync.get = function() {
        return (this.currentVarScope().flags & Xn) > 0 && !this.currentVarScope().inClassFieldInit;
      }, Rn.canAwait.get = function() {
        for (var de = this.scopeStack.length - 1; de >= 0; de--) {
          var en = this.scopeStack[de];
          if (en.inClassFieldInit || en.flags & er)
            return !1;
          if (en.flags & Un)
            return (en.flags & Xn) > 0;
        }
        return this.inModule && this.options.ecmaVersion >= 13 || this.options.allowAwaitOutsideFunction;
      }, Rn.allowSuper.get = function() {
        var de = this.currentThisScope(), en = de.flags, mn = de.inClassFieldInit;
        return (en & Yn) > 0 || mn || this.options.allowSuperOutsideMethod;
      }, Rn.allowDirectSuper.get = function() {
        return (this.currentThisScope().flags & Zn) > 0;
      }, Rn.treatFunctionsAsVar.get = function() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }, Rn.allowNewDotTarget.get = function() {
        var de = this.currentThisScope(), en = de.flags, mn = de.inClassFieldInit;
        return (en & (Un | er)) > 0 || mn;
      }, Rn.inClassStaticBlock.get = function() {
        return (this.currentVarScope().flags & er) > 0;
      }, Tn.extend = function() {
        for (var en = [], mn = arguments.length; mn--; ) en[mn] = arguments[mn];
        for (var $n = this, Vn = 0; Vn < en.length; Vn++)
          $n = en[Vn]($n);
        return $n;
      }, Tn.parse = function(en, mn) {
        return new this(mn, en).parse();
      }, Tn.parseExpressionAt = function(en, mn, $n) {
        var Vn = new this($n, en, mn);
        return Vn.nextToken(), Vn.parseExpression();
      }, Tn.tokenizer = function(en, mn) {
        return new this(mn, en);
      }, Object.defineProperties(Tn.prototype, Rn);
      var hn = Tn.prototype, Qn = /^(?:'((?:\\.|[^'\\])*?)'|"((?:\\.|[^"\\])*?)")/;
      hn.strictDirective = function(de) {
        if (this.options.ecmaVersion < 5)
          return !1;
        for (; ; ) {
          tn.lastIndex = de, de += tn.exec(this.input)[0].length;
          var en = Qn.exec(this.input.slice(de));
          if (!en)
            return !1;
          if ((en[1] || en[2]) === "use strict") {
            tn.lastIndex = de + en[0].length;
            var mn = tn.exec(this.input), $n = mn.index + mn[0].length, Vn = this.input.charAt($n);
            return Vn === ";" || Vn === "}" || Re.test(mn[0]) && !(/[(`.[+\-/*%<>=,?^&]/.test(Vn) || Vn === "!" && this.input.charAt($n + 1) === "=");
          }
          de += en[0].length, tn.lastIndex = de, de += tn.exec(this.input)[0].length, this.input[de] === ";" && de++;
        }
      }, hn.eat = function(de) {
        return this.type === de ? (this.next(), !0) : !1;
      }, hn.isContextual = function(de) {
        return this.type === ee.name && this.value === de && !this.containsEsc;
      }, hn.eatContextual = function(de) {
        return this.isContextual(de) ? (this.next(), !0) : !1;
      }, hn.expectContextual = function(de) {
        this.eatContextual(de) || this.unexpected();
      }, hn.canInsertSemicolon = function() {
        return this.type === ee.eof || this.type === ee.braceR || Re.test(this.input.slice(this.lastTokEnd, this.start));
      }, hn.insertSemicolon = function() {
        if (this.canInsertSemicolon())
          return this.options.onInsertedSemicolon && this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc), !0;
      }, hn.semicolon = function() {
        !this.eat(ee.semi) && !this.insertSemicolon() && this.unexpected();
      }, hn.afterTrailingComma = function(de, en) {
        if (this.type === de)
          return this.options.onTrailingComma && this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc), en || this.next(), !0;
      }, hn.expect = function(de) {
        this.eat(de) || this.unexpected();
      }, hn.unexpected = function(de) {
        this.raise(de ?? this.start, "Unexpected token");
      };
      var rr = function() {
        this.shorthandAssign = this.trailingComma = this.parenthesizedAssign = this.parenthesizedBind = this.doubleProto = -1;
      };
      hn.checkPatternErrors = function(de, en) {
        if (de) {
          de.trailingComma > -1 && this.raiseRecoverable(de.trailingComma, "Comma is not permitted after the rest element");
          var mn = en ? de.parenthesizedAssign : de.parenthesizedBind;
          mn > -1 && this.raiseRecoverable(mn, en ? "Assigning to rvalue" : "Parenthesized pattern");
        }
      }, hn.checkExpressionErrors = function(de, en) {
        if (!de)
          return !1;
        var mn = de.shorthandAssign, $n = de.doubleProto;
        if (!en)
          return mn >= 0 || $n >= 0;
        mn >= 0 && this.raise(mn, "Shorthand property assignments are valid only in destructuring patterns"), $n >= 0 && this.raiseRecoverable($n, "Redefinition of __proto__ property");
      }, hn.checkYieldAwaitInDefaultParams = function() {
        this.yieldPos && (!this.awaitPos || this.yieldPos < this.awaitPos) && this.raise(this.yieldPos, "Yield expression cannot be a default value"), this.awaitPos && this.raise(this.awaitPos, "Await expression cannot be a default value");
      }, hn.isSimpleAssignTarget = function(de) {
        return de.type === "ParenthesizedExpression" ? this.isSimpleAssignTarget(de.expression) : de.type === "Identifier" || de.type === "MemberExpression";
      };
      var tr = Tn.prototype;
      tr.parseTopLevel = function(de) {
        var en = /* @__PURE__ */ Object.create(null);
        for (de.body || (de.body = []); this.type !== ee.eof; ) {
          var mn = this.parseStatement(null, !0, en);
          de.body.push(mn);
        }
        if (this.inModule)
          for (var $n = 0, Vn = Object.keys(this.undefinedExports); $n < Vn.length; $n += 1) {
            var sr = Vn[$n];
            this.raiseRecoverable(this.undefinedExports[sr].start, "Export '" + sr + "' is not defined");
          }
        return this.adaptDirectivePrologue(de.body), this.next(), de.sourceType = this.options.sourceType, this.finishNode(de, "Program");
      };
      var Cr = { kind: "loop" }, Fr = { kind: "switch" };
      tr.isLet = function(de) {
        if (this.options.ecmaVersion < 6 || !this.isContextual("let"))
          return !1;
        tn.lastIndex = this.pos;
        var en = tn.exec(this.input), mn = this.pos + en[0].length, $n = this.input.charCodeAt(mn);
        if ($n === 91 || $n === 92)
          return !0;
        if (de)
          return !1;
        if ($n === 123 || $n > 55295 && $n < 56320)
          return !0;
        if (O($n, !0)) {
          for (var Vn = mn + 1; z($n = this.input.charCodeAt(Vn), !0); )
            ++Vn;
          if ($n === 92 || $n > 55295 && $n < 56320)
            return !0;
          var sr = this.input.slice(mn, Vn);
          if (!E.test(sr))
            return !0;
        }
        return !1;
      }, tr.isAsyncFunction = function() {
        if (this.options.ecmaVersion < 8 || !this.isContextual("async"))
          return !1;
        tn.lastIndex = this.pos;
        var de = tn.exec(this.input), en = this.pos + de[0].length, mn;
        return !Re.test(this.input.slice(this.pos, en)) && this.input.slice(en, en + 8) === "function" && (en + 8 === this.input.length || !(z(mn = this.input.charCodeAt(en + 8)) || mn > 55295 && mn < 56320));
      }, tr.parseStatement = function(de, en, mn) {
        var $n = this.type, Vn = this.startNode(), sr;
        switch (this.isLet(de) && ($n = ee._var, sr = "let"), $n) {
          case ee._break:
          case ee._continue:
            return this.parseBreakContinueStatement(Vn, $n.keyword);
          case ee._debugger:
            return this.parseDebuggerStatement(Vn);
          case ee._do:
            return this.parseDoStatement(Vn);
          case ee._for:
            return this.parseForStatement(Vn);
          case ee._function:
            return de && (this.strict || de !== "if" && de !== "label") && this.options.ecmaVersion >= 6 && this.unexpected(), this.parseFunctionStatement(Vn, !1, !de);
          case ee._class:
            return de && this.unexpected(), this.parseClass(Vn, !0);
          case ee._if:
            return this.parseIfStatement(Vn);
          case ee._return:
            return this.parseReturnStatement(Vn);
          case ee._switch:
            return this.parseSwitchStatement(Vn);
          case ee._throw:
            return this.parseThrowStatement(Vn);
          case ee._try:
            return this.parseTryStatement(Vn);
          case ee._const:
          case ee._var:
            return sr = sr || this.value, de && sr !== "var" && this.unexpected(), this.parseVarStatement(Vn, sr);
          case ee._while:
            return this.parseWhileStatement(Vn);
          case ee._with:
            return this.parseWithStatement(Vn);
          case ee.braceL:
            return this.parseBlock(!0, Vn);
          case ee.semi:
            return this.parseEmptyStatement(Vn);
          case ee._export:
          case ee._import:
            if (this.options.ecmaVersion > 10 && $n === ee._import) {
              tn.lastIndex = this.pos;
              var cr = tn.exec(this.input), Br = this.pos + cr[0].length, Kr = this.input.charCodeAt(Br);
              if (Kr === 40 || Kr === 46)
                return this.parseExpressionStatement(Vn, this.parseExpression());
            }
            return this.options.allowImportExportEverywhere || (en || this.raise(this.start, "'import' and 'export' may only appear at the top level"), this.inModule || this.raise(this.start, "'import' and 'export' may appear only with 'sourceType: module'")), $n === ee._import ? this.parseImport(Vn) : this.parseExport(Vn, mn);
          default:
            if (this.isAsyncFunction())
              return de && this.unexpected(), this.next(), this.parseFunctionStatement(Vn, !0, !de);
            var Li = this.value, Pi = this.parseExpression();
            return $n === ee.name && Pi.type === "Identifier" && this.eat(ee.colon) ? this.parseLabeledStatement(Vn, Li, Pi, de) : this.parseExpressionStatement(Vn, Pi);
        }
      }, tr.parseBreakContinueStatement = function(de, en) {
        var mn = en === "break";
        this.next(), this.eat(ee.semi) || this.insertSemicolon() ? de.label = null : this.type !== ee.name ? this.unexpected() : (de.label = this.parseIdent(), this.semicolon());
        for (var $n = 0; $n < this.labels.length; ++$n) {
          var Vn = this.labels[$n];
          if ((de.label == null || Vn.name === de.label.name) && (Vn.kind != null && (mn || Vn.kind === "loop") || de.label && mn))
            break;
        }
        return $n === this.labels.length && this.raise(de.start, "Unsyntactic " + en), this.finishNode(de, mn ? "BreakStatement" : "ContinueStatement");
      }, tr.parseDebuggerStatement = function(de) {
        return this.next(), this.semicolon(), this.finishNode(de, "DebuggerStatement");
      }, tr.parseDoStatement = function(de) {
        return this.next(), this.labels.push(Cr), de.body = this.parseStatement("do"), this.labels.pop(), this.expect(ee._while), de.test = this.parseParenExpression(), this.options.ecmaVersion >= 6 ? this.eat(ee.semi) : this.semicolon(), this.finishNode(de, "DoWhileStatement");
      }, tr.parseForStatement = function(de) {
        this.next();
        var en = this.options.ecmaVersion >= 9 && this.canAwait && this.eatContextual("await") ? this.lastTokStart : -1;
        if (this.labels.push(Cr), this.enterScope(0), this.expect(ee.parenL), this.type === ee.semi)
          return en > -1 && this.unexpected(en), this.parseFor(de, null);
        var mn = this.isLet();
        if (this.type === ee._var || this.type === ee._const || mn) {
          var $n = this.startNode(), Vn = mn ? "let" : this.value;
          return this.next(), this.parseVar($n, !0, Vn), this.finishNode($n, "VariableDeclaration"), (this.type === ee._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) && $n.declarations.length === 1 ? (this.options.ecmaVersion >= 9 && (this.type === ee._in ? en > -1 && this.unexpected(en) : de.await = en > -1), this.parseForIn(de, $n)) : (en > -1 && this.unexpected(en), this.parseFor(de, $n));
        }
        var sr = this.isContextual("let"), cr = !1, Br = new rr(), Kr = this.parseExpression(en > -1 ? "await" : !0, Br);
        return this.type === ee._in || (cr = this.options.ecmaVersion >= 6 && this.isContextual("of")) ? (this.options.ecmaVersion >= 9 && (this.type === ee._in ? en > -1 && this.unexpected(en) : de.await = en > -1), sr && cr && this.raise(Kr.start, "The left-hand side of a for-of loop may not start with 'let'."), this.toAssignable(Kr, !1, Br), this.checkLValPattern(Kr), this.parseForIn(de, Kr)) : (this.checkExpressionErrors(Br, !0), en > -1 && this.unexpected(en), this.parseFor(de, Kr));
      }, tr.parseFunctionStatement = function(de, en, mn) {
        return this.next(), this.parseFunction(de, Hn | (mn ? 0 : ir), !1, en);
      }, tr.parseIfStatement = function(de) {
        return this.next(), de.test = this.parseParenExpression(), de.consequent = this.parseStatement("if"), de.alternate = this.eat(ee._else) ? this.parseStatement("if") : null, this.finishNode(de, "IfStatement");
      }, tr.parseReturnStatement = function(de) {
        return !this.inFunction && !this.options.allowReturnOutsideFunction && this.raise(this.start, "'return' outside of function"), this.next(), this.eat(ee.semi) || this.insertSemicolon() ? de.argument = null : (de.argument = this.parseExpression(), this.semicolon()), this.finishNode(de, "ReturnStatement");
      }, tr.parseSwitchStatement = function(de) {
        this.next(), de.discriminant = this.parseParenExpression(), de.cases = [], this.expect(ee.braceL), this.labels.push(Fr), this.enterScope(0);
        for (var en, mn = !1; this.type !== ee.braceR; )
          if (this.type === ee._case || this.type === ee._default) {
            var $n = this.type === ee._case;
            en && this.finishNode(en, "SwitchCase"), de.cases.push(en = this.startNode()), en.consequent = [], this.next(), $n ? en.test = this.parseExpression() : (mn && this.raiseRecoverable(this.lastTokStart, "Multiple default clauses"), mn = !0, en.test = null), this.expect(ee.colon);
          } else
            en || this.unexpected(), en.consequent.push(this.parseStatement(null));
        return this.exitScope(), en && this.finishNode(en, "SwitchCase"), this.next(), this.labels.pop(), this.finishNode(de, "SwitchStatement");
      }, tr.parseThrowStatement = function(de) {
        return this.next(), Re.test(this.input.slice(this.lastTokEnd, this.start)) && this.raise(this.lastTokEnd, "Illegal newline after throw"), de.argument = this.parseExpression(), this.semicolon(), this.finishNode(de, "ThrowStatement");
      };
      var An = [];
      tr.parseCatchClauseParam = function() {
        var de = this.parseBindingAtom(), en = de.type === "Identifier";
        return this.enterScope(en ? kn : 0), this.checkLValPattern(de, en ? Wn : Fn), this.expect(ee.parenR), de;
      }, tr.parseTryStatement = function(de) {
        if (this.next(), de.block = this.parseBlock(), de.handler = null, this.type === ee._catch) {
          var en = this.startNode();
          this.next(), this.eat(ee.parenL) ? en.param = this.parseCatchClauseParam() : (this.options.ecmaVersion < 10 && this.unexpected(), en.param = null, this.enterScope(0)), en.body = this.parseBlock(!1), this.exitScope(), de.handler = this.finishNode(en, "CatchClause");
        }
        return de.finalizer = this.eat(ee._finally) ? this.parseBlock() : null, !de.handler && !de.finalizer && this.raise(de.start, "Missing catch or finally clause"), this.finishNode(de, "TryStatement");
      }, tr.parseVarStatement = function(de, en, mn) {
        return this.next(), this.parseVar(de, !1, en, mn), this.semicolon(), this.finishNode(de, "VariableDeclaration");
      }, tr.parseWhileStatement = function(de) {
        return this.next(), de.test = this.parseParenExpression(), this.labels.push(Cr), de.body = this.parseStatement("while"), this.labels.pop(), this.finishNode(de, "WhileStatement");
      }, tr.parseWithStatement = function(de) {
        return this.strict && this.raise(this.start, "'with' in strict mode"), this.next(), de.object = this.parseParenExpression(), de.body = this.parseStatement("with"), this.finishNode(de, "WithStatement");
      }, tr.parseEmptyStatement = function(de) {
        return this.next(), this.finishNode(de, "EmptyStatement");
      }, tr.parseLabeledStatement = function(de, en, mn, $n) {
        for (var Vn = 0, sr = this.labels; Vn < sr.length; Vn += 1) {
          var cr = sr[Vn];
          cr.name === en && this.raise(mn.start, "Label '" + en + "' is already declared");
        }
        for (var Br = this.type.isLoop ? "loop" : this.type === ee._switch ? "switch" : null, Kr = this.labels.length - 1; Kr >= 0; Kr--) {
          var Li = this.labels[Kr];
          if (Li.statementStart === de.start)
            Li.statementStart = this.start, Li.kind = Br;
          else
            break;
        }
        return this.labels.push({ name: en, kind: Br, statementStart: this.start }), de.body = this.parseStatement($n ? $n.indexOf("label") === -1 ? $n + "label" : $n : "label"), this.labels.pop(), de.label = mn, this.finishNode(de, "LabeledStatement");
      }, tr.parseExpressionStatement = function(de, en) {
        return de.expression = en, this.semicolon(), this.finishNode(de, "ExpressionStatement");
      }, tr.parseBlock = function(de, en, mn) {
        for (de === void 0 && (de = !0), en === void 0 && (en = this.startNode()), en.body = [], this.expect(ee.braceL), de && this.enterScope(0); this.type !== ee.braceR; ) {
          var $n = this.parseStatement(null);
          en.body.push($n);
        }
        return mn && (this.strict = !1), this.next(), de && this.exitScope(), this.finishNode(en, "BlockStatement");
      }, tr.parseFor = function(de, en) {
        return de.init = en, this.expect(ee.semi), de.test = this.type === ee.semi ? null : this.parseExpression(), this.expect(ee.semi), de.update = this.type === ee.parenR ? null : this.parseExpression(), this.expect(ee.parenR), de.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(de, "ForStatement");
      }, tr.parseForIn = function(de, en) {
        var mn = this.type === ee._in;
        return this.next(), en.type === "VariableDeclaration" && en.declarations[0].init != null && (!mn || this.options.ecmaVersion < 8 || this.strict || en.kind !== "var" || en.declarations[0].id.type !== "Identifier") && this.raise(
          en.start,
          (mn ? "for-in" : "for-of") + " loop variable declaration may not have an initializer"
        ), de.left = en, de.right = mn ? this.parseExpression() : this.parseMaybeAssign(), this.expect(ee.parenR), de.body = this.parseStatement("for"), this.exitScope(), this.labels.pop(), this.finishNode(de, mn ? "ForInStatement" : "ForOfStatement");
      }, tr.parseVar = function(de, en, mn, $n) {
        for (de.declarations = [], de.kind = mn; ; ) {
          var Vn = this.startNode();
          if (this.parseVarId(Vn, mn), this.eat(ee.eq) ? Vn.init = this.parseMaybeAssign(en) : !$n && mn === "const" && !(this.type === ee._in || this.options.ecmaVersion >= 6 && this.isContextual("of")) ? this.unexpected() : !$n && Vn.id.type !== "Identifier" && !(en && (this.type === ee._in || this.isContextual("of"))) ? this.raise(this.lastTokEnd, "Complex binding patterns require an initialization value") : Vn.init = null, de.declarations.push(this.finishNode(Vn, "VariableDeclarator")), !this.eat(ee.comma))
            break;
        }
        return de;
      }, tr.parseVarId = function(de, en) {
        de.id = this.parseBindingAtom(), this.checkLValPattern(de.id, en === "var" ? Bn : Fn, !1);
      };
      var Hn = 1, ir = 2, dr = 4;
      tr.parseFunction = function(de, en, mn, $n, Vn) {
        this.initFunction(de), (this.options.ecmaVersion >= 9 || this.options.ecmaVersion >= 6 && !$n) && (this.type === ee.star && en & ir && this.unexpected(), de.generator = this.eat(ee.star)), this.options.ecmaVersion >= 8 && (de.async = !!$n), en & Hn && (de.id = en & dr && this.type !== ee.name ? null : this.parseIdent(), de.id && !(en & ir) && this.checkLValSimple(de.id, this.strict || de.generator || de.async ? this.treatFunctionsAsVar ? Bn : Fn : Gn));
        var sr = this.yieldPos, cr = this.awaitPos, Br = this.awaitIdentPos;
        return this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ln(de.async, de.generator)), en & Hn || (de.id = this.type === ee.name ? this.parseIdent() : null), this.parseFunctionParams(de), this.parseFunctionBody(de, mn, !1, Vn), this.yieldPos = sr, this.awaitPos = cr, this.awaitIdentPos = Br, this.finishNode(de, en & Hn ? "FunctionDeclaration" : "FunctionExpression");
      }, tr.parseFunctionParams = function(de) {
        this.expect(ee.parenL), de.params = this.parseBindingList(ee.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams();
      }, tr.parseClass = function(de, en) {
        this.next();
        var mn = this.strict;
        this.strict = !0, this.parseClassId(de, en), this.parseClassSuper(de);
        var $n = this.enterClassBody(), Vn = this.startNode(), sr = !1;
        for (Vn.body = [], this.expect(ee.braceL); this.type !== ee.braceR; ) {
          var cr = this.parseClassElement(de.superClass !== null);
          cr && (Vn.body.push(cr), cr.type === "MethodDefinition" && cr.kind === "constructor" ? (sr && this.raiseRecoverable(cr.start, "Duplicate constructor in the same class"), sr = !0) : cr.key && cr.key.type === "PrivateIdentifier" && ar($n, cr) && this.raiseRecoverable(cr.key.start, "Identifier '#" + cr.key.name + "' has already been declared"));
        }
        return this.strict = mn, this.next(), de.body = this.finishNode(Vn, "ClassBody"), this.exitClassBody(), this.finishNode(de, en ? "ClassDeclaration" : "ClassExpression");
      }, tr.parseClassElement = function(de) {
        if (this.eat(ee.semi))
          return null;
        var en = this.options.ecmaVersion, mn = this.startNode(), $n = "", Vn = !1, sr = !1, cr = "method", Br = !1;
        if (this.eatContextual("static")) {
          if (en >= 13 && this.eat(ee.braceL))
            return this.parseClassStaticBlock(mn), mn;
          this.isClassElementNameStart() || this.type === ee.star ? Br = !0 : $n = "static";
        }
        if (mn.static = Br, !$n && en >= 8 && this.eatContextual("async") && ((this.isClassElementNameStart() || this.type === ee.star) && !this.canInsertSemicolon() ? sr = !0 : $n = "async"), !$n && (en >= 9 || !sr) && this.eat(ee.star) && (Vn = !0), !$n && !sr && !Vn) {
          var Kr = this.value;
          (this.eatContextual("get") || this.eatContextual("set")) && (this.isClassElementNameStart() ? cr = Kr : $n = Kr);
        }
        if ($n ? (mn.computed = !1, mn.key = this.startNodeAt(this.lastTokStart, this.lastTokStartLoc), mn.key.name = $n, this.finishNode(mn.key, "Identifier")) : this.parseClassElementName(mn), en < 13 || this.type === ee.parenL || cr !== "method" || Vn || sr) {
          var Li = !mn.static && Or(mn, "constructor"), Pi = Li && de;
          Li && cr !== "method" && this.raise(mn.key.start, "Constructor can't have get/set modifier"), mn.kind = Li ? "constructor" : cr, this.parseClassMethod(mn, Vn, sr, Pi);
        } else
          this.parseClassField(mn);
        return mn;
      }, tr.isClassElementNameStart = function() {
        return this.type === ee.name || this.type === ee.privateId || this.type === ee.num || this.type === ee.string || this.type === ee.bracketL || this.type.keyword;
      }, tr.parseClassElementName = function(de) {
        this.type === ee.privateId ? (this.value === "constructor" && this.raise(this.start, "Classes can't have an element named '#constructor'"), de.computed = !1, de.key = this.parsePrivateIdent()) : this.parsePropertyName(de);
      }, tr.parseClassMethod = function(de, en, mn, $n) {
        var Vn = de.key;
        de.kind === "constructor" ? (en && this.raise(Vn.start, "Constructor can't be a generator"), mn && this.raise(Vn.start, "Constructor can't be an async method")) : de.static && Or(de, "prototype") && this.raise(Vn.start, "Classes may not have a static property named prototype");
        var sr = de.value = this.parseMethod(en, mn, $n);
        return de.kind === "get" && sr.params.length !== 0 && this.raiseRecoverable(sr.start, "getter should have no params"), de.kind === "set" && sr.params.length !== 1 && this.raiseRecoverable(sr.start, "setter should have exactly one param"), de.kind === "set" && sr.params[0].type === "RestElement" && this.raiseRecoverable(sr.params[0].start, "Setter cannot use rest params"), this.finishNode(de, "MethodDefinition");
      }, tr.parseClassField = function(de) {
        if (Or(de, "constructor") ? this.raise(de.key.start, "Classes can't have a field named 'constructor'") : de.static && Or(de, "prototype") && this.raise(de.key.start, "Classes can't have a static field named 'prototype'"), this.eat(ee.eq)) {
          var en = this.currentThisScope(), mn = en.inClassFieldInit;
          en.inClassFieldInit = !0, de.value = this.parseMaybeAssign(), en.inClassFieldInit = mn;
        } else
          de.value = null;
        return this.semicolon(), this.finishNode(de, "PropertyDefinition");
      }, tr.parseClassStaticBlock = function(de) {
        de.body = [];
        var en = this.labels;
        for (this.labels = [], this.enterScope(er | Yn); this.type !== ee.braceR; ) {
          var mn = this.parseStatement(null);
          de.body.push(mn);
        }
        return this.next(), this.exitScope(), this.labels = en, this.finishNode(de, "StaticBlock");
      }, tr.parseClassId = function(de, en) {
        this.type === ee.name ? (de.id = this.parseIdent(), en && this.checkLValSimple(de.id, Fn, !1)) : (en === !0 && this.unexpected(), de.id = null);
      }, tr.parseClassSuper = function(de) {
        de.superClass = this.eat(ee._extends) ? this.parseExprSubscripts(null, !1) : null;
      }, tr.enterClassBody = function() {
        var de = { declared: /* @__PURE__ */ Object.create(null), used: [] };
        return this.privateNameStack.push(de), de.declared;
      }, tr.exitClassBody = function() {
        var de = this.privateNameStack.pop(), en = de.declared, mn = de.used;
        if (this.options.checkPrivateFields)
          for (var $n = this.privateNameStack.length, Vn = $n === 0 ? null : this.privateNameStack[$n - 1], sr = 0; sr < mn.length; ++sr) {
            var cr = mn[sr];
            Gt(en, cr.name) || (Vn ? Vn.used.push(cr) : this.raiseRecoverable(cr.start, "Private field '#" + cr.name + "' must be declared in an enclosing class"));
          }
      };
      function ar(de, en) {
        var mn = en.key.name, $n = de[mn], Vn = "true";
        return en.type === "MethodDefinition" && (en.kind === "get" || en.kind === "set") && (Vn = (en.static ? "s" : "i") + en.kind), $n === "iget" && Vn === "iset" || $n === "iset" && Vn === "iget" || $n === "sget" && Vn === "sset" || $n === "sset" && Vn === "sget" ? (de[mn] = "true", !1) : $n ? !0 : (de[mn] = Vn, !1);
      }
      function Or(de, en) {
        var mn = de.computed, $n = de.key;
        return !mn && ($n.type === "Identifier" && $n.name === en || $n.type === "Literal" && $n.value === en);
      }
      tr.parseExportAllDeclaration = function(de, en) {
        return this.options.ecmaVersion >= 11 && (this.eatContextual("as") ? (de.exported = this.parseModuleExportName(), this.checkExport(en, de.exported, this.lastTokStart)) : de.exported = null), this.expectContextual("from"), this.type !== ee.string && this.unexpected(), de.source = this.parseExprAtom(), this.semicolon(), this.finishNode(de, "ExportAllDeclaration");
      }, tr.parseExport = function(de, en) {
        if (this.next(), this.eat(ee.star))
          return this.parseExportAllDeclaration(de, en);
        if (this.eat(ee._default))
          return this.checkExport(en, "default", this.lastTokStart), de.declaration = this.parseExportDefaultDeclaration(), this.finishNode(de, "ExportDefaultDeclaration");
        if (this.shouldParseExportStatement())
          de.declaration = this.parseExportDeclaration(de), de.declaration.type === "VariableDeclaration" ? this.checkVariableExport(en, de.declaration.declarations) : this.checkExport(en, de.declaration.id, de.declaration.id.start), de.specifiers = [], de.source = null;
        else {
          if (de.declaration = null, de.specifiers = this.parseExportSpecifiers(en), this.eatContextual("from"))
            this.type !== ee.string && this.unexpected(), de.source = this.parseExprAtom();
          else {
            for (var mn = 0, $n = de.specifiers; mn < $n.length; mn += 1) {
              var Vn = $n[mn];
              this.checkUnreserved(Vn.local), this.checkLocalExport(Vn.local), Vn.local.type === "Literal" && this.raise(Vn.local.start, "A string literal cannot be used as an exported binding without `from`.");
            }
            de.source = null;
          }
          this.semicolon();
        }
        return this.finishNode(de, "ExportNamedDeclaration");
      }, tr.parseExportDeclaration = function(de) {
        return this.parseStatement(null);
      }, tr.parseExportDefaultDeclaration = function() {
        var de;
        if (this.type === ee._function || (de = this.isAsyncFunction())) {
          var en = this.startNode();
          return this.next(), de && this.next(), this.parseFunction(en, Hn | dr, !1, de);
        } else if (this.type === ee._class) {
          var mn = this.startNode();
          return this.parseClass(mn, "nullableID");
        } else {
          var $n = this.parseMaybeAssign();
          return this.semicolon(), $n;
        }
      }, tr.checkExport = function(de, en, mn) {
        de && (typeof en != "string" && (en = en.type === "Identifier" ? en.name : en.value), Gt(de, en) && this.raiseRecoverable(mn, "Duplicate export '" + en + "'"), de[en] = !0);
      }, tr.checkPatternExport = function(de, en) {
        var mn = en.type;
        if (mn === "Identifier")
          this.checkExport(de, en, en.start);
        else if (mn === "ObjectPattern")
          for (var $n = 0, Vn = en.properties; $n < Vn.length; $n += 1) {
            var sr = Vn[$n];
            this.checkPatternExport(de, sr);
          }
        else if (mn === "ArrayPattern")
          for (var cr = 0, Br = en.elements; cr < Br.length; cr += 1) {
            var Kr = Br[cr];
            Kr && this.checkPatternExport(de, Kr);
          }
        else mn === "Property" ? this.checkPatternExport(de, en.value) : mn === "AssignmentPattern" ? this.checkPatternExport(de, en.left) : mn === "RestElement" && this.checkPatternExport(de, en.argument);
      }, tr.checkVariableExport = function(de, en) {
        if (de)
          for (var mn = 0, $n = en; mn < $n.length; mn += 1) {
            var Vn = $n[mn];
            this.checkPatternExport(de, Vn.id);
          }
      }, tr.shouldParseExportStatement = function() {
        return this.type.keyword === "var" || this.type.keyword === "const" || this.type.keyword === "class" || this.type.keyword === "function" || this.isLet() || this.isAsyncFunction();
      }, tr.parseExportSpecifier = function(de) {
        var en = this.startNode();
        return en.local = this.parseModuleExportName(), en.exported = this.eatContextual("as") ? this.parseModuleExportName() : en.local, this.checkExport(
          de,
          en.exported,
          en.exported.start
        ), this.finishNode(en, "ExportSpecifier");
      }, tr.parseExportSpecifiers = function(de) {
        var en = [], mn = !0;
        for (this.expect(ee.braceL); !this.eat(ee.braceR); ) {
          if (mn)
            mn = !1;
          else if (this.expect(ee.comma), this.afterTrailingComma(ee.braceR))
            break;
          en.push(this.parseExportSpecifier(de));
        }
        return en;
      }, tr.parseImport = function(de) {
        return this.next(), this.type === ee.string ? (de.specifiers = An, de.source = this.parseExprAtom()) : (de.specifiers = this.parseImportSpecifiers(), this.expectContextual("from"), de.source = this.type === ee.string ? this.parseExprAtom() : this.unexpected()), this.semicolon(), this.finishNode(de, "ImportDeclaration");
      }, tr.parseImportSpecifier = function() {
        var de = this.startNode();
        return de.imported = this.parseModuleExportName(), this.eatContextual("as") ? de.local = this.parseIdent() : (this.checkUnreserved(de.imported), de.local = de.imported), this.checkLValSimple(de.local, Fn), this.finishNode(de, "ImportSpecifier");
      }, tr.parseImportDefaultSpecifier = function() {
        var de = this.startNode();
        return de.local = this.parseIdent(), this.checkLValSimple(de.local, Fn), this.finishNode(de, "ImportDefaultSpecifier");
      }, tr.parseImportNamespaceSpecifier = function() {
        var de = this.startNode();
        return this.next(), this.expectContextual("as"), de.local = this.parseIdent(), this.checkLValSimple(de.local, Fn), this.finishNode(de, "ImportNamespaceSpecifier");
      }, tr.parseImportSpecifiers = function() {
        var de = [], en = !0;
        if (this.type === ee.name && (de.push(this.parseImportDefaultSpecifier()), !this.eat(ee.comma)))
          return de;
        if (this.type === ee.star)
          return de.push(this.parseImportNamespaceSpecifier()), de;
        for (this.expect(ee.braceL); !this.eat(ee.braceR); ) {
          if (en)
            en = !1;
          else if (this.expect(ee.comma), this.afterTrailingComma(ee.braceR))
            break;
          de.push(this.parseImportSpecifier());
        }
        return de;
      }, tr.parseModuleExportName = function() {
        if (this.options.ecmaVersion >= 13 && this.type === ee.string) {
          var de = this.parseLiteral(this.value);
          return un.test(de.value) && this.raise(de.start, "An export name cannot include a lone surrogate."), de;
        }
        return this.parseIdent(!0);
      }, tr.adaptDirectivePrologue = function(de) {
        for (var en = 0; en < de.length && this.isDirectiveCandidate(de[en]); ++en)
          de[en].directive = de[en].expression.raw.slice(1, -1);
      }, tr.isDirectiveCandidate = function(de) {
        return this.options.ecmaVersion >= 5 && de.type === "ExpressionStatement" && de.expression.type === "Literal" && typeof de.expression.value == "string" && // Reject parenthesized strings.
        (this.input[de.start] === '"' || this.input[de.start] === "'");
      };
      var Sr = Tn.prototype;
      Sr.toAssignable = function(de, en, mn) {
        if (this.options.ecmaVersion >= 6 && de)
          switch (de.type) {
            case "Identifier":
              this.inAsync && de.name === "await" && this.raise(de.start, "Cannot use 'await' as identifier inside an async function");
              break;
            case "ObjectPattern":
            case "ArrayPattern":
            case "AssignmentPattern":
            case "RestElement":
              break;
            case "ObjectExpression":
              de.type = "ObjectPattern", mn && this.checkPatternErrors(mn, !0);
              for (var $n = 0, Vn = de.properties; $n < Vn.length; $n += 1) {
                var sr = Vn[$n];
                this.toAssignable(sr, en), sr.type === "RestElement" && (sr.argument.type === "ArrayPattern" || sr.argument.type === "ObjectPattern") && this.raise(sr.argument.start, "Unexpected token");
              }
              break;
            case "Property":
              de.kind !== "init" && this.raise(de.key.start, "Object pattern can't contain getter or setter"), this.toAssignable(de.value, en);
              break;
            case "ArrayExpression":
              de.type = "ArrayPattern", mn && this.checkPatternErrors(mn, !0), this.toAssignableList(de.elements, en);
              break;
            case "SpreadElement":
              de.type = "RestElement", this.toAssignable(de.argument, en), de.argument.type === "AssignmentPattern" && this.raise(de.argument.start, "Rest elements cannot have a default value");
              break;
            case "AssignmentExpression":
              de.operator !== "=" && this.raise(de.left.end, "Only '=' operator can be used for specifying default value."), de.type = "AssignmentPattern", delete de.operator, this.toAssignable(de.left, en);
              break;
            case "ParenthesizedExpression":
              this.toAssignable(de.expression, en, mn);
              break;
            case "ChainExpression":
              this.raiseRecoverable(de.start, "Optional chaining cannot appear in left-hand side");
              break;
            case "MemberExpression":
              if (!en)
                break;
            default:
              this.raise(de.start, "Assigning to rvalue");
          }
        else mn && this.checkPatternErrors(mn, !0);
        return de;
      }, Sr.toAssignableList = function(de, en) {
        for (var mn = de.length, $n = 0; $n < mn; $n++) {
          var Vn = de[$n];
          Vn && this.toAssignable(Vn, en);
        }
        if (mn) {
          var sr = de[mn - 1];
          this.options.ecmaVersion === 6 && en && sr && sr.type === "RestElement" && sr.argument.type !== "Identifier" && this.unexpected(sr.argument.start);
        }
        return de;
      }, Sr.parseSpread = function(de) {
        var en = this.startNode();
        return this.next(), en.argument = this.parseMaybeAssign(!1, de), this.finishNode(en, "SpreadElement");
      }, Sr.parseRestBinding = function() {
        var de = this.startNode();
        return this.next(), this.options.ecmaVersion === 6 && this.type !== ee.name && this.unexpected(), de.argument = this.parseBindingAtom(), this.finishNode(de, "RestElement");
      }, Sr.parseBindingAtom = function() {
        if (this.options.ecmaVersion >= 6)
          switch (this.type) {
            case ee.bracketL:
              var de = this.startNode();
              return this.next(), de.elements = this.parseBindingList(ee.bracketR, !0, !0), this.finishNode(de, "ArrayPattern");
            case ee.braceL:
              return this.parseObj(!0);
          }
        return this.parseIdent();
      }, Sr.parseBindingList = function(de, en, mn, $n) {
        for (var Vn = [], sr = !0; !this.eat(de); )
          if (sr ? sr = !1 : this.expect(ee.comma), en && this.type === ee.comma)
            Vn.push(null);
          else {
            if (mn && this.afterTrailingComma(de))
              break;
            if (this.type === ee.ellipsis) {
              var cr = this.parseRestBinding();
              this.parseBindingListItem(cr), Vn.push(cr), this.type === ee.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.expect(de);
              break;
            } else
              Vn.push(this.parseAssignableListItem($n));
          }
        return Vn;
      }, Sr.parseAssignableListItem = function(de) {
        var en = this.parseMaybeDefault(this.start, this.startLoc);
        return this.parseBindingListItem(en), en;
      }, Sr.parseBindingListItem = function(de) {
        return de;
      }, Sr.parseMaybeDefault = function(de, en, mn) {
        if (mn = mn || this.parseBindingAtom(), this.options.ecmaVersion < 6 || !this.eat(ee.eq))
          return mn;
        var $n = this.startNodeAt(de, en);
        return $n.left = mn, $n.right = this.parseMaybeAssign(), this.finishNode($n, "AssignmentPattern");
      }, Sr.checkLValSimple = function(de, en, mn) {
        en === void 0 && (en = Kn);
        var $n = en !== Kn;
        switch (de.type) {
          case "Identifier":
            this.strict && this.reservedWordsStrictBind.test(de.name) && this.raiseRecoverable(de.start, ($n ? "Binding " : "Assigning to ") + de.name + " in strict mode"), $n && (en === Fn && de.name === "let" && this.raiseRecoverable(de.start, "let is disallowed as a lexically bound name"), mn && (Gt(mn, de.name) && this.raiseRecoverable(de.start, "Argument name clash"), mn[de.name] = !0), en !== Mn && this.declareName(de.name, en, de.start));
            break;
          case "ChainExpression":
            this.raiseRecoverable(de.start, "Optional chaining cannot appear in left-hand side");
            break;
          case "MemberExpression":
            $n && this.raiseRecoverable(de.start, "Binding member expression");
            break;
          case "ParenthesizedExpression":
            return $n && this.raiseRecoverable(de.start, "Binding parenthesized expression"), this.checkLValSimple(de.expression, en, mn);
          default:
            this.raise(de.start, ($n ? "Binding" : "Assigning to") + " rvalue");
        }
      }, Sr.checkLValPattern = function(de, en, mn) {
        switch (en === void 0 && (en = Kn), de.type) {
          case "ObjectPattern":
            for (var $n = 0, Vn = de.properties; $n < Vn.length; $n += 1) {
              var sr = Vn[$n];
              this.checkLValInnerPattern(sr, en, mn);
            }
            break;
          case "ArrayPattern":
            for (var cr = 0, Br = de.elements; cr < Br.length; cr += 1) {
              var Kr = Br[cr];
              Kr && this.checkLValInnerPattern(Kr, en, mn);
            }
            break;
          default:
            this.checkLValSimple(de, en, mn);
        }
      }, Sr.checkLValInnerPattern = function(de, en, mn) {
        switch (en === void 0 && (en = Kn), de.type) {
          case "Property":
            this.checkLValInnerPattern(de.value, en, mn);
            break;
          case "AssignmentPattern":
            this.checkLValPattern(de.left, en, mn);
            break;
          case "RestElement":
            this.checkLValPattern(de.argument, en, mn);
            break;
          default:
            this.checkLValPattern(de, en, mn);
        }
      };
      var kr = function(en, mn, $n, Vn, sr) {
        this.token = en, this.isExpr = !!mn, this.preserveSpace = !!$n, this.override = Vn, this.generator = !!sr;
      }, Nr = {
        b_stat: new kr("{", !1),
        b_expr: new kr("{", !0),
        b_tmpl: new kr("${", !1),
        p_stat: new kr("(", !1),
        p_expr: new kr("(", !0),
        q_tmpl: new kr("`", !0, !0, function(de) {
          return de.tryReadTemplateToken();
        }),
        f_stat: new kr("function", !1),
        f_expr: new kr("function", !0),
        f_expr_gen: new kr("function", !0, !1, null, !0),
        f_gen: new kr("function", !1, !1, null, !0)
      }, Ur = Tn.prototype;
      Ur.initialContext = function() {
        return [Nr.b_stat];
      }, Ur.curContext = function() {
        return this.context[this.context.length - 1];
      }, Ur.braceIsBlock = function(de) {
        var en = this.curContext();
        return en === Nr.f_expr || en === Nr.f_stat ? !0 : de === ee.colon && (en === Nr.b_stat || en === Nr.b_expr) ? !en.isExpr : de === ee._return || de === ee.name && this.exprAllowed ? Re.test(this.input.slice(this.lastTokEnd, this.start)) : de === ee._else || de === ee.semi || de === ee.eof || de === ee.parenR || de === ee.arrow ? !0 : de === ee.braceL ? en === Nr.b_stat : de === ee._var || de === ee._const || de === ee.name ? !1 : !this.exprAllowed;
      }, Ur.inGeneratorContext = function() {
        for (var de = this.context.length - 1; de >= 1; de--) {
          var en = this.context[de];
          if (en.token === "function")
            return en.generator;
        }
        return !1;
      }, Ur.updateContext = function(de) {
        var en, mn = this.type;
        mn.keyword && de === ee.dot ? this.exprAllowed = !1 : (en = mn.updateContext) ? en.call(this, de) : this.exprAllowed = mn.beforeExpr;
      }, Ur.overrideContext = function(de) {
        this.curContext() !== de && (this.context[this.context.length - 1] = de);
      }, ee.parenR.updateContext = ee.braceR.updateContext = function() {
        if (this.context.length === 1) {
          this.exprAllowed = !0;
          return;
        }
        var de = this.context.pop();
        de === Nr.b_stat && this.curContext().token === "function" && (de = this.context.pop()), this.exprAllowed = !de.isExpr;
      }, ee.braceL.updateContext = function(de) {
        this.context.push(this.braceIsBlock(de) ? Nr.b_stat : Nr.b_expr), this.exprAllowed = !0;
      }, ee.dollarBraceL.updateContext = function() {
        this.context.push(Nr.b_tmpl), this.exprAllowed = !0;
      }, ee.parenL.updateContext = function(de) {
        var en = de === ee._if || de === ee._for || de === ee._with || de === ee._while;
        this.context.push(en ? Nr.p_stat : Nr.p_expr), this.exprAllowed = !0;
      }, ee.incDec.updateContext = function() {
      }, ee._function.updateContext = ee._class.updateContext = function(de) {
        de.beforeExpr && de !== ee._else && !(de === ee.semi && this.curContext() !== Nr.p_stat) && !(de === ee._return && Re.test(this.input.slice(this.lastTokEnd, this.start))) && !((de === ee.colon || de === ee.braceL) && this.curContext() === Nr.b_stat) ? this.context.push(Nr.f_expr) : this.context.push(Nr.f_stat), this.exprAllowed = !1;
      }, ee.colon.updateContext = function() {
        this.curContext().token === "function" && this.context.pop(), this.exprAllowed = !0;
      }, ee.backQuote.updateContext = function() {
        this.curContext() === Nr.q_tmpl ? this.context.pop() : this.context.push(Nr.q_tmpl), this.exprAllowed = !1;
      }, ee.star.updateContext = function(de) {
        if (de === ee._function) {
          var en = this.context.length - 1;
          this.context[en] === Nr.f_expr ? this.context[en] = Nr.f_expr_gen : this.context[en] = Nr.f_gen;
        }
        this.exprAllowed = !0;
      }, ee.name.updateContext = function(de) {
        var en = !1;
        this.options.ecmaVersion >= 6 && de !== ee.dot && (this.value === "of" && !this.exprAllowed || this.value === "yield" && this.inGeneratorContext()) && (en = !0), this.exprAllowed = en;
      };
      var _r = Tn.prototype;
      _r.checkPropClash = function(de, en, mn) {
        if (!(this.options.ecmaVersion >= 9 && de.type === "SpreadElement") && !(this.options.ecmaVersion >= 6 && (de.computed || de.method || de.shorthand))) {
          var $n = de.key, Vn;
          switch ($n.type) {
            case "Identifier":
              Vn = $n.name;
              break;
            case "Literal":
              Vn = String($n.value);
              break;
            default:
              return;
          }
          var sr = de.kind;
          if (this.options.ecmaVersion >= 6) {
            Vn === "__proto__" && sr === "init" && (en.proto && (mn ? mn.doubleProto < 0 && (mn.doubleProto = $n.start) : this.raiseRecoverable($n.start, "Redefinition of __proto__ property")), en.proto = !0);
            return;
          }
          Vn = "$" + Vn;
          var cr = en[Vn];
          if (cr) {
            var Br;
            sr === "init" ? Br = this.strict && cr.init || cr.get || cr.set : Br = cr.init || cr[sr], Br && this.raiseRecoverable($n.start, "Redefinition of property");
          } else
            cr = en[Vn] = {
              init: !1,
              get: !1,
              set: !1
            };
          cr[sr] = !0;
        }
      }, _r.parseExpression = function(de, en) {
        var mn = this.start, $n = this.startLoc, Vn = this.parseMaybeAssign(de, en);
        if (this.type === ee.comma) {
          var sr = this.startNodeAt(mn, $n);
          for (sr.expressions = [Vn]; this.eat(ee.comma); )
            sr.expressions.push(this.parseMaybeAssign(de, en));
          return this.finishNode(sr, "SequenceExpression");
        }
        return Vn;
      }, _r.parseMaybeAssign = function(de, en, mn) {
        if (this.isContextual("yield")) {
          if (this.inGenerator)
            return this.parseYield(de);
          this.exprAllowed = !1;
        }
        var $n = !1, Vn = -1, sr = -1, cr = -1;
        en ? (Vn = en.parenthesizedAssign, sr = en.trailingComma, cr = en.doubleProto, en.parenthesizedAssign = en.trailingComma = -1) : (en = new rr(), $n = !0);
        var Br = this.start, Kr = this.startLoc;
        (this.type === ee.parenL || this.type === ee.name) && (this.potentialArrowAt = this.start, this.potentialArrowInForAwait = de === "await");
        var Li = this.parseMaybeConditional(de, en);
        if (mn && (Li = mn.call(this, Li, Br, Kr)), this.type.isAssign) {
          var Pi = this.startNodeAt(Br, Kr);
          return Pi.operator = this.value, this.type === ee.eq && (Li = this.toAssignable(Li, !1, en)), $n || (en.parenthesizedAssign = en.trailingComma = en.doubleProto = -1), en.shorthandAssign >= Li.start && (en.shorthandAssign = -1), this.type === ee.eq ? this.checkLValPattern(Li) : this.checkLValSimple(Li), Pi.left = Li, this.next(), Pi.right = this.parseMaybeAssign(de), cr > -1 && (en.doubleProto = cr), this.finishNode(Pi, "AssignmentExpression");
        } else
          $n && this.checkExpressionErrors(en, !0);
        return Vn > -1 && (en.parenthesizedAssign = Vn), sr > -1 && (en.trailingComma = sr), Li;
      }, _r.parseMaybeConditional = function(de, en) {
        var mn = this.start, $n = this.startLoc, Vn = this.parseExprOps(de, en);
        if (this.checkExpressionErrors(en))
          return Vn;
        if (this.eat(ee.question)) {
          var sr = this.startNodeAt(mn, $n);
          return sr.test = Vn, sr.consequent = this.parseMaybeAssign(), this.expect(ee.colon), sr.alternate = this.parseMaybeAssign(de), this.finishNode(sr, "ConditionalExpression");
        }
        return Vn;
      }, _r.parseExprOps = function(de, en) {
        var mn = this.start, $n = this.startLoc, Vn = this.parseMaybeUnary(en, !1, !1, de);
        return this.checkExpressionErrors(en) || Vn.start === mn && Vn.type === "ArrowFunctionExpression" ? Vn : this.parseExprOp(Vn, mn, $n, -1, de);
      }, _r.parseExprOp = function(de, en, mn, $n, Vn) {
        var sr = this.type.binop;
        if (sr != null && (!Vn || this.type !== ee._in) && sr > $n) {
          var cr = this.type === ee.logicalOR || this.type === ee.logicalAND, Br = this.type === ee.coalesce;
          Br && (sr = ee.logicalAND.binop);
          var Kr = this.value;
          this.next();
          var Li = this.start, Pi = this.startLoc, Zs = this.parseExprOp(this.parseMaybeUnary(null, !1, !1, Vn), Li, Pi, sr, Vn), Rl = this.buildBinary(en, mn, de, Zs, Kr, cr || Br);
          return (cr && this.type === ee.coalesce || Br && (this.type === ee.logicalOR || this.type === ee.logicalAND)) && this.raiseRecoverable(this.start, "Logical expressions and coalesce expressions cannot be mixed. Wrap either by parentheses"), this.parseExprOp(Rl, en, mn, $n, Vn);
        }
        return de;
      }, _r.buildBinary = function(de, en, mn, $n, Vn, sr) {
        $n.type === "PrivateIdentifier" && this.raise($n.start, "Private identifier can only be left side of binary expression");
        var cr = this.startNodeAt(de, en);
        return cr.left = mn, cr.operator = Vn, cr.right = $n, this.finishNode(cr, sr ? "LogicalExpression" : "BinaryExpression");
      }, _r.parseMaybeUnary = function(de, en, mn, $n) {
        var Vn = this.start, sr = this.startLoc, cr;
        if (this.isContextual("await") && this.canAwait)
          cr = this.parseAwait($n), en = !0;
        else if (this.type.prefix) {
          var Br = this.startNode(), Kr = this.type === ee.incDec;
          Br.operator = this.value, Br.prefix = !0, this.next(), Br.argument = this.parseMaybeUnary(null, !0, Kr, $n), this.checkExpressionErrors(de, !0), Kr ? this.checkLValSimple(Br.argument) : this.strict && Br.operator === "delete" && Br.argument.type === "Identifier" ? this.raiseRecoverable(Br.start, "Deleting local variable in strict mode") : Br.operator === "delete" && Zr(Br.argument) ? this.raiseRecoverable(Br.start, "Private fields can not be deleted") : en = !0, cr = this.finishNode(Br, Kr ? "UpdateExpression" : "UnaryExpression");
        } else if (!en && this.type === ee.privateId)
          ($n || this.privateNameStack.length === 0) && this.options.checkPrivateFields && this.unexpected(), cr = this.parsePrivateIdent(), this.type !== ee._in && this.unexpected();
        else {
          if (cr = this.parseExprSubscripts(de, $n), this.checkExpressionErrors(de))
            return cr;
          for (; this.type.postfix && !this.canInsertSemicolon(); ) {
            var Li = this.startNodeAt(Vn, sr);
            Li.operator = this.value, Li.prefix = !1, Li.argument = cr, this.checkLValSimple(cr), this.next(), cr = this.finishNode(Li, "UpdateExpression");
          }
        }
        if (!mn && this.eat(ee.starstar))
          if (en)
            this.unexpected(this.lastTokStart);
          else
            return this.buildBinary(Vn, sr, cr, this.parseMaybeUnary(null, !1, !1, $n), "**", !1);
        else
          return cr;
      };
      function Zr(de) {
        return de.type === "MemberExpression" && de.property.type === "PrivateIdentifier" || de.type === "ChainExpression" && Zr(de.expression);
      }
      _r.parseExprSubscripts = function(de, en) {
        var mn = this.start, $n = this.startLoc, Vn = this.parseExprAtom(de, en);
        if (Vn.type === "ArrowFunctionExpression" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== ")")
          return Vn;
        var sr = this.parseSubscripts(Vn, mn, $n, !1, en);
        return de && sr.type === "MemberExpression" && (de.parenthesizedAssign >= sr.start && (de.parenthesizedAssign = -1), de.parenthesizedBind >= sr.start && (de.parenthesizedBind = -1), de.trailingComma >= sr.start && (de.trailingComma = -1)), sr;
      }, _r.parseSubscripts = function(de, en, mn, $n, Vn) {
        for (var sr = this.options.ecmaVersion >= 8 && de.type === "Identifier" && de.name === "async" && this.lastTokEnd === de.end && !this.canInsertSemicolon() && de.end - de.start === 5 && this.potentialArrowAt === de.start, cr = !1; ; ) {
          var Br = this.parseSubscript(de, en, mn, $n, sr, cr, Vn);
          if (Br.optional && (cr = !0), Br === de || Br.type === "ArrowFunctionExpression") {
            if (cr) {
              var Kr = this.startNodeAt(en, mn);
              Kr.expression = Br, Br = this.finishNode(Kr, "ChainExpression");
            }
            return Br;
          }
          de = Br;
        }
      }, _r.shouldParseAsyncArrow = function() {
        return !this.canInsertSemicolon() && this.eat(ee.arrow);
      }, _r.parseSubscriptAsyncArrow = function(de, en, mn, $n) {
        return this.parseArrowExpression(this.startNodeAt(de, en), mn, !0, $n);
      }, _r.parseSubscript = function(de, en, mn, $n, Vn, sr, cr) {
        var Br = this.options.ecmaVersion >= 11, Kr = Br && this.eat(ee.questionDot);
        $n && Kr && this.raise(this.lastTokStart, "Optional chaining cannot appear in the callee of new expressions");
        var Li = this.eat(ee.bracketL);
        if (Li || Kr && this.type !== ee.parenL && this.type !== ee.backQuote || this.eat(ee.dot)) {
          var Pi = this.startNodeAt(en, mn);
          Pi.object = de, Li ? (Pi.property = this.parseExpression(), this.expect(ee.bracketR)) : this.type === ee.privateId && de.type !== "Super" ? Pi.property = this.parsePrivateIdent() : Pi.property = this.parseIdent(this.options.allowReserved !== "never"), Pi.computed = !!Li, Br && (Pi.optional = Kr), de = this.finishNode(Pi, "MemberExpression");
        } else if (!$n && this.eat(ee.parenL)) {
          var Zs = new rr(), Rl = this.yieldPos, Kl = this.awaitPos, Ml = this.awaitIdentPos;
          this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0;
          var mc = this.parseExprList(ee.parenR, this.options.ecmaVersion >= 8, !1, Zs);
          if (Vn && !Kr && this.shouldParseAsyncArrow())
            return this.checkPatternErrors(Zs, !1), this.checkYieldAwaitInDefaultParams(), this.awaitIdentPos > 0 && this.raise(this.awaitIdentPos, "Cannot use 'await' as identifier inside an async function"), this.yieldPos = Rl, this.awaitPos = Kl, this.awaitIdentPos = Ml, this.parseSubscriptAsyncArrow(en, mn, mc, cr);
          this.checkExpressionErrors(Zs, !0), this.yieldPos = Rl || this.yieldPos, this.awaitPos = Kl || this.awaitPos, this.awaitIdentPos = Ml || this.awaitIdentPos;
          var Wr = this.startNodeAt(en, mn);
          Wr.callee = de, Wr.arguments = mc, Br && (Wr.optional = Kr), de = this.finishNode(Wr, "CallExpression");
        } else if (this.type === ee.backQuote) {
          (Kr || sr) && this.raise(this.start, "Optional chaining cannot appear in the tag of tagged template expressions");
          var Hr = this.startNodeAt(en, mn);
          Hr.tag = de, Hr.quasi = this.parseTemplate({ isTagged: !0 }), de = this.finishNode(Hr, "TaggedTemplateExpression");
        }
        return de;
      }, _r.parseExprAtom = function(de, en, mn) {
        this.type === ee.slash && this.readRegexp();
        var $n, Vn = this.potentialArrowAt === this.start;
        switch (this.type) {
          case ee._super:
            return this.allowSuper || this.raise(this.start, "'super' keyword outside a method"), $n = this.startNode(), this.next(), this.type === ee.parenL && !this.allowDirectSuper && this.raise($n.start, "super() call outside constructor of a subclass"), this.type !== ee.dot && this.type !== ee.bracketL && this.type !== ee.parenL && this.unexpected(), this.finishNode($n, "Super");
          case ee._this:
            return $n = this.startNode(), this.next(), this.finishNode($n, "ThisExpression");
          case ee.name:
            var sr = this.start, cr = this.startLoc, Br = this.containsEsc, Kr = this.parseIdent(!1);
            if (this.options.ecmaVersion >= 8 && !Br && Kr.name === "async" && !this.canInsertSemicolon() && this.eat(ee._function))
              return this.overrideContext(Nr.f_expr), this.parseFunction(this.startNodeAt(sr, cr), 0, !1, !0, en);
            if (Vn && !this.canInsertSemicolon()) {
              if (this.eat(ee.arrow))
                return this.parseArrowExpression(this.startNodeAt(sr, cr), [Kr], !1, en);
              if (this.options.ecmaVersion >= 8 && Kr.name === "async" && this.type === ee.name && !Br && (!this.potentialArrowInForAwait || this.value !== "of" || this.containsEsc))
                return Kr = this.parseIdent(!1), (this.canInsertSemicolon() || !this.eat(ee.arrow)) && this.unexpected(), this.parseArrowExpression(this.startNodeAt(sr, cr), [Kr], !0, en);
            }
            return Kr;
          case ee.regexp:
            var Li = this.value;
            return $n = this.parseLiteral(Li.value), $n.regex = { pattern: Li.pattern, flags: Li.flags }, $n;
          case ee.num:
          case ee.string:
            return this.parseLiteral(this.value);
          case ee._null:
          case ee._true:
          case ee._false:
            return $n = this.startNode(), $n.value = this.type === ee._null ? null : this.type === ee._true, $n.raw = this.type.keyword, this.next(), this.finishNode($n, "Literal");
          case ee.parenL:
            var Pi = this.start, Zs = this.parseParenAndDistinguishExpression(Vn, en);
            return de && (de.parenthesizedAssign < 0 && !this.isSimpleAssignTarget(Zs) && (de.parenthesizedAssign = Pi), de.parenthesizedBind < 0 && (de.parenthesizedBind = Pi)), Zs;
          case ee.bracketL:
            return $n = this.startNode(), this.next(), $n.elements = this.parseExprList(ee.bracketR, !0, !0, de), this.finishNode($n, "ArrayExpression");
          case ee.braceL:
            return this.overrideContext(Nr.b_expr), this.parseObj(!1, de);
          case ee._function:
            return $n = this.startNode(), this.next(), this.parseFunction($n, 0);
          case ee._class:
            return this.parseClass(this.startNode(), !1);
          case ee._new:
            return this.parseNew();
          case ee.backQuote:
            return this.parseTemplate();
          case ee._import:
            return this.options.ecmaVersion >= 11 ? this.parseExprImport(mn) : this.unexpected();
          default:
            return this.parseExprAtomDefault();
        }
      }, _r.parseExprAtomDefault = function() {
        this.unexpected();
      }, _r.parseExprImport = function(de) {
        var en = this.startNode();
        if (this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword import"), this.next(), this.type === ee.parenL && !de)
          return this.parseDynamicImport(en);
        if (this.type === ee.dot) {
          var mn = this.startNodeAt(en.start, en.loc && en.loc.start);
          return mn.name = "import", en.meta = this.finishNode(mn, "Identifier"), this.parseImportMeta(en);
        } else
          this.unexpected();
      }, _r.parseDynamicImport = function(de) {
        if (this.next(), de.source = this.parseMaybeAssign(), !this.eat(ee.parenR)) {
          var en = this.start;
          this.eat(ee.comma) && this.eat(ee.parenR) ? this.raiseRecoverable(en, "Trailing comma is not allowed in import()") : this.unexpected(en);
        }
        return this.finishNode(de, "ImportExpression");
      }, _r.parseImportMeta = function(de) {
        this.next();
        var en = this.containsEsc;
        return de.property = this.parseIdent(!0), de.property.name !== "meta" && this.raiseRecoverable(de.property.start, "The only valid meta property for import is 'import.meta'"), en && this.raiseRecoverable(de.start, "'import.meta' must not contain escaped characters"), this.options.sourceType !== "module" && !this.options.allowImportExportEverywhere && this.raiseRecoverable(de.start, "Cannot use 'import.meta' outside a module"), this.finishNode(de, "MetaProperty");
      }, _r.parseLiteral = function(de) {
        var en = this.startNode();
        return en.value = de, en.raw = this.input.slice(this.start, this.end), en.raw.charCodeAt(en.raw.length - 1) === 110 && (en.bigint = en.raw.slice(0, -1).replace(/_/g, "")), this.next(), this.finishNode(en, "Literal");
      }, _r.parseParenExpression = function() {
        this.expect(ee.parenL);
        var de = this.parseExpression();
        return this.expect(ee.parenR), de;
      }, _r.shouldParseArrow = function(de) {
        return !this.canInsertSemicolon();
      }, _r.parseParenAndDistinguishExpression = function(de, en) {
        var mn = this.start, $n = this.startLoc, Vn, sr = this.options.ecmaVersion >= 8;
        if (this.options.ecmaVersion >= 6) {
          this.next();
          var cr = this.start, Br = this.startLoc, Kr = [], Li = !0, Pi = !1, Zs = new rr(), Rl = this.yieldPos, Kl = this.awaitPos, Ml;
          for (this.yieldPos = 0, this.awaitPos = 0; this.type !== ee.parenR; )
            if (Li ? Li = !1 : this.expect(ee.comma), sr && this.afterTrailingComma(ee.parenR, !0)) {
              Pi = !0;
              break;
            } else if (this.type === ee.ellipsis) {
              Ml = this.start, Kr.push(this.parseParenItem(this.parseRestBinding())), this.type === ee.comma && this.raiseRecoverable(
                this.start,
                "Comma is not permitted after the rest element"
              );
              break;
            } else
              Kr.push(this.parseMaybeAssign(!1, Zs, this.parseParenItem));
          var mc = this.lastTokEnd, Wr = this.lastTokEndLoc;
          if (this.expect(ee.parenR), de && this.shouldParseArrow(Kr) && this.eat(ee.arrow))
            return this.checkPatternErrors(Zs, !1), this.checkYieldAwaitInDefaultParams(), this.yieldPos = Rl, this.awaitPos = Kl, this.parseParenArrowList(mn, $n, Kr, en);
          (!Kr.length || Pi) && this.unexpected(this.lastTokStart), Ml && this.unexpected(Ml), this.checkExpressionErrors(Zs, !0), this.yieldPos = Rl || this.yieldPos, this.awaitPos = Kl || this.awaitPos, Kr.length > 1 ? (Vn = this.startNodeAt(cr, Br), Vn.expressions = Kr, this.finishNodeAt(Vn, "SequenceExpression", mc, Wr)) : Vn = Kr[0];
        } else
          Vn = this.parseParenExpression();
        if (this.options.preserveParens) {
          var Hr = this.startNodeAt(mn, $n);
          return Hr.expression = Vn, this.finishNode(Hr, "ParenthesizedExpression");
        } else
          return Vn;
      }, _r.parseParenItem = function(de) {
        return de;
      }, _r.parseParenArrowList = function(de, en, mn, $n) {
        return this.parseArrowExpression(this.startNodeAt(de, en), mn, !1, $n);
      };
      var Jr = [];
      _r.parseNew = function() {
        this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword new");
        var de = this.startNode();
        if (this.next(), this.options.ecmaVersion >= 6 && this.type === ee.dot) {
          var en = this.startNodeAt(de.start, de.loc && de.loc.start);
          en.name = "new", de.meta = this.finishNode(en, "Identifier"), this.next();
          var mn = this.containsEsc;
          return de.property = this.parseIdent(!0), de.property.name !== "target" && this.raiseRecoverable(de.property.start, "The only valid meta property for new is 'new.target'"), mn && this.raiseRecoverable(de.start, "'new.target' must not contain escaped characters"), this.allowNewDotTarget || this.raiseRecoverable(de.start, "'new.target' can only be used in functions and class static block"), this.finishNode(de, "MetaProperty");
        }
        var $n = this.start, Vn = this.startLoc;
        return de.callee = this.parseSubscripts(this.parseExprAtom(null, !1, !0), $n, Vn, !0, !1), this.eat(ee.parenL) ? de.arguments = this.parseExprList(ee.parenR, this.options.ecmaVersion >= 8, !1) : de.arguments = Jr, this.finishNode(de, "NewExpression");
      }, _r.parseTemplateElement = function(de) {
        var en = de.isTagged, mn = this.startNode();
        return this.type === ee.invalidTemplate ? (en || this.raiseRecoverable(this.start, "Bad escape sequence in untagged template literal"), mn.value = {
          raw: this.value,
          cooked: null
        }) : mn.value = {
          raw: this.input.slice(this.start, this.end).replace(/\r\n?/g, `
`),
          cooked: this.value
        }, this.next(), mn.tail = this.type === ee.backQuote, this.finishNode(mn, "TemplateElement");
      }, _r.parseTemplate = function(de) {
        de === void 0 && (de = {});
        var en = de.isTagged;
        en === void 0 && (en = !1);
        var mn = this.startNode();
        this.next(), mn.expressions = [];
        var $n = this.parseTemplateElement({ isTagged: en });
        for (mn.quasis = [$n]; !$n.tail; )
          this.type === ee.eof && this.raise(this.pos, "Unterminated template literal"), this.expect(ee.dollarBraceL), mn.expressions.push(this.parseExpression()), this.expect(ee.braceR), mn.quasis.push($n = this.parseTemplateElement({ isTagged: en }));
        return this.next(), this.finishNode(mn, "TemplateLiteral");
      }, _r.isAsyncProp = function(de) {
        return !de.computed && de.key.type === "Identifier" && de.key.name === "async" && (this.type === ee.name || this.type === ee.num || this.type === ee.string || this.type === ee.bracketL || this.type.keyword || this.options.ecmaVersion >= 9 && this.type === ee.star) && !Re.test(this.input.slice(this.lastTokEnd, this.start));
      }, _r.parseObj = function(de, en) {
        var mn = this.startNode(), $n = !0, Vn = {};
        for (mn.properties = [], this.next(); !this.eat(ee.braceR); ) {
          if ($n)
            $n = !1;
          else if (this.expect(ee.comma), this.options.ecmaVersion >= 5 && this.afterTrailingComma(ee.braceR))
            break;
          var sr = this.parseProperty(de, en);
          de || this.checkPropClash(sr, Vn, en), mn.properties.push(sr);
        }
        return this.finishNode(mn, de ? "ObjectPattern" : "ObjectExpression");
      }, _r.parseProperty = function(de, en) {
        var mn = this.startNode(), $n, Vn, sr, cr;
        if (this.options.ecmaVersion >= 9 && this.eat(ee.ellipsis))
          return de ? (mn.argument = this.parseIdent(!1), this.type === ee.comma && this.raiseRecoverable(this.start, "Comma is not permitted after the rest element"), this.finishNode(mn, "RestElement")) : (mn.argument = this.parseMaybeAssign(!1, en), this.type === ee.comma && en && en.trailingComma < 0 && (en.trailingComma = this.start), this.finishNode(mn, "SpreadElement"));
        this.options.ecmaVersion >= 6 && (mn.method = !1, mn.shorthand = !1, (de || en) && (sr = this.start, cr = this.startLoc), de || ($n = this.eat(ee.star)));
        var Br = this.containsEsc;
        return this.parsePropertyName(mn), !de && !Br && this.options.ecmaVersion >= 8 && !$n && this.isAsyncProp(mn) ? (Vn = !0, $n = this.options.ecmaVersion >= 9 && this.eat(ee.star), this.parsePropertyName(mn)) : Vn = !1, this.parsePropertyValue(mn, de, $n, Vn, sr, cr, en, Br), this.finishNode(mn, "Property");
      }, _r.parseGetterSetter = function(de) {
        de.kind = de.key.name, this.parsePropertyName(de), de.value = this.parseMethod(!1);
        var en = de.kind === "get" ? 0 : 1;
        if (de.value.params.length !== en) {
          var mn = de.value.start;
          de.kind === "get" ? this.raiseRecoverable(mn, "getter should have no params") : this.raiseRecoverable(mn, "setter should have exactly one param");
        } else
          de.kind === "set" && de.value.params[0].type === "RestElement" && this.raiseRecoverable(de.value.params[0].start, "Setter cannot use rest params");
      }, _r.parsePropertyValue = function(de, en, mn, $n, Vn, sr, cr, Br) {
        (mn || $n) && this.type === ee.colon && this.unexpected(), this.eat(ee.colon) ? (de.value = en ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(!1, cr), de.kind = "init") : this.options.ecmaVersion >= 6 && this.type === ee.parenL ? (en && this.unexpected(), de.kind = "init", de.method = !0, de.value = this.parseMethod(mn, $n)) : !en && !Br && this.options.ecmaVersion >= 5 && !de.computed && de.key.type === "Identifier" && (de.key.name === "get" || de.key.name === "set") && this.type !== ee.comma && this.type !== ee.braceR && this.type !== ee.eq ? ((mn || $n) && this.unexpected(), this.parseGetterSetter(de)) : this.options.ecmaVersion >= 6 && !de.computed && de.key.type === "Identifier" ? ((mn || $n) && this.unexpected(), this.checkUnreserved(de.key), de.key.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = Vn), de.kind = "init", en ? de.value = this.parseMaybeDefault(Vn, sr, this.copyNode(de.key)) : this.type === ee.eq && cr ? (cr.shorthandAssign < 0 && (cr.shorthandAssign = this.start), de.value = this.parseMaybeDefault(Vn, sr, this.copyNode(de.key))) : de.value = this.copyNode(de.key), de.shorthand = !0) : this.unexpected();
      }, _r.parsePropertyName = function(de) {
        if (this.options.ecmaVersion >= 6) {
          if (this.eat(ee.bracketL))
            return de.computed = !0, de.key = this.parseMaybeAssign(), this.expect(ee.bracketR), de.key;
          de.computed = !1;
        }
        return de.key = this.type === ee.num || this.type === ee.string ? this.parseExprAtom() : this.parseIdent(this.options.allowReserved !== "never");
      }, _r.initFunction = function(de) {
        de.id = null, this.options.ecmaVersion >= 6 && (de.generator = de.expression = !1), this.options.ecmaVersion >= 8 && (de.async = !1);
      }, _r.parseMethod = function(de, en, mn) {
        var $n = this.startNode(), Vn = this.yieldPos, sr = this.awaitPos, cr = this.awaitIdentPos;
        return this.initFunction($n), this.options.ecmaVersion >= 6 && ($n.generator = de), this.options.ecmaVersion >= 8 && ($n.async = !!en), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, this.enterScope(Ln(en, $n.generator) | Yn | (mn ? Zn : 0)), this.expect(ee.parenL), $n.params = this.parseBindingList(ee.parenR, !1, this.options.ecmaVersion >= 8), this.checkYieldAwaitInDefaultParams(), this.parseFunctionBody($n, !1, !0, !1), this.yieldPos = Vn, this.awaitPos = sr, this.awaitIdentPos = cr, this.finishNode($n, "FunctionExpression");
      }, _r.parseArrowExpression = function(de, en, mn, $n) {
        var Vn = this.yieldPos, sr = this.awaitPos, cr = this.awaitIdentPos;
        return this.enterScope(Ln(mn, !1) | jn), this.initFunction(de), this.options.ecmaVersion >= 8 && (de.async = !!mn), this.yieldPos = 0, this.awaitPos = 0, this.awaitIdentPos = 0, de.params = this.toAssignableList(en, !0), this.parseFunctionBody(de, !0, !1, $n), this.yieldPos = Vn, this.awaitPos = sr, this.awaitIdentPos = cr, this.finishNode(de, "ArrowFunctionExpression");
      }, _r.parseFunctionBody = function(de, en, mn, $n) {
        var Vn = en && this.type !== ee.braceL, sr = this.strict, cr = !1;
        if (Vn)
          de.body = this.parseMaybeAssign($n), de.expression = !0, this.checkParams(de, !1);
        else {
          var Br = this.options.ecmaVersion >= 7 && !this.isSimpleParamList(de.params);
          (!sr || Br) && (cr = this.strictDirective(this.end), cr && Br && this.raiseRecoverable(de.start, "Illegal 'use strict' directive in function with non-simple parameter list"));
          var Kr = this.labels;
          this.labels = [], cr && (this.strict = !0), this.checkParams(de, !sr && !cr && !en && !mn && this.isSimpleParamList(de.params)), this.strict && de.id && this.checkLValSimple(de.id, Mn), de.body = this.parseBlock(!1, void 0, cr && !sr), de.expression = !1, this.adaptDirectivePrologue(de.body.body), this.labels = Kr;
        }
        this.exitScope();
      }, _r.isSimpleParamList = function(de) {
        for (var en = 0, mn = de; en < mn.length; en += 1) {
          var $n = mn[en];
          if ($n.type !== "Identifier")
            return !1;
        }
        return !0;
      }, _r.checkParams = function(de, en) {
        for (var mn = /* @__PURE__ */ Object.create(null), $n = 0, Vn = de.params; $n < Vn.length; $n += 1) {
          var sr = Vn[$n];
          this.checkLValInnerPattern(sr, Bn, en ? null : mn);
        }
      }, _r.parseExprList = function(de, en, mn, $n) {
        for (var Vn = [], sr = !0; !this.eat(de); ) {
          if (sr)
            sr = !1;
          else if (this.expect(ee.comma), en && this.afterTrailingComma(de))
            break;
          var cr = void 0;
          mn && this.type === ee.comma ? cr = null : this.type === ee.ellipsis ? (cr = this.parseSpread($n), $n && this.type === ee.comma && $n.trailingComma < 0 && ($n.trailingComma = this.start)) : cr = this.parseMaybeAssign(!1, $n), Vn.push(cr);
        }
        return Vn;
      }, _r.checkUnreserved = function(de) {
        var en = de.start, mn = de.end, $n = de.name;
        if (this.inGenerator && $n === "yield" && this.raiseRecoverable(en, "Cannot use 'yield' as identifier inside a generator"), this.inAsync && $n === "await" && this.raiseRecoverable(en, "Cannot use 'await' as identifier inside an async function"), this.currentThisScope().inClassFieldInit && $n === "arguments" && this.raiseRecoverable(en, "Cannot use 'arguments' in class field initializer"), this.inClassStaticBlock && ($n === "arguments" || $n === "await") && this.raise(en, "Cannot use " + $n + " in class static initialization block"), this.keywords.test($n) && this.raise(en, "Unexpected keyword '" + $n + "'"), !(this.options.ecmaVersion < 6 && this.input.slice(en, mn).indexOf("\\") !== -1)) {
          var Vn = this.strict ? this.reservedWordsStrict : this.reservedWords;
          Vn.test($n) && (!this.inAsync && $n === "await" && this.raiseRecoverable(en, "Cannot use keyword 'await' outside an async function"), this.raiseRecoverable(en, "The keyword '" + $n + "' is reserved"));
        }
      }, _r.parseIdent = function(de) {
        var en = this.parseIdentNode();
        return this.next(!!de), this.finishNode(en, "Identifier"), de || (this.checkUnreserved(en), en.name === "await" && !this.awaitIdentPos && (this.awaitIdentPos = en.start)), en;
      }, _r.parseIdentNode = function() {
        var de = this.startNode();
        return this.type === ee.name ? de.name = this.value : this.type.keyword ? (de.name = this.type.keyword, (de.name === "class" || de.name === "function") && (this.lastTokEnd !== this.lastTokStart + 1 || this.input.charCodeAt(this.lastTokStart) !== 46) && this.context.pop(), this.type = ee.name) : this.unexpected(), de;
      }, _r.parsePrivateIdent = function() {
        var de = this.startNode();
        return this.type === ee.privateId ? de.name = this.value : this.unexpected(), this.next(), this.finishNode(de, "PrivateIdentifier"), this.options.checkPrivateFields && (this.privateNameStack.length === 0 ? this.raise(de.start, "Private field '#" + de.name + "' must be declared in an enclosing class") : this.privateNameStack[this.privateNameStack.length - 1].used.push(de)), de;
      }, _r.parseYield = function(de) {
        this.yieldPos || (this.yieldPos = this.start);
        var en = this.startNode();
        return this.next(), this.type === ee.semi || this.canInsertSemicolon() || this.type !== ee.star && !this.type.startsExpr ? (en.delegate = !1, en.argument = null) : (en.delegate = this.eat(ee.star), en.argument = this.parseMaybeAssign(de)), this.finishNode(en, "YieldExpression");
      }, _r.parseAwait = function(de) {
        this.awaitPos || (this.awaitPos = this.start);
        var en = this.startNode();
        return this.next(), en.argument = this.parseMaybeUnary(null, !0, !1, de), this.finishNode(en, "AwaitExpression");
      };
      var ii = Tn.prototype;
      ii.raise = function(de, en) {
        var mn = yn(this.input, de);
        en += " (" + mn.line + ":" + mn.column + ")";
        var $n = new SyntaxError(en);
        throw $n.pos = de, $n.loc = mn, $n.raisedAt = this.pos, $n;
      }, ii.raiseRecoverable = ii.raise, ii.curPosition = function() {
        if (this.options.locations)
          return new gn(this.curLine, this.pos - this.lineStart);
      };
      var Ti = Tn.prototype, Mi = function(en) {
        this.flags = en, this.var = [], this.lexical = [], this.functions = [], this.inClassFieldInit = !1;
      };
      Ti.enterScope = function(de) {
        this.scopeStack.push(new Mi(de));
      }, Ti.exitScope = function() {
        this.scopeStack.pop();
      }, Ti.treatFunctionsAsVarInScope = function(de) {
        return de.flags & Un || !this.inModule && de.flags & Nn;
      }, Ti.declareName = function(de, en, mn) {
        var $n = !1;
        if (en === Fn) {
          var Vn = this.currentScope();
          $n = Vn.lexical.indexOf(de) > -1 || Vn.functions.indexOf(de) > -1 || Vn.var.indexOf(de) > -1, Vn.lexical.push(de), this.inModule && Vn.flags & Nn && delete this.undefinedExports[de];
        } else if (en === Wn) {
          var sr = this.currentScope();
          sr.lexical.push(de);
        } else if (en === Gn) {
          var cr = this.currentScope();
          this.treatFunctionsAsVar ? $n = cr.lexical.indexOf(de) > -1 : $n = cr.lexical.indexOf(de) > -1 || cr.var.indexOf(de) > -1, cr.functions.push(de);
        } else
          for (var Br = this.scopeStack.length - 1; Br >= 0; --Br) {
            var Kr = this.scopeStack[Br];
            if (Kr.lexical.indexOf(de) > -1 && !(Kr.flags & kn && Kr.lexical[0] === de) || !this.treatFunctionsAsVarInScope(Kr) && Kr.functions.indexOf(de) > -1) {
              $n = !0;
              break;
            }
            if (Kr.var.push(de), this.inModule && Kr.flags & Nn && delete this.undefinedExports[de], Kr.flags & bn)
              break;
          }
        $n && this.raiseRecoverable(mn, "Identifier '" + de + "' has already been declared");
      }, Ti.checkLocalExport = function(de) {
        this.scopeStack[0].lexical.indexOf(de.name) === -1 && this.scopeStack[0].var.indexOf(de.name) === -1 && (this.undefinedExports[de.name] = de);
      }, Ti.currentScope = function() {
        return this.scopeStack[this.scopeStack.length - 1];
      }, Ti.currentVarScope = function() {
        for (var de = this.scopeStack.length - 1; ; de--) {
          var en = this.scopeStack[de];
          if (en.flags & bn)
            return en;
        }
      }, Ti.currentThisScope = function() {
        for (var de = this.scopeStack.length - 1; ; de--) {
          var en = this.scopeStack[de];
          if (en.flags & bn && !(en.flags & jn))
            return en;
        }
      };
      var ui = function(en, mn, $n) {
        this.type = "", this.start = mn, this.end = 0, en.options.locations && (this.loc = new dn(en, $n)), en.options.directSourceFile && (this.sourceFile = en.options.directSourceFile), en.options.ranges && (this.range = [mn, 0]);
      }, Ii = Tn.prototype;
      Ii.startNode = function() {
        return new ui(this, this.start, this.startLoc);
      }, Ii.startNodeAt = function(de, en) {
        return new ui(this, de, en);
      };
      function bs(de, en, mn, $n) {
        return de.type = en, de.end = mn, this.options.locations && (de.loc.end = $n), this.options.ranges && (de.range[1] = mn), de;
      }
      Ii.finishNode = function(de, en) {
        return bs.call(this, de, en, this.lastTokEnd, this.lastTokEndLoc);
      }, Ii.finishNodeAt = function(de, en, mn, $n) {
        return bs.call(this, de, en, mn, $n);
      }, Ii.copyNode = function(de) {
        var en = new ui(this, de.start, this.startLoc);
        for (var mn in de)
          en[mn] = de[mn];
        return en;
      };
      var Oi = "ASCII ASCII_Hex_Digit AHex Alphabetic Alpha Any Assigned Bidi_Control Bidi_C Bidi_Mirrored Bidi_M Case_Ignorable CI Cased Changes_When_Casefolded CWCF Changes_When_Casemapped CWCM Changes_When_Lowercased CWL Changes_When_NFKC_Casefolded CWKCF Changes_When_Titlecased CWT Changes_When_Uppercased CWU Dash Default_Ignorable_Code_Point DI Deprecated Dep Diacritic Dia Emoji Emoji_Component Emoji_Modifier Emoji_Modifier_Base Emoji_Presentation Extender Ext Grapheme_Base Gr_Base Grapheme_Extend Gr_Ext Hex_Digit Hex IDS_Binary_Operator IDSB IDS_Trinary_Operator IDST ID_Continue IDC ID_Start IDS Ideographic Ideo Join_Control Join_C Logical_Order_Exception LOE Lowercase Lower Math Noncharacter_Code_Point NChar Pattern_Syntax Pat_Syn Pattern_White_Space Pat_WS Quotation_Mark QMark Radical Regional_Indicator RI Sentence_Terminal STerm Soft_Dotted SD Terminal_Punctuation Term Unified_Ideograph UIdeo Uppercase Upper Variation_Selector VS White_Space space XID_Continue XIDC XID_Start XIDS", Vs = Oi + " Extended_Pictographic", _s = Vs, Is = _s + " EBase EComp EMod EPres ExtPict", Fa = Is, io = Fa, Da = {
        9: Oi,
        10: Vs,
        11: _s,
        12: Is,
        13: Fa,
        14: io
      }, oo = "Basic_Emoji Emoji_Keycap_Sequence RGI_Emoji_Modifier_Sequence RGI_Emoji_Flag_Sequence RGI_Emoji_Tag_Sequence RGI_Emoji_ZWJ_Sequence RGI_Emoji", Xs = {
        9: "",
        10: "",
        11: "",
        12: "",
        13: "",
        14: oo
      }, so = "Cased_Letter LC Close_Punctuation Pe Connector_Punctuation Pc Control Cc cntrl Currency_Symbol Sc Dash_Punctuation Pd Decimal_Number Nd digit Enclosing_Mark Me Final_Punctuation Pf Format Cf Initial_Punctuation Pi Letter L Letter_Number Nl Line_Separator Zl Lowercase_Letter Ll Mark M Combining_Mark Math_Symbol Sm Modifier_Letter Lm Modifier_Symbol Sk Nonspacing_Mark Mn Number N Open_Punctuation Ps Other C Other_Letter Lo Other_Number No Other_Punctuation Po Other_Symbol So Paragraph_Separator Zp Private_Use Co Punctuation P punct Separator Z Space_Separator Zs Spacing_Mark Mc Surrogate Cs Symbol S Titlecase_Letter Lt Unassigned Cn Uppercase_Letter Lu", Ol = "Adlam Adlm Ahom Anatolian_Hieroglyphs Hluw Arabic Arab Armenian Armn Avestan Avst Balinese Bali Bamum Bamu Bassa_Vah Bass Batak Batk Bengali Beng Bhaiksuki Bhks Bopomofo Bopo Brahmi Brah Braille Brai Buginese Bugi Buhid Buhd Canadian_Aboriginal Cans Carian Cari Caucasian_Albanian Aghb Chakma Cakm Cham Cham Cherokee Cher Common Zyyy Coptic Copt Qaac Cuneiform Xsux Cypriot Cprt Cyrillic Cyrl Deseret Dsrt Devanagari Deva Duployan Dupl Egyptian_Hieroglyphs Egyp Elbasan Elba Ethiopic Ethi Georgian Geor Glagolitic Glag Gothic Goth Grantha Gran Greek Grek Gujarati Gujr Gurmukhi Guru Han Hani Hangul Hang Hanunoo Hano Hatran Hatr Hebrew Hebr Hiragana Hira Imperial_Aramaic Armi Inherited Zinh Qaai Inscriptional_Pahlavi Phli Inscriptional_Parthian Prti Javanese Java Kaithi Kthi Kannada Knda Katakana Kana Kayah_Li Kali Kharoshthi Khar Khmer Khmr Khojki Khoj Khudawadi Sind Lao Laoo Latin Latn Lepcha Lepc Limbu Limb Linear_A Lina Linear_B Linb Lisu Lisu Lycian Lyci Lydian Lydi Mahajani Mahj Malayalam Mlym Mandaic Mand Manichaean Mani Marchen Marc Masaram_Gondi Gonm Meetei_Mayek Mtei Mende_Kikakui Mend Meroitic_Cursive Merc Meroitic_Hieroglyphs Mero Miao Plrd Modi Mongolian Mong Mro Mroo Multani Mult Myanmar Mymr Nabataean Nbat New_Tai_Lue Talu Newa Newa Nko Nkoo Nushu Nshu Ogham Ogam Ol_Chiki Olck Old_Hungarian Hung Old_Italic Ital Old_North_Arabian Narb Old_Permic Perm Old_Persian Xpeo Old_South_Arabian Sarb Old_Turkic Orkh Oriya Orya Osage Osge Osmanya Osma Pahawh_Hmong Hmng Palmyrene Palm Pau_Cin_Hau Pauc Phags_Pa Phag Phoenician Phnx Psalter_Pahlavi Phlp Rejang Rjng Runic Runr Samaritan Samr Saurashtra Saur Sharada Shrd Shavian Shaw Siddham Sidd SignWriting Sgnw Sinhala Sinh Sora_Sompeng Sora Soyombo Soyo Sundanese Sund Syloti_Nagri Sylo Syriac Syrc Tagalog Tglg Tagbanwa Tagb Tai_Le Tale Tai_Tham Lana Tai_Viet Tavt Takri Takr Tamil Taml Tangut Tang Telugu Telu Thaana Thaa Thai Thai Tibetan Tibt Tifinagh Tfng Tirhuta Tirh Ugaritic Ugar Vai Vaii Warang_Citi Wara Yi Yiii Zanabazar_Square Zanb", kl = Ol + " Dogra Dogr Gunjala_Gondi Gong Hanifi_Rohingya Rohg Makasar Maka Medefaidrin Medf Old_Sogdian Sogo Sogdian Sogd", uc = kl + " Elymaic Elym Nandinagari Nand Nyiakeng_Puachue_Hmong Hmnp Wancho Wcho", Vl = uc + " Chorasmian Chrs Diak Dives_Akuru Khitan_Small_Script Kits Yezi Yezidi", Ma = Vl + " Cypro_Minoan Cpmn Old_Uyghur Ougr Tangsa Tnsa Toto Vithkuqi Vith", Ll = Ma + " Hrkt Katakana_Or_Hiragana Kawi Nag_Mundari Nagm Unknown Zzzz", Oa = {
        9: Ol,
        10: kl,
        11: uc,
        12: Vl,
        13: Ma,
        14: Ll
      }, cc = {};
      function va(de) {
        var en = cc[de] = {
          binary: Et(Da[de] + " " + so),
          binaryOfStrings: Et(Xs[de]),
          nonBinary: {
            General_Category: Et(so),
            Script: Et(Oa[de])
          }
        };
        en.nonBinary.Script_Extensions = en.nonBinary.Script, en.nonBinary.gc = en.nonBinary.General_Category, en.nonBinary.sc = en.nonBinary.Script, en.nonBinary.scx = en.nonBinary.Script_Extensions;
      }
      for (var yc = 0, vc = [9, 10, 11, 12, 13, 14]; yc < vc.length; yc += 1) {
        var Af = vc[yc];
        va(Af);
      }
      var Yr = Tn.prototype, Ra = function(en) {
        this.parser = en, this.validFlags = "gim" + (en.options.ecmaVersion >= 6 ? "uy" : "") + (en.options.ecmaVersion >= 9 ? "s" : "") + (en.options.ecmaVersion >= 13 ? "d" : "") + (en.options.ecmaVersion >= 15 ? "v" : ""), this.unicodeProperties = cc[en.options.ecmaVersion >= 14 ? 14 : en.options.ecmaVersion], this.source = "", this.flags = "", this.start = 0, this.switchU = !1, this.switchV = !1, this.switchN = !1, this.pos = 0, this.lastIntValue = 0, this.lastStringValue = "", this.lastAssertionIsQuantifiable = !1, this.numCapturingParens = 0, this.maxBackReference = 0, this.groupNames = [], this.backReferenceNames = [];
      };
      Ra.prototype.reset = function(en, mn, $n) {
        var Vn = $n.indexOf("v") !== -1, sr = $n.indexOf("u") !== -1;
        this.start = en | 0, this.source = mn + "", this.flags = $n, Vn && this.parser.options.ecmaVersion >= 15 ? (this.switchU = !0, this.switchV = !0, this.switchN = !0) : (this.switchU = sr && this.parser.options.ecmaVersion >= 6, this.switchV = !1, this.switchN = sr && this.parser.options.ecmaVersion >= 9);
      }, Ra.prototype.raise = function(en) {
        this.parser.raiseRecoverable(this.start, "Invalid regular expression: /" + this.source + "/: " + en);
      }, Ra.prototype.at = function(en, mn) {
        mn === void 0 && (mn = !1);
        var $n = this.source, Vn = $n.length;
        if (en >= Vn)
          return -1;
        var sr = $n.charCodeAt(en);
        if (!(mn || this.switchU) || sr <= 55295 || sr >= 57344 || en + 1 >= Vn)
          return sr;
        var cr = $n.charCodeAt(en + 1);
        return cr >= 56320 && cr <= 57343 ? (sr << 10) + cr - 56613888 : sr;
      }, Ra.prototype.nextIndex = function(en, mn) {
        mn === void 0 && (mn = !1);
        var $n = this.source, Vn = $n.length;
        if (en >= Vn)
          return Vn;
        var sr = $n.charCodeAt(en), cr;
        return !(mn || this.switchU) || sr <= 55295 || sr >= 57344 || en + 1 >= Vn || (cr = $n.charCodeAt(en + 1)) < 56320 || cr > 57343 ? en + 1 : en + 2;
      }, Ra.prototype.current = function(en) {
        return en === void 0 && (en = !1), this.at(this.pos, en);
      }, Ra.prototype.lookahead = function(en) {
        return en === void 0 && (en = !1), this.at(this.nextIndex(this.pos, en), en);
      }, Ra.prototype.advance = function(en) {
        en === void 0 && (en = !1), this.pos = this.nextIndex(this.pos, en);
      }, Ra.prototype.eat = function(en, mn) {
        return mn === void 0 && (mn = !1), this.current(mn) === en ? (this.advance(mn), !0) : !1;
      }, Ra.prototype.eatChars = function(en, mn) {
        mn === void 0 && (mn = !1);
        for (var $n = this.pos, Vn = 0, sr = en; Vn < sr.length; Vn += 1) {
          var cr = sr[Vn], Br = this.at($n, mn);
          if (Br === -1 || Br !== cr)
            return !1;
          $n = this.nextIndex($n, mn);
        }
        return this.pos = $n, !0;
      }, Yr.validateRegExpFlags = function(de) {
        for (var en = de.validFlags, mn = de.flags, $n = !1, Vn = !1, sr = 0; sr < mn.length; sr++) {
          var cr = mn.charAt(sr);
          en.indexOf(cr) === -1 && this.raise(de.start, "Invalid regular expression flag"), mn.indexOf(cr, sr + 1) > -1 && this.raise(de.start, "Duplicate regular expression flag"), cr === "u" && ($n = !0), cr === "v" && (Vn = !0);
        }
        this.options.ecmaVersion >= 15 && $n && Vn && this.raise(de.start, "Invalid regular expression flag");
      }, Yr.validateRegExpPattern = function(de) {
        this.regexp_pattern(de), !de.switchN && this.options.ecmaVersion >= 9 && de.groupNames.length > 0 && (de.switchN = !0, this.regexp_pattern(de));
      }, Yr.regexp_pattern = function(de) {
        de.pos = 0, de.lastIntValue = 0, de.lastStringValue = "", de.lastAssertionIsQuantifiable = !1, de.numCapturingParens = 0, de.maxBackReference = 0, de.groupNames.length = 0, de.backReferenceNames.length = 0, this.regexp_disjunction(de), de.pos !== de.source.length && (de.eat(
          41
          /* ) */
        ) && de.raise("Unmatched ')'"), (de.eat(
          93
          /* ] */
        ) || de.eat(
          125
          /* } */
        )) && de.raise("Lone quantifier brackets")), de.maxBackReference > de.numCapturingParens && de.raise("Invalid escape");
        for (var en = 0, mn = de.backReferenceNames; en < mn.length; en += 1) {
          var $n = mn[en];
          de.groupNames.indexOf($n) === -1 && de.raise("Invalid named capture referenced");
        }
      }, Yr.regexp_disjunction = function(de) {
        for (this.regexp_alternative(de); de.eat(
          124
          /* | */
        ); )
          this.regexp_alternative(de);
        this.regexp_eatQuantifier(de, !0) && de.raise("Nothing to repeat"), de.eat(
          123
          /* { */
        ) && de.raise("Lone quantifier brackets");
      }, Yr.regexp_alternative = function(de) {
        for (; de.pos < de.source.length && this.regexp_eatTerm(de); )
          ;
      }, Yr.regexp_eatTerm = function(de) {
        return this.regexp_eatAssertion(de) ? (de.lastAssertionIsQuantifiable && this.regexp_eatQuantifier(de) && de.switchU && de.raise("Invalid quantifier"), !0) : (de.switchU ? this.regexp_eatAtom(de) : this.regexp_eatExtendedAtom(de)) ? (this.regexp_eatQuantifier(de), !0) : !1;
      }, Yr.regexp_eatAssertion = function(de) {
        var en = de.pos;
        if (de.lastAssertionIsQuantifiable = !1, de.eat(
          94
          /* ^ */
        ) || de.eat(
          36
          /* $ */
        ))
          return !0;
        if (de.eat(
          92
          /* \ */
        )) {
          if (de.eat(
            66
            /* B */
          ) || de.eat(
            98
            /* b */
          ))
            return !0;
          de.pos = en;
        }
        if (de.eat(
          40
          /* ( */
        ) && de.eat(
          63
          /* ? */
        )) {
          var mn = !1;
          if (this.options.ecmaVersion >= 9 && (mn = de.eat(
            60
            /* < */
          )), de.eat(
            61
            /* = */
          ) || de.eat(
            33
            /* ! */
          ))
            return this.regexp_disjunction(de), de.eat(
              41
              /* ) */
            ) || de.raise("Unterminated group"), de.lastAssertionIsQuantifiable = !mn, !0;
        }
        return de.pos = en, !1;
      }, Yr.regexp_eatQuantifier = function(de, en) {
        return en === void 0 && (en = !1), this.regexp_eatQuantifierPrefix(de, en) ? (de.eat(
          63
          /* ? */
        ), !0) : !1;
      }, Yr.regexp_eatQuantifierPrefix = function(de, en) {
        return de.eat(
          42
          /* * */
        ) || de.eat(
          43
          /* + */
        ) || de.eat(
          63
          /* ? */
        ) || this.regexp_eatBracedQuantifier(de, en);
      }, Yr.regexp_eatBracedQuantifier = function(de, en) {
        var mn = de.pos;
        if (de.eat(
          123
          /* { */
        )) {
          var $n = 0, Vn = -1;
          if (this.regexp_eatDecimalDigits(de) && ($n = de.lastIntValue, de.eat(
            44
            /* , */
          ) && this.regexp_eatDecimalDigits(de) && (Vn = de.lastIntValue), de.eat(
            125
            /* } */
          )))
            return Vn !== -1 && Vn < $n && !en && de.raise("numbers out of order in {} quantifier"), !0;
          de.switchU && !en && de.raise("Incomplete quantifier"), de.pos = mn;
        }
        return !1;
      }, Yr.regexp_eatAtom = function(de) {
        return this.regexp_eatPatternCharacters(de) || de.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(de) || this.regexp_eatCharacterClass(de) || this.regexp_eatUncapturingGroup(de) || this.regexp_eatCapturingGroup(de);
      }, Yr.regexp_eatReverseSolidusAtomEscape = function(de) {
        var en = de.pos;
        if (de.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatAtomEscape(de))
            return !0;
          de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatUncapturingGroup = function(de) {
        var en = de.pos;
        if (de.eat(
          40
          /* ( */
        )) {
          if (de.eat(
            63
            /* ? */
          ) && de.eat(
            58
            /* : */
          )) {
            if (this.regexp_disjunction(de), de.eat(
              41
              /* ) */
            ))
              return !0;
            de.raise("Unterminated group");
          }
          de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatCapturingGroup = function(de) {
        if (de.eat(
          40
          /* ( */
        )) {
          if (this.options.ecmaVersion >= 9 ? this.regexp_groupSpecifier(de) : de.current() === 63 && de.raise("Invalid group"), this.regexp_disjunction(de), de.eat(
            41
            /* ) */
          ))
            return de.numCapturingParens += 1, !0;
          de.raise("Unterminated group");
        }
        return !1;
      }, Yr.regexp_eatExtendedAtom = function(de) {
        return de.eat(
          46
          /* . */
        ) || this.regexp_eatReverseSolidusAtomEscape(de) || this.regexp_eatCharacterClass(de) || this.regexp_eatUncapturingGroup(de) || this.regexp_eatCapturingGroup(de) || this.regexp_eatInvalidBracedQuantifier(de) || this.regexp_eatExtendedPatternCharacter(de);
      }, Yr.regexp_eatInvalidBracedQuantifier = function(de) {
        return this.regexp_eatBracedQuantifier(de, !0) && de.raise("Nothing to repeat"), !1;
      }, Yr.regexp_eatSyntaxCharacter = function(de) {
        var en = de.current();
        return Bl(en) ? (de.lastIntValue = en, de.advance(), !0) : !1;
      };
      function Bl(de) {
        return de === 36 || de >= 40 && de <= 43 || de === 46 || de === 63 || de >= 91 && de <= 94 || de >= 123 && de <= 125;
      }
      Yr.regexp_eatPatternCharacters = function(de) {
        for (var en = de.pos, mn = 0; (mn = de.current()) !== -1 && !Bl(mn); )
          de.advance();
        return de.pos !== en;
      }, Yr.regexp_eatExtendedPatternCharacter = function(de) {
        var en = de.current();
        return en !== -1 && en !== 36 && !(en >= 40 && en <= 43) && en !== 46 && en !== 63 && en !== 91 && en !== 94 && en !== 124 ? (de.advance(), !0) : !1;
      }, Yr.regexp_groupSpecifier = function(de) {
        if (de.eat(
          63
          /* ? */
        )) {
          if (this.regexp_eatGroupName(de)) {
            de.groupNames.indexOf(de.lastStringValue) !== -1 && de.raise("Duplicate capture group name"), de.groupNames.push(de.lastStringValue);
            return;
          }
          de.raise("Invalid group");
        }
      }, Yr.regexp_eatGroupName = function(de) {
        if (de.lastStringValue = "", de.eat(
          60
          /* < */
        )) {
          if (this.regexp_eatRegExpIdentifierName(de) && de.eat(
            62
            /* > */
          ))
            return !0;
          de.raise("Invalid capture group name");
        }
        return !1;
      }, Yr.regexp_eatRegExpIdentifierName = function(de) {
        if (de.lastStringValue = "", this.regexp_eatRegExpIdentifierStart(de)) {
          for (de.lastStringValue += Qt(de.lastIntValue); this.regexp_eatRegExpIdentifierPart(de); )
            de.lastStringValue += Qt(de.lastIntValue);
          return !0;
        }
        return !1;
      }, Yr.regexp_eatRegExpIdentifierStart = function(de) {
        var en = de.pos, mn = this.options.ecmaVersion >= 11, $n = de.current(mn);
        return de.advance(mn), $n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(de, mn) && ($n = de.lastIntValue), Nf($n) ? (de.lastIntValue = $n, !0) : (de.pos = en, !1);
      };
      function Nf(de) {
        return O(de, !0) || de === 36 || de === 95;
      }
      Yr.regexp_eatRegExpIdentifierPart = function(de) {
        var en = de.pos, mn = this.options.ecmaVersion >= 11, $n = de.current(mn);
        return de.advance(mn), $n === 92 && this.regexp_eatRegExpUnicodeEscapeSequence(de, mn) && ($n = de.lastIntValue), Ff($n) ? (de.lastIntValue = $n, !0) : (de.pos = en, !1);
      };
      function Ff(de) {
        return z(de, !0) || de === 36 || de === 95 || de === 8204 || de === 8205;
      }
      Yr.regexp_eatAtomEscape = function(de) {
        return this.regexp_eatBackReference(de) || this.regexp_eatCharacterClassEscape(de) || this.regexp_eatCharacterEscape(de) || de.switchN && this.regexp_eatKGroupName(de) ? !0 : (de.switchU && (de.current() === 99 && de.raise("Invalid unicode escape"), de.raise("Invalid escape")), !1);
      }, Yr.regexp_eatBackReference = function(de) {
        var en = de.pos;
        if (this.regexp_eatDecimalEscape(de)) {
          var mn = de.lastIntValue;
          if (de.switchU)
            return mn > de.maxBackReference && (de.maxBackReference = mn), !0;
          if (mn <= de.numCapturingParens)
            return !0;
          de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatKGroupName = function(de) {
        if (de.eat(
          107
          /* k */
        )) {
          if (this.regexp_eatGroupName(de))
            return de.backReferenceNames.push(de.lastStringValue), !0;
          de.raise("Invalid named reference");
        }
        return !1;
      }, Yr.regexp_eatCharacterEscape = function(de) {
        return this.regexp_eatControlEscape(de) || this.regexp_eatCControlLetter(de) || this.regexp_eatZero(de) || this.regexp_eatHexEscapeSequence(de) || this.regexp_eatRegExpUnicodeEscapeSequence(de, !1) || !de.switchU && this.regexp_eatLegacyOctalEscapeSequence(de) || this.regexp_eatIdentityEscape(de);
      }, Yr.regexp_eatCControlLetter = function(de) {
        var en = de.pos;
        if (de.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatControlLetter(de))
            return !0;
          de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatZero = function(de) {
        return de.current() === 48 && !Nl(de.lookahead()) ? (de.lastIntValue = 0, de.advance(), !0) : !1;
      }, Yr.regexp_eatControlEscape = function(de) {
        var en = de.current();
        return en === 116 ? (de.lastIntValue = 9, de.advance(), !0) : en === 110 ? (de.lastIntValue = 10, de.advance(), !0) : en === 118 ? (de.lastIntValue = 11, de.advance(), !0) : en === 102 ? (de.lastIntValue = 12, de.advance(), !0) : en === 114 ? (de.lastIntValue = 13, de.advance(), !0) : !1;
      }, Yr.regexp_eatControlLetter = function(de) {
        var en = de.current();
        return xc(en) ? (de.lastIntValue = en % 32, de.advance(), !0) : !1;
      };
      function xc(de) {
        return de >= 65 && de <= 90 || de >= 97 && de <= 122;
      }
      Yr.regexp_eatRegExpUnicodeEscapeSequence = function(de, en) {
        en === void 0 && (en = !1);
        var mn = de.pos, $n = en || de.switchU;
        if (de.eat(
          117
          /* u */
        )) {
          if (this.regexp_eatFixedHexDigits(de, 4)) {
            var Vn = de.lastIntValue;
            if ($n && Vn >= 55296 && Vn <= 56319) {
              var sr = de.pos;
              if (de.eat(
                92
                /* \ */
              ) && de.eat(
                117
                /* u */
              ) && this.regexp_eatFixedHexDigits(de, 4)) {
                var cr = de.lastIntValue;
                if (cr >= 56320 && cr <= 57343)
                  return de.lastIntValue = (Vn - 55296) * 1024 + (cr - 56320) + 65536, !0;
              }
              de.pos = sr, de.lastIntValue = Vn;
            }
            return !0;
          }
          if ($n && de.eat(
            123
            /* { */
          ) && this.regexp_eatHexDigits(de) && de.eat(
            125
            /* } */
          ) && Df(de.lastIntValue))
            return !0;
          $n && de.raise("Invalid unicode escape"), de.pos = mn;
        }
        return !1;
      };
      function Df(de) {
        return de >= 0 && de <= 1114111;
      }
      Yr.regexp_eatIdentityEscape = function(de) {
        if (de.switchU)
          return this.regexp_eatSyntaxCharacter(de) ? !0 : de.eat(
            47
            /* / */
          ) ? (de.lastIntValue = 47, !0) : !1;
        var en = de.current();
        return en !== 99 && (!de.switchN || en !== 107) ? (de.lastIntValue = en, de.advance(), !0) : !1;
      }, Yr.regexp_eatDecimalEscape = function(de) {
        de.lastIntValue = 0;
        var en = de.current();
        if (en >= 49 && en <= 57) {
          do
            de.lastIntValue = 10 * de.lastIntValue + (en - 48), de.advance();
          while ((en = de.current()) >= 48 && en <= 57);
          return !0;
        }
        return !1;
      };
      var zl = 0, La = 1, ya = 2;
      Yr.regexp_eatCharacterClassEscape = function(de) {
        var en = de.current();
        if (Al(en))
          return de.lastIntValue = -1, de.advance(), La;
        var mn = !1;
        if (de.switchU && this.options.ecmaVersion >= 9 && ((mn = en === 80) || en === 112)) {
          de.lastIntValue = -1, de.advance();
          var $n;
          if (de.eat(
            123
            /* { */
          ) && ($n = this.regexp_eatUnicodePropertyValueExpression(de)) && de.eat(
            125
            /* } */
          ))
            return mn && $n === ya && de.raise("Invalid property name"), $n;
          de.raise("Invalid property name");
        }
        return zl;
      };
      function Al(de) {
        return de === 100 || de === 68 || de === 115 || de === 83 || de === 119 || de === 87;
      }
      Yr.regexp_eatUnicodePropertyValueExpression = function(de) {
        var en = de.pos;
        if (this.regexp_eatUnicodePropertyName(de) && de.eat(
          61
          /* = */
        )) {
          var mn = de.lastStringValue;
          if (this.regexp_eatUnicodePropertyValue(de)) {
            var $n = de.lastStringValue;
            return this.regexp_validateUnicodePropertyNameAndValue(de, mn, $n), La;
          }
        }
        if (de.pos = en, this.regexp_eatLoneUnicodePropertyNameOrValue(de)) {
          var Vn = de.lastStringValue;
          return this.regexp_validateUnicodePropertyNameOrValue(de, Vn);
        }
        return zl;
      }, Yr.regexp_validateUnicodePropertyNameAndValue = function(de, en, mn) {
        Gt(de.unicodeProperties.nonBinary, en) || de.raise("Invalid property name"), de.unicodeProperties.nonBinary[en].test(mn) || de.raise("Invalid property value");
      }, Yr.regexp_validateUnicodePropertyNameOrValue = function(de, en) {
        if (de.unicodeProperties.binary.test(en))
          return La;
        if (de.switchV && de.unicodeProperties.binaryOfStrings.test(en))
          return ya;
        de.raise("Invalid property name");
      }, Yr.regexp_eatUnicodePropertyName = function(de) {
        var en = 0;
        for (de.lastStringValue = ""; bc(en = de.current()); )
          de.lastStringValue += Qt(en), de.advance();
        return de.lastStringValue !== "";
      };
      function bc(de) {
        return xc(de) || de === 95;
      }
      Yr.regexp_eatUnicodePropertyValue = function(de) {
        var en = 0;
        for (de.lastStringValue = ""; dc(en = de.current()); )
          de.lastStringValue += Qt(en), de.advance();
        return de.lastStringValue !== "";
      };
      function dc(de) {
        return bc(de) || Nl(de);
      }
      Yr.regexp_eatLoneUnicodePropertyNameOrValue = function(de) {
        return this.regexp_eatUnicodePropertyValue(de);
      }, Yr.regexp_eatCharacterClass = function(de) {
        if (de.eat(
          91
          /* [ */
        )) {
          var en = de.eat(
            94
            /* ^ */
          ), mn = this.regexp_classContents(de);
          return de.eat(
            93
            /* ] */
          ) || de.raise("Unterminated character class"), en && mn === ya && de.raise("Negated character class may contain strings"), !0;
        }
        return !1;
      }, Yr.regexp_classContents = function(de) {
        return de.current() === 93 ? La : de.switchV ? this.regexp_classSetExpression(de) : (this.regexp_nonEmptyClassRanges(de), La);
      }, Yr.regexp_nonEmptyClassRanges = function(de) {
        for (; this.regexp_eatClassAtom(de); ) {
          var en = de.lastIntValue;
          if (de.eat(
            45
            /* - */
          ) && this.regexp_eatClassAtom(de)) {
            var mn = de.lastIntValue;
            de.switchU && (en === -1 || mn === -1) && de.raise("Invalid character class"), en !== -1 && mn !== -1 && en > mn && de.raise("Range out of order in character class");
          }
        }
      }, Yr.regexp_eatClassAtom = function(de) {
        var en = de.pos;
        if (de.eat(
          92
          /* \ */
        )) {
          if (this.regexp_eatClassEscape(de))
            return !0;
          if (de.switchU) {
            var mn = de.current();
            (mn === 99 || Cc(mn)) && de.raise("Invalid class escape"), de.raise("Invalid escape");
          }
          de.pos = en;
        }
        var $n = de.current();
        return $n !== 93 ? (de.lastIntValue = $n, de.advance(), !0) : !1;
      }, Yr.regexp_eatClassEscape = function(de) {
        var en = de.pos;
        if (de.eat(
          98
          /* b */
        ))
          return de.lastIntValue = 8, !0;
        if (de.switchU && de.eat(
          45
          /* - */
        ))
          return de.lastIntValue = 45, !0;
        if (!de.switchU && de.eat(
          99
          /* c */
        )) {
          if (this.regexp_eatClassControlLetter(de))
            return !0;
          de.pos = en;
        }
        return this.regexp_eatCharacterClassEscape(de) || this.regexp_eatCharacterEscape(de);
      }, Yr.regexp_classSetExpression = function(de) {
        var en = La, mn;
        if (!this.regexp_eatClassSetRange(de)) if (mn = this.regexp_eatClassSetOperand(de)) {
          mn === ya && (en = ya);
          for (var $n = de.pos; de.eatChars(
            [38, 38]
            /* && */
          ); ) {
            if (de.current() !== 38 && (mn = this.regexp_eatClassSetOperand(de))) {
              mn !== ya && (en = La);
              continue;
            }
            de.raise("Invalid character in character class");
          }
          if ($n !== de.pos)
            return en;
          for (; de.eatChars(
            [45, 45]
            /* -- */
          ); )
            this.regexp_eatClassSetOperand(de) || de.raise("Invalid character in character class");
          if ($n !== de.pos)
            return en;
        } else
          de.raise("Invalid character in character class");
        for (; ; )
          if (!this.regexp_eatClassSetRange(de)) {
            if (mn = this.regexp_eatClassSetOperand(de), !mn)
              return en;
            mn === ya && (en = ya);
          }
      }, Yr.regexp_eatClassSetRange = function(de) {
        var en = de.pos;
        if (this.regexp_eatClassSetCharacter(de)) {
          var mn = de.lastIntValue;
          if (de.eat(
            45
            /* - */
          ) && this.regexp_eatClassSetCharacter(de)) {
            var $n = de.lastIntValue;
            return mn !== -1 && $n !== -1 && mn > $n && de.raise("Range out of order in character class"), !0;
          }
          de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatClassSetOperand = function(de) {
        return this.regexp_eatClassSetCharacter(de) ? La : this.regexp_eatClassStringDisjunction(de) || this.regexp_eatNestedClass(de);
      }, Yr.regexp_eatNestedClass = function(de) {
        var en = de.pos;
        if (de.eat(
          91
          /* [ */
        )) {
          var mn = de.eat(
            94
            /* ^ */
          ), $n = this.regexp_classContents(de);
          if (de.eat(
            93
            /* ] */
          ))
            return mn && $n === ya && de.raise("Negated character class may contain strings"), $n;
          de.pos = en;
        }
        if (de.eat(
          92
          /* \ */
        )) {
          var Vn = this.regexp_eatCharacterClassEscape(de);
          if (Vn)
            return Vn;
          de.pos = en;
        }
        return null;
      }, Yr.regexp_eatClassStringDisjunction = function(de) {
        var en = de.pos;
        if (de.eatChars(
          [92, 113]
          /* \q */
        )) {
          if (de.eat(
            123
            /* { */
          )) {
            var mn = this.regexp_classStringDisjunctionContents(de);
            if (de.eat(
              125
              /* } */
            ))
              return mn;
          } else
            de.raise("Invalid escape");
          de.pos = en;
        }
        return null;
      }, Yr.regexp_classStringDisjunctionContents = function(de) {
        for (var en = this.regexp_classString(de); de.eat(
          124
          /* | */
        ); )
          this.regexp_classString(de) === ya && (en = ya);
        return en;
      }, Yr.regexp_classString = function(de) {
        for (var en = 0; this.regexp_eatClassSetCharacter(de); )
          en++;
        return en === 1 ? La : ya;
      }, Yr.regexp_eatClassSetCharacter = function(de) {
        var en = de.pos;
        if (de.eat(
          92
          /* \ */
        ))
          return this.regexp_eatCharacterEscape(de) || this.regexp_eatClassSetReservedPunctuator(de) ? !0 : de.eat(
            98
            /* b */
          ) ? (de.lastIntValue = 8, !0) : (de.pos = en, !1);
        var mn = de.current();
        return mn < 0 || mn === de.lookahead() && ao(mn) || fc(mn) ? !1 : (de.advance(), de.lastIntValue = mn, !0);
      };
      function ao(de) {
        return de === 33 || de >= 35 && de <= 38 || de >= 42 && de <= 44 || de === 46 || de >= 58 && de <= 64 || de === 94 || de === 96 || de === 126;
      }
      function fc(de) {
        return de === 40 || de === 41 || de === 45 || de === 47 || de >= 91 && de <= 93 || de >= 123 && de <= 125;
      }
      Yr.regexp_eatClassSetReservedPunctuator = function(de) {
        var en = de.current();
        return Rf(en) ? (de.lastIntValue = en, de.advance(), !0) : !1;
      };
      function Rf(de) {
        return de === 33 || de === 35 || de === 37 || de === 38 || de === 44 || de === 45 || de >= 58 && de <= 62 || de === 64 || de === 96 || de === 126;
      }
      Yr.regexp_eatClassControlLetter = function(de) {
        var en = de.current();
        return Nl(en) || en === 95 ? (de.lastIntValue = en % 32, de.advance(), !0) : !1;
      }, Yr.regexp_eatHexEscapeSequence = function(de) {
        var en = de.pos;
        if (de.eat(
          120
          /* x */
        )) {
          if (this.regexp_eatFixedHexDigits(de, 2))
            return !0;
          de.switchU && de.raise("Invalid escape"), de.pos = en;
        }
        return !1;
      }, Yr.regexp_eatDecimalDigits = function(de) {
        var en = de.pos, mn = 0;
        for (de.lastIntValue = 0; Nl(mn = de.current()); )
          de.lastIntValue = 10 * de.lastIntValue + (mn - 48), de.advance();
        return de.pos !== en;
      };
      function Nl(de) {
        return de >= 48 && de <= 57;
      }
      Yr.regexp_eatHexDigits = function(de) {
        var en = de.pos, mn = 0;
        for (de.lastIntValue = 0; jl(mn = de.current()); )
          de.lastIntValue = 16 * de.lastIntValue + lo(mn), de.advance();
        return de.pos !== en;
      };
      function jl(de) {
        return de >= 48 && de <= 57 || de >= 65 && de <= 70 || de >= 97 && de <= 102;
      }
      function lo(de) {
        return de >= 65 && de <= 70 ? 10 + (de - 65) : de >= 97 && de <= 102 ? 10 + (de - 97) : de - 48;
      }
      Yr.regexp_eatLegacyOctalEscapeSequence = function(de) {
        if (this.regexp_eatOctalDigit(de)) {
          var en = de.lastIntValue;
          if (this.regexp_eatOctalDigit(de)) {
            var mn = de.lastIntValue;
            en <= 3 && this.regexp_eatOctalDigit(de) ? de.lastIntValue = en * 64 + mn * 8 + de.lastIntValue : de.lastIntValue = en * 8 + mn;
          } else
            de.lastIntValue = en;
          return !0;
        }
        return !1;
      }, Yr.regexp_eatOctalDigit = function(de) {
        var en = de.current();
        return Cc(en) ? (de.lastIntValue = en - 48, de.advance(), !0) : (de.lastIntValue = 0, !1);
      };
      function Cc(de) {
        return de >= 48 && de <= 55;
      }
      Yr.regexp_eatFixedHexDigits = function(de, en) {
        var mn = de.pos;
        de.lastIntValue = 0;
        for (var $n = 0; $n < en; ++$n) {
          var Vn = de.current();
          if (!jl(Vn))
            return de.pos = mn, !1;
          de.lastIntValue = 16 * de.lastIntValue + lo(Vn), de.advance();
        }
        return !0;
      };
      var Fl = function(en) {
        this.type = en.type, this.value = en.value, this.start = en.start, this.end = en.end, en.options.locations && (this.loc = new dn(en, en.startLoc, en.endLoc)), en.options.ranges && (this.range = [en.start, en.end]);
      }, ki = Tn.prototype;
      ki.next = function(de) {
        !de && this.type.keyword && this.containsEsc && this.raiseRecoverable(this.start, "Escape sequence in keyword " + this.type.keyword), this.options.onToken && this.options.onToken(new Fl(this)), this.lastTokEnd = this.end, this.lastTokStart = this.start, this.lastTokEndLoc = this.endLoc, this.lastTokStartLoc = this.startLoc, this.nextToken();
      }, ki.getToken = function() {
        return this.next(), new Fl(this);
      }, typeof Symbol < "u" && (ki[Symbol.iterator] = function() {
        var de = this;
        return {
          next: function() {
            var en = de.getToken();
            return {
              done: en.type === ee.eof,
              value: en
            };
          }
        };
      }), ki.nextToken = function() {
        var de = this.curContext();
        if ((!de || !de.preserveSpace) && this.skipSpace(), this.start = this.pos, this.options.locations && (this.startLoc = this.curPosition()), this.pos >= this.input.length)
          return this.finishToken(ee.eof);
        if (de.override)
          return de.override(this);
        this.readToken(this.fullCharCodeAtPos());
      }, ki.readToken = function(de) {
        return O(de, this.options.ecmaVersion >= 6) || de === 92 ? this.readWord() : this.getTokenFromCode(de);
      }, ki.fullCharCodeAtPos = function() {
        var de = this.input.charCodeAt(this.pos);
        if (de <= 55295 || de >= 56320)
          return de;
        var en = this.input.charCodeAt(this.pos + 1);
        return en <= 56319 || en >= 57344 ? de : (de << 10) + en - 56613888;
      }, ki.skipBlockComment = function() {
        var de = this.options.onComment && this.curPosition(), en = this.pos, mn = this.input.indexOf("*/", this.pos += 2);
        if (mn === -1 && this.raise(this.pos - 2, "Unterminated comment"), this.pos = mn + 2, this.options.locations)
          for (var $n = void 0, Vn = en; ($n = xt(this.input, Vn, this.pos)) > -1; )
            ++this.curLine, Vn = this.lineStart = $n;
        this.options.onComment && this.options.onComment(
          !0,
          this.input.slice(en + 2, mn),
          en,
          this.pos,
          de,
          this.curPosition()
        );
      }, ki.skipLineComment = function(de) {
        for (var en = this.pos, mn = this.options.onComment && this.curPosition(), $n = this.input.charCodeAt(this.pos += de); this.pos < this.input.length && !yt($n); )
          $n = this.input.charCodeAt(++this.pos);
        this.options.onComment && this.options.onComment(
          !1,
          this.input.slice(en + de, this.pos),
          en,
          this.pos,
          mn,
          this.curPosition()
        );
      }, ki.skipSpace = function() {
        e: for (; this.pos < this.input.length; ) {
          var de = this.input.charCodeAt(this.pos);
          switch (de) {
            case 32:
            case 160:
              ++this.pos;
              break;
            case 13:
              this.input.charCodeAt(this.pos + 1) === 10 && ++this.pos;
            case 10:
            case 8232:
            case 8233:
              ++this.pos, this.options.locations && (++this.curLine, this.lineStart = this.pos);
              break;
            case 47:
              switch (this.input.charCodeAt(this.pos + 1)) {
                case 42:
                  this.skipBlockComment();
                  break;
                case 47:
                  this.skipLineComment(2);
                  break;
                default:
                  break e;
              }
              break;
            default:
              if (de > 8 && de < 14 || de >= 5760 && Kt.test(String.fromCharCode(de)))
                ++this.pos;
              else
                break e;
          }
        }
      }, ki.finishToken = function(de, en) {
        this.end = this.pos, this.options.locations && (this.endLoc = this.curPosition());
        var mn = this.type;
        this.type = de, this.value = en, this.updateContext(mn);
      }, ki.readToken_dot = function() {
        var de = this.input.charCodeAt(this.pos + 1);
        if (de >= 48 && de <= 57)
          return this.readNumber(!0);
        var en = this.input.charCodeAt(this.pos + 2);
        return this.options.ecmaVersion >= 6 && de === 46 && en === 46 ? (this.pos += 3, this.finishToken(ee.ellipsis)) : (++this.pos, this.finishToken(ee.dot));
      }, ki.readToken_slash = function() {
        var de = this.input.charCodeAt(this.pos + 1);
        return this.exprAllowed ? (++this.pos, this.readRegexp()) : de === 61 ? this.finishOp(ee.assign, 2) : this.finishOp(ee.slash, 1);
      }, ki.readToken_mult_modulo_exp = function(de) {
        var en = this.input.charCodeAt(this.pos + 1), mn = 1, $n = de === 42 ? ee.star : ee.modulo;
        return this.options.ecmaVersion >= 7 && de === 42 && en === 42 && (++mn, $n = ee.starstar, en = this.input.charCodeAt(this.pos + 2)), en === 61 ? this.finishOp(ee.assign, mn + 1) : this.finishOp($n, mn);
      }, ki.readToken_pipe_amp = function(de) {
        var en = this.input.charCodeAt(this.pos + 1);
        if (en === de) {
          if (this.options.ecmaVersion >= 12) {
            var mn = this.input.charCodeAt(this.pos + 2);
            if (mn === 61)
              return this.finishOp(ee.assign, 3);
          }
          return this.finishOp(de === 124 ? ee.logicalOR : ee.logicalAND, 2);
        }
        return en === 61 ? this.finishOp(ee.assign, 2) : this.finishOp(de === 124 ? ee.bitwiseOR : ee.bitwiseAND, 1);
      }, ki.readToken_caret = function() {
        var de = this.input.charCodeAt(this.pos + 1);
        return de === 61 ? this.finishOp(ee.assign, 2) : this.finishOp(ee.bitwiseXOR, 1);
      }, ki.readToken_plus_min = function(de) {
        var en = this.input.charCodeAt(this.pos + 1);
        return en === de ? en === 45 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 62 && (this.lastTokEnd === 0 || Re.test(this.input.slice(this.lastTokEnd, this.pos))) ? (this.skipLineComment(3), this.skipSpace(), this.nextToken()) : this.finishOp(ee.incDec, 2) : en === 61 ? this.finishOp(ee.assign, 2) : this.finishOp(ee.plusMin, 1);
      }, ki.readToken_lt_gt = function(de) {
        var en = this.input.charCodeAt(this.pos + 1), mn = 1;
        return en === de ? (mn = de === 62 && this.input.charCodeAt(this.pos + 2) === 62 ? 3 : 2, this.input.charCodeAt(this.pos + mn) === 61 ? this.finishOp(ee.assign, mn + 1) : this.finishOp(ee.bitShift, mn)) : en === 33 && de === 60 && !this.inModule && this.input.charCodeAt(this.pos + 2) === 45 && this.input.charCodeAt(this.pos + 3) === 45 ? (this.skipLineComment(4), this.skipSpace(), this.nextToken()) : (en === 61 && (mn = 2), this.finishOp(ee.relational, mn));
      }, ki.readToken_eq_excl = function(de) {
        var en = this.input.charCodeAt(this.pos + 1);
        return en === 61 ? this.finishOp(ee.equality, this.input.charCodeAt(this.pos + 2) === 61 ? 3 : 2) : de === 61 && en === 62 && this.options.ecmaVersion >= 6 ? (this.pos += 2, this.finishToken(ee.arrow)) : this.finishOp(de === 61 ? ee.eq : ee.prefix, 1);
      }, ki.readToken_question = function() {
        var de = this.options.ecmaVersion;
        if (de >= 11) {
          var en = this.input.charCodeAt(this.pos + 1);
          if (en === 46) {
            var mn = this.input.charCodeAt(this.pos + 2);
            if (mn < 48 || mn > 57)
              return this.finishOp(ee.questionDot, 2);
          }
          if (en === 63) {
            if (de >= 12) {
              var $n = this.input.charCodeAt(this.pos + 2);
              if ($n === 61)
                return this.finishOp(ee.assign, 3);
            }
            return this.finishOp(ee.coalesce, 2);
          }
        }
        return this.finishOp(ee.question, 1);
      }, ki.readToken_numberSign = function() {
        var de = this.options.ecmaVersion, en = 35;
        if (de >= 13 && (++this.pos, en = this.fullCharCodeAtPos(), O(en, !0) || en === 92))
          return this.finishToken(ee.privateId, this.readWord1());
        this.raise(this.pos, "Unexpected character '" + Qt(en) + "'");
      }, ki.getTokenFromCode = function(de) {
        switch (de) {
          case 46:
            return this.readToken_dot();
          case 40:
            return ++this.pos, this.finishToken(ee.parenL);
          case 41:
            return ++this.pos, this.finishToken(ee.parenR);
          case 59:
            return ++this.pos, this.finishToken(ee.semi);
          case 44:
            return ++this.pos, this.finishToken(ee.comma);
          case 91:
            return ++this.pos, this.finishToken(ee.bracketL);
          case 93:
            return ++this.pos, this.finishToken(ee.bracketR);
          case 123:
            return ++this.pos, this.finishToken(ee.braceL);
          case 125:
            return ++this.pos, this.finishToken(ee.braceR);
          case 58:
            return ++this.pos, this.finishToken(ee.colon);
          case 96:
            if (this.options.ecmaVersion < 6)
              break;
            return ++this.pos, this.finishToken(ee.backQuote);
          case 48:
            var en = this.input.charCodeAt(this.pos + 1);
            if (en === 120 || en === 88)
              return this.readRadixNumber(16);
            if (this.options.ecmaVersion >= 6) {
              if (en === 111 || en === 79)
                return this.readRadixNumber(8);
              if (en === 98 || en === 66)
                return this.readRadixNumber(2);
            }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return this.readNumber(!1);
          case 34:
          case 39:
            return this.readString(de);
          case 47:
            return this.readToken_slash();
          case 37:
          case 42:
            return this.readToken_mult_modulo_exp(de);
          case 124:
          case 38:
            return this.readToken_pipe_amp(de);
          case 94:
            return this.readToken_caret();
          case 43:
          case 45:
            return this.readToken_plus_min(de);
          case 60:
          case 62:
            return this.readToken_lt_gt(de);
          case 61:
          case 33:
            return this.readToken_eq_excl(de);
          case 63:
            return this.readToken_question();
          case 126:
            return this.finishOp(ee.prefix, 1);
          case 35:
            return this.readToken_numberSign();
        }
        this.raise(this.pos, "Unexpected character '" + Qt(de) + "'");
      }, ki.finishOp = function(de, en) {
        var mn = this.input.slice(this.pos, this.pos + en);
        return this.pos += en, this.finishToken(de, mn);
      }, ki.readRegexp = function() {
        for (var de, en, mn = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(mn, "Unterminated regular expression");
          var $n = this.input.charAt(this.pos);
          if (Re.test($n) && this.raise(mn, "Unterminated regular expression"), de)
            de = !1;
          else {
            if ($n === "[")
              en = !0;
            else if ($n === "]" && en)
              en = !1;
            else if ($n === "/" && !en)
              break;
            de = $n === "\\";
          }
          ++this.pos;
        }
        var Vn = this.input.slice(mn, this.pos);
        ++this.pos;
        var sr = this.pos, cr = this.readWord1();
        this.containsEsc && this.unexpected(sr);
        var Br = this.regexpState || (this.regexpState = new Ra(this));
        Br.reset(mn, Vn, cr), this.validateRegExpFlags(Br), this.validateRegExpPattern(Br);
        var Kr = null;
        try {
          Kr = new RegExp(Vn, cr);
        } catch {
        }
        return this.finishToken(ee.regexp, { pattern: Vn, flags: cr, value: Kr });
      }, ki.readInt = function(de, en, mn) {
        for (var $n = this.options.ecmaVersion >= 12 && en === void 0, Vn = mn && this.input.charCodeAt(this.pos) === 48, sr = this.pos, cr = 0, Br = 0, Kr = 0, Li = en ?? 1 / 0; Kr < Li; ++Kr, ++this.pos) {
          var Pi = this.input.charCodeAt(this.pos), Zs = void 0;
          if ($n && Pi === 95) {
            Vn && this.raiseRecoverable(this.pos, "Numeric separator is not allowed in legacy octal numeric literals"), Br === 95 && this.raiseRecoverable(this.pos, "Numeric separator must be exactly one underscore"), Kr === 0 && this.raiseRecoverable(this.pos, "Numeric separator is not allowed at the first of digits"), Br = Pi;
            continue;
          }
          if (Pi >= 97 ? Zs = Pi - 97 + 10 : Pi >= 65 ? Zs = Pi - 65 + 10 : Pi >= 48 && Pi <= 57 ? Zs = Pi - 48 : Zs = 1 / 0, Zs >= de)
            break;
          Br = Pi, cr = cr * de + Zs;
        }
        return $n && Br === 95 && this.raiseRecoverable(this.pos - 1, "Numeric separator is not allowed at the last of digits"), this.pos === sr || en != null && this.pos - sr !== en ? null : cr;
      };
      function Dl(de, en) {
        return en ? parseInt(de, 8) : parseFloat(de.replace(/_/g, ""));
      }
      function Js(de) {
        return typeof BigInt != "function" ? null : BigInt(de.replace(/_/g, ""));
      }
      ki.readRadixNumber = function(de) {
        var en = this.pos;
        this.pos += 2;
        var mn = this.readInt(de);
        return mn == null && this.raise(this.start + 2, "Expected number in radix " + de), this.options.ecmaVersion >= 11 && this.input.charCodeAt(this.pos) === 110 ? (mn = Js(this.input.slice(en, this.pos)), ++this.pos) : O(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ee.num, mn);
      }, ki.readNumber = function(de) {
        var en = this.pos;
        !de && this.readInt(10, void 0, !0) === null && this.raise(en, "Invalid number");
        var mn = this.pos - en >= 2 && this.input.charCodeAt(en) === 48;
        mn && this.strict && this.raise(en, "Invalid number");
        var $n = this.input.charCodeAt(this.pos);
        if (!mn && !de && this.options.ecmaVersion >= 11 && $n === 110) {
          var Vn = Js(this.input.slice(en, this.pos));
          return ++this.pos, O(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number"), this.finishToken(ee.num, Vn);
        }
        mn && /[89]/.test(this.input.slice(en, this.pos)) && (mn = !1), $n === 46 && !mn && (++this.pos, this.readInt(10), $n = this.input.charCodeAt(this.pos)), ($n === 69 || $n === 101) && !mn && ($n = this.input.charCodeAt(++this.pos), ($n === 43 || $n === 45) && ++this.pos, this.readInt(10) === null && this.raise(en, "Invalid number")), O(this.fullCharCodeAtPos()) && this.raise(this.pos, "Identifier directly after number");
        var sr = Dl(this.input.slice(en, this.pos), mn);
        return this.finishToken(ee.num, sr);
      }, ki.readCodePoint = function() {
        var de = this.input.charCodeAt(this.pos), en;
        if (de === 123) {
          this.options.ecmaVersion < 6 && this.unexpected();
          var mn = ++this.pos;
          en = this.readHexChar(this.input.indexOf("}", this.pos) - this.pos), ++this.pos, en > 1114111 && this.invalidStringToken(mn, "Code point out of bounds");
        } else
          en = this.readHexChar(4);
        return en;
      }, ki.readString = function(de) {
        for (var en = "", mn = ++this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          var $n = this.input.charCodeAt(this.pos);
          if ($n === de)
            break;
          $n === 92 ? (en += this.input.slice(mn, this.pos), en += this.readEscapedChar(!1), mn = this.pos) : $n === 8232 || $n === 8233 ? (this.options.ecmaVersion < 10 && this.raise(this.start, "Unterminated string constant"), ++this.pos, this.options.locations && (this.curLine++, this.lineStart = this.pos)) : (yt($n) && this.raise(this.start, "Unterminated string constant"), ++this.pos);
        }
        return en += this.input.slice(mn, this.pos++), this.finishToken(ee.string, en);
      };
      var Hl = {};
      ki.tryReadTemplateToken = function() {
        this.inTemplateElement = !0;
        try {
          this.readTmplToken();
        } catch (de) {
          if (de === Hl)
            this.readInvalidTemplateToken();
          else
            throw de;
        }
        this.inTemplateElement = !1;
      }, ki.invalidStringToken = function(de, en) {
        if (this.inTemplateElement && this.options.ecmaVersion >= 9)
          throw Hl;
        this.raise(de, en);
      }, ki.readTmplToken = function() {
        for (var de = "", en = this.pos; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated template");
          var mn = this.input.charCodeAt(this.pos);
          if (mn === 96 || mn === 36 && this.input.charCodeAt(this.pos + 1) === 123)
            return this.pos === this.start && (this.type === ee.template || this.type === ee.invalidTemplate) ? mn === 36 ? (this.pos += 2, this.finishToken(ee.dollarBraceL)) : (++this.pos, this.finishToken(ee.backQuote)) : (de += this.input.slice(en, this.pos), this.finishToken(ee.template, de));
          if (mn === 92)
            de += this.input.slice(en, this.pos), de += this.readEscapedChar(!0), en = this.pos;
          else if (yt(mn)) {
            switch (de += this.input.slice(en, this.pos), ++this.pos, mn) {
              case 13:
                this.input.charCodeAt(this.pos) === 10 && ++this.pos;
              case 10:
                de += `
`;
                break;
              default:
                de += String.fromCharCode(mn);
                break;
            }
            this.options.locations && (++this.curLine, this.lineStart = this.pos), en = this.pos;
          } else
            ++this.pos;
        }
      }, ki.readInvalidTemplateToken = function() {
        for (; this.pos < this.input.length; this.pos++)
          switch (this.input[this.pos]) {
            case "\\":
              ++this.pos;
              break;
            case "$":
              if (this.input[this.pos + 1] !== "{")
                break;
            case "`":
              return this.finishToken(ee.invalidTemplate, this.input.slice(this.start, this.pos));
          }
        this.raise(this.start, "Unterminated template");
      }, ki.readEscapedChar = function(de) {
        var en = this.input.charCodeAt(++this.pos);
        switch (++this.pos, en) {
          case 110:
            return `
`;
          case 114:
            return "\r";
          case 120:
            return String.fromCharCode(this.readHexChar(2));
          case 117:
            return Qt(this.readCodePoint());
          case 116:
            return "	";
          case 98:
            return "\b";
          case 118:
            return "\v";
          case 102:
            return "\f";
          case 13:
            this.input.charCodeAt(this.pos) === 10 && ++this.pos;
          case 10:
            return this.options.locations && (this.lineStart = this.pos, ++this.curLine), "";
          case 56:
          case 57:
            if (this.strict && this.invalidStringToken(
              this.pos - 1,
              "Invalid escape sequence"
            ), de) {
              var mn = this.pos - 1;
              this.invalidStringToken(
                mn,
                "Invalid escape sequence in template string"
              );
            }
          default:
            if (en >= 48 && en <= 55) {
              var $n = this.input.substr(this.pos - 1, 3).match(/^[0-7]+/)[0], Vn = parseInt($n, 8);
              return Vn > 255 && ($n = $n.slice(0, -1), Vn = parseInt($n, 8)), this.pos += $n.length - 1, en = this.input.charCodeAt(this.pos), ($n !== "0" || en === 56 || en === 57) && (this.strict || de) && this.invalidStringToken(
                this.pos - 1 - $n.length,
                de ? "Octal literal in template string" : "Octal literal in strict mode"
              ), String.fromCharCode(Vn);
            }
            return yt(en) ? "" : String.fromCharCode(en);
        }
      }, ki.readHexChar = function(de) {
        var en = this.pos, mn = this.readInt(16, de);
        return mn === null && this.invalidStringToken(en, "Bad character escape sequence"), mn;
      }, ki.readWord1 = function() {
        this.containsEsc = !1;
        for (var de = "", en = !0, mn = this.pos, $n = this.options.ecmaVersion >= 6; this.pos < this.input.length; ) {
          var Vn = this.fullCharCodeAtPos();
          if (z(Vn, $n))
            this.pos += Vn <= 65535 ? 1 : 2;
          else if (Vn === 92) {
            this.containsEsc = !0, de += this.input.slice(mn, this.pos);
            var sr = this.pos;
            this.input.charCodeAt(++this.pos) !== 117 && this.invalidStringToken(this.pos, "Expecting Unicode escape sequence \\uXXXX"), ++this.pos;
            var cr = this.readCodePoint();
            (en ? O : z)(cr, $n) || this.invalidStringToken(sr, "Invalid Unicode escape"), de += Qt(cr), mn = this.pos;
          } else
            break;
          en = !1;
        }
        return de + this.input.slice(mn, this.pos);
      }, ki.readWord = function() {
        var de = this.readWord1(), en = ee.name;
        return this.keywords.test(de) && (en = K[de]), this.finishToken(en, de);
      };
      var Ul = "8.11.3";
      Tn.acorn = {
        Parser: Tn,
        version: Ul,
        defaultOptions: vn,
        Position: gn,
        SourceLocation: dn,
        getLineInfo: yn,
        Node: ui,
        TokenType: Q,
        tokTypes: ee,
        keywordTypes: K,
        TokContext: kr,
        tokContexts: Nr,
        isIdentifierChar: z,
        isIdentifierStart: O,
        Token: Fl,
        isNewLine: yt,
        lineBreak: Re,
        lineBreakG: wt,
        nonASCIIwhitespace: Kt
      };
      function Of(de, en) {
        return Tn.parse(de, en);
      }
      function pc(de, en, mn) {
        return Tn.parseExpressionAt(de, en, mn);
      }
      function hc(de, en) {
        return Tn.tokenizer(de, en);
      }
      l.Node = ui, l.Parser = Tn, l.Position = gn, l.SourceLocation = dn, l.TokContext = kr, l.Token = Fl, l.TokenType = Q, l.defaultOptions = vn, l.getLineInfo = yn, l.isIdentifierChar = z, l.isIdentifierStart = O, l.isNewLine = yt, l.keywordTypes = K, l.lineBreak = Re, l.lineBreakG = wt, l.nonASCIIwhitespace = Kt, l.parse = Of, l.parseExpressionAt = pc, l.tokContexts = Nr, l.tokTypes = ee, l.tokenizer = hc, l.version = Ul;
    });
  }(acorn, acorn.exports)), acorn.exports;
}
(function(s) {
  const o = xhtml, l = /^[\da-fA-F]+$/, u = /^\d+$/, c = /* @__PURE__ */ new WeakMap();
  function m(b) {
    b = b.Parser.acorn || b;
    let S = c.get(b);
    if (!S) {
      const E = b.tokTypes, P = b.TokContext, T = b.TokenType, N = new P("<tag", !1), O = new P("</tag", !1), z = new P("<tag>...</tag>", !0, !0), Q = {
        tc_oTag: N,
        tc_cTag: O,
        tc_expr: z
      }, W = {
        jsxName: new T("jsxName"),
        jsxText: new T("jsxText", { beforeExpr: !0 }),
        jsxTagStart: new T("jsxTagStart", { startsExpr: !0 }),
        jsxTagEnd: new T("jsxTagEnd")
      };
      W.jsxTagStart.updateContext = function() {
        this.context.push(z), this.context.push(N), this.exprAllowed = !1;
      }, W.jsxTagEnd.updateContext = function(ue) {
        let te = this.context.pop();
        te === N && ue === E.slash || te === O ? (this.context.pop(), this.exprAllowed = this.curContext() === z) : this.exprAllowed = !0;
      }, S = { tokContexts: Q, tokTypes: W }, c.set(b, S);
    }
    return S;
  }
  function g(b) {
    if (!b)
      return b;
    if (b.type === "JSXIdentifier")
      return b.name;
    if (b.type === "JSXNamespacedName")
      return b.namespace.name + ":" + b.name.name;
    if (b.type === "JSXMemberExpression")
      return g(b.object) + "." + g(b.property);
  }
  s.exports = function(b) {
    return b = b || {}, function(S) {
      return v({
        allowNamespaces: b.allowNamespaces !== !1,
        allowNamespacedObjects: !!b.allowNamespacedObjects
      }, S);
    };
  }, Object.defineProperty(s.exports, "tokTypes", {
    get: function() {
      return m(requireAcorn()).tokTypes;
    },
    configurable: !0,
    enumerable: !0
  });
  function v(b, S) {
    const E = S.acorn || requireAcorn(), P = m(E), T = E.tokTypes, N = P.tokTypes, O = E.tokContexts, z = P.tokContexts.tc_oTag, Q = P.tokContexts.tc_cTag, W = P.tokContexts.tc_expr, ue = E.isNewLine, te = E.isIdentifierStart, K = E.isIdentifierChar;
    return class extends S {
      // Expose actual `tokTypes` and `tokContexts` to other plugins.
      static get acornJsx() {
        return P;
      }
      // Reads inline JSX contents token.
      jsx_readToken() {
        let ve = "", ee = this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated JSX contents");
          let Re = this.input.charCodeAt(this.pos);
          switch (Re) {
            case 60:
            case 123:
              return this.pos === this.start ? Re === 60 && this.exprAllowed ? (++this.pos, this.finishToken(N.jsxTagStart)) : this.getTokenFromCode(Re) : (ve += this.input.slice(ee, this.pos), this.finishToken(N.jsxText, ve));
            case 38:
              ve += this.input.slice(ee, this.pos), ve += this.jsx_readEntity(), ee = this.pos;
              break;
            case 62:
            case 125:
              this.raise(
                this.pos,
                "Unexpected token `" + this.input[this.pos] + "`. Did you mean `" + (Re === 62 ? "&gt;" : "&rbrace;") + '` or `{"' + this.input[this.pos] + '"}`?'
              );
            default:
              ue(Re) ? (ve += this.input.slice(ee, this.pos), ve += this.jsx_readNewLine(!0), ee = this.pos) : ++this.pos;
          }
        }
      }
      jsx_readNewLine(ve) {
        let ee = this.input.charCodeAt(this.pos), Re;
        return ++this.pos, ee === 13 && this.input.charCodeAt(this.pos) === 10 ? (++this.pos, Re = ve ? `
` : `\r
`) : Re = String.fromCharCode(ee), this.options.locations && (++this.curLine, this.lineStart = this.pos), Re;
      }
      jsx_readString(ve) {
        let ee = "", Re = ++this.pos;
        for (; ; ) {
          this.pos >= this.input.length && this.raise(this.start, "Unterminated string constant");
          let wt = this.input.charCodeAt(this.pos);
          if (wt === ve) break;
          wt === 38 ? (ee += this.input.slice(Re, this.pos), ee += this.jsx_readEntity(), Re = this.pos) : ue(wt) ? (ee += this.input.slice(Re, this.pos), ee += this.jsx_readNewLine(!1), Re = this.pos) : ++this.pos;
        }
        return ee += this.input.slice(Re, this.pos++), this.finishToken(T.string, ee);
      }
      jsx_readEntity() {
        let ve = "", ee = 0, Re, wt = this.input[this.pos];
        wt !== "&" && this.raise(this.pos, "Entity must start with an ampersand");
        let yt = ++this.pos;
        for (; this.pos < this.input.length && ee++ < 10; ) {
          if (wt = this.input[this.pos++], wt === ";") {
            ve[0] === "#" ? ve[1] === "x" ? (ve = ve.substr(2), l.test(ve) && (Re = String.fromCharCode(parseInt(ve, 16)))) : (ve = ve.substr(1), u.test(ve) && (Re = String.fromCharCode(parseInt(ve, 10)))) : Re = o[ve];
            break;
          }
          ve += wt;
        }
        return Re || (this.pos = yt, "&");
      }
      // Read a JSX identifier (valid tag or attribute name).
      //
      // Optimized version since JSX identifiers can't contain
      // escape characters and so can be read as single slice.
      // Also assumes that first character was already checked
      // by isIdentifierStart in readToken.
      jsx_readWord() {
        let ve, ee = this.pos;
        do
          ve = this.input.charCodeAt(++this.pos);
        while (K(ve) || ve === 45);
        return this.finishToken(N.jsxName, this.input.slice(ee, this.pos));
      }
      // Parse next token as JSX identifier
      jsx_parseIdentifier() {
        let ve = this.startNode();
        return this.type === N.jsxName ? ve.name = this.value : this.type.keyword ? ve.name = this.type.keyword : this.unexpected(), this.next(), this.finishNode(ve, "JSXIdentifier");
      }
      // Parse namespaced identifier.
      jsx_parseNamespacedName() {
        let ve = this.start, ee = this.startLoc, Re = this.jsx_parseIdentifier();
        if (!b.allowNamespaces || !this.eat(T.colon)) return Re;
        var wt = this.startNodeAt(ve, ee);
        return wt.namespace = Re, wt.name = this.jsx_parseIdentifier(), this.finishNode(wt, "JSXNamespacedName");
      }
      // Parses element name in any form - namespaced, member
      // or single identifier.
      jsx_parseElementName() {
        if (this.type === N.jsxTagEnd) return "";
        let ve = this.start, ee = this.startLoc, Re = this.jsx_parseNamespacedName();
        for (this.type === T.dot && Re.type === "JSXNamespacedName" && !b.allowNamespacedObjects && this.unexpected(); this.eat(T.dot); ) {
          let wt = this.startNodeAt(ve, ee);
          wt.object = Re, wt.property = this.jsx_parseIdentifier(), Re = this.finishNode(wt, "JSXMemberExpression");
        }
        return Re;
      }
      // Parses any type of JSX attribute value.
      jsx_parseAttributeValue() {
        switch (this.type) {
          case T.braceL:
            let ve = this.jsx_parseExpressionContainer();
            return ve.expression.type === "JSXEmptyExpression" && this.raise(ve.start, "JSX attributes must only be assigned a non-empty expression"), ve;
          case N.jsxTagStart:
          case T.string:
            return this.parseExprAtom();
          default:
            this.raise(this.start, "JSX value should be either an expression or a quoted JSX text");
        }
      }
      // JSXEmptyExpression is unique type since it doesn't actually parse anything,
      // and so it should start at the end of last read token (left brace) and finish
      // at the beginning of the next one (right brace).
      jsx_parseEmptyExpression() {
        let ve = this.startNodeAt(this.lastTokEnd, this.lastTokEndLoc);
        return this.finishNodeAt(ve, "JSXEmptyExpression", this.start, this.startLoc);
      }
      // Parses JSX expression enclosed into curly brackets.
      jsx_parseExpressionContainer() {
        let ve = this.startNode();
        return this.next(), ve.expression = this.type === T.braceR ? this.jsx_parseEmptyExpression() : this.parseExpression(), this.expect(T.braceR), this.finishNode(ve, "JSXExpressionContainer");
      }
      // Parses following JSX attribute name-value pair.
      jsx_parseAttribute() {
        let ve = this.startNode();
        return this.eat(T.braceL) ? (this.expect(T.ellipsis), ve.argument = this.parseMaybeAssign(), this.expect(T.braceR), this.finishNode(ve, "JSXSpreadAttribute")) : (ve.name = this.jsx_parseNamespacedName(), ve.value = this.eat(T.eq) ? this.jsx_parseAttributeValue() : null, this.finishNode(ve, "JSXAttribute"));
      }
      // Parses JSX opening tag starting after '<'.
      jsx_parseOpeningElementAt(ve, ee) {
        let Re = this.startNodeAt(ve, ee);
        Re.attributes = [];
        let wt = this.jsx_parseElementName();
        for (wt && (Re.name = wt); this.type !== T.slash && this.type !== N.jsxTagEnd; )
          Re.attributes.push(this.jsx_parseAttribute());
        return Re.selfClosing = this.eat(T.slash), this.expect(N.jsxTagEnd), this.finishNode(Re, wt ? "JSXOpeningElement" : "JSXOpeningFragment");
      }
      // Parses JSX closing tag starting after '</'.
      jsx_parseClosingElementAt(ve, ee) {
        let Re = this.startNodeAt(ve, ee), wt = this.jsx_parseElementName();
        return wt && (Re.name = wt), this.expect(N.jsxTagEnd), this.finishNode(Re, wt ? "JSXClosingElement" : "JSXClosingFragment");
      }
      // Parses entire JSX element, including it's opening tag
      // (starting after '<'), attributes, contents and closing tag.
      jsx_parseElementAt(ve, ee) {
        let Re = this.startNodeAt(ve, ee), wt = [], yt = this.jsx_parseOpeningElementAt(ve, ee), xt = null;
        if (!yt.selfClosing) {
          e: for (; ; )
            switch (this.type) {
              case N.jsxTagStart:
                if (ve = this.start, ee = this.startLoc, this.next(), this.eat(T.slash)) {
                  xt = this.jsx_parseClosingElementAt(ve, ee);
                  break e;
                }
                wt.push(this.jsx_parseElementAt(ve, ee));
                break;
              case N.jsxText:
                wt.push(this.parseExprAtom());
                break;
              case T.braceL:
                wt.push(this.jsx_parseExpressionContainer());
                break;
              default:
                this.unexpected();
            }
          g(xt.name) !== g(yt.name) && this.raise(
            xt.start,
            "Expected corresponding JSX closing tag for <" + g(yt.name) + ">"
          );
        }
        let Kt = yt.name ? "Element" : "Fragment";
        return Re["opening" + Kt] = yt, Re["closing" + Kt] = xt, Re.children = wt, this.type === T.relational && this.value === "<" && this.raise(this.start, "Adjacent JSX elements must be wrapped in an enclosing tag"), this.finishNode(Re, "JSX" + Kt);
      }
      // Parse JSX text
      jsx_parseText() {
        let ve = this.parseLiteral(this.value);
        return ve.type = "JSXText", ve;
      }
      // Parses entire JSX element from current position.
      jsx_parseElement() {
        let ve = this.start, ee = this.startLoc;
        return this.next(), this.jsx_parseElementAt(ve, ee);
      }
      parseExprAtom(ve) {
        return this.type === N.jsxText ? this.jsx_parseText() : this.type === N.jsxTagStart ? this.jsx_parseElement() : super.parseExprAtom(ve);
      }
      readToken(ve) {
        let ee = this.curContext();
        if (ee === W) return this.jsx_readToken();
        if (ee === z || ee === Q) {
          if (te(ve)) return this.jsx_readWord();
          if (ve == 62)
            return ++this.pos, this.finishToken(N.jsxTagEnd);
          if ((ve === 34 || ve === 39) && ee == z)
            return this.jsx_readString(ve);
        }
        return ve === 60 && this.exprAllowed && this.input.charCodeAt(this.pos + 1) !== 33 ? (++this.pos, this.finishToken(N.jsxTagStart)) : super.readToken(ve);
      }
      updateContext(ve) {
        if (this.type == T.braceL) {
          var ee = this.curContext();
          ee == z ? this.context.push(O.b_expr) : ee == W ? this.context.push(O.b_tmpl) : super.updateContext(ve), this.exprAllowed = !0;
        } else if (this.type === T.slash && ve === N.jsxTagStart)
          this.context.length -= 2, this.context.push(Q), this.exprAllowed = !1;
        else
          return super.updateContext(ve);
      }
    };
  }
})(acornJsx$1);
var acornJsxExports = acornJsx$1.exports;
const acornJsx = /* @__PURE__ */ getDefaultExportFromCjs(acornJsxExports), asciiAlpha = regexCheck(/[A-Za-z]/), asciiAlphanumeric = regexCheck(/[\dA-Za-z]/), asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
function asciiControl(s) {
  return (
    // Special whitespace codes (which have negative values), C0 and Control
    // character DEL
    s !== null && (s < 32 || s === 127)
  );
}
const asciiDigit = regexCheck(/\d/), asciiHexDigit = regexCheck(/[\dA-Fa-f]/), asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
function markdownLineEnding(s) {
  return s !== null && s < -2;
}
function markdownLineEndingOrSpace(s) {
  return s !== null && (s < 0 || s === 32);
}
function markdownSpace(s) {
  return s === -2 || s === -1 || s === 32;
}
const unicodePunctuation = regexCheck(new RegExp("\\p{P}|\\p{S}", "u")), unicodeWhitespace = regexCheck(/\s/);
function regexCheck(s) {
  return o;
  function o(l) {
    return l !== null && l > -1 && s.test(String.fromCharCode(l));
  }
}
function color$1(s) {
  return s;
}
const own$8 = {}.hasOwnProperty, CONTINUE$1 = Symbol("continue"), EXIT$1 = Symbol("exit"), SKIP$1 = Symbol("skip");
function visit$1(s, o) {
  let l, u;
  typeof o == "function" ? l = o : o && typeof o == "object" && (o.enter && (l = o.enter), o.leave && (u = o.leave)), c(s, void 0, void 0, [])();
  function c(m, g, v, b) {
    return nodelike(m) && (S.displayName = "node (" + m.type + ")"), S;
    function S() {
      const E = l ? toResult$1(l(m, g, v, b)) : [];
      if (E[0] === EXIT$1)
        return E;
      if (E[0] !== SKIP$1) {
        let P;
        for (P in m)
          if (own$8.call(m, P) && m[P] && typeof m[P] == "object" && // @ts-expect-error: custom esast extension.
          P !== "data" && // @ts-expect-error: custom esast extension.
          P !== "position") {
            const T = b.concat(m), N = m[P];
            if (Array.isArray(N)) {
              const O = (
                /** @type {Array<unknown>} */
                N
              );
              let z = 0;
              for (; z > -1 && z < O.length; ) {
                const Q = O[z];
                if (nodelike(Q)) {
                  const W = c(
                    Q,
                    P,
                    z,
                    T
                  )();
                  if (W[0] === EXIT$1) return W;
                  z = typeof W[1] == "number" ? W[1] : z + 1;
                } else
                  z++;
              }
            } else if (nodelike(N)) {
              const O = c(N, P, void 0, T)();
              if (O[0] === EXIT$1) return O;
            }
          }
      }
      return u ? toResult$1(u(m, g, v, b)) : E;
    }
  }
}
function toResult$1(s) {
  return Array.isArray(s) ? s : typeof s == "number" ? [CONTINUE$1, s] : [s];
}
function nodelike(s) {
  return !!(s && typeof s == "object" && "type" in s && typeof s.type == "string" && s.type.length > 0);
}
function eventsToAcorn(s, o) {
  const l = o.prefix || "", u = o.suffix || "", c = Object.assign({}, o.acornOptions), m = [], g = [], v = c.onComment, b = c.onToken;
  let S = !1, E, P;
  const T = Object.assign({}, c, {
    onComment: m,
    preserveParens: !0
  });
  b && (T.onToken = g);
  const N = collect(s, o.tokenTypes), O = N.value, z = l + O + u, Q = o.expression && empty$2(O);
  if (Q && !o.allowEmpty)
    throw new VFileMessage("Unexpected empty expression", {
      place: ue(0),
      ruleId: "unexpected-empty-expression",
      source: "micromark-extension-mdx-expression"
    });
  try {
    E = o.expression && !Q ? o.acorn.parseExpressionAt(z, 0, T) : o.acorn.parse(z, T);
  } catch (te) {
    const K = (
      /** @type {AcornError} */
      te
    ), ve = ue(K.pos);
    K.message = String(K.message).replace(/ \(\d+:\d+\)$/, ""), K.pos = ve.offset, K.loc = {
      line: ve.line,
      column: ve.column - 1
    }, P = K, S = K.raisedAt >= l.length + O.length || // Broken comments are raised at their start, not their end.
    K.message === "Unterminated comment";
  }
  if (E && o.expression && !Q)
    if (empty$2(z.slice(E.end, z.length - u.length)))
      E = {
        type: "Program",
        start: 0,
        end: l.length + O.length,
        // @ts-expect-error: It’s good.
        body: [{
          type: "ExpressionStatement",
          expression: E,
          start: 0,
          end: l.length + O.length
        }],
        sourceType: "module",
        comments: []
      };
    else {
      const te = ue(E.end), K = (
        /** @type {AcornError} */
        new Error("Unexpected content after expression")
      );
      K.pos = te.offset, K.loc = {
        line: te.line,
        column: te.column - 1
      }, P = K, E = void 0;
    }
  if (E) {
    if (E.comments = m, visit$1(E, function(te, K, ve, ee) {
      let Re = (
        /** @type {AcornNode | Array<AcornNode>} */
        ee[ee.length - 1]
      ), wt = K;
      te.type === "ParenthesizedExpression" && Re && wt && (typeof ve == "number" && (Re = Re[wt], wt = ve), Re[wt] = te.expression), W(te);
    }), Array.isArray(v))
      v.push(...m);
    else if (typeof v == "function")
      for (const te of m)
        v(te.type === "Block", te.value, te.start, te.end, te.loc.start, te.loc.end);
    for (const te of g)
      te.end <= l.length || te.start - l.length >= O.length || (W(te), Array.isArray(b) ? b.push(te) : b(te));
  }
  return {
    estree: E,
    error: P,
    swallow: S
  };
  function W(te) {
    const K = ue(te.start), ve = ue(te.end);
    te.start = K.offset, te.end = ve.offset, te.loc = {
      start: {
        line: K.line,
        column: K.column - 1,
        offset: K.offset
      },
      end: {
        line: ve.line,
        column: ve.column - 1,
        offset: ve.offset
      }
    }, te.range = [te.start, te.end];
  }
  function ue(te) {
    let K = te - l.length;
    K < 0 ? K = 0 : K > O.length && (K = O.length);
    let ve = relativeToPoint(N.stops, K);
    return ve || (ve = {
      line: o.start.line,
      column: o.start.column,
      offset: o.start.offset
    }), ve;
  }
}
function empty$2(s) {
  return /^\s*$/.test(s.replace(/\/\*[\s\S]*?\*\//g, "").replace(/\/\/[^\r\n]*(\r\n|\n|\r)/g, ""));
}
function collect(s, o) {
  const l = {
    value: "",
    stops: []
  };
  let u = -1;
  for (; ++u < s.length; ) {
    const c = s[u];
    if (c[0] === "enter") {
      const m = c[1].type;
      if (m === "lineEnding" || o.includes(m)) {
        const g = c[2].sliceStream(c[1]);
        for (; g.length > 0 && g[0] === -1; )
          g.shift();
        const v = serializeChunks$1(g);
        l.stops.push([l.value.length, c[1].start]), l.value += v, l.stops.push([l.value.length, c[1].end]);
      }
    }
  }
  return l;
}
function relativeToPoint(s, o) {
  let l = 0;
  for (; l < s.length && s[l][0] <= o; )
    l += 1;
  if (l === 0)
    return;
  const [u, c] = s[l - 1], m = o - u;
  return {
    line: c.line,
    column: c.column + m,
    offset: c.offset + m
  };
}
function serializeChunks$1(s) {
  let o = -1;
  const l = [];
  let u;
  for (; ++o < s.length; ) {
    const c = s[o];
    let m;
    if (typeof c == "string")
      m = c;
    else switch (c) {
      case -5: {
        m = "\r";
        break;
      }
      case -4: {
        m = `
`;
        break;
      }
      case -3: {
        m = `\r
`;
        break;
      }
      case -2: {
        m = "	";
        break;
      }
      case -1: {
        if (u) continue;
        m = " ";
        break;
      }
      default:
        m = String.fromCharCode(c);
    }
    u = c === -2, l.push(m);
  }
  return l.join("");
}
function positionFromEstree(s) {
  const o = s || {}, l = o.loc || {}, u = o.range || [void 0, void 0], c = pointOrUndefined(l.start, u[0] || o.start), m = pointOrUndefined(l.end, u[1] || o.end);
  if (c && m)
    return { start: c, end: m };
}
function pointOrUndefined(s, o) {
  if (s && typeof s == "object") {
    const l = "line" in s ? numberOrUndefined(s.line) : void 0, u = "column" in s ? numberOrUndefined(s.column) : void 0;
    if (l && u !== void 0)
      return {
        line: l,
        column: u + 1,
        offset: numberOrUndefined(o)
      };
  }
}
function numberOrUndefined(s) {
  return typeof s == "number" && s > -1 ? s : void 0;
}
const trouble$2 = "https://github.com/micromark/micromark-extension-mdx-expression/tree/main/packages/micromark-extension-mdx-expression", unexpectedEofHash = "#unexpected-end-of-file-in-expression-expected-a-corresponding-closing-brace-for-", unexpectedLazyHash = "#unexpected-lazy-line-in-expression-in-container-expected-line-to-be-prefixed", nonSpreadHash = "#unexpected-type-in-code-expected-an-object-spread-spread", spreadExtraHash = "#unexpected-extra-content-in-spread-only-a-single-spread-is-supported", acornHash = "#could-not-parse-expression-with-acorn";
function factoryMdxExpression(s, o, l, u, c, m, g, v, b, S, E) {
  const P = this, T = this.events.length + 3;
  let N = 0, O, z;
  return Q;
  function Q(K) {
    return s.enter(l), s.enter(u), s.consume(K), s.exit(u), O = P.now(), W;
  }
  function W(K) {
    if (K === null) {
      if (z) throw z;
      const ve = new VFileMessage(
        "Unexpected end of file in expression, expected a corresponding closing brace for `{`",
        {
          place: P.now(),
          ruleId: "unexpected-eof",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw ve.url = trouble$2 + unexpectedEofHash, ve;
    }
    if (markdownLineEnding(K))
      return s.enter("lineEnding"), s.consume(K), s.exit("lineEnding"), te;
    if (K === 125 && N === 0) {
      const ve = m ? mdxExpressionParse.call(
        P,
        m,
        g,
        c,
        T,
        O,
        S || !1,
        b || !1
      ) : {
        type: "ok",
        estree: void 0
      };
      if (ve.type === "ok") {
        s.enter(u), s.consume(K), s.exit(u);
        const ee = s.exit(l);
        return v && ve.estree && Object.assign(ee, {
          estree: ve.estree
        }), o;
      }
      return z = ve.message, s.enter(c), s.consume(K), ue;
    }
    return s.enter(c), ue(K);
  }
  function ue(K) {
    return K === 125 && N === 0 || K === null || markdownLineEnding(K) ? (s.exit(c), W(K)) : (K === 123 && !m ? N += 1 : K === 125 && (N -= 1), s.consume(K), ue);
  }
  function te(K) {
    const ve = P.now();
    if (ve.line !== O.line && !E && P.parser.lazy[ve.line]) {
      const ee = new VFileMessage(
        "Unexpected lazy line in expression in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc",
        {
          place: P.now(),
          ruleId: "unexpected-lazy",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw ee.url = trouble$2 + unexpectedLazyHash, ee;
    }
    return W(K);
  }
}
function mdxExpressionParse(s, o, l, u, c, m, g) {
  const v = eventsToAcorn(this.events.slice(u), {
    acorn: s,
    tokenTypes: [l],
    acornOptions: o,
    start: c,
    expression: !0,
    allowEmpty: m,
    prefix: g ? "({" : "",
    suffix: g ? "})" : ""
  }), b = v.estree;
  if (g && b) {
    const S = b.body[0];
    if (S.type !== "ExpressionStatement" || S.expression.type !== "ObjectExpression") {
      const E = positionFromEstree(S), P = new VFileMessage(
        "Unexpected `" + S.type + "` in code: expected an object spread (`{...spread}`)",
        {
          place: E.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw P.url = trouble$2 + nonSpreadHash, P;
    }
    if (S.expression.properties[1]) {
      const E = positionFromEstree(S.expression.properties[1]), P = new VFileMessage(
        "Unexpected extra content in spread: only a single spread is supported",
        {
          place: E.start,
          ruleId: "spread-extra",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw P.url = trouble$2 + spreadExtraHash, P;
    }
    if (S.expression.properties[0] && S.expression.properties[0].type !== "SpreadElement") {
      const E = positionFromEstree(S.expression.properties[0]), P = new VFileMessage(
        "Unexpected `" + S.expression.properties[0].type + "` in code: only spread elements are supported",
        {
          place: E.start,
          ruleId: "non-spread",
          source: "micromark-extension-mdx-expression"
        }
      );
      throw P.url = trouble$2 + nonSpreadHash, P;
    }
  }
  if (v.error) {
    const S = new VFileMessage("Could not parse expression with acorn", {
      cause: v.error,
      place: {
        line: v.error.loc.line,
        column: v.error.loc.column + 1,
        offset: v.error.pos
      },
      ruleId: "acorn",
      source: "micromark-extension-mdx-expression"
    });
    return S.url = trouble$2 + acornHash, {
      type: "nok",
      message: S
    };
  }
  return {
    type: "ok",
    estree: b
  };
}
function factorySpace(s, o, l, u) {
  const c = u ? u - 1 : Number.POSITIVE_INFINITY;
  let m = 0;
  return g;
  function g(b) {
    return markdownSpace(b) ? (s.enter(l), v(b)) : o(b);
  }
  function v(b) {
    return markdownSpace(b) && m++ < c ? (s.consume(b), v) : (s.exit(l), o(b));
  }
}
function mdxExpression$1(s) {
  const o = s || {}, l = o.addResult, u = o.acorn, c = o.spread;
  let m = o.allowEmpty, g;
  if (m == null && (m = !0), u) {
    if (!u.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    g = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, o.acornOptions);
  } else if (o.acornOptions || o.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      123: {
        name: "mdxFlowExpression",
        tokenize: v,
        concrete: !0
      }
    },
    text: {
      123: {
        name: "mdxTextExpression",
        tokenize: b
      }
    }
  };
  function v(S, E, P) {
    const T = this;
    return N;
    function N(W) {
      return O(W);
    }
    function O(W) {
      return factoryMdxExpression.call(T, S, z, "mdxFlowExpression", "mdxFlowExpressionMarker", "mdxFlowExpressionChunk", u, g, l, c, m)(W);
    }
    function z(W) {
      return markdownSpace(W) ? factorySpace(S, Q, "whitespace")(W) : Q(W);
    }
    function Q(W) {
      const ue = T.parser.constructs.flow[60], K = (Array.isArray(ue) ? ue : (
        /* c8 ignore next 3 -- always a list when normalized. */
        ue ? [ue] : []
      )).find(function(ve) {
        return ve.name === "mdxJsxFlowTag";
      });
      return W === 60 && K ? S.attempt(K, Q, P)(W) : W === null || markdownLineEnding(W) ? E(W) : P(W);
    }
  }
  function b(S, E) {
    const P = this;
    return T;
    function T(N) {
      return factoryMdxExpression.call(P, S, E, "mdxTextExpression", "mdxTextExpressionMarker", "mdxTextExpressionChunk", u, g, l, c, m, !0)(N);
    }
  }
}
const startRe = /[$_\p{ID_Start}]/u, contRe = /[$_\u{200C}\u{200D}\p{ID_Continue}]/u, contReJsx = /[-$_\u{200C}\u{200D}\p{ID_Continue}]/u, nameRe = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, nameReJsx = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, emptyOptions$5 = {};
function start(s) {
  return s ? startRe.test(String.fromCodePoint(s)) : !1;
}
function cont(s, o) {
  const u = (o || emptyOptions$5).jsx ? contReJsx : contRe;
  return s ? u.test(String.fromCodePoint(s)) : !1;
}
function name(s, o) {
  return ((o || emptyOptions$5).jsx ? nameReJsx : nameRe).test(s);
}
const trouble$1 = "https://github.com/micromark/micromark-extension-mdx-jsx";
function factoryTag(s, o, l, u, c, m, g, v, b, S, E, P, T, N, O, z, Q, W, ue, te, K, ve, ee, Re, wt, yt, xt, Kt, tn, ln, rn, an) {
  const Gt = this;
  let nn, vt;
  return Et;
  function Et(hn) {
    return s.enter(v), s.enter(b), s.consume(hn), s.exit(b), Qt;
  }
  function Qt(hn) {
    return markdownLineEndingOrSpace(hn) ? l(hn) : (nn = un, Wn(hn));
  }
  function un(hn) {
    if (hn === 47)
      return s.enter(S), s.consume(hn), s.exit(S), nn = gn, Wn;
    if (hn === 62)
      return Gn(hn);
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(P), s.enter(T), s.consume(hn), dn;
    Rn(hn, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (hn === 33 ? " (note: to create a comment in MDX, use `{/* text */}`)" : ""));
  }
  function gn(hn) {
    if (hn === 62)
      return Gn(hn);
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(P), s.enter(T), s.consume(hn), dn;
    Rn(hn, "before name", "a character that can start a name, such as a letter, `$`, or `_`" + (hn === 42 || hn === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function dn(hn) {
    if (hn !== null && hn >= 0 && cont(hn, {
      jsx: !0
    }))
      return s.consume(hn), dn;
    if (hn === 46 || hn === 47 || hn === 58 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn))
      return s.exit(T), nn = yn, Wn(hn);
    Rn(hn, "in name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (hn === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function yn(hn) {
    if (hn === 46)
      return s.enter(N), s.consume(hn), s.exit(N), nn = vn, Wn;
    if (hn === 58)
      return s.enter(z), s.consume(hn), s.exit(z), nn = _n, Wn;
    if (hn === 47 || hn === 62 || hn === 123 || hn !== null && hn >= 0 && start(hn))
      return s.exit(P), Xn(hn);
    Rn(hn, "after name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function vn(hn) {
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(O), s.consume(hn), Pn;
    Rn(hn, "before member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function Pn(hn) {
    if (hn !== null && hn >= 0 && cont(hn, {
      jsx: !0
    }))
      return s.consume(hn), Pn;
    if (hn === 46 || hn === 47 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn))
      return s.exit(O), nn = On, Wn(hn);
    Rn(hn, "in member name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag" + (hn === 64 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function On(hn) {
    if (hn === 46)
      return s.enter(N), s.consume(hn), s.exit(N), nn = vn, Wn;
    if (hn === 47 || hn === 62 || hn === 123 || hn !== null && hn >= 0 && start(hn))
      return s.exit(P), Xn(hn);
    Rn(hn, "after member name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function _n(hn) {
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(Q), s.consume(hn), Nn;
    Rn(hn, "before local name", "a character that can start a name, such as a letter, `$`, or `_`" + (hn === 43 || hn !== null && hn > 46 && hn < 58 ? " (note: to create a link in MDX, use `[text](url)`)" : ""));
  }
  function Nn(hn) {
    if (hn !== null && hn >= 0 && cont(hn, {
      jsx: !0
    }))
      return s.consume(hn), Nn;
    if (hn === 47 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn))
      return s.exit(Q), nn = Un, Wn(hn);
    Rn(hn, "in local name", "a name character such as letters, digits, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function Un(hn) {
    if (hn === 47 || hn === 62 || hn === 123 || hn !== null && hn >= 0 && start(hn))
      return s.exit(P), Xn(hn);
    Rn(hn, "after local name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function Xn(hn) {
    if (hn === 47)
      return s.enter(E), s.consume(hn), s.exit(E), nn = Fn, Wn;
    if (hn === 62)
      return Gn(hn);
    if (hn === 123)
      return factoryMdxExpression.call(Gt, s, zn, W, ue, te, u, c, m, !0, !1, g)(hn);
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(K), s.enter(ve), s.enter(ee), s.consume(hn), jn;
    Rn(hn, "before attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; whitespace before attributes; or the end of the tag");
  }
  function zn(hn) {
    return nn = Xn, Wn(hn);
  }
  function jn(hn) {
    if (hn !== null && hn >= 0 && cont(hn, {
      jsx: !0
    }))
      return s.consume(hn), jn;
    if (hn === 47 || hn === 58 || hn === 61 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn))
      return s.exit(ee), nn = kn, Wn(hn);
    Rn(hn, "in attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function kn(hn) {
    if (hn === 58)
      return s.enter(Re), s.consume(hn), s.exit(Re), nn = Yn, Wn;
    if (hn === 61)
      return s.exit(ve), s.enter(yt), s.consume(hn), s.exit(yt), nn = bn, Wn;
    if (hn === 47 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn) || hn !== null && hn >= 0 && start(hn))
      return s.exit(ve), s.exit(K), nn = Xn, Wn(hn);
    Rn(hn, "after attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function Yn(hn) {
    if (hn !== null && hn >= 0 && start(hn))
      return s.enter(wt), s.consume(hn), Zn;
    Rn(hn, "before local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function Zn(hn) {
    if (hn !== null && hn >= 0 && cont(hn, {
      jsx: !0
    }))
      return s.consume(hn), Zn;
    if (hn === 47 || hn === 61 || hn === 62 || hn === 123 || markdownLineEndingOrSpace(hn) || unicodeWhitespace(hn))
      return s.exit(wt), s.exit(ve), nn = er, Wn(hn);
    Rn(hn, "in local attribute name", "an attribute name character such as letters, digits, `$`, or `_`; `=` to initialize a value; whitespace before attributes; or the end of the tag");
  }
  function er(hn) {
    if (hn === 61)
      return s.enter(yt), s.consume(hn), s.exit(yt), nn = bn, Wn;
    if (hn === 47 || hn === 62 || hn === 123 || hn !== null && hn >= 0 && start(hn))
      return s.exit(K), Xn(hn);
    Rn(hn, "after local attribute name", "a character that can start an attribute name, such as a letter, `$`, or `_`; `=` to initialize a value; or the end of the tag");
  }
  function bn(hn) {
    if (hn === 34 || hn === 39)
      return s.enter(xt), s.enter(Kt), s.consume(hn), s.exit(Kt), vt = hn, Kn;
    if (hn === 123)
      return factoryMdxExpression.call(Gt, s, Ln, ln, rn, an, u, c, m, !1, !1, g)(hn);
    Rn(hn, "before attribute value", "a character that can start an attribute value, such as `\"`, `'`, or `{`" + (hn === 60 ? " (note: to use an element or fragment as a prop value in MDX, use `{<element />}`)" : ""));
  }
  function Ln(hn) {
    return s.exit(K), nn = Xn, Wn(hn);
  }
  function Kn(hn) {
    return hn === null && Rn(hn, "in attribute value", "a corresponding closing quote `" + String.fromCodePoint(vt) + "`"), hn === vt ? (s.enter(Kt), s.consume(hn), s.exit(Kt), s.exit(xt), s.exit(K), vt = void 0, nn = Xn, Wn) : markdownLineEnding(hn) ? (nn = Kn, Wn(hn)) : (s.enter(tn), Bn(hn));
  }
  function Bn(hn) {
    return hn === null || hn === vt || markdownLineEnding(hn) ? (s.exit(tn), Kn(hn)) : (s.consume(hn), Bn);
  }
  function Fn(hn) {
    if (hn === 62)
      return Gn(hn);
    Rn(hn, "after self-closing slash", "`>` to end the tag" + (hn === 42 || hn === 47 ? " (note: JS comments in JSX tags are not supported in MDX)" : ""));
  }
  function Gn(hn) {
    return s.enter(b), s.consume(hn), s.exit(b), s.exit(v), o;
  }
  function Wn(hn) {
    return markdownLineEnding(hn) ? (s.enter("lineEnding"), s.consume(hn), s.exit("lineEnding"), Tn) : markdownSpace(hn) || unicodeWhitespace(hn) ? (s.enter("esWhitespace"), Mn(hn)) : nn(hn);
  }
  function Mn(hn) {
    return markdownLineEnding(hn) ? (s.exit("esWhitespace"), Wn(hn)) : markdownSpace(hn) || unicodeWhitespace(hn) ? (s.consume(hn), Mn) : (s.exit("esWhitespace"), nn(hn));
  }
  function Tn(hn) {
    if (!g && Gt.parser.lazy[Gt.now().line]) {
      const Qn = new VFileMessage("Unexpected lazy line in container, expected line to be prefixed with `>` when in a block quote, whitespace when in a list, etc", Gt.now(), "micromark-extension-mdx-jsx:unexpected-lazy");
      throw Qn.url = trouble$1 + "#unexpected-lazy-line-in-container-expected-line-to-be", Qn;
    }
    return Wn(hn);
  }
  function Rn(hn, Qn, rr) {
    const tr = new VFileMessage("Unexpected " + (hn === null ? "end of file" : "character `" + (hn === 96 ? "` ` `" : String.fromCodePoint(hn)) + "` (" + serializeCharCode(hn) + ")") + " " + Qn + ", expected " + rr, Gt.now(), "micromark-extension-mdx-jsx:unexpected-" + (hn === null ? "eof" : "character"));
    throw tr.url = trouble$1 + (hn === null ? "#unexpected-end-of-file-at-expected-expect" : "#unexpected-character-at-expected-expect"), tr;
  }
}
function serializeCharCode(s) {
  return "U+" + s.toString(16).toUpperCase().padStart(4, "0");
}
function jsxText$1(s, o) {
  return {
    name: "mdxJsxTextTag",
    tokenize: l
  };
  function l(u, c, m) {
    return factoryTag.call(this, u, c, m, s, o.acornOptions, o.addResult, !0, "mdxJsxTextTag", "mdxJsxTextTagMarker", "mdxJsxTextTagClosingMarker", "mdxJsxTextTagSelfClosingMarker", "mdxJsxTextTagName", "mdxJsxTextTagNamePrimary", "mdxJsxTextTagNameMemberMarker", "mdxJsxTextTagNameMember", "mdxJsxTextTagNamePrefixMarker", "mdxJsxTextTagNameLocal", "mdxJsxTextTagExpressionAttribute", "mdxJsxTextTagExpressionAttributeMarker", "mdxJsxTextTagExpressionAttributeValue", "mdxJsxTextTagAttribute", "mdxJsxTextTagAttributeName", "mdxJsxTextTagAttributeNamePrimary", "mdxJsxTextTagAttributeNamePrefixMarker", "mdxJsxTextTagAttributeNameLocal", "mdxJsxTextTagAttributeInitializerMarker", "mdxJsxTextTagAttributeValueLiteral", "mdxJsxTextTagAttributeValueLiteralMarker", "mdxJsxTextTagAttributeValueLiteralValue", "mdxJsxTextTagAttributeValueExpression", "mdxJsxTextTagAttributeValueExpressionMarker", "mdxJsxTextTagAttributeValueExpressionValue");
  }
}
function jsxFlow(s, o) {
  return {
    name: "mdxJsxFlowTag",
    tokenize: l,
    concrete: !0
  };
  function l(u, c, m) {
    const g = this;
    return v;
    function v(P) {
      return b(P);
    }
    function b(P) {
      return factoryTag.call(g, u, S, m, s, o.acornOptions, o.addResult, !1, "mdxJsxFlowTag", "mdxJsxFlowTagMarker", "mdxJsxFlowTagClosingMarker", "mdxJsxFlowTagSelfClosingMarker", "mdxJsxFlowTagName", "mdxJsxFlowTagNamePrimary", "mdxJsxFlowTagNameMemberMarker", "mdxJsxFlowTagNameMember", "mdxJsxFlowTagNamePrefixMarker", "mdxJsxFlowTagNameLocal", "mdxJsxFlowTagExpressionAttribute", "mdxJsxFlowTagExpressionAttributeMarker", "mdxJsxFlowTagExpressionAttributeValue", "mdxJsxFlowTagAttribute", "mdxJsxFlowTagAttributeName", "mdxJsxFlowTagAttributeNamePrimary", "mdxJsxFlowTagAttributeNamePrefixMarker", "mdxJsxFlowTagAttributeNameLocal", "mdxJsxFlowTagAttributeInitializerMarker", "mdxJsxFlowTagAttributeValueLiteral", "mdxJsxFlowTagAttributeValueLiteralMarker", "mdxJsxFlowTagAttributeValueLiteralValue", "mdxJsxFlowTagAttributeValueExpression", "mdxJsxFlowTagAttributeValueExpressionMarker", "mdxJsxFlowTagAttributeValueExpressionValue")(P);
    }
    function S(P) {
      return markdownSpace(P) ? factorySpace(u, E, "whitespace")(P) : E(P);
    }
    function E(P) {
      const T = g.parser.constructs.flow[123], O = (Array.isArray(T) ? T : T ? [T] : []).find((z) => z.name === "mdxFlowExpression");
      return P === 60 ? (
        // We can’t just say: fine. Lines of blocks have to be parsed until an eol/eof.
        v(P)
      ) : P === 123 && O ? u.attempt(O, E, m)(P) : P === null || markdownLineEnding(P) ? c(P) : m(P);
    }
  }
}
function mdxJsx(s) {
  const o = s || {}, l = o.acorn;
  let u;
  if (l) {
    if (!l.parse || !l.parseExpressionAt)
      throw new Error("Expected a proper `acorn` instance passed in as `options.acorn`");
    u = Object.assign({
      ecmaVersion: 2024,
      sourceType: "module"
    }, o.acornOptions, {
      locations: !0
    });
  } else if (o.acornOptions || o.addResult)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  return {
    flow: {
      60: jsxFlow(l || void 0, {
        acornOptions: u,
        addResult: o.addResult || void 0
      })
    },
    text: {
      60: jsxText$1(l || void 0, {
        acornOptions: u,
        addResult: o.addResult || void 0
      })
    }
  };
}
function mdxMd() {
  return {
    disable: { null: ["autolink", "codeIndented", "htmlFlow", "htmlText"] }
  };
}
function splice(s, o, l, u) {
  const c = s.length;
  let m = 0, g;
  if (o < 0 ? o = -o > c ? 0 : c + o : o = o > c ? c : o, l = l > 0 ? l : 0, u.length < 1e4)
    g = Array.from(u), g.unshift(o, l), s.splice(...g);
  else
    for (l && s.splice(o, l); m < u.length; )
      g = u.slice(m, m + 1e4), g.unshift(o, 0), s.splice(...g), m += 1e4, o += 1e4;
}
function push(s, o) {
  return s.length > 0 ? (splice(s, s.length, 0, o), s) : o;
}
function classifyCharacter(s) {
  if (s === null || markdownLineEndingOrSpace(s) || unicodeWhitespace(s))
    return 1;
  if (unicodePunctuation(s))
    return 2;
}
function resolveAll(s, o, l) {
  const u = [];
  let c = -1;
  for (; ++c < s.length; ) {
    const m = s[c].resolveAll;
    m && !u.includes(m) && (o = m(o, l), u.push(m));
  }
  return o;
}
const attention = {
  name: "attention",
  tokenize: tokenizeAttention,
  resolveAll: resolveAllAttention
};
function resolveAllAttention(s, o) {
  let l = -1, u, c, m, g, v, b, S, E;
  for (; ++l < s.length; )
    if (s[l][0] === "enter" && s[l][1].type === "attentionSequence" && s[l][1]._close) {
      for (u = l; u--; )
        if (s[u][0] === "exit" && s[u][1].type === "attentionSequence" && s[u][1]._open && // If the markers are the same:
        o.sliceSerialize(s[u][1]).charCodeAt(0) === o.sliceSerialize(s[l][1]).charCodeAt(0)) {
          if ((s[u][1]._close || s[l][1]._open) && (s[l][1].end.offset - s[l][1].start.offset) % 3 && !((s[u][1].end.offset - s[u][1].start.offset + s[l][1].end.offset - s[l][1].start.offset) % 3))
            continue;
          b = s[u][1].end.offset - s[u][1].start.offset > 1 && s[l][1].end.offset - s[l][1].start.offset > 1 ? 2 : 1;
          const P = Object.assign({}, s[u][1].end), T = Object.assign({}, s[l][1].start);
          movePoint(P, -b), movePoint(T, b), g = {
            type: b > 1 ? "strongSequence" : "emphasisSequence",
            start: P,
            end: Object.assign({}, s[u][1].end)
          }, v = {
            type: b > 1 ? "strongSequence" : "emphasisSequence",
            start: Object.assign({}, s[l][1].start),
            end: T
          }, m = {
            type: b > 1 ? "strongText" : "emphasisText",
            start: Object.assign({}, s[u][1].end),
            end: Object.assign({}, s[l][1].start)
          }, c = {
            type: b > 1 ? "strong" : "emphasis",
            start: Object.assign({}, g.start),
            end: Object.assign({}, v.end)
          }, s[u][1].end = Object.assign({}, g.start), s[l][1].start = Object.assign({}, v.end), S = [], s[u][1].end.offset - s[u][1].start.offset && (S = push(S, [["enter", s[u][1], o], ["exit", s[u][1], o]])), S = push(S, [["enter", c, o], ["enter", g, o], ["exit", g, o], ["enter", m, o]]), S = push(S, resolveAll(o.parser.constructs.insideSpan.null, s.slice(u + 1, l), o)), S = push(S, [["exit", m, o], ["enter", v, o], ["exit", v, o], ["exit", c, o]]), s[l][1].end.offset - s[l][1].start.offset ? (E = 2, S = push(S, [["enter", s[l][1], o], ["exit", s[l][1], o]])) : E = 0, splice(s, u - 1, l - u + 3, S), l = u + S.length - E - 2;
          break;
        }
    }
  for (l = -1; ++l < s.length; )
    s[l][1].type === "attentionSequence" && (s[l][1].type = "data");
  return s;
}
function tokenizeAttention(s, o) {
  const l = this.parser.constructs.attentionMarkers.null, u = this.previous, c = classifyCharacter(u);
  let m;
  return g;
  function g(b) {
    return m = b, s.enter("attentionSequence"), v(b);
  }
  function v(b) {
    if (b === m)
      return s.consume(b), v;
    const S = s.exit("attentionSequence"), E = classifyCharacter(b), P = !E || E === 2 && c || l.includes(b), T = !c || c === 2 && E || l.includes(u);
    return S._open = !!(m === 42 ? P : P && (c || !T)), S._close = !!(m === 42 ? T : T && (E || !P)), o(b);
  }
}
function movePoint(s, o) {
  s.column += o, s.offset += o, s._bufferIndex += o;
}
const autolink = {
  name: "autolink",
  tokenize: tokenizeAutolink
};
function tokenizeAutolink(s, o, l) {
  let u = 0;
  return c;
  function c(N) {
    return s.enter("autolink"), s.enter("autolinkMarker"), s.consume(N), s.exit("autolinkMarker"), s.enter("autolinkProtocol"), m;
  }
  function m(N) {
    return asciiAlpha(N) ? (s.consume(N), g) : N === 64 ? l(N) : S(N);
  }
  function g(N) {
    return N === 43 || N === 45 || N === 46 || asciiAlphanumeric(N) ? (u = 1, v(N)) : S(N);
  }
  function v(N) {
    return N === 58 ? (s.consume(N), u = 0, b) : (N === 43 || N === 45 || N === 46 || asciiAlphanumeric(N)) && u++ < 32 ? (s.consume(N), v) : (u = 0, S(N));
  }
  function b(N) {
    return N === 62 ? (s.exit("autolinkProtocol"), s.enter("autolinkMarker"), s.consume(N), s.exit("autolinkMarker"), s.exit("autolink"), o) : N === null || N === 32 || N === 60 || asciiControl(N) ? l(N) : (s.consume(N), b);
  }
  function S(N) {
    return N === 64 ? (s.consume(N), E) : asciiAtext(N) ? (s.consume(N), S) : l(N);
  }
  function E(N) {
    return asciiAlphanumeric(N) ? P(N) : l(N);
  }
  function P(N) {
    return N === 46 ? (s.consume(N), u = 0, E) : N === 62 ? (s.exit("autolinkProtocol").type = "autolinkEmail", s.enter("autolinkMarker"), s.consume(N), s.exit("autolinkMarker"), s.exit("autolink"), o) : T(N);
  }
  function T(N) {
    if ((N === 45 || asciiAlphanumeric(N)) && u++ < 63) {
      const O = N === 45 ? T : P;
      return s.consume(N), O;
    }
    return l(N);
  }
}
const blankLine = {
  tokenize: tokenizeBlankLine,
  partial: !0
};
function tokenizeBlankLine(s, o, l) {
  return u;
  function u(m) {
    return markdownSpace(m) ? factorySpace(s, c, "linePrefix")(m) : c(m);
  }
  function c(m) {
    return m === null || markdownLineEnding(m) ? o(m) : l(m);
  }
}
const blockQuote = {
  name: "blockQuote",
  tokenize: tokenizeBlockQuoteStart,
  continuation: {
    tokenize: tokenizeBlockQuoteContinuation
  },
  exit: exit$1
};
function tokenizeBlockQuoteStart(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    if (g === 62) {
      const v = u.containerState;
      return v.open || (s.enter("blockQuote", {
        _container: !0
      }), v.open = !0), s.enter("blockQuotePrefix"), s.enter("blockQuoteMarker"), s.consume(g), s.exit("blockQuoteMarker"), m;
    }
    return l(g);
  }
  function m(g) {
    return markdownSpace(g) ? (s.enter("blockQuotePrefixWhitespace"), s.consume(g), s.exit("blockQuotePrefixWhitespace"), s.exit("blockQuotePrefix"), o) : (s.exit("blockQuotePrefix"), o(g));
  }
}
function tokenizeBlockQuoteContinuation(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return markdownSpace(g) ? factorySpace(s, m, "linePrefix", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(g) : m(g);
  }
  function m(g) {
    return s.attempt(blockQuote, o, l)(g);
  }
}
function exit$1(s) {
  s.exit("blockQuote");
}
const characterEscape = {
  name: "characterEscape",
  tokenize: tokenizeCharacterEscape
};
function tokenizeCharacterEscape(s, o, l) {
  return u;
  function u(m) {
    return s.enter("characterEscape"), s.enter("escapeMarker"), s.consume(m), s.exit("escapeMarker"), c;
  }
  function c(m) {
    return asciiPunctuation(m) ? (s.enter("characterEscapeValue"), s.consume(m), s.exit("characterEscapeValue"), s.exit("characterEscape"), o) : l(m);
  }
}
const characterReference = {
  name: "characterReference",
  tokenize: tokenizeCharacterReference
};
function tokenizeCharacterReference(s, o, l) {
  const u = this;
  let c = 0, m, g;
  return v;
  function v(P) {
    return s.enter("characterReference"), s.enter("characterReferenceMarker"), s.consume(P), s.exit("characterReferenceMarker"), b;
  }
  function b(P) {
    return P === 35 ? (s.enter("characterReferenceMarkerNumeric"), s.consume(P), s.exit("characterReferenceMarkerNumeric"), S) : (s.enter("characterReferenceValue"), m = 31, g = asciiAlphanumeric, E(P));
  }
  function S(P) {
    return P === 88 || P === 120 ? (s.enter("characterReferenceMarkerHexadecimal"), s.consume(P), s.exit("characterReferenceMarkerHexadecimal"), s.enter("characterReferenceValue"), m = 6, g = asciiHexDigit, E) : (s.enter("characterReferenceValue"), m = 7, g = asciiDigit, E(P));
  }
  function E(P) {
    if (P === 59 && c) {
      const T = s.exit("characterReferenceValue");
      return g === asciiAlphanumeric && !decodeNamedCharacterReference(u.sliceSerialize(T)) ? l(P) : (s.enter("characterReferenceMarker"), s.consume(P), s.exit("characterReferenceMarker"), s.exit("characterReference"), o);
    }
    return g(P) && c++ < m ? (s.consume(P), E) : l(P);
  }
}
const nonLazyContinuation = {
  tokenize: tokenizeNonLazyContinuation,
  partial: !0
}, codeFenced = {
  name: "codeFenced",
  tokenize: tokenizeCodeFenced,
  concrete: !0
};
function tokenizeCodeFenced(s, o, l) {
  const u = this, c = {
    tokenize: ve,
    partial: !0
  };
  let m = 0, g = 0, v;
  return b;
  function b(ee) {
    return S(ee);
  }
  function S(ee) {
    const Re = u.events[u.events.length - 1];
    return m = Re && Re[1].type === "linePrefix" ? Re[2].sliceSerialize(Re[1], !0).length : 0, v = ee, s.enter("codeFenced"), s.enter("codeFencedFence"), s.enter("codeFencedFenceSequence"), E(ee);
  }
  function E(ee) {
    return ee === v ? (g++, s.consume(ee), E) : g < 3 ? l(ee) : (s.exit("codeFencedFenceSequence"), markdownSpace(ee) ? factorySpace(s, P, "whitespace")(ee) : P(ee));
  }
  function P(ee) {
    return ee === null || markdownLineEnding(ee) ? (s.exit("codeFencedFence"), u.interrupt ? o(ee) : s.check(nonLazyContinuation, z, K)(ee)) : (s.enter("codeFencedFenceInfo"), s.enter("chunkString", {
      contentType: "string"
    }), T(ee));
  }
  function T(ee) {
    return ee === null || markdownLineEnding(ee) ? (s.exit("chunkString"), s.exit("codeFencedFenceInfo"), P(ee)) : markdownSpace(ee) ? (s.exit("chunkString"), s.exit("codeFencedFenceInfo"), factorySpace(s, N, "whitespace")(ee)) : ee === 96 && ee === v ? l(ee) : (s.consume(ee), T);
  }
  function N(ee) {
    return ee === null || markdownLineEnding(ee) ? P(ee) : (s.enter("codeFencedFenceMeta"), s.enter("chunkString", {
      contentType: "string"
    }), O(ee));
  }
  function O(ee) {
    return ee === null || markdownLineEnding(ee) ? (s.exit("chunkString"), s.exit("codeFencedFenceMeta"), P(ee)) : ee === 96 && ee === v ? l(ee) : (s.consume(ee), O);
  }
  function z(ee) {
    return s.attempt(c, K, Q)(ee);
  }
  function Q(ee) {
    return s.enter("lineEnding"), s.consume(ee), s.exit("lineEnding"), W;
  }
  function W(ee) {
    return m > 0 && markdownSpace(ee) ? factorySpace(s, ue, "linePrefix", m + 1)(ee) : ue(ee);
  }
  function ue(ee) {
    return ee === null || markdownLineEnding(ee) ? s.check(nonLazyContinuation, z, K)(ee) : (s.enter("codeFlowValue"), te(ee));
  }
  function te(ee) {
    return ee === null || markdownLineEnding(ee) ? (s.exit("codeFlowValue"), ue(ee)) : (s.consume(ee), te);
  }
  function K(ee) {
    return s.exit("codeFenced"), o(ee);
  }
  function ve(ee, Re, wt) {
    let yt = 0;
    return xt;
    function xt(an) {
      return ee.enter("lineEnding"), ee.consume(an), ee.exit("lineEnding"), Kt;
    }
    function Kt(an) {
      return ee.enter("codeFencedFence"), markdownSpace(an) ? factorySpace(ee, tn, "linePrefix", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(an) : tn(an);
    }
    function tn(an) {
      return an === v ? (ee.enter("codeFencedFenceSequence"), ln(an)) : wt(an);
    }
    function ln(an) {
      return an === v ? (yt++, ee.consume(an), ln) : yt >= g ? (ee.exit("codeFencedFenceSequence"), markdownSpace(an) ? factorySpace(ee, rn, "whitespace")(an) : rn(an)) : wt(an);
    }
    function rn(an) {
      return an === null || markdownLineEnding(an) ? (ee.exit("codeFencedFence"), Re(an)) : wt(an);
    }
  }
}
function tokenizeNonLazyContinuation(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return g === null ? l(g) : (s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), m);
  }
  function m(g) {
    return u.parser.lazy[u.now().line] ? l(g) : o(g);
  }
}
const codeIndented = {
  name: "codeIndented",
  tokenize: tokenizeCodeIndented
}, furtherStart = {
  tokenize: tokenizeFurtherStart,
  partial: !0
};
function tokenizeCodeIndented(s, o, l) {
  const u = this;
  return c;
  function c(S) {
    return s.enter("codeIndented"), factorySpace(s, m, "linePrefix", 5)(S);
  }
  function m(S) {
    const E = u.events[u.events.length - 1];
    return E && E[1].type === "linePrefix" && E[2].sliceSerialize(E[1], !0).length >= 4 ? g(S) : l(S);
  }
  function g(S) {
    return S === null ? b(S) : markdownLineEnding(S) ? s.attempt(furtherStart, g, b)(S) : (s.enter("codeFlowValue"), v(S));
  }
  function v(S) {
    return S === null || markdownLineEnding(S) ? (s.exit("codeFlowValue"), g(S)) : (s.consume(S), v);
  }
  function b(S) {
    return s.exit("codeIndented"), o(S);
  }
}
function tokenizeFurtherStart(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return u.parser.lazy[u.now().line] ? l(g) : markdownLineEnding(g) ? (s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), c) : factorySpace(s, m, "linePrefix", 5)(g);
  }
  function m(g) {
    const v = u.events[u.events.length - 1];
    return v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? o(g) : markdownLineEnding(g) ? c(g) : l(g);
  }
}
const codeText = {
  name: "codeText",
  tokenize: tokenizeCodeText,
  resolve: resolveCodeText,
  previous: previous$1
};
function resolveCodeText(s) {
  let o = s.length - 4, l = 3, u, c;
  if ((s[l][1].type === "lineEnding" || s[l][1].type === "space") && (s[o][1].type === "lineEnding" || s[o][1].type === "space")) {
    for (u = l; ++u < o; )
      if (s[u][1].type === "codeTextData") {
        s[l][1].type = "codeTextPadding", s[o][1].type = "codeTextPadding", l += 2, o -= 2;
        break;
      }
  }
  for (u = l - 1, o++; ++u <= o; )
    c === void 0 ? u !== o && s[u][1].type !== "lineEnding" && (c = u) : (u === o || s[u][1].type === "lineEnding") && (s[c][1].type = "codeTextData", u !== c + 2 && (s[c][1].end = s[u - 1][1].end, s.splice(c + 2, u - c - 2), o -= u - c - 2, u = c + 2), c = void 0);
  return s;
}
function previous$1(s) {
  return s !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
}
function tokenizeCodeText(s, o, l) {
  let u = 0, c, m;
  return g;
  function g(P) {
    return s.enter("codeText"), s.enter("codeTextSequence"), v(P);
  }
  function v(P) {
    return P === 96 ? (s.consume(P), u++, v) : (s.exit("codeTextSequence"), b(P));
  }
  function b(P) {
    return P === null ? l(P) : P === 32 ? (s.enter("space"), s.consume(P), s.exit("space"), b) : P === 96 ? (m = s.enter("codeTextSequence"), c = 0, E(P)) : markdownLineEnding(P) ? (s.enter("lineEnding"), s.consume(P), s.exit("lineEnding"), b) : (s.enter("codeTextData"), S(P));
  }
  function S(P) {
    return P === null || P === 32 || P === 96 || markdownLineEnding(P) ? (s.exit("codeTextData"), b(P)) : (s.consume(P), S);
  }
  function E(P) {
    return P === 96 ? (s.consume(P), c++, E) : c === u ? (s.exit("codeTextSequence"), s.exit("codeText"), o(P)) : (m.type = "codeTextData", S(P));
  }
}
class SpliceBuffer {
  /**
   * @param {ReadonlyArray<T> | null | undefined} [initial]
   *   Initial items (optional).
   * @returns
   *   Splice buffer.
   */
  constructor(o) {
    this.left = o ? [...o] : [], this.right = [];
  }
  /**
   * Array access;
   * does not move the cursor.
   *
   * @param {number} index
   *   Index.
   * @return {T}
   *   Item.
   */
  get(o) {
    if (o < 0 || o >= this.left.length + this.right.length)
      throw new RangeError("Cannot access index `" + o + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`");
    return o < this.left.length ? this.left[o] : this.right[this.right.length - o + this.left.length - 1];
  }
  /**
   * The length of the splice buffer, one greater than the largest index in the
   * array.
   */
  get length() {
    return this.left.length + this.right.length;
  }
  /**
   * Remove and return `list[0]`;
   * moves the cursor to `0`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  shift() {
    return this.setCursor(0), this.right.pop();
  }
  /**
   * Slice the buffer to get an array;
   * does not move the cursor.
   *
   * @param {number} start
   *   Start.
   * @param {number | null | undefined} [end]
   *   End (optional).
   * @returns {Array<T>}
   *   Array of items.
   */
  slice(o, l) {
    const u = l ?? Number.POSITIVE_INFINITY;
    return u < this.left.length ? this.left.slice(o, u) : o > this.left.length ? this.right.slice(this.right.length - u + this.left.length, this.right.length - o + this.left.length).reverse() : this.left.slice(o).concat(this.right.slice(this.right.length - u + this.left.length).reverse());
  }
  /**
   * Mimics the behavior of Array.prototype.splice() except for the change of
   * interface necessary to avoid segfaults when patching in very large arrays.
   *
   * This operation moves cursor is moved to `start` and results in the cursor
   * placed after any inserted items.
   *
   * @param {number} start
   *   Start;
   *   zero-based index at which to start changing the array;
   *   negative numbers count backwards from the end of the array and values
   *   that are out-of bounds are clamped to the appropriate end of the array.
   * @param {number | null | undefined} [deleteCount=0]
   *   Delete count (default: `0`);
   *   maximum number of elements to delete, starting from start.
   * @param {Array<T> | null | undefined} [items=[]]
   *   Items to include in place of the deleted items (default: `[]`).
   * @return {Array<T>}
   *   Any removed items.
   */
  splice(o, l, u) {
    const c = l || 0;
    this.setCursor(Math.trunc(o));
    const m = this.right.splice(this.right.length - c, Number.POSITIVE_INFINITY);
    return u && chunkedPush(this.left, u), m.reverse();
  }
  /**
   * Remove and return the highest-numbered item in the array, so
   * `list[list.length - 1]`;
   * Moves the cursor to `length`.
   *
   * @returns {T | undefined}
   *   Item, optional.
   */
  pop() {
    return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop();
  }
  /**
   * Inserts a single item to the high-numbered side of the array;
   * moves the cursor to `length`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  push(o) {
    this.setCursor(Number.POSITIVE_INFINITY), this.left.push(o);
  }
  /**
   * Inserts many items to the high-numbered side of the array.
   * Moves the cursor to `length`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  pushMany(o) {
    this.setCursor(Number.POSITIVE_INFINITY), chunkedPush(this.left, o);
  }
  /**
   * Inserts a single item to the low-numbered side of the array;
   * Moves the cursor to `0`.
   *
   * @param {T} item
   *   Item.
   * @returns {undefined}
   *   Nothing.
   */
  unshift(o) {
    this.setCursor(0), this.right.push(o);
  }
  /**
   * Inserts many items to the low-numbered side of the array;
   * moves the cursor to `0`.
   *
   * @param {Array<T>} items
   *   Items.
   * @returns {undefined}
   *   Nothing.
   */
  unshiftMany(o) {
    this.setCursor(0), chunkedPush(this.right, o.reverse());
  }
  /**
   * Move the cursor to a specific position in the array. Requires
   * time proportional to the distance moved.
   *
   * If `n < 0`, the cursor will end up at the beginning.
   * If `n > length`, the cursor will end up at the end.
   *
   * @param {number} n
   *   Position.
   * @return {undefined}
   *   Nothing.
   */
  setCursor(o) {
    if (!(o === this.left.length || o > this.left.length && this.right.length === 0 || o < 0 && this.left.length === 0))
      if (o < this.left.length) {
        const l = this.left.splice(o, Number.POSITIVE_INFINITY);
        chunkedPush(this.right, l.reverse());
      } else {
        const l = this.right.splice(this.left.length + this.right.length - o, Number.POSITIVE_INFINITY);
        chunkedPush(this.left, l.reverse());
      }
  }
}
function chunkedPush(s, o) {
  let l = 0;
  if (o.length < 1e4)
    s.push(...o);
  else
    for (; l < o.length; )
      s.push(...o.slice(l, l + 1e4)), l += 1e4;
}
function subtokenize(s) {
  const o = {};
  let l = -1, u, c, m, g, v, b, S;
  const E = new SpliceBuffer(s);
  for (; ++l < E.length; ) {
    for (; l in o; )
      l = o[l];
    if (u = E.get(l), l && u[1].type === "chunkFlow" && E.get(l - 1)[1].type === "listItemPrefix" && (b = u[1]._tokenizer.events, m = 0, m < b.length && b[m][1].type === "lineEndingBlank" && (m += 2), m < b.length && b[m][1].type === "content"))
      for (; ++m < b.length && b[m][1].type !== "content"; )
        b[m][1].type === "chunkText" && (b[m][1]._isInFirstContentOfListItem = !0, m++);
    if (u[0] === "enter")
      u[1].contentType && (Object.assign(o, subcontent(E, l)), l = o[l], S = !0);
    else if (u[1]._container) {
      for (m = l, c = void 0; m-- && (g = E.get(m), g[1].type === "lineEnding" || g[1].type === "lineEndingBlank"); )
        g[0] === "enter" && (c && (E.get(c)[1].type = "lineEndingBlank"), g[1].type = "lineEnding", c = m);
      c && (u[1].end = Object.assign({}, E.get(c)[1].start), v = E.slice(c, l), v.unshift(u), E.splice(c, l - c + 1, v));
    }
  }
  return splice(s, 0, Number.POSITIVE_INFINITY, E.slice(0)), !S;
}
function subcontent(s, o) {
  const l = s.get(o)[1], u = s.get(o)[2];
  let c = o - 1;
  const m = [], g = l._tokenizer || u.parser[l.contentType](l.start), v = g.events, b = [], S = {};
  let E, P, T = -1, N = l, O = 0, z = 0;
  const Q = [z];
  for (; N; ) {
    for (; s.get(++c)[1] !== N; )
      ;
    m.push(c), N._tokenizer || (E = u.sliceStream(N), N.next || E.push(null), P && g.defineSkip(N.start), N._isInFirstContentOfListItem && (g._gfmTasklistFirstContentOfListItem = !0), g.write(E), N._isInFirstContentOfListItem && (g._gfmTasklistFirstContentOfListItem = void 0)), P = N, N = N.next;
  }
  for (N = l; ++T < v.length; )
    // Find a void token that includes a break.
    v[T][0] === "exit" && v[T - 1][0] === "enter" && v[T][1].type === v[T - 1][1].type && v[T][1].start.line !== v[T][1].end.line && (z = T + 1, Q.push(z), N._tokenizer = void 0, N.previous = void 0, N = N.next);
  for (g.events = [], N ? (N._tokenizer = void 0, N.previous = void 0) : Q.pop(), T = Q.length; T--; ) {
    const W = v.slice(Q[T], Q[T + 1]), ue = m.pop();
    b.push([ue, ue + W.length - 1]), s.splice(ue, 2, W);
  }
  for (b.reverse(), T = -1; ++T < b.length; )
    S[O + b[T][0]] = O + b[T][1], O += b[T][1] - b[T][0] - 1;
  return S;
}
const content$1 = {
  tokenize: tokenizeContent,
  resolve: resolveContent
}, continuationConstruct = {
  tokenize: tokenizeContinuation,
  partial: !0
};
function resolveContent(s) {
  return subtokenize(s), s;
}
function tokenizeContent(s, o) {
  let l;
  return u;
  function u(v) {
    return s.enter("content"), l = s.enter("chunkContent", {
      contentType: "content"
    }), c(v);
  }
  function c(v) {
    return v === null ? m(v) : markdownLineEnding(v) ? s.check(continuationConstruct, g, m)(v) : (s.consume(v), c);
  }
  function m(v) {
    return s.exit("chunkContent"), s.exit("content"), o(v);
  }
  function g(v) {
    return s.consume(v), s.exit("chunkContent"), l.next = s.enter("chunkContent", {
      contentType: "content",
      previous: l
    }), l = l.next, c;
  }
}
function tokenizeContinuation(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return s.exit("chunkContent"), s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), factorySpace(s, m, "linePrefix");
  }
  function m(g) {
    if (g === null || markdownLineEnding(g))
      return l(g);
    const v = u.events[u.events.length - 1];
    return !u.parser.constructs.disable.null.includes("codeIndented") && v && v[1].type === "linePrefix" && v[2].sliceSerialize(v[1], !0).length >= 4 ? o(g) : s.interrupt(u.parser.constructs.flow, l, o)(g);
  }
}
function factoryDestination(s, o, l, u, c, m, g, v, b) {
  const S = b || Number.POSITIVE_INFINITY;
  let E = 0;
  return P;
  function P(W) {
    return W === 60 ? (s.enter(u), s.enter(c), s.enter(m), s.consume(W), s.exit(m), T) : W === null || W === 32 || W === 41 || asciiControl(W) ? l(W) : (s.enter(u), s.enter(g), s.enter(v), s.enter("chunkString", {
      contentType: "string"
    }), z(W));
  }
  function T(W) {
    return W === 62 ? (s.enter(m), s.consume(W), s.exit(m), s.exit(c), s.exit(u), o) : (s.enter(v), s.enter("chunkString", {
      contentType: "string"
    }), N(W));
  }
  function N(W) {
    return W === 62 ? (s.exit("chunkString"), s.exit(v), T(W)) : W === null || W === 60 || markdownLineEnding(W) ? l(W) : (s.consume(W), W === 92 ? O : N);
  }
  function O(W) {
    return W === 60 || W === 62 || W === 92 ? (s.consume(W), N) : N(W);
  }
  function z(W) {
    return !E && (W === null || W === 41 || markdownLineEndingOrSpace(W)) ? (s.exit("chunkString"), s.exit(v), s.exit(g), s.exit(u), o(W)) : E < S && W === 40 ? (s.consume(W), E++, z) : W === 41 ? (s.consume(W), E--, z) : W === null || W === 32 || W === 40 || asciiControl(W) ? l(W) : (s.consume(W), W === 92 ? Q : z);
  }
  function Q(W) {
    return W === 40 || W === 41 || W === 92 ? (s.consume(W), z) : z(W);
  }
}
function factoryLabel(s, o, l, u, c, m) {
  const g = this;
  let v = 0, b;
  return S;
  function S(N) {
    return s.enter(u), s.enter(c), s.consume(N), s.exit(c), s.enter(m), E;
  }
  function E(N) {
    return v > 999 || N === null || N === 91 || N === 93 && !b || // To do: remove in the future once we’ve switched from
    // `micromark-extension-footnote` to `micromark-extension-gfm-footnote`,
    // which doesn’t need this.
    // Hidden footnotes hook.
    /* c8 ignore next 3 */
    N === 94 && !v && "_hiddenFootnoteSupport" in g.parser.constructs ? l(N) : N === 93 ? (s.exit(m), s.enter(c), s.consume(N), s.exit(c), s.exit(u), o) : markdownLineEnding(N) ? (s.enter("lineEnding"), s.consume(N), s.exit("lineEnding"), E) : (s.enter("chunkString", {
      contentType: "string"
    }), P(N));
  }
  function P(N) {
    return N === null || N === 91 || N === 93 || markdownLineEnding(N) || v++ > 999 ? (s.exit("chunkString"), E(N)) : (s.consume(N), b || (b = !markdownSpace(N)), N === 92 ? T : P);
  }
  function T(N) {
    return N === 91 || N === 92 || N === 93 ? (s.consume(N), v++, P) : P(N);
  }
}
function factoryTitle(s, o, l, u, c, m) {
  let g;
  return v;
  function v(T) {
    return T === 34 || T === 39 || T === 40 ? (s.enter(u), s.enter(c), s.consume(T), s.exit(c), g = T === 40 ? 41 : T, b) : l(T);
  }
  function b(T) {
    return T === g ? (s.enter(c), s.consume(T), s.exit(c), s.exit(u), o) : (s.enter(m), S(T));
  }
  function S(T) {
    return T === g ? (s.exit(m), b(g)) : T === null ? l(T) : markdownLineEnding(T) ? (s.enter("lineEnding"), s.consume(T), s.exit("lineEnding"), factorySpace(s, S, "linePrefix")) : (s.enter("chunkString", {
      contentType: "string"
    }), E(T));
  }
  function E(T) {
    return T === g || T === null || markdownLineEnding(T) ? (s.exit("chunkString"), S(T)) : (s.consume(T), T === 92 ? P : E);
  }
  function P(T) {
    return T === g || T === 92 ? (s.consume(T), E) : E(T);
  }
}
function factoryWhitespace(s, o) {
  let l;
  return u;
  function u(c) {
    return markdownLineEnding(c) ? (s.enter("lineEnding"), s.consume(c), s.exit("lineEnding"), l = !0, u) : markdownSpace(c) ? factorySpace(
      s,
      u,
      l ? "linePrefix" : "lineSuffix"
    )(c) : o(c);
  }
}
function normalizeIdentifier(s) {
  return s.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
}
const definition$1 = {
  name: "definition",
  tokenize: tokenizeDefinition
}, titleBefore = {
  tokenize: tokenizeTitleBefore,
  partial: !0
};
function tokenizeDefinition(s, o, l) {
  const u = this;
  let c;
  return m;
  function m(N) {
    return s.enter("definition"), g(N);
  }
  function g(N) {
    return factoryLabel.call(
      u,
      s,
      v,
      // Note: we don’t need to reset the way `markdown-rs` does.
      l,
      "definitionLabel",
      "definitionLabelMarker",
      "definitionLabelString"
    )(N);
  }
  function v(N) {
    return c = normalizeIdentifier(u.sliceSerialize(u.events[u.events.length - 1][1]).slice(1, -1)), N === 58 ? (s.enter("definitionMarker"), s.consume(N), s.exit("definitionMarker"), b) : l(N);
  }
  function b(N) {
    return markdownLineEndingOrSpace(N) ? factoryWhitespace(s, S)(N) : S(N);
  }
  function S(N) {
    return factoryDestination(
      s,
      E,
      // Note: we don’t need to reset the way `markdown-rs` does.
      l,
      "definitionDestination",
      "definitionDestinationLiteral",
      "definitionDestinationLiteralMarker",
      "definitionDestinationRaw",
      "definitionDestinationString"
    )(N);
  }
  function E(N) {
    return s.attempt(titleBefore, P, P)(N);
  }
  function P(N) {
    return markdownSpace(N) ? factorySpace(s, T, "whitespace")(N) : T(N);
  }
  function T(N) {
    return N === null || markdownLineEnding(N) ? (s.exit("definition"), u.parser.defined.push(c), o(N)) : l(N);
  }
}
function tokenizeTitleBefore(s, o, l) {
  return u;
  function u(v) {
    return markdownLineEndingOrSpace(v) ? factoryWhitespace(s, c)(v) : l(v);
  }
  function c(v) {
    return factoryTitle(s, m, l, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(v);
  }
  function m(v) {
    return markdownSpace(v) ? factorySpace(s, g, "whitespace")(v) : g(v);
  }
  function g(v) {
    return v === null || markdownLineEnding(v) ? o(v) : l(v);
  }
}
const hardBreakEscape = {
  name: "hardBreakEscape",
  tokenize: tokenizeHardBreakEscape
};
function tokenizeHardBreakEscape(s, o, l) {
  return u;
  function u(m) {
    return s.enter("hardBreakEscape"), s.consume(m), c;
  }
  function c(m) {
    return markdownLineEnding(m) ? (s.exit("hardBreakEscape"), o(m)) : l(m);
  }
}
const headingAtx = {
  name: "headingAtx",
  tokenize: tokenizeHeadingAtx,
  resolve: resolveHeadingAtx
};
function resolveHeadingAtx(s, o) {
  let l = s.length - 2, u = 3, c, m;
  return s[u][1].type === "whitespace" && (u += 2), l - 2 > u && s[l][1].type === "whitespace" && (l -= 2), s[l][1].type === "atxHeadingSequence" && (u === l - 1 || l - 4 > u && s[l - 2][1].type === "whitespace") && (l -= u + 1 === l ? 2 : 4), l > u && (c = {
    type: "atxHeadingText",
    start: s[u][1].start,
    end: s[l][1].end
  }, m = {
    type: "chunkText",
    start: s[u][1].start,
    end: s[l][1].end,
    contentType: "text"
  }, splice(s, u, l - u + 1, [["enter", c, o], ["enter", m, o], ["exit", m, o], ["exit", c, o]])), s;
}
function tokenizeHeadingAtx(s, o, l) {
  let u = 0;
  return c;
  function c(E) {
    return s.enter("atxHeading"), m(E);
  }
  function m(E) {
    return s.enter("atxHeadingSequence"), g(E);
  }
  function g(E) {
    return E === 35 && u++ < 6 ? (s.consume(E), g) : E === null || markdownLineEndingOrSpace(E) ? (s.exit("atxHeadingSequence"), v(E)) : l(E);
  }
  function v(E) {
    return E === 35 ? (s.enter("atxHeadingSequence"), b(E)) : E === null || markdownLineEnding(E) ? (s.exit("atxHeading"), o(E)) : markdownSpace(E) ? factorySpace(s, v, "whitespace")(E) : (s.enter("atxHeadingText"), S(E));
  }
  function b(E) {
    return E === 35 ? (s.consume(E), b) : (s.exit("atxHeadingSequence"), v(E));
  }
  function S(E) {
    return E === null || E === 35 || markdownLineEndingOrSpace(E) ? (s.exit("atxHeadingText"), v(E)) : (s.consume(E), S);
  }
}
const htmlBlockNames = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "search",
  "section",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
], htmlRawNames = ["pre", "script", "style", "textarea"], htmlFlow = {
  name: "htmlFlow",
  tokenize: tokenizeHtmlFlow,
  resolveTo: resolveToHtmlFlow,
  concrete: !0
}, blankLineBefore$1 = {
  tokenize: tokenizeBlankLineBefore,
  partial: !0
}, nonLazyContinuationStart = {
  tokenize: tokenizeNonLazyContinuationStart,
  partial: !0
};
function resolveToHtmlFlow(s) {
  let o = s.length;
  for (; o-- && !(s[o][0] === "enter" && s[o][1].type === "htmlFlow"); )
    ;
  return o > 1 && s[o - 2][1].type === "linePrefix" && (s[o][1].start = s[o - 2][1].start, s[o + 1][1].start = s[o - 2][1].start, s.splice(o - 2, 2)), s;
}
function tokenizeHtmlFlow(s, o, l) {
  const u = this;
  let c, m, g, v, b;
  return S;
  function S(dn) {
    return E(dn);
  }
  function E(dn) {
    return s.enter("htmlFlow"), s.enter("htmlFlowData"), s.consume(dn), P;
  }
  function P(dn) {
    return dn === 33 ? (s.consume(dn), T) : dn === 47 ? (s.consume(dn), m = !0, z) : dn === 63 ? (s.consume(dn), c = 3, u.interrupt ? o : Qt) : asciiAlpha(dn) ? (s.consume(dn), g = String.fromCharCode(dn), Q) : l(dn);
  }
  function T(dn) {
    return dn === 45 ? (s.consume(dn), c = 2, N) : dn === 91 ? (s.consume(dn), c = 5, v = 0, O) : asciiAlpha(dn) ? (s.consume(dn), c = 4, u.interrupt ? o : Qt) : l(dn);
  }
  function N(dn) {
    return dn === 45 ? (s.consume(dn), u.interrupt ? o : Qt) : l(dn);
  }
  function O(dn) {
    const yn = "CDATA[";
    return dn === yn.charCodeAt(v++) ? (s.consume(dn), v === yn.length ? u.interrupt ? o : tn : O) : l(dn);
  }
  function z(dn) {
    return asciiAlpha(dn) ? (s.consume(dn), g = String.fromCharCode(dn), Q) : l(dn);
  }
  function Q(dn) {
    if (dn === null || dn === 47 || dn === 62 || markdownLineEndingOrSpace(dn)) {
      const yn = dn === 47, vn = g.toLowerCase();
      return !yn && !m && htmlRawNames.includes(vn) ? (c = 1, u.interrupt ? o(dn) : tn(dn)) : htmlBlockNames.includes(g.toLowerCase()) ? (c = 6, yn ? (s.consume(dn), W) : u.interrupt ? o(dn) : tn(dn)) : (c = 7, u.interrupt && !u.parser.lazy[u.now().line] ? l(dn) : m ? ue(dn) : te(dn));
    }
    return dn === 45 || asciiAlphanumeric(dn) ? (s.consume(dn), g += String.fromCharCode(dn), Q) : l(dn);
  }
  function W(dn) {
    return dn === 62 ? (s.consume(dn), u.interrupt ? o : tn) : l(dn);
  }
  function ue(dn) {
    return markdownSpace(dn) ? (s.consume(dn), ue) : xt(dn);
  }
  function te(dn) {
    return dn === 47 ? (s.consume(dn), xt) : dn === 58 || dn === 95 || asciiAlpha(dn) ? (s.consume(dn), K) : markdownSpace(dn) ? (s.consume(dn), te) : xt(dn);
  }
  function K(dn) {
    return dn === 45 || dn === 46 || dn === 58 || dn === 95 || asciiAlphanumeric(dn) ? (s.consume(dn), K) : ve(dn);
  }
  function ve(dn) {
    return dn === 61 ? (s.consume(dn), ee) : markdownSpace(dn) ? (s.consume(dn), ve) : te(dn);
  }
  function ee(dn) {
    return dn === null || dn === 60 || dn === 61 || dn === 62 || dn === 96 ? l(dn) : dn === 34 || dn === 39 ? (s.consume(dn), b = dn, Re) : markdownSpace(dn) ? (s.consume(dn), ee) : wt(dn);
  }
  function Re(dn) {
    return dn === b ? (s.consume(dn), b = null, yt) : dn === null || markdownLineEnding(dn) ? l(dn) : (s.consume(dn), Re);
  }
  function wt(dn) {
    return dn === null || dn === 34 || dn === 39 || dn === 47 || dn === 60 || dn === 61 || dn === 62 || dn === 96 || markdownLineEndingOrSpace(dn) ? ve(dn) : (s.consume(dn), wt);
  }
  function yt(dn) {
    return dn === 47 || dn === 62 || markdownSpace(dn) ? te(dn) : l(dn);
  }
  function xt(dn) {
    return dn === 62 ? (s.consume(dn), Kt) : l(dn);
  }
  function Kt(dn) {
    return dn === null || markdownLineEnding(dn) ? tn(dn) : markdownSpace(dn) ? (s.consume(dn), Kt) : l(dn);
  }
  function tn(dn) {
    return dn === 45 && c === 2 ? (s.consume(dn), Gt) : dn === 60 && c === 1 ? (s.consume(dn), nn) : dn === 62 && c === 4 ? (s.consume(dn), un) : dn === 63 && c === 3 ? (s.consume(dn), Qt) : dn === 93 && c === 5 ? (s.consume(dn), Et) : markdownLineEnding(dn) && (c === 6 || c === 7) ? (s.exit("htmlFlowData"), s.check(blankLineBefore$1, gn, ln)(dn)) : dn === null || markdownLineEnding(dn) ? (s.exit("htmlFlowData"), ln(dn)) : (s.consume(dn), tn);
  }
  function ln(dn) {
    return s.check(nonLazyContinuationStart, rn, gn)(dn);
  }
  function rn(dn) {
    return s.enter("lineEnding"), s.consume(dn), s.exit("lineEnding"), an;
  }
  function an(dn) {
    return dn === null || markdownLineEnding(dn) ? ln(dn) : (s.enter("htmlFlowData"), tn(dn));
  }
  function Gt(dn) {
    return dn === 45 ? (s.consume(dn), Qt) : tn(dn);
  }
  function nn(dn) {
    return dn === 47 ? (s.consume(dn), g = "", vt) : tn(dn);
  }
  function vt(dn) {
    if (dn === 62) {
      const yn = g.toLowerCase();
      return htmlRawNames.includes(yn) ? (s.consume(dn), un) : tn(dn);
    }
    return asciiAlpha(dn) && g.length < 8 ? (s.consume(dn), g += String.fromCharCode(dn), vt) : tn(dn);
  }
  function Et(dn) {
    return dn === 93 ? (s.consume(dn), Qt) : tn(dn);
  }
  function Qt(dn) {
    return dn === 62 ? (s.consume(dn), un) : dn === 45 && c === 2 ? (s.consume(dn), Qt) : tn(dn);
  }
  function un(dn) {
    return dn === null || markdownLineEnding(dn) ? (s.exit("htmlFlowData"), gn(dn)) : (s.consume(dn), un);
  }
  function gn(dn) {
    return s.exit("htmlFlow"), o(dn);
  }
}
function tokenizeNonLazyContinuationStart(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return markdownLineEnding(g) ? (s.enter("lineEnding"), s.consume(g), s.exit("lineEnding"), m) : l(g);
  }
  function m(g) {
    return u.parser.lazy[u.now().line] ? l(g) : o(g);
  }
}
function tokenizeBlankLineBefore(s, o, l) {
  return u;
  function u(c) {
    return s.enter("lineEnding"), s.consume(c), s.exit("lineEnding"), s.attempt(blankLine, o, l);
  }
}
const htmlText = {
  name: "htmlText",
  tokenize: tokenizeHtmlText
};
function tokenizeHtmlText(s, o, l) {
  const u = this;
  let c, m, g;
  return v;
  function v(Qt) {
    return s.enter("htmlText"), s.enter("htmlTextData"), s.consume(Qt), b;
  }
  function b(Qt) {
    return Qt === 33 ? (s.consume(Qt), S) : Qt === 47 ? (s.consume(Qt), ve) : Qt === 63 ? (s.consume(Qt), te) : asciiAlpha(Qt) ? (s.consume(Qt), wt) : l(Qt);
  }
  function S(Qt) {
    return Qt === 45 ? (s.consume(Qt), E) : Qt === 91 ? (s.consume(Qt), m = 0, O) : asciiAlpha(Qt) ? (s.consume(Qt), ue) : l(Qt);
  }
  function E(Qt) {
    return Qt === 45 ? (s.consume(Qt), N) : l(Qt);
  }
  function P(Qt) {
    return Qt === null ? l(Qt) : Qt === 45 ? (s.consume(Qt), T) : markdownLineEnding(Qt) ? (g = P, nn(Qt)) : (s.consume(Qt), P);
  }
  function T(Qt) {
    return Qt === 45 ? (s.consume(Qt), N) : P(Qt);
  }
  function N(Qt) {
    return Qt === 62 ? Gt(Qt) : Qt === 45 ? T(Qt) : P(Qt);
  }
  function O(Qt) {
    const un = "CDATA[";
    return Qt === un.charCodeAt(m++) ? (s.consume(Qt), m === un.length ? z : O) : l(Qt);
  }
  function z(Qt) {
    return Qt === null ? l(Qt) : Qt === 93 ? (s.consume(Qt), Q) : markdownLineEnding(Qt) ? (g = z, nn(Qt)) : (s.consume(Qt), z);
  }
  function Q(Qt) {
    return Qt === 93 ? (s.consume(Qt), W) : z(Qt);
  }
  function W(Qt) {
    return Qt === 62 ? Gt(Qt) : Qt === 93 ? (s.consume(Qt), W) : z(Qt);
  }
  function ue(Qt) {
    return Qt === null || Qt === 62 ? Gt(Qt) : markdownLineEnding(Qt) ? (g = ue, nn(Qt)) : (s.consume(Qt), ue);
  }
  function te(Qt) {
    return Qt === null ? l(Qt) : Qt === 63 ? (s.consume(Qt), K) : markdownLineEnding(Qt) ? (g = te, nn(Qt)) : (s.consume(Qt), te);
  }
  function K(Qt) {
    return Qt === 62 ? Gt(Qt) : te(Qt);
  }
  function ve(Qt) {
    return asciiAlpha(Qt) ? (s.consume(Qt), ee) : l(Qt);
  }
  function ee(Qt) {
    return Qt === 45 || asciiAlphanumeric(Qt) ? (s.consume(Qt), ee) : Re(Qt);
  }
  function Re(Qt) {
    return markdownLineEnding(Qt) ? (g = Re, nn(Qt)) : markdownSpace(Qt) ? (s.consume(Qt), Re) : Gt(Qt);
  }
  function wt(Qt) {
    return Qt === 45 || asciiAlphanumeric(Qt) ? (s.consume(Qt), wt) : Qt === 47 || Qt === 62 || markdownLineEndingOrSpace(Qt) ? yt(Qt) : l(Qt);
  }
  function yt(Qt) {
    return Qt === 47 ? (s.consume(Qt), Gt) : Qt === 58 || Qt === 95 || asciiAlpha(Qt) ? (s.consume(Qt), xt) : markdownLineEnding(Qt) ? (g = yt, nn(Qt)) : markdownSpace(Qt) ? (s.consume(Qt), yt) : Gt(Qt);
  }
  function xt(Qt) {
    return Qt === 45 || Qt === 46 || Qt === 58 || Qt === 95 || asciiAlphanumeric(Qt) ? (s.consume(Qt), xt) : Kt(Qt);
  }
  function Kt(Qt) {
    return Qt === 61 ? (s.consume(Qt), tn) : markdownLineEnding(Qt) ? (g = Kt, nn(Qt)) : markdownSpace(Qt) ? (s.consume(Qt), Kt) : yt(Qt);
  }
  function tn(Qt) {
    return Qt === null || Qt === 60 || Qt === 61 || Qt === 62 || Qt === 96 ? l(Qt) : Qt === 34 || Qt === 39 ? (s.consume(Qt), c = Qt, ln) : markdownLineEnding(Qt) ? (g = tn, nn(Qt)) : markdownSpace(Qt) ? (s.consume(Qt), tn) : (s.consume(Qt), rn);
  }
  function ln(Qt) {
    return Qt === c ? (s.consume(Qt), c = void 0, an) : Qt === null ? l(Qt) : markdownLineEnding(Qt) ? (g = ln, nn(Qt)) : (s.consume(Qt), ln);
  }
  function rn(Qt) {
    return Qt === null || Qt === 34 || Qt === 39 || Qt === 60 || Qt === 61 || Qt === 96 ? l(Qt) : Qt === 47 || Qt === 62 || markdownLineEndingOrSpace(Qt) ? yt(Qt) : (s.consume(Qt), rn);
  }
  function an(Qt) {
    return Qt === 47 || Qt === 62 || markdownLineEndingOrSpace(Qt) ? yt(Qt) : l(Qt);
  }
  function Gt(Qt) {
    return Qt === 62 ? (s.consume(Qt), s.exit("htmlTextData"), s.exit("htmlText"), o) : l(Qt);
  }
  function nn(Qt) {
    return s.exit("htmlTextData"), s.enter("lineEnding"), s.consume(Qt), s.exit("lineEnding"), vt;
  }
  function vt(Qt) {
    return markdownSpace(Qt) ? factorySpace(s, Et, "linePrefix", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(Qt) : Et(Qt);
  }
  function Et(Qt) {
    return s.enter("htmlTextData"), g(Qt);
  }
}
const labelEnd = {
  name: "labelEnd",
  tokenize: tokenizeLabelEnd,
  resolveTo: resolveToLabelEnd,
  resolveAll: resolveAllLabelEnd
}, resourceConstruct = {
  tokenize: tokenizeResource
}, referenceFullConstruct = {
  tokenize: tokenizeReferenceFull
}, referenceCollapsedConstruct = {
  tokenize: tokenizeReferenceCollapsed
};
function resolveAllLabelEnd(s) {
  let o = -1;
  for (; ++o < s.length; ) {
    const l = s[o][1];
    (l.type === "labelImage" || l.type === "labelLink" || l.type === "labelEnd") && (s.splice(o + 1, l.type === "labelImage" ? 4 : 2), l.type = "data", o++);
  }
  return s;
}
function resolveToLabelEnd(s, o) {
  let l = s.length, u = 0, c, m, g, v;
  for (; l--; )
    if (c = s[l][1], m) {
      if (c.type === "link" || c.type === "labelLink" && c._inactive)
        break;
      s[l][0] === "enter" && c.type === "labelLink" && (c._inactive = !0);
    } else if (g) {
      if (s[l][0] === "enter" && (c.type === "labelImage" || c.type === "labelLink") && !c._balanced && (m = l, c.type !== "labelLink")) {
        u = 2;
        break;
      }
    } else c.type === "labelEnd" && (g = l);
  const b = {
    type: s[m][1].type === "labelLink" ? "link" : "image",
    start: Object.assign({}, s[m][1].start),
    end: Object.assign({}, s[s.length - 1][1].end)
  }, S = {
    type: "label",
    start: Object.assign({}, s[m][1].start),
    end: Object.assign({}, s[g][1].end)
  }, E = {
    type: "labelText",
    start: Object.assign({}, s[m + u + 2][1].end),
    end: Object.assign({}, s[g - 2][1].start)
  };
  return v = [["enter", b, o], ["enter", S, o]], v = push(v, s.slice(m + 1, m + u + 3)), v = push(v, [["enter", E, o]]), v = push(v, resolveAll(o.parser.constructs.insideSpan.null, s.slice(m + u + 4, g - 3), o)), v = push(v, [["exit", E, o], s[g - 2], s[g - 1], ["exit", S, o]]), v = push(v, s.slice(g + 1)), v = push(v, [["exit", b, o]]), splice(s, m, s.length, v), s;
}
function tokenizeLabelEnd(s, o, l) {
  const u = this;
  let c = u.events.length, m, g;
  for (; c--; )
    if ((u.events[c][1].type === "labelImage" || u.events[c][1].type === "labelLink") && !u.events[c][1]._balanced) {
      m = u.events[c][1];
      break;
    }
  return v;
  function v(T) {
    return m ? m._inactive ? P(T) : (g = u.parser.defined.includes(normalizeIdentifier(u.sliceSerialize({
      start: m.end,
      end: u.now()
    }))), s.enter("labelEnd"), s.enter("labelMarker"), s.consume(T), s.exit("labelMarker"), s.exit("labelEnd"), b) : l(T);
  }
  function b(T) {
    return T === 40 ? s.attempt(resourceConstruct, E, g ? E : P)(T) : T === 91 ? s.attempt(referenceFullConstruct, E, g ? S : P)(T) : g ? E(T) : P(T);
  }
  function S(T) {
    return s.attempt(referenceCollapsedConstruct, E, P)(T);
  }
  function E(T) {
    return o(T);
  }
  function P(T) {
    return m._balanced = !0, l(T);
  }
}
function tokenizeResource(s, o, l) {
  return u;
  function u(P) {
    return s.enter("resource"), s.enter("resourceMarker"), s.consume(P), s.exit("resourceMarker"), c;
  }
  function c(P) {
    return markdownLineEndingOrSpace(P) ? factoryWhitespace(s, m)(P) : m(P);
  }
  function m(P) {
    return P === 41 ? E(P) : factoryDestination(s, g, v, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(P);
  }
  function g(P) {
    return markdownLineEndingOrSpace(P) ? factoryWhitespace(s, b)(P) : E(P);
  }
  function v(P) {
    return l(P);
  }
  function b(P) {
    return P === 34 || P === 39 || P === 40 ? factoryTitle(s, S, l, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(P) : E(P);
  }
  function S(P) {
    return markdownLineEndingOrSpace(P) ? factoryWhitespace(s, E)(P) : E(P);
  }
  function E(P) {
    return P === 41 ? (s.enter("resourceMarker"), s.consume(P), s.exit("resourceMarker"), s.exit("resource"), o) : l(P);
  }
}
function tokenizeReferenceFull(s, o, l) {
  const u = this;
  return c;
  function c(v) {
    return factoryLabel.call(u, s, m, g, "reference", "referenceMarker", "referenceString")(v);
  }
  function m(v) {
    return u.parser.defined.includes(normalizeIdentifier(u.sliceSerialize(u.events[u.events.length - 1][1]).slice(1, -1))) ? o(v) : l(v);
  }
  function g(v) {
    return l(v);
  }
}
function tokenizeReferenceCollapsed(s, o, l) {
  return u;
  function u(m) {
    return s.enter("reference"), s.enter("referenceMarker"), s.consume(m), s.exit("referenceMarker"), c;
  }
  function c(m) {
    return m === 93 ? (s.enter("referenceMarker"), s.consume(m), s.exit("referenceMarker"), s.exit("reference"), o) : l(m);
  }
}
const labelStartImage = {
  name: "labelStartImage",
  tokenize: tokenizeLabelStartImage,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartImage(s, o, l) {
  const u = this;
  return c;
  function c(v) {
    return s.enter("labelImage"), s.enter("labelImageMarker"), s.consume(v), s.exit("labelImageMarker"), m;
  }
  function m(v) {
    return v === 91 ? (s.enter("labelMarker"), s.consume(v), s.exit("labelMarker"), s.exit("labelImage"), g) : l(v);
  }
  function g(v) {
    return v === 94 && "_hiddenFootnoteSupport" in u.parser.constructs ? l(v) : o(v);
  }
}
const labelStartLink = {
  name: "labelStartLink",
  tokenize: tokenizeLabelStartLink,
  resolveAll: labelEnd.resolveAll
};
function tokenizeLabelStartLink(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return s.enter("labelLink"), s.enter("labelMarker"), s.consume(g), s.exit("labelMarker"), s.exit("labelLink"), m;
  }
  function m(g) {
    return g === 94 && "_hiddenFootnoteSupport" in u.parser.constructs ? l(g) : o(g);
  }
}
const lineEnding = {
  name: "lineEnding",
  tokenize: tokenizeLineEnding
};
function tokenizeLineEnding(s, o) {
  return l;
  function l(u) {
    return s.enter("lineEnding"), s.consume(u), s.exit("lineEnding"), factorySpace(s, o, "linePrefix");
  }
}
const thematicBreak$2 = {
  name: "thematicBreak",
  tokenize: tokenizeThematicBreak
};
function tokenizeThematicBreak(s, o, l) {
  let u = 0, c;
  return m;
  function m(S) {
    return s.enter("thematicBreak"), g(S);
  }
  function g(S) {
    return c = S, v(S);
  }
  function v(S) {
    return S === c ? (s.enter("thematicBreakSequence"), b(S)) : u >= 3 && (S === null || markdownLineEnding(S)) ? (s.exit("thematicBreak"), o(S)) : l(S);
  }
  function b(S) {
    return S === c ? (s.consume(S), u++, b) : (s.exit("thematicBreakSequence"), markdownSpace(S) ? factorySpace(s, v, "whitespace")(S) : v(S));
  }
}
const list$2 = {
  name: "list",
  tokenize: tokenizeListStart,
  continuation: {
    tokenize: tokenizeListContinuation
  },
  exit: tokenizeListEnd
}, listItemPrefixWhitespaceConstruct = {
  tokenize: tokenizeListItemPrefixWhitespace,
  partial: !0
}, indentConstruct = {
  tokenize: tokenizeIndent$1,
  partial: !0
};
function tokenizeListStart(s, o, l) {
  const u = this, c = u.events[u.events.length - 1];
  let m = c && c[1].type === "linePrefix" ? c[2].sliceSerialize(c[1], !0).length : 0, g = 0;
  return v;
  function v(N) {
    const O = u.containerState.type || (N === 42 || N === 43 || N === 45 ? "listUnordered" : "listOrdered");
    if (O === "listUnordered" ? !u.containerState.marker || N === u.containerState.marker : asciiDigit(N)) {
      if (u.containerState.type || (u.containerState.type = O, s.enter(O, {
        _container: !0
      })), O === "listUnordered")
        return s.enter("listItemPrefix"), N === 42 || N === 45 ? s.check(thematicBreak$2, l, S)(N) : S(N);
      if (!u.interrupt || N === 49)
        return s.enter("listItemPrefix"), s.enter("listItemValue"), b(N);
    }
    return l(N);
  }
  function b(N) {
    return asciiDigit(N) && ++g < 10 ? (s.consume(N), b) : (!u.interrupt || g < 2) && (u.containerState.marker ? N === u.containerState.marker : N === 41 || N === 46) ? (s.exit("listItemValue"), S(N)) : l(N);
  }
  function S(N) {
    return s.enter("listItemMarker"), s.consume(N), s.exit("listItemMarker"), u.containerState.marker = u.containerState.marker || N, s.check(
      blankLine,
      // Can’t be empty when interrupting.
      u.interrupt ? l : E,
      s.attempt(listItemPrefixWhitespaceConstruct, T, P)
    );
  }
  function E(N) {
    return u.containerState.initialBlankLine = !0, m++, T(N);
  }
  function P(N) {
    return markdownSpace(N) ? (s.enter("listItemPrefixWhitespace"), s.consume(N), s.exit("listItemPrefixWhitespace"), T) : l(N);
  }
  function T(N) {
    return u.containerState.size = m + u.sliceSerialize(s.exit("listItemPrefix"), !0).length, o(N);
  }
}
function tokenizeListContinuation(s, o, l) {
  const u = this;
  return u.containerState._closeFlow = void 0, s.check(blankLine, c, m);
  function c(v) {
    return u.containerState.furtherBlankLines = u.containerState.furtherBlankLines || u.containerState.initialBlankLine, factorySpace(s, o, "listItemIndent", u.containerState.size + 1)(v);
  }
  function m(v) {
    return u.containerState.furtherBlankLines || !markdownSpace(v) ? (u.containerState.furtherBlankLines = void 0, u.containerState.initialBlankLine = void 0, g(v)) : (u.containerState.furtherBlankLines = void 0, u.containerState.initialBlankLine = void 0, s.attempt(indentConstruct, o, g)(v));
  }
  function g(v) {
    return u.containerState._closeFlow = !0, u.interrupt = void 0, factorySpace(s, s.attempt(list$2, o, l), "linePrefix", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(v);
  }
}
function tokenizeIndent$1(s, o, l) {
  const u = this;
  return factorySpace(s, c, "listItemIndent", u.containerState.size + 1);
  function c(m) {
    const g = u.events[u.events.length - 1];
    return g && g[1].type === "listItemIndent" && g[2].sliceSerialize(g[1], !0).length === u.containerState.size ? o(m) : l(m);
  }
}
function tokenizeListEnd(s) {
  s.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(s, o, l) {
  const u = this;
  return factorySpace(s, c, "listItemPrefixWhitespace", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5);
  function c(m) {
    const g = u.events[u.events.length - 1];
    return !markdownSpace(m) && g && g[1].type === "listItemPrefixWhitespace" ? o(m) : l(m);
  }
}
const setextUnderline = {
  name: "setextUnderline",
  tokenize: tokenizeSetextUnderline,
  resolveTo: resolveToSetextUnderline
};
function resolveToSetextUnderline(s, o) {
  let l = s.length, u, c, m;
  for (; l--; )
    if (s[l][0] === "enter") {
      if (s[l][1].type === "content") {
        u = l;
        break;
      }
      s[l][1].type === "paragraph" && (c = l);
    } else
      s[l][1].type === "content" && s.splice(l, 1), !m && s[l][1].type === "definition" && (m = l);
  const g = {
    type: "setextHeading",
    start: Object.assign({}, s[c][1].start),
    end: Object.assign({}, s[s.length - 1][1].end)
  };
  return s[c][1].type = "setextHeadingText", m ? (s.splice(c, 0, ["enter", g, o]), s.splice(m + 1, 0, ["exit", s[u][1], o]), s[u][1].end = Object.assign({}, s[m][1].end)) : s[u][1] = g, s.push(["exit", g, o]), s;
}
function tokenizeSetextUnderline(s, o, l) {
  const u = this;
  let c;
  return m;
  function m(S) {
    let E = u.events.length, P;
    for (; E--; )
      if (u.events[E][1].type !== "lineEnding" && u.events[E][1].type !== "linePrefix" && u.events[E][1].type !== "content") {
        P = u.events[E][1].type === "paragraph";
        break;
      }
    return !u.parser.lazy[u.now().line] && (u.interrupt || P) ? (s.enter("setextHeadingLine"), c = S, g(S)) : l(S);
  }
  function g(S) {
    return s.enter("setextHeadingLineSequence"), v(S);
  }
  function v(S) {
    return S === c ? (s.consume(S), v) : (s.exit("setextHeadingLineSequence"), markdownSpace(S) ? factorySpace(s, b, "lineSuffix")(S) : b(S));
  }
  function b(S) {
    return S === null || markdownLineEnding(S) ? (s.exit("setextHeadingLine"), o(S)) : l(S);
  }
}
const blankLineBefore = {
  tokenize: tokenizeNextBlank,
  partial: !0
}, trouble = "https://github.com/micromark/micromark-extension-mdxjs-esm", allowedAcornTypes = /* @__PURE__ */ new Set(["ExportAllDeclaration", "ExportDefaultDeclaration", "ExportNamedDeclaration", "ImportDeclaration"]);
function mdxjsEsm$1(s) {
  const o = {
    tokenize: c,
    concrete: !0
  };
  if (!s || !s.acorn || !s.acorn.parse)
    throw new Error("Expected an `acorn` instance passed in as `options.acorn`");
  const l = s.acorn, u = Object.assign({
    ecmaVersion: 2024,
    sourceType: "module"
  }, s.acornOptions, {
    locations: !0
  });
  return {
    flow: {
      101: o,
      105: o
    }
  };
  function c(m, g, v) {
    const b = this, S = b.parser.definedModuleSpecifiers || (b.parser.definedModuleSpecifiers = []), E = this.events.length + 1;
    let P = "";
    return b.interrupt ? v : T;
    function T(ue) {
      return b.now().column > 1 ? v(ue) : (m.enter("mdxjsEsm"), m.enter("mdxjsEsmData"), m.consume(ue), P += String.fromCharCode(ue), N);
    }
    function N(ue) {
      return asciiAlpha(ue) ? (m.consume(ue), P += String.fromCharCode(ue), N) : (P === "import" || P === "export") && ue === 32 ? (m.consume(ue), O) : v(ue);
    }
    function O(ue) {
      return ue === null || markdownLineEnding(ue) ? (m.exit("mdxjsEsmData"), z(ue)) : (m.consume(ue), O);
    }
    function z(ue) {
      return ue === null ? W(ue) : markdownLineEnding(ue) ? m.check(blankLineBefore, W, Q)(ue) : (m.enter("mdxjsEsmData"), O(ue));
    }
    function Q(ue) {
      return m.enter("lineEnding"), m.consume(ue), m.exit("lineEnding"), z;
    }
    function W(ue) {
      const te = eventsToAcorn(b.events.slice(E), {
        acorn: l,
        acornOptions: u,
        tokenTypes: ["mdxjsEsmData"],
        prefix: S.length > 0 ? "var " + S.join(",") + `
` : ""
      });
      if (te.error) {
        if (ue !== null && te.swallow)
          return Q(ue);
        const ve = new VFileMessage("Could not parse import/exports with acorn", {
          cause: te.error,
          place: {
            line: te.error.loc.line,
            column: te.error.loc.column + 1,
            offset: te.error.pos
          },
          ruleId: "acorn",
          source: "micromark-extension-mdxjs-esm"
        });
        throw ve.url = trouble + "#could-not-parse-importexports-with-acorn", ve;
      }
      S.length > 0 && te.estree.body.shift();
      let K = -1;
      for (; ++K < te.estree.body.length; ) {
        const ve = te.estree.body[K];
        if (!allowedAcornTypes.has(ve.type)) {
          const ee = new VFileMessage("Unexpected `" + ve.type + "` in code: only import/exports are supported", {
            place: positionFromEstree(ve),
            ruleId: "non-esm",
            source: "micromark-extension-mdxjs-esm"
          });
          throw ee.url = trouble + "#unexpected-type-in-code-only-importexports-are-supported", ee;
        }
        if (ve.type === "ImportDeclaration" && !b.interrupt) {
          let ee = -1;
          for (; ++ee < ve.specifiers.length; ) {
            const Re = ve.specifiers[ee];
            S.push(Re.local.name);
          }
        }
      }
      return Object.assign(m.exit("mdxjsEsm"), s.addResult ? {
        estree: te.estree
      } : void 0), g(ue);
    }
  }
}
function tokenizeNextBlank(s, o, l) {
  return u;
  function u(c) {
    return s.enter("lineEndingBlank"), s.consume(c), s.exit("lineEndingBlank"), s.attempt(blankLine, o, l);
  }
}
const hasOwnProperty = {}.hasOwnProperty;
function combineExtensions(s) {
  const o = {};
  let l = -1;
  for (; ++l < s.length; )
    syntaxExtension(o, s[l]);
  return o;
}
function syntaxExtension(s, o) {
  let l;
  for (l in o) {
    const c = (hasOwnProperty.call(s, l) ? s[l] : void 0) || (s[l] = {}), m = o[l];
    let g;
    if (m)
      for (g in m) {
        hasOwnProperty.call(c, g) || (c[g] = []);
        const v = m[g];
        constructs(
          // @ts-expect-error Looks like a list.
          c[g],
          Array.isArray(v) ? v : v ? [v] : []
        );
      }
  }
}
function constructs(s, o) {
  let l = -1;
  const u = [];
  for (; ++l < o.length; )
    (o[l].add === "after" ? s : u).push(o[l]);
  splice(s, 0, 0, u);
}
function mdxjs(s) {
  const o = Object.assign(
    {
      acorn: Parser.extend(acornJsx()),
      acornOptions: { ecmaVersion: 2024, sourceType: "module" },
      addResult: !0
    },
    s
  );
  return combineExtensions([
    mdxjsEsm$1(o),
    mdxExpression$1(o),
    mdxJsx(o),
    mdxMd()
  ]);
}
const emptyOptions$4 = {};
function remarkMdx(s) {
  const o = (
    /** @type {Processor} */
    this
  ), l = s || emptyOptions$4, u = o.data(), c = u.micromarkExtensions || (u.micromarkExtensions = []), m = u.fromMarkdownExtensions || (u.fromMarkdownExtensions = []), g = u.toMarkdownExtensions || (u.toMarkdownExtensions = []);
  c.push(mdxjs(l)), m.push(mdxFromMarkdown()), g.push(mdxToMarkdown(l));
}
const emptyOptions$3 = {};
function toString$1(s, o) {
  const l = emptyOptions$3, u = typeof l.includeImageAlt == "boolean" ? l.includeImageAlt : !0, c = typeof l.includeHtml == "boolean" ? l.includeHtml : !0;
  return one(s, u, c);
}
function one(s, o, l) {
  if (node(s)) {
    if ("value" in s)
      return s.type === "html" && !l ? "" : s.value;
    if (o && "alt" in s && s.alt)
      return s.alt;
    if ("children" in s)
      return all$1(s.children, o, l);
  }
  return Array.isArray(s) ? all$1(s, o, l) : "";
}
function all$1(s, o, l) {
  const u = [];
  let c = -1;
  for (; ++c < s.length; )
    u[c] = one(s[c], o, l);
  return u.join("");
}
function node(s) {
  return !!(s && typeof s == "object");
}
function decodeNumericCharacterReference(s, o) {
  const l = Number.parseInt(s, o);
  return (
    // C0 except for HT, LF, FF, CR, space.
    l < 9 || l === 11 || l > 13 && l < 32 || // Control character (DEL) of C0, and C1 controls.
    l > 126 && l < 160 || // Lone high surrogates and low surrogates.
    l > 55295 && l < 57344 || // Noncharacters.
    l > 64975 && l < 65008 || /* eslint-disable no-bitwise */
    (l & 65535) === 65535 || (l & 65535) === 65534 || /* eslint-enable no-bitwise */
    // Out of range
    l > 1114111 ? "�" : String.fromCodePoint(l)
  );
}
function normalizeUri(s) {
  const o = [];
  let l = -1, u = 0, c = 0;
  for (; ++l < s.length; ) {
    const m = s.charCodeAt(l);
    let g = "";
    if (m === 37 && asciiAlphanumeric(s.charCodeAt(l + 1)) && asciiAlphanumeric(s.charCodeAt(l + 2)))
      c = 2;
    else if (m < 128)
      /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(m)) || (g = String.fromCharCode(m));
    else if (m > 55295 && m < 57344) {
      const v = s.charCodeAt(l + 1);
      m < 56320 && v > 56319 && v < 57344 ? (g = String.fromCharCode(m, v), c = 1) : g = "�";
    } else
      g = String.fromCharCode(m);
    g && (o.push(s.slice(u, l), encodeURIComponent(g)), u = l + c + 1, g = ""), c && (l += c, c = 0);
  }
  return o.join("") + s.slice(u);
}
const content = {
  tokenize: initializeContent
};
function initializeContent(s) {
  const o = s.attempt(
    this.parser.constructs.contentInitial,
    u,
    c
  );
  let l;
  return o;
  function u(v) {
    if (v === null) {
      s.consume(v);
      return;
    }
    return s.enter("lineEnding"), s.consume(v), s.exit("lineEnding"), factorySpace(s, o, "linePrefix");
  }
  function c(v) {
    return s.enter("paragraph"), m(v);
  }
  function m(v) {
    const b = s.enter("chunkText", {
      contentType: "text",
      previous: l
    });
    return l && (l.next = b), l = b, g(v);
  }
  function g(v) {
    if (v === null) {
      s.exit("chunkText"), s.exit("paragraph"), s.consume(v);
      return;
    }
    return markdownLineEnding(v) ? (s.consume(v), s.exit("chunkText"), m) : (s.consume(v), g);
  }
}
const document$2 = {
  tokenize: initializeDocument
}, containerConstruct = {
  tokenize: tokenizeContainer
};
function initializeDocument(s) {
  const o = this, l = [];
  let u = 0, c, m, g;
  return v;
  function v(te) {
    if (u < l.length) {
      const K = l[u];
      return o.containerState = K[1], s.attempt(
        K[0].continuation,
        b,
        S
      )(te);
    }
    return S(te);
  }
  function b(te) {
    if (u++, o.containerState._closeFlow) {
      o.containerState._closeFlow = void 0, c && ue();
      const K = o.events.length;
      let ve = K, ee;
      for (; ve--; )
        if (o.events[ve][0] === "exit" && o.events[ve][1].type === "chunkFlow") {
          ee = o.events[ve][1].end;
          break;
        }
      W(u);
      let Re = K;
      for (; Re < o.events.length; )
        o.events[Re][1].end = Object.assign({}, ee), Re++;
      return splice(
        o.events,
        ve + 1,
        0,
        o.events.slice(K)
      ), o.events.length = Re, S(te);
    }
    return v(te);
  }
  function S(te) {
    if (u === l.length) {
      if (!c)
        return T(te);
      if (c.currentConstruct && c.currentConstruct.concrete)
        return O(te);
      o.interrupt = !!(c.currentConstruct && !c._gfmTableDynamicInterruptHack);
    }
    return o.containerState = {}, s.check(
      containerConstruct,
      E,
      P
    )(te);
  }
  function E(te) {
    return c && ue(), W(u), T(te);
  }
  function P(te) {
    return o.parser.lazy[o.now().line] = u !== l.length, g = o.now().offset, O(te);
  }
  function T(te) {
    return o.containerState = {}, s.attempt(
      containerConstruct,
      N,
      O
    )(te);
  }
  function N(te) {
    return u++, l.push([o.currentConstruct, o.containerState]), T(te);
  }
  function O(te) {
    if (te === null) {
      c && ue(), W(0), s.consume(te);
      return;
    }
    return c = c || o.parser.flow(o.now()), s.enter("chunkFlow", {
      contentType: "flow",
      previous: m,
      _tokenizer: c
    }), z(te);
  }
  function z(te) {
    if (te === null) {
      Q(s.exit("chunkFlow"), !0), W(0), s.consume(te);
      return;
    }
    return markdownLineEnding(te) ? (s.consume(te), Q(s.exit("chunkFlow")), u = 0, o.interrupt = void 0, v) : (s.consume(te), z);
  }
  function Q(te, K) {
    const ve = o.sliceStream(te);
    if (K && ve.push(null), te.previous = m, m && (m.next = te), m = te, c.defineSkip(te.start), c.write(ve), o.parser.lazy[te.start.line]) {
      let ee = c.events.length;
      for (; ee--; )
        if (
          // The token starts before the line ending…
          c.events[ee][1].start.offset < g && // …and either is not ended yet…
          (!c.events[ee][1].end || // …or ends after it.
          c.events[ee][1].end.offset > g)
        )
          return;
      const Re = o.events.length;
      let wt = Re, yt, xt;
      for (; wt--; )
        if (o.events[wt][0] === "exit" && o.events[wt][1].type === "chunkFlow") {
          if (yt) {
            xt = o.events[wt][1].end;
            break;
          }
          yt = !0;
        }
      for (W(u), ee = Re; ee < o.events.length; )
        o.events[ee][1].end = Object.assign({}, xt), ee++;
      splice(
        o.events,
        wt + 1,
        0,
        o.events.slice(Re)
      ), o.events.length = ee;
    }
  }
  function W(te) {
    let K = l.length;
    for (; K-- > te; ) {
      const ve = l[K];
      o.containerState = ve[1], ve[0].exit.call(o, s);
    }
    l.length = te;
  }
  function ue() {
    c.write([null]), m = void 0, c = void 0, o.containerState._closeFlow = void 0;
  }
}
function tokenizeContainer(s, o, l) {
  return factorySpace(
    s,
    s.attempt(this.parser.constructs.document, o, l),
    "linePrefix",
    this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4
  );
}
const flow$1 = {
  tokenize: initializeFlow
};
function initializeFlow(s) {
  const o = this, l = s.attempt(
    // Try to parse a blank line.
    blankLine,
    u,
    // Try to parse initial flow (essentially, only code).
    s.attempt(
      this.parser.constructs.flowInitial,
      c,
      factorySpace(
        s,
        s.attempt(
          this.parser.constructs.flow,
          c,
          s.attempt(content$1, c)
        ),
        "linePrefix"
      )
    )
  );
  return l;
  function u(m) {
    if (m === null) {
      s.consume(m);
      return;
    }
    return s.enter("lineEndingBlank"), s.consume(m), s.exit("lineEndingBlank"), o.currentConstruct = void 0, l;
  }
  function c(m) {
    if (m === null) {
      s.consume(m);
      return;
    }
    return s.enter("lineEnding"), s.consume(m), s.exit("lineEnding"), o.currentConstruct = void 0, l;
  }
}
const resolver = {
  resolveAll: createResolver()
}, string$1 = initializeFactory("string"), text$5 = initializeFactory("text");
function initializeFactory(s) {
  return {
    tokenize: o,
    resolveAll: createResolver(
      s === "text" ? resolveAllLineSuffixes : void 0
    )
  };
  function o(l) {
    const u = this, c = this.parser.constructs[s], m = l.attempt(c, g, v);
    return g;
    function g(E) {
      return S(E) ? m(E) : v(E);
    }
    function v(E) {
      if (E === null) {
        l.consume(E);
        return;
      }
      return l.enter("data"), l.consume(E), b;
    }
    function b(E) {
      return S(E) ? (l.exit("data"), m(E)) : (l.consume(E), b);
    }
    function S(E) {
      if (E === null)
        return !0;
      const P = c[E];
      let T = -1;
      if (P)
        for (; ++T < P.length; ) {
          const N = P[T];
          if (!N.previous || N.previous.call(u, u.previous))
            return !0;
        }
      return !1;
    }
  }
}
function createResolver(s) {
  return o;
  function o(l, u) {
    let c = -1, m;
    for (; ++c <= l.length; )
      m === void 0 ? l[c] && l[c][1].type === "data" && (m = c, c++) : (!l[c] || l[c][1].type !== "data") && (c !== m + 2 && (l[m][1].end = l[c - 1][1].end, l.splice(m + 2, c - m - 2), c = m + 2), m = void 0);
    return s ? s(l, u) : l;
  }
}
function resolveAllLineSuffixes(s, o) {
  let l = 0;
  for (; ++l <= s.length; )
    if ((l === s.length || s[l][1].type === "lineEnding") && s[l - 1][1].type === "data") {
      const u = s[l - 1][1], c = o.sliceStream(u);
      let m = c.length, g = -1, v = 0, b;
      for (; m--; ) {
        const S = c[m];
        if (typeof S == "string") {
          for (g = S.length; S.charCodeAt(g - 1) === 32; )
            v++, g--;
          if (g) break;
          g = -1;
        } else if (S === -2)
          b = !0, v++;
        else if (S !== -1) {
          m++;
          break;
        }
      }
      if (v) {
        const S = {
          type: l === s.length || b || v < 2 ? "lineSuffix" : "hardBreakTrailing",
          start: {
            line: u.end.line,
            column: u.end.column - v,
            offset: u.end.offset - v,
            _index: u.start._index + m,
            _bufferIndex: m ? g : u.start._bufferIndex + g
          },
          end: Object.assign({}, u.end)
        };
        u.end = Object.assign({}, S.start), u.start.offset === u.end.offset ? Object.assign(u, S) : (s.splice(
          l,
          0,
          ["enter", S, o],
          ["exit", S, o]
        ), l += 2);
      }
      l++;
    }
  return s;
}
function createTokenizer(s, o, l) {
  let u = Object.assign(
    l ? Object.assign({}, l) : {
      line: 1,
      column: 1,
      offset: 0
    },
    {
      _index: 0,
      _bufferIndex: -1
    }
  );
  const c = {}, m = [];
  let g = [], v = [];
  const b = {
    consume: ue,
    enter: te,
    exit: K,
    attempt: Re(ve),
    check: Re(ee),
    interrupt: Re(ee, {
      interrupt: !0
    })
  }, S = {
    previous: null,
    code: null,
    containerState: {},
    events: [],
    parser: s,
    sliceStream: N,
    sliceSerialize: T,
    now: O,
    defineSkip: z,
    write: P
  };
  let E = o.tokenize.call(S, b);
  return o.resolveAll && m.push(o), S;
  function P(Kt) {
    return g = push(g, Kt), Q(), g[g.length - 1] !== null ? [] : (wt(o, 0), S.events = resolveAll(m, S.events, S), S.events);
  }
  function T(Kt, tn) {
    return serializeChunks(N(Kt), tn);
  }
  function N(Kt) {
    return sliceChunks(g, Kt);
  }
  function O() {
    const { line: Kt, column: tn, offset: ln, _index: rn, _bufferIndex: an } = u;
    return {
      line: Kt,
      column: tn,
      offset: ln,
      _index: rn,
      _bufferIndex: an
    };
  }
  function z(Kt) {
    c[Kt.line] = Kt.column, xt();
  }
  function Q() {
    let Kt;
    for (; u._index < g.length; ) {
      const tn = g[u._index];
      if (typeof tn == "string")
        for (Kt = u._index, u._bufferIndex < 0 && (u._bufferIndex = 0); u._index === Kt && u._bufferIndex < tn.length; )
          W(tn.charCodeAt(u._bufferIndex));
      else
        W(tn);
    }
  }
  function W(Kt) {
    E = E(Kt);
  }
  function ue(Kt) {
    markdownLineEnding(Kt) ? (u.line++, u.column = 1, u.offset += Kt === -3 ? 2 : 1, xt()) : Kt !== -1 && (u.column++, u.offset++), u._bufferIndex < 0 ? u._index++ : (u._bufferIndex++, u._bufferIndex === g[u._index].length && (u._bufferIndex = -1, u._index++)), S.previous = Kt;
  }
  function te(Kt, tn) {
    const ln = tn || {};
    return ln.type = Kt, ln.start = O(), S.events.push(["enter", ln, S]), v.push(ln), ln;
  }
  function K(Kt) {
    const tn = v.pop();
    return tn.end = O(), S.events.push(["exit", tn, S]), tn;
  }
  function ve(Kt, tn) {
    wt(Kt, tn.from);
  }
  function ee(Kt, tn) {
    tn.restore();
  }
  function Re(Kt, tn) {
    return ln;
    function ln(rn, an, Gt) {
      let nn, vt, Et, Qt;
      return Array.isArray(rn) ? gn(rn) : "tokenize" in rn ? (
        // @ts-expect-error Looks like a construct.
        gn([rn])
      ) : un(rn);
      function un(Pn) {
        return On;
        function On(_n) {
          const Nn = _n !== null && Pn[_n], Un = _n !== null && Pn.null, Xn = [
            // To do: add more extension tests.
            /* c8 ignore next 2 */
            ...Array.isArray(Nn) ? Nn : Nn ? [Nn] : [],
            ...Array.isArray(Un) ? Un : Un ? [Un] : []
          ];
          return gn(Xn)(_n);
        }
      }
      function gn(Pn) {
        return nn = Pn, vt = 0, Pn.length === 0 ? Gt : dn(Pn[vt]);
      }
      function dn(Pn) {
        return On;
        function On(_n) {
          return Qt = yt(), Et = Pn, Pn.partial || (S.currentConstruct = Pn), Pn.name && S.parser.constructs.disable.null.includes(Pn.name) ? vn() : Pn.tokenize.call(
            // If we do have fields, create an object w/ `context` as its
            // prototype.
            // This allows a “live binding”, which is needed for `interrupt`.
            tn ? Object.assign(Object.create(S), tn) : S,
            b,
            yn,
            vn
          )(_n);
        }
      }
      function yn(Pn) {
        return Kt(Et, Qt), an;
      }
      function vn(Pn) {
        return Qt.restore(), ++vt < nn.length ? dn(nn[vt]) : Gt;
      }
    }
  }
  function wt(Kt, tn) {
    Kt.resolveAll && !m.includes(Kt) && m.push(Kt), Kt.resolve && splice(
      S.events,
      tn,
      S.events.length - tn,
      Kt.resolve(S.events.slice(tn), S)
    ), Kt.resolveTo && (S.events = Kt.resolveTo(S.events, S));
  }
  function yt() {
    const Kt = O(), tn = S.previous, ln = S.currentConstruct, rn = S.events.length, an = Array.from(v);
    return {
      restore: Gt,
      from: rn
    };
    function Gt() {
      u = Kt, S.previous = tn, S.currentConstruct = ln, S.events.length = rn, v = an, xt();
    }
  }
  function xt() {
    u.line in c && u.column < 2 && (u.column = c[u.line], u.offset += c[u.line] - 1);
  }
}
function sliceChunks(s, o) {
  const l = o.start._index, u = o.start._bufferIndex, c = o.end._index, m = o.end._bufferIndex;
  let g;
  if (l === c)
    g = [s[l].slice(u, m)];
  else {
    if (g = s.slice(l, c), u > -1) {
      const v = g[0];
      typeof v == "string" ? g[0] = v.slice(u) : g.shift();
    }
    m > 0 && g.push(s[c].slice(0, m));
  }
  return g;
}
function serializeChunks(s, o) {
  let l = -1;
  const u = [];
  let c;
  for (; ++l < s.length; ) {
    const m = s[l];
    let g;
    if (typeof m == "string")
      g = m;
    else
      switch (m) {
        case -5: {
          g = "\r";
          break;
        }
        case -4: {
          g = `
`;
          break;
        }
        case -3: {
          g = `\r
`;
          break;
        }
        case -2: {
          g = o ? " " : "	";
          break;
        }
        case -1: {
          if (!o && c) continue;
          g = " ";
          break;
        }
        default:
          g = String.fromCharCode(m);
      }
    c = m === -2, u.push(g);
  }
  return u.join("");
}
const document$1 = {
  42: list$2,
  43: list$2,
  45: list$2,
  48: list$2,
  49: list$2,
  50: list$2,
  51: list$2,
  52: list$2,
  53: list$2,
  54: list$2,
  55: list$2,
  56: list$2,
  57: list$2,
  62: blockQuote
}, contentInitial = {
  91: definition$1
}, flowInitial = {
  [-2]: codeIndented,
  [-1]: codeIndented,
  32: codeIndented
}, flow = {
  35: headingAtx,
  42: thematicBreak$2,
  45: [setextUnderline, thematicBreak$2],
  60: htmlFlow,
  61: setextUnderline,
  95: thematicBreak$2,
  96: codeFenced,
  126: codeFenced
}, string = {
  38: characterReference,
  92: characterEscape
}, text$4 = {
  [-5]: lineEnding,
  [-4]: lineEnding,
  [-3]: lineEnding,
  33: labelStartImage,
  38: characterReference,
  42: attention,
  60: [autolink, htmlText],
  91: labelStartLink,
  92: [hardBreakEscape, characterEscape],
  93: labelEnd,
  95: attention,
  96: codeText
}, insideSpan = {
  null: [attention, resolver]
}, attentionMarkers = {
  null: [42, 95]
}, disable = {
  null: []
}, defaultConstructs = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  attentionMarkers,
  contentInitial,
  disable,
  document: document$1,
  flow,
  flowInitial,
  insideSpan,
  string,
  text: text$4
}, Symbol.toStringTag, { value: "Module" }));
function parse$1(s) {
  const l = (
    /** @type {FullNormalizedExtension} */
    combineExtensions([defaultConstructs, ...(s || {}).extensions || []])
  ), u = {
    defined: [],
    lazy: {},
    constructs: l,
    content: c(content),
    document: c(document$2),
    flow: c(flow$1),
    string: c(string$1),
    text: c(text$5)
  };
  return u;
  function c(m) {
    return g;
    function g(v) {
      return createTokenizer(u, m, v);
    }
  }
}
function postprocess(s) {
  for (; !subtokenize(s); )
    ;
  return s;
}
const search = /[\0\t\n\r]/g;
function preprocess() {
  let s = 1, o = "", l = !0, u;
  return c;
  function c(m, g, v) {
    const b = [];
    let S, E, P, T, N;
    for (m = o + (typeof m == "string" ? m.toString() : new TextDecoder(g || void 0).decode(m)), P = 0, o = "", l && (m.charCodeAt(0) === 65279 && P++, l = void 0); P < m.length; ) {
      if (search.lastIndex = P, S = search.exec(m), T = S && S.index !== void 0 ? S.index : m.length, N = m.charCodeAt(T), !S) {
        o = m.slice(P);
        break;
      }
      if (N === 10 && P === T && u)
        b.push(-3), u = void 0;
      else
        switch (u && (b.push(-5), u = void 0), P < T && (b.push(m.slice(P, T)), s += T - P), N) {
          case 0: {
            b.push(65533), s++;
            break;
          }
          case 9: {
            for (E = Math.ceil(s / 4) * 4, b.push(-2); s++ < E; ) b.push(-1);
            break;
          }
          case 10: {
            b.push(-4), s = 1;
            break;
          }
          default:
            u = !0, s = 1;
        }
      P = T + 1;
    }
    return v && (u && b.push(-5), o && b.push(o), b.push(null)), b;
  }
}
const characterEscapeOrReference = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function decodeString(s) {
  return s.replace(characterEscapeOrReference, decode);
}
function decode(s, o, l) {
  if (o)
    return o;
  if (l.charCodeAt(0) === 35) {
    const c = l.charCodeAt(1), m = c === 120 || c === 88;
    return decodeNumericCharacterReference(l.slice(m ? 2 : 1), m ? 16 : 10);
  }
  return decodeNamedCharacterReference(l) || s;
}
const own$7 = {}.hasOwnProperty;
function fromMarkdown(s, o, l) {
  return typeof o != "string" && (l = o, o = void 0), compiler(l)(postprocess(parse$1(l).document().write(preprocess()(s, o, !0))));
}
function compiler(s) {
  const o = {
    transforms: [],
    canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"],
    enter: {
      autolink: m(Ln),
      autolinkProtocol: yt,
      autolinkEmail: yt,
      atxHeading: m(Yn),
      blockQuote: m(Un),
      characterEscape: yt,
      characterReference: yt,
      codeFenced: m(Xn),
      codeFencedFenceInfo: g,
      codeFencedFenceMeta: g,
      codeIndented: m(Xn, g),
      codeText: m(zn, g),
      codeTextData: yt,
      data: yt,
      codeFlowValue: yt,
      definition: m(jn),
      definitionDestinationString: g,
      definitionLabelString: g,
      definitionTitleString: g,
      emphasis: m(kn),
      hardBreakEscape: m(Zn),
      hardBreakTrailing: m(Zn),
      htmlFlow: m(er, g),
      htmlFlowData: yt,
      htmlText: m(er, g),
      htmlTextData: yt,
      image: m(bn),
      label: g,
      link: m(Ln),
      listItem: m(Bn),
      listItemValue: T,
      listOrdered: m(Kn, P),
      listUnordered: m(Kn),
      paragraph: m(Fn),
      reference: dn,
      referenceString: g,
      resourceDestinationString: g,
      resourceTitleString: g,
      setextHeading: m(Yn),
      strong: m(Gn),
      thematicBreak: m(Mn)
    },
    exit: {
      atxHeading: b(),
      atxHeadingSequence: ve,
      autolink: b(),
      autolinkEmail: Nn,
      autolinkProtocol: _n,
      blockQuote: b(),
      characterEscapeValue: xt,
      characterReferenceMarkerHexadecimal: vn,
      characterReferenceMarkerNumeric: vn,
      characterReferenceValue: Pn,
      characterReference: On,
      codeFenced: b(Q),
      codeFencedFence: z,
      codeFencedFenceInfo: N,
      codeFencedFenceMeta: O,
      codeFlowValue: xt,
      codeIndented: b(W),
      codeText: b(an),
      codeTextData: xt,
      data: xt,
      definition: b(),
      definitionDestinationString: K,
      definitionLabelString: ue,
      definitionTitleString: te,
      emphasis: b(),
      hardBreakEscape: b(tn),
      hardBreakTrailing: b(tn),
      htmlFlow: b(ln),
      htmlFlowData: xt,
      htmlText: b(rn),
      htmlTextData: xt,
      image: b(nn),
      label: Et,
      labelText: vt,
      lineEnding: Kt,
      link: b(Gt),
      listItem: b(),
      listOrdered: b(),
      listUnordered: b(),
      paragraph: b(),
      referenceString: yn,
      resourceDestinationString: Qt,
      resourceTitleString: un,
      resource: gn,
      setextHeading: b(wt),
      setextHeadingLineSequence: Re,
      setextHeadingText: ee,
      strong: b(),
      thematicBreak: b()
    }
  };
  configure(o, (s || {}).mdastExtensions || []);
  const l = {};
  return u;
  function u(Tn) {
    let Rn = {
      type: "root",
      children: []
    };
    const hn = {
      stack: [Rn],
      tokenStack: [],
      config: o,
      enter: v,
      exit: S,
      buffer: g,
      resume: E,
      data: l
    }, Qn = [];
    let rr = -1;
    for (; ++rr < Tn.length; )
      if (Tn[rr][1].type === "listOrdered" || Tn[rr][1].type === "listUnordered")
        if (Tn[rr][0] === "enter")
          Qn.push(rr);
        else {
          const tr = Qn.pop();
          rr = c(Tn, tr, rr);
        }
    for (rr = -1; ++rr < Tn.length; ) {
      const tr = o[Tn[rr][0]];
      own$7.call(tr, Tn[rr][1].type) && tr[Tn[rr][1].type].call(Object.assign({
        sliceSerialize: Tn[rr][2].sliceSerialize
      }, hn), Tn[rr][1]);
    }
    if (hn.tokenStack.length > 0) {
      const tr = hn.tokenStack[hn.tokenStack.length - 1];
      (tr[1] || defaultOnError).call(hn, void 0, tr[0]);
    }
    for (Rn.position = {
      start: point$1(Tn.length > 0 ? Tn[0][1].start : {
        line: 1,
        column: 1,
        offset: 0
      }),
      end: point$1(Tn.length > 0 ? Tn[Tn.length - 2][1].end : {
        line: 1,
        column: 1,
        offset: 0
      })
    }, rr = -1; ++rr < o.transforms.length; )
      Rn = o.transforms[rr](Rn) || Rn;
    return Rn;
  }
  function c(Tn, Rn, hn) {
    let Qn = Rn - 1, rr = -1, tr = !1, Cr, Fr, An, Hn;
    for (; ++Qn <= hn; ) {
      const ir = Tn[Qn];
      switch (ir[1].type) {
        case "listUnordered":
        case "listOrdered":
        case "blockQuote": {
          ir[0] === "enter" ? rr++ : rr--, Hn = void 0;
          break;
        }
        case "lineEndingBlank": {
          ir[0] === "enter" && (Cr && !Hn && !rr && !An && (An = Qn), Hn = void 0);
          break;
        }
        case "linePrefix":
        case "listItemValue":
        case "listItemMarker":
        case "listItemPrefix":
        case "listItemPrefixWhitespace":
          break;
        default:
          Hn = void 0;
      }
      if (!rr && ir[0] === "enter" && ir[1].type === "listItemPrefix" || rr === -1 && ir[0] === "exit" && (ir[1].type === "listUnordered" || ir[1].type === "listOrdered")) {
        if (Cr) {
          let dr = Qn;
          for (Fr = void 0; dr--; ) {
            const ar = Tn[dr];
            if (ar[1].type === "lineEnding" || ar[1].type === "lineEndingBlank") {
              if (ar[0] === "exit") continue;
              Fr && (Tn[Fr][1].type = "lineEndingBlank", tr = !0), ar[1].type = "lineEnding", Fr = dr;
            } else if (!(ar[1].type === "linePrefix" || ar[1].type === "blockQuotePrefix" || ar[1].type === "blockQuotePrefixWhitespace" || ar[1].type === "blockQuoteMarker" || ar[1].type === "listItemIndent")) break;
          }
          An && (!Fr || An < Fr) && (Cr._spread = !0), Cr.end = Object.assign({}, Fr ? Tn[Fr][1].start : ir[1].end), Tn.splice(Fr || Qn, 0, ["exit", Cr, ir[2]]), Qn++, hn++;
        }
        if (ir[1].type === "listItemPrefix") {
          const dr = {
            type: "listItem",
            _spread: !1,
            start: Object.assign({}, ir[1].start),
            // @ts-expect-error: we’ll add `end` in a second.
            end: void 0
          };
          Cr = dr, Tn.splice(Qn, 0, ["enter", dr, ir[2]]), Qn++, hn++, An = void 0, Hn = !0;
        }
      }
    }
    return Tn[Rn][1]._spread = tr, hn;
  }
  function m(Tn, Rn) {
    return hn;
    function hn(Qn) {
      v.call(this, Tn(Qn), Qn), Rn && Rn.call(this, Qn);
    }
  }
  function g() {
    this.stack.push({
      type: "fragment",
      children: []
    });
  }
  function v(Tn, Rn, hn) {
    this.stack[this.stack.length - 1].children.push(Tn), this.stack.push(Tn), this.tokenStack.push([Rn, hn]), Tn.position = {
      start: point$1(Rn.start),
      // @ts-expect-error: `end` will be patched later.
      end: void 0
    };
  }
  function b(Tn) {
    return Rn;
    function Rn(hn) {
      Tn && Tn.call(this, hn), S.call(this, hn);
    }
  }
  function S(Tn, Rn) {
    const hn = this.stack.pop(), Qn = this.tokenStack.pop();
    if (Qn)
      Qn[0].type !== Tn.type && (Rn ? Rn.call(this, Tn, Qn[0]) : (Qn[1] || defaultOnError).call(this, Tn, Qn[0]));
    else throw new Error("Cannot close `" + Tn.type + "` (" + stringifyPosition({
      start: Tn.start,
      end: Tn.end
    }) + "): it’s not open");
    hn.position.end = point$1(Tn.end);
  }
  function E() {
    return toString$1(this.stack.pop());
  }
  function P() {
    this.data.expectingFirstListItemValue = !0;
  }
  function T(Tn) {
    if (this.data.expectingFirstListItemValue) {
      const Rn = this.stack[this.stack.length - 2];
      Rn.start = Number.parseInt(this.sliceSerialize(Tn), 10), this.data.expectingFirstListItemValue = void 0;
    }
  }
  function N() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.lang = Tn;
  }
  function O() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.meta = Tn;
  }
  function z() {
    this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0);
  }
  function Q() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.value = Tn.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0;
  }
  function W() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.value = Tn.replace(/(\r?\n|\r)$/g, "");
  }
  function ue(Tn) {
    const Rn = this.resume(), hn = this.stack[this.stack.length - 1];
    hn.label = Rn, hn.identifier = normalizeIdentifier(this.sliceSerialize(Tn)).toLowerCase();
  }
  function te() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.title = Tn;
  }
  function K() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.url = Tn;
  }
  function ve(Tn) {
    const Rn = this.stack[this.stack.length - 1];
    if (!Rn.depth) {
      const hn = this.sliceSerialize(Tn).length;
      Rn.depth = hn;
    }
  }
  function ee() {
    this.data.setextHeadingSlurpLineEnding = !0;
  }
  function Re(Tn) {
    const Rn = this.stack[this.stack.length - 1];
    Rn.depth = this.sliceSerialize(Tn).codePointAt(0) === 61 ? 1 : 2;
  }
  function wt() {
    this.data.setextHeadingSlurpLineEnding = void 0;
  }
  function yt(Tn) {
    const hn = this.stack[this.stack.length - 1].children;
    let Qn = hn[hn.length - 1];
    (!Qn || Qn.type !== "text") && (Qn = Wn(), Qn.position = {
      start: point$1(Tn.start),
      // @ts-expect-error: we’ll add `end` later.
      end: void 0
    }, hn.push(Qn)), this.stack.push(Qn);
  }
  function xt(Tn) {
    const Rn = this.stack.pop();
    Rn.value += this.sliceSerialize(Tn), Rn.position.end = point$1(Tn.end);
  }
  function Kt(Tn) {
    const Rn = this.stack[this.stack.length - 1];
    if (this.data.atHardBreak) {
      const hn = Rn.children[Rn.children.length - 1];
      hn.position.end = point$1(Tn.end), this.data.atHardBreak = void 0;
      return;
    }
    !this.data.setextHeadingSlurpLineEnding && o.canContainEols.includes(Rn.type) && (yt.call(this, Tn), xt.call(this, Tn));
  }
  function tn() {
    this.data.atHardBreak = !0;
  }
  function ln() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.value = Tn;
  }
  function rn() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.value = Tn;
  }
  function an() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.value = Tn;
  }
  function Gt() {
    const Tn = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Rn = this.data.referenceType || "shortcut";
      Tn.type += "Reference", Tn.referenceType = Rn, delete Tn.url, delete Tn.title;
    } else
      delete Tn.identifier, delete Tn.label;
    this.data.referenceType = void 0;
  }
  function nn() {
    const Tn = this.stack[this.stack.length - 1];
    if (this.data.inReference) {
      const Rn = this.data.referenceType || "shortcut";
      Tn.type += "Reference", Tn.referenceType = Rn, delete Tn.url, delete Tn.title;
    } else
      delete Tn.identifier, delete Tn.label;
    this.data.referenceType = void 0;
  }
  function vt(Tn) {
    const Rn = this.sliceSerialize(Tn), hn = this.stack[this.stack.length - 2];
    hn.label = decodeString(Rn), hn.identifier = normalizeIdentifier(Rn).toLowerCase();
  }
  function Et() {
    const Tn = this.stack[this.stack.length - 1], Rn = this.resume(), hn = this.stack[this.stack.length - 1];
    if (this.data.inReference = !0, hn.type === "link") {
      const Qn = Tn.children;
      hn.children = Qn;
    } else
      hn.alt = Rn;
  }
  function Qt() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.url = Tn;
  }
  function un() {
    const Tn = this.resume(), Rn = this.stack[this.stack.length - 1];
    Rn.title = Tn;
  }
  function gn() {
    this.data.inReference = void 0;
  }
  function dn() {
    this.data.referenceType = "collapsed";
  }
  function yn(Tn) {
    const Rn = this.resume(), hn = this.stack[this.stack.length - 1];
    hn.label = Rn, hn.identifier = normalizeIdentifier(this.sliceSerialize(Tn)).toLowerCase(), this.data.referenceType = "full";
  }
  function vn(Tn) {
    this.data.characterReferenceType = Tn.type;
  }
  function Pn(Tn) {
    const Rn = this.sliceSerialize(Tn), hn = this.data.characterReferenceType;
    let Qn;
    hn ? (Qn = decodeNumericCharacterReference(Rn, hn === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : Qn = decodeNamedCharacterReference(Rn);
    const rr = this.stack[this.stack.length - 1];
    rr.value += Qn;
  }
  function On(Tn) {
    const Rn = this.stack.pop();
    Rn.position.end = point$1(Tn.end);
  }
  function _n(Tn) {
    xt.call(this, Tn);
    const Rn = this.stack[this.stack.length - 1];
    Rn.url = this.sliceSerialize(Tn);
  }
  function Nn(Tn) {
    xt.call(this, Tn);
    const Rn = this.stack[this.stack.length - 1];
    Rn.url = "mailto:" + this.sliceSerialize(Tn);
  }
  function Un() {
    return {
      type: "blockquote",
      children: []
    };
  }
  function Xn() {
    return {
      type: "code",
      lang: null,
      meta: null,
      value: ""
    };
  }
  function zn() {
    return {
      type: "inlineCode",
      value: ""
    };
  }
  function jn() {
    return {
      type: "definition",
      identifier: "",
      label: null,
      title: null,
      url: ""
    };
  }
  function kn() {
    return {
      type: "emphasis",
      children: []
    };
  }
  function Yn() {
    return {
      type: "heading",
      // @ts-expect-error `depth` will be set later.
      depth: 0,
      children: []
    };
  }
  function Zn() {
    return {
      type: "break"
    };
  }
  function er() {
    return {
      type: "html",
      value: ""
    };
  }
  function bn() {
    return {
      type: "image",
      title: null,
      url: "",
      alt: null
    };
  }
  function Ln() {
    return {
      type: "link",
      title: null,
      url: "",
      children: []
    };
  }
  function Kn(Tn) {
    return {
      type: "list",
      ordered: Tn.type === "listOrdered",
      start: null,
      spread: Tn._spread,
      children: []
    };
  }
  function Bn(Tn) {
    return {
      type: "listItem",
      spread: Tn._spread,
      checked: null,
      children: []
    };
  }
  function Fn() {
    return {
      type: "paragraph",
      children: []
    };
  }
  function Gn() {
    return {
      type: "strong",
      children: []
    };
  }
  function Wn() {
    return {
      type: "text",
      value: ""
    };
  }
  function Mn() {
    return {
      type: "thematicBreak"
    };
  }
}
function point$1(s) {
  return {
    line: s.line,
    column: s.column,
    offset: s.offset
  };
}
function configure(s, o) {
  let l = -1;
  for (; ++l < o.length; ) {
    const u = o[l];
    Array.isArray(u) ? configure(s, u) : extension(s, u);
  }
}
function extension(s, o) {
  let l;
  for (l in o)
    if (own$7.call(o, l))
      switch (l) {
        case "canContainEols": {
          const u = o[l];
          u && s[l].push(...u);
          break;
        }
        case "transforms": {
          const u = o[l];
          u && s[l].push(...u);
          break;
        }
        case "enter":
        case "exit": {
          const u = o[l];
          u && Object.assign(s[l], u);
          break;
        }
      }
}
function defaultOnError(s, o) {
  throw s ? new Error("Cannot close `" + s.type + "` (" + stringifyPosition({
    start: s.start,
    end: s.end
  }) + "): a different token (`" + o.type + "`, " + stringifyPosition({
    start: o.start,
    end: o.end
  }) + ") is open") : new Error("Cannot close document, a token (`" + o.type + "`, " + stringifyPosition({
    start: o.start,
    end: o.end
  }) + ") is still open");
}
function remarkParse(s) {
  const o = this;
  o.parser = l;
  function l(u) {
    return fromMarkdown(u, {
      ...o.data("settings"),
      ...s,
      // Note: these options are not in the readme.
      // The goal is for them to be set by plugins on `data` instead of being
      // passed by users.
      extensions: o.data("micromarkExtensions") || [],
      mdastExtensions: o.data("fromMarkdownExtensions") || []
    });
  }
}
function blockquote$1(s, o) {
  const l = {
    type: "element",
    tagName: "blockquote",
    properties: {},
    children: s.wrap(s.all(o), !0)
  };
  return s.patch(o, l), s.applyData(o, l);
}
function hardBreak$1(s, o) {
  const l = { type: "element", tagName: "br", properties: {}, children: [] };
  return s.patch(o, l), [s.applyData(o, l), { type: "text", value: `
` }];
}
function code$2(s, o) {
  const l = o.value ? o.value + `
` : "", u = {};
  o.lang && (u.className = ["language-" + o.lang]);
  let c = {
    type: "element",
    tagName: "code",
    properties: u,
    children: [{ type: "text", value: l }]
  };
  return o.meta && (c.data = { meta: o.meta }), s.patch(o, c), c = s.applyData(o, c), c = { type: "element", tagName: "pre", properties: {}, children: [c] }, s.patch(o, c), c;
}
function strikethrough(s, o) {
  const l = {
    type: "element",
    tagName: "del",
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
function emphasis$1(s, o) {
  const l = {
    type: "element",
    tagName: "em",
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
function footnoteReference$1(s, o) {
  const l = typeof s.options.clobberPrefix == "string" ? s.options.clobberPrefix : "user-content-", u = String(o.identifier).toUpperCase(), c = normalizeUri(u.toLowerCase()), m = s.footnoteOrder.indexOf(u);
  let g, v = s.footnoteCounts.get(u);
  v === void 0 ? (v = 0, s.footnoteOrder.push(u), g = s.footnoteOrder.length) : g = m + 1, v += 1, s.footnoteCounts.set(u, v);
  const b = {
    type: "element",
    tagName: "a",
    properties: {
      href: "#" + l + "fn-" + c,
      id: l + "fnref-" + c + (v > 1 ? "-" + v : ""),
      dataFootnoteRef: !0,
      ariaDescribedBy: ["footnote-label"]
    },
    children: [{ type: "text", value: String(g) }]
  };
  s.patch(o, b);
  const S = {
    type: "element",
    tagName: "sup",
    properties: {},
    children: [b]
  };
  return s.patch(o, S), s.applyData(o, S);
}
function heading$1(s, o) {
  const l = {
    type: "element",
    tagName: "h" + o.depth,
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
function html$4(s, o) {
  if (s.options.allowDangerousHtml) {
    const l = { type: "raw", value: o.value };
    return s.patch(o, l), s.applyData(o, l);
  }
}
function revert(s, o) {
  const l = o.referenceType;
  let u = "]";
  if (l === "collapsed" ? u += "[]" : l === "full" && (u += "[" + (o.label || o.identifier) + "]"), o.type === "imageReference")
    return [{ type: "text", value: "![" + o.alt + u }];
  const c = s.all(o), m = c[0];
  m && m.type === "text" ? m.value = "[" + m.value : c.unshift({ type: "text", value: "[" });
  const g = c[c.length - 1];
  return g && g.type === "text" ? g.value += u : c.push({ type: "text", value: u }), c;
}
function imageReference$1(s, o) {
  const l = String(o.identifier).toUpperCase(), u = s.definitionById.get(l);
  if (!u)
    return revert(s, o);
  const c = { src: normalizeUri(u.url || ""), alt: o.alt };
  u.title !== null && u.title !== void 0 && (c.title = u.title);
  const m = { type: "element", tagName: "img", properties: c, children: [] };
  return s.patch(o, m), s.applyData(o, m);
}
function image$1(s, o) {
  const l = { src: normalizeUri(o.url) };
  o.alt !== null && o.alt !== void 0 && (l.alt = o.alt), o.title !== null && o.title !== void 0 && (l.title = o.title);
  const u = { type: "element", tagName: "img", properties: l, children: [] };
  return s.patch(o, u), s.applyData(o, u);
}
function inlineCode$1(s, o) {
  const l = { type: "text", value: o.value.replace(/\r?\n|\r/g, " ") };
  s.patch(o, l);
  const u = {
    type: "element",
    tagName: "code",
    properties: {},
    children: [l]
  };
  return s.patch(o, u), s.applyData(o, u);
}
function linkReference$1(s, o) {
  const l = String(o.identifier).toUpperCase(), u = s.definitionById.get(l);
  if (!u)
    return revert(s, o);
  const c = { href: normalizeUri(u.url || "") };
  u.title !== null && u.title !== void 0 && (c.title = u.title);
  const m = {
    type: "element",
    tagName: "a",
    properties: c,
    children: s.all(o)
  };
  return s.patch(o, m), s.applyData(o, m);
}
function link$1(s, o) {
  const l = { href: normalizeUri(o.url) };
  o.title !== null && o.title !== void 0 && (l.title = o.title);
  const u = {
    type: "element",
    tagName: "a",
    properties: l,
    children: s.all(o)
  };
  return s.patch(o, u), s.applyData(o, u);
}
function listItem$1(s, o, l) {
  const u = s.all(o), c = l ? listLoose(l) : listItemLoose(o), m = {}, g = [];
  if (typeof o.checked == "boolean") {
    const E = u[0];
    let P;
    E && E.type === "element" && E.tagName === "p" ? P = E : (P = { type: "element", tagName: "p", properties: {}, children: [] }, u.unshift(P)), P.children.length > 0 && P.children.unshift({ type: "text", value: " " }), P.children.unshift({
      type: "element",
      tagName: "input",
      properties: { type: "checkbox", checked: o.checked, disabled: !0 },
      children: []
    }), m.className = ["task-list-item"];
  }
  let v = -1;
  for (; ++v < u.length; ) {
    const E = u[v];
    (c || v !== 0 || E.type !== "element" || E.tagName !== "p") && g.push({ type: "text", value: `
` }), E.type === "element" && E.tagName === "p" && !c ? g.push(...E.children) : g.push(E);
  }
  const b = u[u.length - 1];
  b && (c || b.type !== "element" || b.tagName !== "p") && g.push({ type: "text", value: `
` });
  const S = { type: "element", tagName: "li", properties: m, children: g };
  return s.patch(o, S), s.applyData(o, S);
}
function listLoose(s) {
  let o = !1;
  if (s.type === "list") {
    o = s.spread || !1;
    const l = s.children;
    let u = -1;
    for (; !o && ++u < l.length; )
      o = listItemLoose(l[u]);
  }
  return o;
}
function listItemLoose(s) {
  const o = s.spread;
  return o ?? s.children.length > 1;
}
function list$1(s, o) {
  const l = {}, u = s.all(o);
  let c = -1;
  for (typeof o.start == "number" && o.start !== 1 && (l.start = o.start); ++c < u.length; ) {
    const g = u[c];
    if (g.type === "element" && g.tagName === "li" && g.properties && Array.isArray(g.properties.className) && g.properties.className.includes("task-list-item")) {
      l.className = ["contains-task-list"];
      break;
    }
  }
  const m = {
    type: "element",
    tagName: o.ordered ? "ol" : "ul",
    properties: l,
    children: s.wrap(u, !0)
  };
  return s.patch(o, m), s.applyData(o, m);
}
function paragraph$1(s, o) {
  const l = {
    type: "element",
    tagName: "p",
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
function root$2(s, o) {
  const l = { type: "root", children: s.wrap(s.all(o)) };
  return s.patch(o, l), s.applyData(o, l);
}
function strong$1(s, o) {
  const l = {
    type: "element",
    tagName: "strong",
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
const pointEnd = point("end"), pointStart = point("start");
function point(s) {
  return o;
  function o(l) {
    const u = l && l.position && l.position[s] || {};
    if (typeof u.line == "number" && u.line > 0 && typeof u.column == "number" && u.column > 0)
      return {
        line: u.line,
        column: u.column,
        offset: typeof u.offset == "number" && u.offset > -1 ? u.offset : void 0
      };
  }
}
function position(s) {
  const o = pointStart(s), l = pointEnd(s);
  if (o && l)
    return { start: o, end: l };
}
function table(s, o) {
  const l = s.all(o), u = l.shift(), c = [];
  if (u) {
    const g = {
      type: "element",
      tagName: "thead",
      properties: {},
      children: s.wrap([u], !0)
    };
    s.patch(o.children[0], g), c.push(g);
  }
  if (l.length > 0) {
    const g = {
      type: "element",
      tagName: "tbody",
      properties: {},
      children: s.wrap(l, !0)
    }, v = pointStart(o.children[1]), b = pointEnd(o.children[o.children.length - 1]);
    v && b && (g.position = { start: v, end: b }), c.push(g);
  }
  const m = {
    type: "element",
    tagName: "table",
    properties: {},
    children: s.wrap(c, !0)
  };
  return s.patch(o, m), s.applyData(o, m);
}
function tableRow(s, o, l) {
  const u = l ? l.children : void 0, m = (u ? u.indexOf(o) : 1) === 0 ? "th" : "td", g = l && l.type === "table" ? l.align : void 0, v = g ? g.length : o.children.length;
  let b = -1;
  const S = [];
  for (; ++b < v; ) {
    const P = o.children[b], T = {}, N = g ? g[b] : void 0;
    N && (T.align = N);
    let O = { type: "element", tagName: m, properties: T, children: [] };
    P && (O.children = s.all(P), s.patch(P, O), O = s.applyData(P, O)), S.push(O);
  }
  const E = {
    type: "element",
    tagName: "tr",
    properties: {},
    children: s.wrap(S, !0)
  };
  return s.patch(o, E), s.applyData(o, E);
}
function tableCell(s, o) {
  const l = {
    type: "element",
    tagName: "td",
    // Assume body cell.
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, l), s.applyData(o, l);
}
const tab = 9, space = 32;
function trimLines(s) {
  const o = String(s), l = /\r?\n|\r/g;
  let u = l.exec(o), c = 0;
  const m = [];
  for (; u; )
    m.push(
      trimLine(o.slice(c, u.index), c > 0, !0),
      u[0]
    ), c = u.index + u[0].length, u = l.exec(o);
  return m.push(trimLine(o.slice(c), c > 0, !1)), m.join("");
}
function trimLine(s, o, l) {
  let u = 0, c = s.length;
  if (o) {
    let m = s.codePointAt(u);
    for (; m === tab || m === space; )
      u++, m = s.codePointAt(u);
  }
  if (l) {
    let m = s.codePointAt(c - 1);
    for (; m === tab || m === space; )
      c--, m = s.codePointAt(c - 1);
  }
  return c > u ? s.slice(u, c) : "";
}
function text$3(s, o) {
  const l = { type: "text", value: trimLines(String(o.value)) };
  return s.patch(o, l), s.applyData(o, l);
}
function thematicBreak$1(s, o) {
  const l = {
    type: "element",
    tagName: "hr",
    properties: {},
    children: []
  };
  return s.patch(o, l), s.applyData(o, l);
}
const handlers$1 = {
  blockquote: blockquote$1,
  break: hardBreak$1,
  code: code$2,
  delete: strikethrough,
  emphasis: emphasis$1,
  footnoteReference: footnoteReference$1,
  heading: heading$1,
  html: html$4,
  imageReference: imageReference$1,
  image: image$1,
  inlineCode: inlineCode$1,
  linkReference: linkReference$1,
  link: link$1,
  listItem: listItem$1,
  list: list$1,
  paragraph: paragraph$1,
  // @ts-expect-error: root is different, but hard to type.
  root: root$2,
  strong: strong$1,
  table,
  tableCell,
  tableRow,
  text: text$3,
  thematicBreak: thematicBreak$1,
  toml: ignore$1,
  yaml: ignore$1,
  definition: ignore$1,
  footnoteDefinition: ignore$1
};
function ignore$1() {
}
const VOID = -1, PRIMITIVE = 0, ARRAY = 1, OBJECT = 2, DATE = 3, REGEXP = 4, MAP = 5, SET = 6, ERROR = 7, BIGINT = 8, env = typeof self == "object" ? self : globalThis, deserializer = (s, o) => {
  const l = (c, m) => (s.set(m, c), c), u = (c) => {
    if (s.has(c))
      return s.get(c);
    const [m, g] = o[c];
    switch (m) {
      case PRIMITIVE:
      case VOID:
        return l(g, c);
      case ARRAY: {
        const v = l([], c);
        for (const b of g)
          v.push(u(b));
        return v;
      }
      case OBJECT: {
        const v = l({}, c);
        for (const [b, S] of g)
          v[u(b)] = u(S);
        return v;
      }
      case DATE:
        return l(new Date(g), c);
      case REGEXP: {
        const { source: v, flags: b } = g;
        return l(new RegExp(v, b), c);
      }
      case MAP: {
        const v = l(/* @__PURE__ */ new Map(), c);
        for (const [b, S] of g)
          v.set(u(b), u(S));
        return v;
      }
      case SET: {
        const v = l(/* @__PURE__ */ new Set(), c);
        for (const b of g)
          v.add(u(b));
        return v;
      }
      case ERROR: {
        const { name: v, message: b } = g;
        return l(new env[v](b), c);
      }
      case BIGINT:
        return l(BigInt(g), c);
      case "BigInt":
        return l(Object(BigInt(g)), c);
    }
    return l(new env[m](g), c);
  };
  return u;
}, deserialize = (s) => deserializer(/* @__PURE__ */ new Map(), s)(0), EMPTY = "", { toString } = {}, { keys } = Object, typeOf = (s) => {
  const o = typeof s;
  if (o !== "object" || !s)
    return [PRIMITIVE, o];
  const l = toString.call(s).slice(8, -1);
  switch (l) {
    case "Array":
      return [ARRAY, EMPTY];
    case "Object":
      return [OBJECT, EMPTY];
    case "Date":
      return [DATE, EMPTY];
    case "RegExp":
      return [REGEXP, EMPTY];
    case "Map":
      return [MAP, EMPTY];
    case "Set":
      return [SET, EMPTY];
  }
  return l.includes("Array") ? [ARRAY, l] : l.includes("Error") ? [ERROR, l] : [OBJECT, l];
}, shouldSkip = ([s, o]) => s === PRIMITIVE && (o === "function" || o === "symbol"), serializer = (s, o, l, u) => {
  const c = (g, v) => {
    const b = u.push(g) - 1;
    return l.set(v, b), b;
  }, m = (g) => {
    if (l.has(g))
      return l.get(g);
    let [v, b] = typeOf(g);
    switch (v) {
      case PRIMITIVE: {
        let E = g;
        switch (b) {
          case "bigint":
            v = BIGINT, E = g.toString();
            break;
          case "function":
          case "symbol":
            if (s)
              throw new TypeError("unable to serialize " + b);
            E = null;
            break;
          case "undefined":
            return c([VOID], g);
        }
        return c([v, E], g);
      }
      case ARRAY: {
        if (b)
          return c([b, [...g]], g);
        const E = [], P = c([v, E], g);
        for (const T of g)
          E.push(m(T));
        return P;
      }
      case OBJECT: {
        if (b)
          switch (b) {
            case "BigInt":
              return c([b, g.toString()], g);
            case "Boolean":
            case "Number":
            case "String":
              return c([b, g.valueOf()], g);
          }
        if (o && "toJSON" in g)
          return m(g.toJSON());
        const E = [], P = c([v, E], g);
        for (const T of keys(g))
          (s || !shouldSkip(typeOf(g[T]))) && E.push([m(T), m(g[T])]);
        return P;
      }
      case DATE:
        return c([v, g.toISOString()], g);
      case REGEXP: {
        const { source: E, flags: P } = g;
        return c([v, { source: E, flags: P }], g);
      }
      case MAP: {
        const E = [], P = c([v, E], g);
        for (const [T, N] of g)
          (s || !(shouldSkip(typeOf(T)) || shouldSkip(typeOf(N)))) && E.push([m(T), m(N)]);
        return P;
      }
      case SET: {
        const E = [], P = c([v, E], g);
        for (const T of g)
          (s || !shouldSkip(typeOf(T))) && E.push(m(T));
        return P;
      }
    }
    const { message: S } = g;
    return c([v, { name: b, message: S }], g);
  };
  return m;
}, serialize$1 = (s, { json: o, lossy: l } = {}) => {
  const u = [];
  return serializer(!(o || l), !!o, /* @__PURE__ */ new Map(), u)(s), u;
}, structuredClone$1 = typeof structuredClone == "function" ? (
  /* c8 ignore start */
  (s, o) => o && ("json" in o || "lossy" in o) ? deserialize(serialize$1(s, o)) : structuredClone(s)
) : (s, o) => deserialize(serialize$1(s, o));
function defaultFootnoteBackContent(s, o) {
  const l = [{ type: "text", value: "↩" }];
  return o > 1 && l.push({
    type: "element",
    tagName: "sup",
    properties: {},
    children: [{ type: "text", value: String(o) }]
  }), l;
}
function defaultFootnoteBackLabel(s, o) {
  return "Back to reference " + (s + 1) + (o > 1 ? "-" + o : "");
}
function footer(s) {
  const o = typeof s.options.clobberPrefix == "string" ? s.options.clobberPrefix : "user-content-", l = s.options.footnoteBackContent || defaultFootnoteBackContent, u = s.options.footnoteBackLabel || defaultFootnoteBackLabel, c = s.options.footnoteLabel || "Footnotes", m = s.options.footnoteLabelTagName || "h2", g = s.options.footnoteLabelProperties || {
    className: ["sr-only"]
  }, v = [];
  let b = -1;
  for (; ++b < s.footnoteOrder.length; ) {
    const S = s.footnoteById.get(
      s.footnoteOrder[b]
    );
    if (!S)
      continue;
    const E = s.all(S), P = String(S.identifier).toUpperCase(), T = normalizeUri(P.toLowerCase());
    let N = 0;
    const O = [], z = s.footnoteCounts.get(P);
    for (; z !== void 0 && ++N <= z; ) {
      O.length > 0 && O.push({ type: "text", value: " " });
      let ue = typeof l == "string" ? l : l(b, N);
      typeof ue == "string" && (ue = { type: "text", value: ue }), O.push({
        type: "element",
        tagName: "a",
        properties: {
          href: "#" + o + "fnref-" + T + (N > 1 ? "-" + N : ""),
          dataFootnoteBackref: "",
          ariaLabel: typeof u == "string" ? u : u(b, N),
          className: ["data-footnote-backref"]
        },
        children: Array.isArray(ue) ? ue : [ue]
      });
    }
    const Q = E[E.length - 1];
    if (Q && Q.type === "element" && Q.tagName === "p") {
      const ue = Q.children[Q.children.length - 1];
      ue && ue.type === "text" ? ue.value += " " : Q.children.push({ type: "text", value: " " }), Q.children.push(...O);
    } else
      E.push(...O);
    const W = {
      type: "element",
      tagName: "li",
      properties: { id: o + "fn-" + T },
      children: s.wrap(E, !0)
    };
    s.patch(S, W), v.push(W);
  }
  if (v.length !== 0)
    return {
      type: "element",
      tagName: "section",
      properties: { dataFootnotes: !0, className: ["footnotes"] },
      children: [
        {
          type: "element",
          tagName: m,
          properties: {
            ...structuredClone$1(g),
            id: "footnote-label"
          },
          children: [{ type: "text", value: c }]
        },
        { type: "text", value: `
` },
        {
          type: "element",
          tagName: "ol",
          properties: {},
          children: s.wrap(v, !0)
        },
        { type: "text", value: `
` }
      ]
    };
}
const convert = (
  // Note: overloads in JSDoc can’t yet use different `@template`s.
  /**
   * @type {(
   *   (<Condition extends string>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & {type: Condition}) &
   *   (<Condition extends Props>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Condition) &
   *   (<Condition extends TestFunction>(test: Condition) => (node: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node & Predicate<Condition, Node>) &
   *   ((test?: null | undefined) => (node?: unknown, index?: number | null | undefined, parent?: Parent | null | undefined, context?: unknown) => node is Node) &
   *   ((test?: Test) => Check)
   * )}
   */
  /**
   * @param {Test} [test]
   * @returns {Check}
   */
  function(s) {
    if (s == null)
      return ok;
    if (typeof s == "function")
      return castFactory(s);
    if (typeof s == "object")
      return Array.isArray(s) ? anyFactory(s) : propsFactory(s);
    if (typeof s == "string")
      return typeFactory(s);
    throw new Error("Expected function, string, or object as test");
  }
);
function anyFactory(s) {
  const o = [];
  let l = -1;
  for (; ++l < s.length; )
    o[l] = convert(s[l]);
  return castFactory(u);
  function u(...c) {
    let m = -1;
    for (; ++m < o.length; )
      if (o[m].apply(this, c)) return !0;
    return !1;
  }
}
function propsFactory(s) {
  const o = (
    /** @type {Record<string, unknown>} */
    s
  );
  return castFactory(l);
  function l(u) {
    const c = (
      /** @type {Record<string, unknown>} */
      /** @type {unknown} */
      u
    );
    let m;
    for (m in s)
      if (c[m] !== o[m]) return !1;
    return !0;
  }
}
function typeFactory(s) {
  return castFactory(o);
  function o(l) {
    return l && l.type === s;
  }
}
function castFactory(s) {
  return o;
  function o(l, u, c) {
    return !!(looksLikeANode(l) && s.call(
      this,
      l,
      typeof u == "number" ? u : void 0,
      c || void 0
    ));
  }
}
function ok() {
  return !0;
}
function looksLikeANode(s) {
  return s !== null && typeof s == "object" && "type" in s;
}
function color(s) {
  return s;
}
const empty$1 = [], CONTINUE = !0, EXIT = !1, SKIP = "skip";
function visitParents(s, o, l, u) {
  let c;
  typeof o == "function" && typeof l != "function" ? (u = l, l = o) : c = o;
  const m = convert(c), g = u ? -1 : 1;
  v(s, void 0, [])();
  function v(b, S, E) {
    const P = (
      /** @type {Record<string, unknown>} */
      b && typeof b == "object" ? b : {}
    );
    if (typeof P.type == "string") {
      const N = (
        // `hast`
        typeof P.tagName == "string" ? P.tagName : (
          // `xast`
          typeof P.name == "string" ? P.name : void 0
        )
      );
      Object.defineProperty(T, "name", {
        value: "node (" + (b.type + (N ? "<" + N + ">" : "")) + ")"
      });
    }
    return T;
    function T() {
      let N = empty$1, O, z, Q;
      if ((!o || m(b, S, E[E.length - 1] || void 0)) && (N = toResult(l(b, E)), N[0] === EXIT))
        return N;
      if ("children" in b && b.children) {
        const W = (
          /** @type {UnistParent} */
          b
        );
        if (W.children && N[0] !== SKIP)
          for (z = (u ? W.children.length : -1) + g, Q = E.concat(W); z > -1 && z < W.children.length; ) {
            const ue = W.children[z];
            if (O = v(ue, z, Q)(), O[0] === EXIT)
              return O;
            z = typeof O[1] == "number" ? O[1] : z + g;
          }
      }
      return N;
    }
  }
}
function toResult(s) {
  return Array.isArray(s) ? s : typeof s == "number" ? [CONTINUE, s] : s == null ? empty$1 : [s];
}
function visit(s, o, l, u) {
  let c, m, g;
  typeof o == "function" && typeof l != "function" ? (m = void 0, g = o, c = l) : (m = o, g = l, c = u), visitParents(s, m, v, c);
  function v(b, S) {
    const E = S[S.length - 1], P = E ? E.children.indexOf(b) : void 0;
    return g(b, P, E);
  }
}
const own$6 = {}.hasOwnProperty, emptyOptions$2 = {};
function createState$1(s, o) {
  const l = o || emptyOptions$2, u = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), m = /* @__PURE__ */ new Map(), g = { ...handlers$1, ...l.handlers }, v = {
    all: S,
    applyData,
    definitionById: u,
    footnoteById: c,
    footnoteCounts: m,
    footnoteOrder: [],
    handlers: g,
    one: b,
    options: l,
    patch: patch$1,
    wrap: wrap$1
  };
  return visit(s, function(E) {
    if (E.type === "definition" || E.type === "footnoteDefinition") {
      const P = E.type === "definition" ? u : c, T = String(E.identifier).toUpperCase();
      P.has(T) || P.set(T, E);
    }
  }), v;
  function b(E, P) {
    const T = E.type, N = v.handlers[T];
    if (own$6.call(v.handlers, T) && N)
      return N(v, E, P);
    if (v.options.passThrough && v.options.passThrough.includes(T)) {
      if ("children" in E) {
        const { children: z, ...Q } = E, W = structuredClone$1(Q);
        return W.children = v.all(E), W;
      }
      return structuredClone$1(E);
    }
    return (v.options.unknownHandler || defaultUnknownHandler)(v, E, P);
  }
  function S(E) {
    const P = [];
    if ("children" in E) {
      const T = E.children;
      let N = -1;
      for (; ++N < T.length; ) {
        const O = v.one(T[N], E);
        if (O) {
          if (N && T[N - 1].type === "break" && (!Array.isArray(O) && O.type === "text" && (O.value = trimMarkdownSpaceStart(O.value)), !Array.isArray(O) && O.type === "element")) {
            const z = O.children[0];
            z && z.type === "text" && (z.value = trimMarkdownSpaceStart(z.value));
          }
          Array.isArray(O) ? P.push(...O) : P.push(O);
        }
      }
    }
    return P;
  }
}
function patch$1(s, o) {
  s.position && (o.position = position(s));
}
function applyData(s, o) {
  let l = o;
  if (s && s.data) {
    const u = s.data.hName, c = s.data.hChildren, m = s.data.hProperties;
    if (typeof u == "string")
      if (l.type === "element")
        l.tagName = u;
      else {
        const g = "children" in l ? l.children : [l];
        l = { type: "element", tagName: u, properties: {}, children: g };
      }
    l.type === "element" && m && Object.assign(l.properties, structuredClone$1(m)), "children" in l && l.children && c !== null && c !== void 0 && (l.children = c);
  }
  return l;
}
function defaultUnknownHandler(s, o) {
  const l = o.data || {}, u = "value" in o && !(own$6.call(l, "hProperties") || own$6.call(l, "hChildren")) ? { type: "text", value: o.value } : {
    type: "element",
    tagName: "div",
    properties: {},
    children: s.all(o)
  };
  return s.patch(o, u), s.applyData(o, u);
}
function wrap$1(s, o) {
  const l = [];
  let u = -1;
  for (o && l.push({ type: "text", value: `
` }); ++u < s.length; )
    u && l.push({ type: "text", value: `
` }), l.push(s[u]);
  return o && s.length > 0 && l.push({ type: "text", value: `
` }), l;
}
function trimMarkdownSpaceStart(s) {
  let o = 0, l = s.charCodeAt(o);
  for (; l === 9 || l === 32; )
    o++, l = s.charCodeAt(o);
  return s.slice(o);
}
function toHast(s, o) {
  const l = createState$1(s, o), u = l.one(s, void 0), c = footer(l), m = Array.isArray(u) ? { type: "root", children: u } : u || { type: "root", children: [] };
  return c && m.children.push({ type: "text", value: `
` }, c), m;
}
function remarkRehype(s, o) {
  return s && "run" in s ? async function(l, u) {
    const c = (
      /** @type {HastRoot} */
      toHast(l, { file: u, ...o })
    );
    await s.run(c, u);
  } : function(l, u) {
    return (
      /** @type {HastRoot} */
      toHast(l, { file: u, ...o || s })
    );
  };
}
function bail(s) {
  if (s)
    throw s;
}
var hasOwn = Object.prototype.hasOwnProperty, toStr = Object.prototype.toString, defineProperty = Object.defineProperty, gOPD = Object.getOwnPropertyDescriptor, isArray = function s(o) {
  return typeof Array.isArray == "function" ? Array.isArray(o) : toStr.call(o) === "[object Array]";
}, isPlainObject$1 = function s(o) {
  if (!o || toStr.call(o) !== "[object Object]")
    return !1;
  var l = hasOwn.call(o, "constructor"), u = o.constructor && o.constructor.prototype && hasOwn.call(o.constructor.prototype, "isPrototypeOf");
  if (o.constructor && !l && !u)
    return !1;
  var c;
  for (c in o)
    ;
  return typeof c > "u" || hasOwn.call(o, c);
}, setProperty = function s(o, l) {
  defineProperty && l.name === "__proto__" ? defineProperty(o, l.name, {
    enumerable: !0,
    configurable: !0,
    value: l.newValue,
    writable: !0
  }) : o[l.name] = l.newValue;
}, getProperty = function s(o, l) {
  if (l === "__proto__")
    if (hasOwn.call(o, l)) {
      if (gOPD)
        return gOPD(o, l).value;
    } else return;
  return o[l];
}, extend = function s() {
  var o, l, u, c, m, g, v = arguments[0], b = 1, S = arguments.length, E = !1;
  for (typeof v == "boolean" && (E = v, v = arguments[1] || {}, b = 2), (v == null || typeof v != "object" && typeof v != "function") && (v = {}); b < S; ++b)
    if (o = arguments[b], o != null)
      for (l in o)
        u = getProperty(v, l), c = getProperty(o, l), v !== c && (E && c && (isPlainObject$1(c) || (m = isArray(c))) ? (m ? (m = !1, g = u && isArray(u) ? u : []) : g = u && isPlainObject$1(u) ? u : {}, setProperty(v, { name: l, newValue: s(E, g, c) })) : typeof c < "u" && setProperty(v, { name: l, newValue: c }));
  return v;
};
const extend$1 = /* @__PURE__ */ getDefaultExportFromCjs(extend);
function isPlainObject(s) {
  if (typeof s != "object" || s === null)
    return !1;
  const o = Object.getPrototypeOf(s);
  return (o === null || o === Object.prototype || Object.getPrototypeOf(o) === null) && !(Symbol.toStringTag in s) && !(Symbol.iterator in s);
}
function trough() {
  const s = [], o = { run: l, use: u };
  return o;
  function l(...c) {
    let m = -1;
    const g = c.pop();
    if (typeof g != "function")
      throw new TypeError("Expected function as last argument, not " + g);
    v(null, ...c);
    function v(b, ...S) {
      const E = s[++m];
      let P = -1;
      if (b) {
        g(b);
        return;
      }
      for (; ++P < c.length; )
        (S[P] === null || S[P] === void 0) && (S[P] = c[P]);
      c = S, E ? wrap(E, v)(...S) : g(null, ...S);
    }
  }
  function u(c) {
    if (typeof c != "function")
      throw new TypeError(
        "Expected `middelware` to be a function, not " + c
      );
    return s.push(c), o;
  }
}
function wrap(s, o) {
  let l;
  return u;
  function u(...g) {
    const v = s.length > g.length;
    let b;
    v && g.push(c);
    try {
      b = s.apply(this, g);
    } catch (S) {
      const E = (
        /** @type {Error} */
        S
      );
      if (v && l)
        throw E;
      return c(E);
    }
    v || (b && b.then && typeof b.then == "function" ? b.then(m, c) : b instanceof Error ? c(b) : m(b));
  }
  function c(g, ...v) {
    l || (l = !0, o(g, ...v));
  }
  function m(g) {
    c(null, g);
  }
}
const CallableInstance = (
  /**
   * @type {new <Parameters extends Array<unknown>, Result>(property: string | symbol) => (...parameters: Parameters) => Result}
   */
  /** @type {unknown} */
  /**
   * @this {Function}
   * @param {string | symbol} property
   * @returns {(...parameters: Array<unknown>) => unknown}
   */
  function(s) {
    const u = (
      /** @type {Record<string | symbol, Function>} */
      // Prototypes do exist.
      // type-coverage:ignore-next-line
      this.constructor.prototype
    ), c = u[s], m = function() {
      return c.apply(m, arguments);
    };
    return Object.setPrototypeOf(m, u), m;
  }
), own$5 = {}.hasOwnProperty;
class Processor extends CallableInstance {
  /**
   * Create a processor.
   */
  constructor() {
    super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = trough();
  }
  /**
   * Copy a processor.
   *
   * @deprecated
   *   This is a private internal method and should not be used.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   New *unfrozen* processor ({@linkcode Processor}) that is
   *   configured to work the same as its ancestor.
   *   When the descendant processor is configured in the future it does not
   *   affect the ancestral processor.
   */
  copy() {
    const o = (
      /** @type {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>} */
      new Processor()
    );
    let l = -1;
    for (; ++l < this.attachers.length; ) {
      const u = this.attachers[l];
      o.use(...u);
    }
    return o.data(extend$1(!0, {}, this.namespace)), o;
  }
  /**
   * Configure the processor with info available to all plugins.
   * Information is stored in an object.
   *
   * Typically, options can be given to a specific plugin, but sometimes it
   * makes sense to have information shared with several plugins.
   * For example, a list of HTML elements that are self-closing, which is
   * needed during all phases.
   *
   * > **Note**: setting information cannot occur on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * > **Note**: to register custom data in TypeScript, augment the
   * > {@linkcode Data} interface.
   *
   * @example
   *   This example show how to get and set info:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   const processor = unified().data('alpha', 'bravo')
   *
   *   processor.data('alpha') // => 'bravo'
   *
   *   processor.data() // => {alpha: 'bravo'}
   *
   *   processor.data({charlie: 'delta'})
   *
   *   processor.data() // => {charlie: 'delta'}
   *   ```
   *
   * @template {keyof Data} Key
   *
   * @overload
   * @returns {Data}
   *
   * @overload
   * @param {Data} dataset
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Key} key
   * @returns {Data[Key]}
   *
   * @overload
   * @param {Key} key
   * @param {Data[Key]} value
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @param {Data | Key} [key]
   *   Key to get or set, or entire dataset to set, or nothing to get the
   *   entire dataset (optional).
   * @param {Data[Key]} [value]
   *   Value to set (optional).
   * @returns {unknown}
   *   The current processor when setting, the value at `key` when getting, or
   *   the entire dataset when getting without key.
   */
  data(o, l) {
    return typeof o == "string" ? arguments.length === 2 ? (assertUnfrozen("data", this.frozen), this.namespace[o] = l, this) : own$5.call(this.namespace, o) && this.namespace[o] || void 0 : o ? (assertUnfrozen("data", this.frozen), this.namespace = o, this) : this.namespace;
  }
  /**
   * Freeze a processor.
   *
   * Frozen processors are meant to be extended and not to be configured
   * directly.
   *
   * When a processor is frozen it cannot be unfrozen.
   * New processors working the same way can be created by calling the
   * processor.
   *
   * It’s possible to freeze processors explicitly by calling `.freeze()`.
   * Processors freeze automatically when `.parse()`, `.run()`, `.runSync()`,
   * `.stringify()`, `.process()`, or `.processSync()` are called.
   *
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   The current processor.
   */
  freeze() {
    if (this.frozen)
      return this;
    const o = (
      /** @type {Processor} */
      /** @type {unknown} */
      this
    );
    for (; ++this.freezeIndex < this.attachers.length; ) {
      const [l, ...u] = this.attachers[this.freezeIndex];
      if (u[0] === !1)
        continue;
      u[0] === !0 && (u[0] = void 0);
      const c = l.call(o, ...u);
      typeof c == "function" && this.transformers.use(c);
    }
    return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this;
  }
  /**
   * Parse text to a syntax tree.
   *
   * > **Note**: `parse` freezes the processor if not already *frozen*.
   *
   * > **Note**: `parse` performs the parse phase, not the run phase or other
   * > phases.
   *
   * @param {Compatible | undefined} [file]
   *   file to parse (optional); typically `string` or `VFile`; any value
   *   accepted as `x` in `new VFile(x)`.
   * @returns {ParseTree extends undefined ? Node : ParseTree}
   *   Syntax tree representing `file`.
   */
  parse(o) {
    this.freeze();
    const l = vfile(o), u = this.parser || this.Parser;
    return assertParser("parse", u), u(String(l), l);
  }
  /**
   * Process the given file as configured on the processor.
   *
   * > **Note**: `process` freezes the processor if not already *frozen*.
   *
   * > **Note**: `process` performs the parse, run, and stringify phases.
   *
   * @overload
   * @param {Compatible | undefined} file
   * @param {ProcessCallback<VFileWithOutput<CompileResult>>} done
   * @returns {undefined}
   *
   * @overload
   * @param {Compatible | undefined} [file]
   * @returns {Promise<VFileWithOutput<CompileResult>>}
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`]; any value accepted as
   *   `x` in `new VFile(x)`.
   * @param {ProcessCallback<VFileWithOutput<CompileResult>> | undefined} [done]
   *   Callback (optional).
   * @returns {Promise<VFile> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise a promise, rejected with a fatal error or resolved with the
   *   processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  process(o, l) {
    const u = this;
    return this.freeze(), assertParser("process", this.parser || this.Parser), assertCompiler("process", this.compiler || this.Compiler), l ? c(void 0, l) : new Promise(c);
    function c(m, g) {
      const v = vfile(o), b = (
        /** @type {HeadTree extends undefined ? Node : HeadTree} */
        /** @type {unknown} */
        u.parse(v)
      );
      u.run(b, v, function(E, P, T) {
        if (E || !P || !T)
          return S(E);
        const N = (
          /** @type {CompileTree extends undefined ? Node : CompileTree} */
          /** @type {unknown} */
          P
        ), O = u.stringify(N, T);
        looksLikeAValue(O) ? T.value = O : T.result = O, S(
          E,
          /** @type {VFileWithOutput<CompileResult>} */
          T
        );
      });
      function S(E, P) {
        E || !P ? g(E) : m ? m(P) : l(void 0, P);
      }
    }
  }
  /**
   * Process the given file as configured on the processor.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `processSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `processSync` performs the parse, run, and stringify phases.
   *
   * @param {Compatible | undefined} [file]
   *   File (optional); typically `string` or `VFile`; any value accepted as
   *   `x` in `new VFile(x)`.
   * @returns {VFileWithOutput<CompileResult>}
   *   The processed file.
   *
   *   The parsed, transformed, and compiled value is available at
   *   `file.value` (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most
   *   > compilers return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  processSync(o) {
    let l = !1, u;
    return this.freeze(), assertParser("processSync", this.parser || this.Parser), assertCompiler("processSync", this.compiler || this.Compiler), this.process(o, c), assertDone("processSync", "process", l), u;
    function c(m, g) {
      l = !0, bail(m), u = g;
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * > **Note**: `run` freezes the processor if not already *frozen*.
   *
   * > **Note**: `run` performs the run phase, not other phases.
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} file
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} done
   * @returns {undefined}
   *
   * @overload
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   * @param {Compatible | undefined} [file]
   * @returns {Promise<TailTree extends undefined ? Node : TailTree>}
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {(
   *   RunCallback<TailTree extends undefined ? Node : TailTree> |
   *   Compatible
   * )} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @param {RunCallback<TailTree extends undefined ? Node : TailTree>} [done]
   *   Callback (optional).
   * @returns {Promise<TailTree extends undefined ? Node : TailTree> | undefined}
   *   Nothing if `done` is given.
   *   Otherwise, a promise rejected with a fatal error or resolved with the
   *   transformed tree.
   */
  run(o, l, u) {
    assertNode(o), this.freeze();
    const c = this.transformers;
    return !u && typeof l == "function" && (u = l, l = void 0), u ? m(void 0, u) : new Promise(m);
    function m(g, v) {
      const b = vfile(l);
      c.run(o, b, S);
      function S(E, P, T) {
        const N = (
          /** @type {TailTree extends undefined ? Node : TailTree} */
          P || o
        );
        E ? v(E) : g ? g(N) : u(void 0, N, T);
      }
    }
  }
  /**
   * Run *transformers* on a syntax tree.
   *
   * An error is thrown if asynchronous transforms are configured.
   *
   * > **Note**: `runSync` freezes the processor if not already *frozen*.
   *
   * > **Note**: `runSync` performs the run phase, not other phases.
   *
   * @param {HeadTree extends undefined ? Node : HeadTree} tree
   *   Tree to transform and inspect.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {TailTree extends undefined ? Node : TailTree}
   *   Transformed tree.
   */
  runSync(o, l) {
    let u = !1, c;
    return this.run(o, l, m), assertDone("runSync", "run", u), c;
    function m(g, v) {
      bail(g), c = v, u = !0;
    }
  }
  /**
   * Compile a syntax tree.
   *
   * > **Note**: `stringify` freezes the processor if not already *frozen*.
   *
   * > **Note**: `stringify` performs the stringify phase, not the run phase
   * > or other phases.
   *
   * @param {CompileTree extends undefined ? Node : CompileTree} tree
   *   Tree to compile.
   * @param {Compatible | undefined} [file]
   *   File associated with `node` (optional); any value accepted as `x` in
   *   `new VFile(x)`.
   * @returns {CompileResult extends undefined ? Value : CompileResult}
   *   Textual representation of the tree (see note).
   *
   *   > **Note**: unified typically compiles by serializing: most compilers
   *   > return `string` (or `Uint8Array`).
   *   > Some compilers, such as the one configured with
   *   > [`rehype-react`][rehype-react], return other values (in this case, a
   *   > React tree).
   *   > If you’re using a compiler that doesn’t serialize, expect different
   *   > result values.
   *   >
   *   > To register custom results in TypeScript, add them to
   *   > {@linkcode CompileResultMap}.
   *
   *   [rehype-react]: https://github.com/rehypejs/rehype-react
   */
  stringify(o, l) {
    this.freeze();
    const u = vfile(l), c = this.compiler || this.Compiler;
    return assertCompiler("stringify", c), assertNode(o), c(o, u);
  }
  /**
   * Configure the processor to use a plugin, a list of usable values, or a
   * preset.
   *
   * If the processor is already using a plugin, the previous plugin
   * configuration is changed based on the options that are passed in.
   * In other words, the plugin is not added a second time.
   *
   * > **Note**: `use` cannot be called on *frozen* processors.
   * > Call the processor first to create a new unfrozen processor.
   *
   * @example
   *   There are many ways to pass plugins to `.use()`.
   *   This example gives an overview:
   *
   *   ```js
   *   import {unified} from 'unified'
   *
   *   unified()
   *     // Plugin with options:
   *     .use(pluginA, {x: true, y: true})
   *     // Passing the same plugin again merges configuration (to `{x: true, y: false, z: true}`):
   *     .use(pluginA, {y: false, z: true})
   *     // Plugins:
   *     .use([pluginB, pluginC])
   *     // Two plugins, the second with options:
   *     .use([pluginD, [pluginE, {}]])
   *     // Preset with plugins and settings:
   *     .use({plugins: [pluginF, [pluginG, {}]], settings: {position: false}})
   *     // Settings only:
   *     .use({settings: {position: false}})
   *   ```
   *
   * @template {Array<unknown>} [Parameters=[]]
   * @template {Node | string | undefined} [Input=undefined]
   * @template [Output=Input]
   *
   * @overload
   * @param {Preset | null | undefined} [preset]
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {PluggableList} list
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *
   * @overload
   * @param {Plugin<Parameters, Input, Output>} plugin
   * @param {...(Parameters | [boolean])} parameters
   * @returns {UsePlugin<ParseTree, HeadTree, TailTree, CompileTree, CompileResult, Input, Output>}
   *
   * @param {PluggableList | Plugin | Preset | null | undefined} value
   *   Usable value.
   * @param {...unknown} parameters
   *   Parameters, when a plugin is given as a usable value.
   * @returns {Processor<ParseTree, HeadTree, TailTree, CompileTree, CompileResult>}
   *   Current processor.
   */
  use(o, ...l) {
    const u = this.attachers, c = this.namespace;
    if (assertUnfrozen("use", this.frozen), o != null) if (typeof o == "function")
      b(o, l);
    else if (typeof o == "object")
      Array.isArray(o) ? v(o) : g(o);
    else
      throw new TypeError("Expected usable value, not `" + o + "`");
    return this;
    function m(S) {
      if (typeof S == "function")
        b(S, []);
      else if (typeof S == "object")
        if (Array.isArray(S)) {
          const [E, ...P] = (
            /** @type {PluginTuple<Array<unknown>>} */
            S
          );
          b(E, P);
        } else
          g(S);
      else
        throw new TypeError("Expected usable value, not `" + S + "`");
    }
    function g(S) {
      if (!("plugins" in S) && !("settings" in S))
        throw new Error(
          "Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"
        );
      v(S.plugins), S.settings && (c.settings = extend$1(!0, c.settings, S.settings));
    }
    function v(S) {
      let E = -1;
      if (S != null) if (Array.isArray(S))
        for (; ++E < S.length; ) {
          const P = S[E];
          m(P);
        }
      else
        throw new TypeError("Expected a list of plugins, not `" + S + "`");
    }
    function b(S, E) {
      let P = -1, T = -1;
      for (; ++P < u.length; )
        if (u[P][0] === S) {
          T = P;
          break;
        }
      if (T === -1)
        u.push([S, ...E]);
      else if (E.length > 0) {
        let [N, ...O] = E;
        const z = u[T][1];
        isPlainObject(z) && isPlainObject(N) && (N = extend$1(!0, z, N)), u[T] = [S, N, ...O];
      }
    }
  }
}
const unified = new Processor().freeze();
function assertParser(s, o) {
  if (typeof o != "function")
    throw new TypeError("Cannot `" + s + "` without `parser`");
}
function assertCompiler(s, o) {
  if (typeof o != "function")
    throw new TypeError("Cannot `" + s + "` without `compiler`");
}
function assertUnfrozen(s, o) {
  if (o)
    throw new Error(
      "Cannot call `" + s + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`."
    );
}
function assertNode(s) {
  if (!isPlainObject(s) || typeof s.type != "string")
    throw new TypeError("Expected node, got `" + s + "`");
}
function assertDone(s, o, l) {
  if (!l)
    throw new Error(
      "`" + s + "` finished async. Use `" + o + "` instead"
    );
}
function vfile(s) {
  return looksLikeAVFile(s) ? s : new VFile(s);
}
function looksLikeAVFile(s) {
  return !!(s && typeof s == "object" && "message" in s && "messages" in s);
}
function looksLikeAValue(s) {
  return typeof s == "string" || isUint8Array(s);
}
function isUint8Array(s) {
  return !!(s && typeof s == "object" && "byteLength" in s && "byteOffset" in s);
}
class WalkerBase {
  constructor() {
    this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (o) => this.replacement = o
    };
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   * @param {Node} node
   */
  replace(o, l, u, c) {
    o && l && (u != null ? o[l][u] = c : o[l] = c);
  }
  /**
   * @template {Node} Parent
   * @param {Parent | null | undefined} parent
   * @param {keyof Parent | null | undefined} prop
   * @param {number | null | undefined} index
   */
  remove(o, l, u) {
    o && l && (u != null ? o[l].splice(u, 1) : delete o[l]);
  }
}
class SyncWalker extends WalkerBase {
  /**
   *
   * @param {SyncHandler} [enter]
   * @param {SyncHandler} [leave]
   */
  constructor(o, l) {
    super(), this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.context = {
      skip: () => this.should_skip = !0,
      remove: () => this.should_remove = !0,
      replace: (u) => this.replacement = u
    }, this.enter = o, this.leave = l;
  }
  /**
   * @template {Node} Parent
   * @param {Node} node
   * @param {Parent | null} parent
   * @param {keyof Parent} [prop]
   * @param {number | null} [index]
   * @returns {Node | null}
   */
  visit(o, l, u, c) {
    if (o) {
      if (this.enter) {
        const g = this.should_skip, v = this.should_remove, b = this.replacement;
        this.should_skip = !1, this.should_remove = !1, this.replacement = null, this.enter.call(this.context, o, l, u, c), this.replacement && (o = this.replacement, this.replace(l, u, c, o)), this.should_remove && this.remove(l, u, c);
        const S = this.should_skip, E = this.should_remove;
        if (this.should_skip = g, this.should_remove = v, this.replacement = b, S) return o;
        if (E) return null;
      }
      let m;
      for (m in o) {
        const g = o[m];
        if (g && typeof g == "object")
          if (Array.isArray(g)) {
            const v = (
              /** @type {Array<unknown>} */
              g
            );
            for (let b = 0; b < v.length; b += 1) {
              const S = v[b];
              isNode(S) && (this.visit(S, o, m, b) || b--);
            }
          } else isNode(g) && this.visit(g, o, m, null);
      }
      if (this.leave) {
        const g = this.replacement, v = this.should_remove;
        this.replacement = null, this.should_remove = !1, this.leave.call(this.context, o, l, u, c), this.replacement && (o = this.replacement, this.replace(l, u, c, o)), this.should_remove && this.remove(l, u, c);
        const b = this.should_remove;
        if (this.replacement = g, this.should_remove = v, b) return null;
      }
    }
    return o;
  }
}
function isNode(s) {
  return s !== null && typeof s == "object" && "type" in s && typeof s.type == "string";
}
function walk$1(s, { enter: o, leave: l }) {
  return new SyncWalker(o, l).visit(s, null);
}
function is_reference(s, o) {
  if (s.type === "MemberExpression")
    return !s.computed && is_reference(s.object, s);
  if (s.type === "Identifier") {
    if (!o) return !0;
    switch (o.type) {
      case "MemberExpression":
        return o.computed || s === o.object;
      case "MethodDefinition":
        return o.computed;
      case "PropertyDefinition":
        return o.computed || s === o.value;
      case "Property":
        return o.computed || s === o.value;
      case "ExportSpecifier":
      case "ImportSpecifier":
        return s === o.local;
      case "LabeledStatement":
      case "BreakStatement":
      case "ContinueStatement":
        return !1;
      default:
        return !0;
    }
  }
  return !1;
}
function analyze(s) {
  const o = /* @__PURE__ */ new WeakMap(), l = /* @__PURE__ */ new Map(), u = new Scope(null, !1), c = [];
  let m = u;
  walk$1(s, {
    enter(g, v) {
      switch (g.type) {
        case "Identifier":
          v && is_reference(g, v) && c.push([m, g]);
          break;
        case "ImportDeclaration":
          g.specifiers.forEach((b) => {
            m.declarations.set(b.local.name, b);
          });
          break;
        case "FunctionExpression":
        case "FunctionDeclaration":
        case "ArrowFunctionExpression":
          g.type === "FunctionDeclaration" ? (g.id && m.declarations.set(g.id.name, g), o.set(g, m = new Scope(m, !1))) : (o.set(g, m = new Scope(m, !1)), g.type === "FunctionExpression" && g.id && m.declarations.set(g.id.name, g)), g.params.forEach((b) => {
            extract_names(b).forEach((S) => {
              m.declarations.set(S, g);
            });
          });
          break;
        case "ForStatement":
        case "ForInStatement":
        case "ForOfStatement":
          o.set(g, m = new Scope(m, !0));
          break;
        case "BlockStatement":
          o.set(g, m = new Scope(m, !0));
          break;
        case "ClassDeclaration":
        case "VariableDeclaration":
          m.add_declaration(g);
          break;
        case "CatchClause":
          o.set(g, m = new Scope(m, !0)), g.param && extract_names(g.param).forEach((b) => {
            g.param && m.declarations.set(b, g.param);
          });
          break;
      }
    },
    leave(g) {
      o.has(g) && m !== null && m.parent && (m = m.parent);
    }
  });
  for (let g = c.length - 1; g >= 0; --g) {
    const [v, b] = c[g];
    v.references.has(b.name) || add_reference(v, b.name), v.find_owner(b.name) || l.set(b.name, b);
  }
  return { map: o, scope: u, globals: l };
}
function add_reference(s, o) {
  s.references.add(o), s.parent && add_reference(s.parent, o);
}
class Scope {
  /**
   * @param {Scope | null} parent 
   * @param {boolean} block 
   */
  constructor(o, l) {
    this.parent = o, this.block = l, this.declarations = /* @__PURE__ */ new Map(), this.initialised_declarations = /* @__PURE__ */ new Set(), this.references = /* @__PURE__ */ new Set();
  }
  /**
   * @param {import('estree').VariableDeclaration | import('estree').ClassDeclaration} node
   */
  add_declaration(o) {
    if (o.type === "VariableDeclaration")
      if (o.kind === "var" && this.block && this.parent)
        this.parent.add_declaration(o);
      else {
        const l = (u) => {
          extract_names(u.id).forEach((c) => {
            this.declarations.set(c, o), u.init && this.initialised_declarations.add(c);
          });
        };
        o.declarations.forEach(l);
      }
    else o.id && this.declarations.set(o.id.name, o);
  }
  /**
   * @param {string} name
   * @returns {Scope | null}
   */
  find_owner(o) {
    return this.declarations.has(o) ? this : this.parent && this.parent.find_owner(o);
  }
  /**
   * @param {string} name
   * @returns {boolean}
   */
  has(o) {
    return this.declarations.has(o) || !!this.parent && this.parent.has(o);
  }
}
function extract_names(s) {
  return extract_identifiers(s).map((o) => o.name);
}
function extract_identifiers(s, o = []) {
  switch (s.type) {
    case "Identifier":
      o.push(s);
      break;
    case "MemberExpression":
      let l = s;
      for (; l.type === "MemberExpression"; )
        l = /** @type {any} */
        l.object;
      o.push(
        /** @type {any} */
        l
      );
      break;
    case "ObjectPattern":
      const u = (m) => {
        m.type === "RestElement" ? extract_identifiers(m.argument, o) : extract_identifiers(m.value, o);
      };
      s.properties.forEach(u);
      break;
    case "ArrayPattern":
      const c = (m) => {
        m && extract_identifiers(m, o);
      };
      s.elements.forEach((m) => {
        m && c(m);
      });
      break;
    case "RestElement":
      extract_identifiers(s.argument, o);
      break;
    case "AssignmentPattern":
      extract_identifiers(s.left, o);
      break;
  }
  return o;
}
function create$2(s, o) {
  const l = ["start", "end", "loc", "range", "comments"];
  let u = -1;
  for (; ++u < l.length; ) {
    const c = l[u];
    c in s && (o[c] = s[c]);
  }
}
function declarationToExpression(s) {
  return s.type === "FunctionDeclaration" ? { ...s, type: "FunctionExpression" } : (s.type, { ...s, type: "ClassExpression" });
}
function isDeclaration(s) {
  return s.type === "FunctionDeclaration" || s.type === "ClassDeclaration" || s.type === "VariableDeclaration";
}
function specifiersToDeclarations(s, o) {
  let l = -1;
  const u = [], c = [];
  let m;
  for (; ++l < s.length; ) {
    const g = s[l];
    g.type === "ImportNamespaceSpecifier" ? m = g : c.push(g);
  }
  if (m) {
    const g = {
      type: "VariableDeclarator",
      id: m.local,
      init: o
    };
    create$2(m, g), u.push(g);
  }
  return u.push({
    type: "VariableDeclarator",
    id: {
      type: "ObjectPattern",
      properties: c.map(function(g) {
        let v = g.type === "ImportSpecifier" ? g.imported : g.type === "ExportSpecifier" ? g.exported : { type: "Identifier", name: "default" }, b = g.local;
        g.type === "ExportSpecifier" && (b = v, v = g.local);
        const S = {
          type: "Property",
          kind: "init",
          shorthand: v.name === b.name,
          method: !1,
          computed: !1,
          key: v,
          value: b
        };
        return create$2(g, S), S;
      })
    },
    init: m ? { type: "Identifier", name: m.local.name } : o
  }), u;
}
function toIdOrMemberExpression(s) {
  let o = -1, l;
  for (; ++o < s.length; ) {
    const u = s[o], c = typeof u == "string" && name(u) ? { type: "Identifier", name: u } : { type: "Literal", value: u };
    l = l ? {
      type: "MemberExpression",
      object: l,
      property: c,
      computed: c.type === "Literal",
      optional: !1
    } : c;
  }
  return l.type, l;
}
function toJsxIdOrMemberExpression(s) {
  let o = -1, l;
  for (; ++o < s.length; ) {
    const u = s[o];
    typeof u == "string" && name(u, { jsx: !0 });
    const c = { type: "JSXIdentifier", name: u };
    l = l ? { type: "JSXMemberExpression", object: l, property: c } : c;
  }
  return l;
}
function recmaDocument(s) {
  const o = s.baseUrl || void 0, l = typeof o == "object" ? o.href : o, u = s.outputFormat || "program", c = s.pragma === void 0 ? "React.createElement" : s.pragma, m = s.pragmaFrag === void 0 ? "React.Fragment" : s.pragmaFrag, g = s.pragmaImportSource || "react", v = s.jsxImportSource || "react", b = s.jsxRuntime || "automatic";
  return function(E, P) {
    const T = [], N = [];
    let O = 0, z, Q, W;
    if (b === "classic" && m && injectPragma(E, "@jsxFrag", m), b === "classic" && c && injectPragma(E, "@jsx", c), b === "automatic" && v && injectPragma(E, "@jsxImportSource", v), b && injectPragma(E, "@jsxRuntime", b), b === "classic" && g) {
      if (!c)
        throw new Error(
          "Missing `pragma` in classic runtime with `pragmaImportSource`"
        );
      ve({
        type: "ImportDeclaration",
        specifiers: [
          {
            type: "ImportDefaultSpecifier",
            local: { type: "Identifier", name: c.split(".")[0] }
          }
        ],
        source: { type: "Literal", value: g }
      });
    }
    for (W of E.body)
      if (W.type === "ExportDefaultDeclaration")
        z && P.fail(
          "Unexpected duplicate layout, expected a single layout (previous: " + stringifyPosition(positionFromEstree(z)) + ")",
          {
            ancestors: [E, W],
            place: positionFromEstree(W),
            ruleId: "duplicate-layout",
            source: "recma-document"
          }
        ), z = W, N.push({
          type: "VariableDeclaration",
          kind: "const",
          declarations: [
            {
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "MDXLayout" },
              init: isDeclaration(W.declaration) ? declarationToExpression(W.declaration) : W.declaration
            }
          ]
        });
      else if (W.type === "ExportNamedDeclaration" && W.source) {
        const ee = (
          /** @type {SimpleLiteral} */
          W.source
        );
        W.specifiers = W.specifiers.filter(function(Re) {
          if (Re.exported.name === "default") {
            z && P.fail(
              "Unexpected duplicate layout, expected a single layout (previous: " + stringifyPosition(positionFromEstree(z)) + ")",
              {
                ancestors: [E, W, Re],
                place: positionFromEstree(W),
                ruleId: "duplicate-layout",
                source: "recma-document"
              }
            ), z = Re;
            const wt = [];
            if (Re.local.name === "default")
              wt.push({
                type: "ImportDefaultSpecifier",
                local: { type: "Identifier", name: "MDXLayout" }
              });
            else {
              const Kt = {
                type: "ImportSpecifier",
                imported: Re.local,
                local: { type: "Identifier", name: "MDXLayout" }
              };
              create$2(Re.local, Kt), wt.push(Kt);
            }
            const yt = { type: "Literal", value: ee.value };
            create$2(ee, yt);
            const xt = {
              type: "ImportDeclaration",
              specifiers: wt,
              source: yt
            };
            return create$2(Re, xt), ve(xt), !1;
          }
          return !0;
        }), W.specifiers.length > 0 && K(W);
      } else W.type === "ExportNamedDeclaration" || W.type === "ExportAllDeclaration" ? K(W) : W.type === "ImportDeclaration" ? ve(W) : W.type === "ExpressionStatement" && (W.expression.type === "JSXElement" || // @ts-expect-error: `estree-jsx` does not register `JSXFragment` as an expression.
      W.expression.type === "JSXFragment") ? (Q = !0, N.push(
        ...S(W.expression, u, !!z)
      )) : N.push(W);
    Q || N.push(
      ...S(void 0, u, !!z)
    ), T.push(["MDXContent", "default"]), u === "function-body" && N.push({
      type: "ReturnStatement",
      argument: {
        type: "ObjectExpression",
        properties: [
          ...Array.from({ length: O }).map(
            /**
             * @param {undefined} _
             *   Nothing.
             * @param {number} index
             *   Index.
             * @returns {SpreadElement}
             *   Node.
             */
            function(ee, Re) {
              return {
                type: "SpreadElement",
                argument: {
                  type: "Identifier",
                  name: "_exportAll" + (Re + 1)
                }
              };
            }
          ),
          ...T.map(function(ee) {
            return {
              type: "Property",
              kind: "init",
              method: !1,
              computed: !1,
              shorthand: typeof ee == "string",
              key: {
                type: "Identifier",
                name: typeof ee == "string" ? ee : ee[1]
              },
              value: {
                type: "Identifier",
                name: typeof ee == "string" ? ee : ee[0]
              }
            };
          })
        ]
      }
    }), E.body = N;
    let ue = !1, te = !1;
    (l || u === "function-body") && walk$1(E, {
      enter(ee) {
        if ((ee.type === "ExportAllDeclaration" || ee.type === "ExportNamedDeclaration" || ee.type === "ImportDeclaration") && ee.source) {
          let Re = ee.source.value;
          try {
            new URL(Re);
          } catch {
            (Re.startsWith("/") || Re.startsWith("./") || Re.startsWith("../")) && (Re = new URL(Re, l).href);
          }
          const wt = { type: "Literal", value: Re };
          create$2(ee.source, wt), ee.source = wt;
          return;
        }
        if (ee.type === "ImportExpression") {
          te = !0;
          const Re = {
            type: "CallExpression",
            callee: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
            arguments: [ee.source],
            optional: !1
          };
          ee.source = Re;
          return;
        }
        if (ee.type === "MemberExpression" && "object" in ee && ee.object.type === "MetaProperty" && ee.property.type === "Identifier" && ee.object.meta.name === "import" && ee.object.property.name === "meta" && ee.property.name === "url") {
          ue = !0;
          const Re = { type: "Identifier", name: "_importMetaUrl" };
          create$2(ee, Re), this.replace(Re);
        }
      }
    }), te && (l || (ue = !0), E.body.push(
      resolveDynamicMdxSpecifier(
        l ? { type: "Literal", value: l } : { type: "Identifier", name: "_importMetaUrl" }
      )
    )), ue && E.body.unshift(...createImportMetaUrlVariable());
    function K(ee) {
      if (ee.type === "ExportNamedDeclaration") {
        ee.declaration && T.push(
          ...analyze(ee.declaration).scope.declarations.keys()
        );
        for (W of ee.specifiers)
          T.push(W.exported.name);
      }
      ve(ee);
    }
    function ve(ee) {
      let Re, wt;
      if (u === "function-body")
        if (
          // Always have a source:
          ee.type === "ImportDeclaration" || ee.type === "ExportAllDeclaration" || // Source optional:
          ee.type === "ExportNamedDeclaration" && ee.source
        ) {
          ee.source;
          const yt = { type: "ImportExpression", source: ee.source };
          create$2(ee, yt), wt = { type: "AwaitExpression", argument: yt }, (ee.type === "ImportDeclaration" || ee.type === "ExportNamedDeclaration") && ee.specifiers.length === 0 ? Re = { type: "ExpressionStatement", expression: wt } : Re = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: ee.type === "ExportAllDeclaration" ? [
              {
                type: "VariableDeclarator",
                id: {
                  type: "Identifier",
                  name: "_exportAll" + ++O
                },
                init: wt
              }
            ] : specifiersToDeclarations(ee.specifiers, wt)
          };
        } else if (ee.declaration)
          Re = ee.declaration;
        else {
          const yt = ee.specifiers.filter(function(xt) {
            return xt.local.name !== xt.exported.name;
          }).map(function(xt) {
            return {
              type: "VariableDeclarator",
              id: xt.exported,
              init: xt.local
            };
          });
          yt.length > 0 && (Re = {
            type: "VariableDeclaration",
            kind: "const",
            declarations: yt
          });
        }
      else
        Re = ee;
      Re && N.push(Re);
    }
  };
  function S(E, P, T) {
    let O = {
      type: "JSXElement",
      openingElement: {
        type: "JSXOpeningElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" },
        attributes: [
          {
            type: "JSXSpreadAttribute",
            argument: { type: "Identifier", name: "props" }
          }
        ],
        selfClosing: !1
      },
      closingElement: {
        type: "JSXClosingElement",
        name: { type: "JSXIdentifier", name: "MDXLayout" }
      },
      children: [
        {
          type: "JSXElement",
          openingElement: {
            type: "JSXOpeningElement",
            name: { type: "JSXIdentifier", name: "_createMdxContent" },
            attributes: [
              {
                type: "JSXSpreadAttribute",
                argument: { type: "Identifier", name: "props" }
              }
            ],
            selfClosing: !0
          },
          closingElement: null,
          children: []
        }
      ]
    };
    T || (O = {
      type: "ConditionalExpression",
      test: { type: "Identifier", name: "MDXLayout" },
      consequent: O,
      alternate: {
        type: "CallExpression",
        callee: { type: "Identifier", name: "_createMdxContent" },
        arguments: [{ type: "Identifier", name: "props" }],
        optional: !1
      }
    });
    let z = (
      // Cast because TS otherwise does not think `JSXFragment`s are expressions.
      /** @type {Readonly<Expression> | Readonly<JSXFragment>} */
      E || { type: "Identifier", name: "undefined" }
    );
    z.type === "JSXFragment" && z.children.length === 1 && z.children[0].type === "JSXElement" && (z = z.children[0]);
    let Q = !1;
    walk$1(z, {
      enter(ue) {
        if (ue.type === "ArrowFunctionExpression" || ue.type === "FunctionDeclaration" || ue.type === "FunctionExpression")
          return this.skip();
        (ue.type === "AwaitExpression" || /* c8 ignore next 2 -- can only occur in a function (which then can
         * only be async, so skipped it) */
        ue.type === "ForOfStatement" && ue.await) && (Q = !0);
      }
    });
    const W = {
      type: "FunctionDeclaration",
      id: { type: "Identifier", name: "MDXContent" },
      params: [
        {
          type: "AssignmentPattern",
          left: { type: "Identifier", name: "props" },
          right: { type: "ObjectExpression", properties: [] }
        }
      ],
      body: {
        type: "BlockStatement",
        body: [{ type: "ReturnStatement", argument: O }]
      }
    };
    return [
      {
        type: "FunctionDeclaration",
        async: Q,
        id: { type: "Identifier", name: "_createMdxContent" },
        params: [{ type: "Identifier", name: "props" }],
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ReturnStatement",
              // Cast because TS doesn’t think `JSXFragment` is an expression.
              // eslint-disable-next-line object-shorthand
              argument: (
                /** @type {Expression} */
                z
              )
            }
          ]
        }
      },
      P === "program" ? { type: "ExportDefaultDeclaration", declaration: W } : W
    ];
  }
}
function injectPragma(s, o, l) {
  var u;
  (u = s.comments) == null || u.unshift({
    type: "Block",
    value: o + " " + l,
    data: { _mdxIsPragmaComment: !0 }
  });
}
function resolveDynamicMdxSpecifier(s) {
  return {
    type: "FunctionDeclaration",
    id: { type: "Identifier", name: "_resolveDynamicMdxSpecifier" },
    generator: !1,
    async: !1,
    params: [{ type: "Identifier", name: "d" }],
    body: {
      type: "BlockStatement",
      body: [
        {
          type: "IfStatement",
          test: {
            type: "BinaryExpression",
            left: {
              type: "UnaryExpression",
              operator: "typeof",
              prefix: !0,
              argument: { type: "Identifier", name: "d" }
            },
            operator: "!==",
            right: { type: "Literal", value: "string" }
          },
          consequent: {
            type: "ReturnStatement",
            argument: { type: "Identifier", name: "d" }
          },
          alternate: null
        },
        // To do: use `URL.canParse` when widely supported (see commented
        // out code below).
        {
          type: "TryStatement",
          block: {
            type: "BlockStatement",
            body: [
              {
                type: "ExpressionStatement",
                expression: {
                  type: "NewExpression",
                  callee: { type: "Identifier", name: "URL" },
                  arguments: [{ type: "Identifier", name: "d" }]
                }
              },
              {
                type: "ReturnStatement",
                argument: { type: "Identifier", name: "d" }
              }
            ]
          },
          handler: {
            type: "CatchClause",
            param: null,
            body: { type: "BlockStatement", body: [] }
          },
          finalizer: null
        },
        // To do: use `URL.canParse` when widely supported.
        // {
        //   type: 'IfStatement',
        //   test: {
        //     type: 'CallExpression',
        //     callee: toIdOrMemberExpression(['URL', 'canParse']),
        //     arguments: [{type: 'Identifier', name: 'd'}],
        //     optional: false
        //   },
        //   consequent: {
        //     type: 'ReturnStatement',
        //     argument: {type: 'Identifier', name: 'd'}
        //   },
        //   alternate: null
        // },
        {
          type: "IfStatement",
          test: {
            type: "LogicalExpression",
            left: {
              type: "LogicalExpression",
              left: {
                type: "CallExpression",
                callee: toIdOrMemberExpression(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "/" }],
                optional: !1
              },
              operator: "||",
              right: {
                type: "CallExpression",
                callee: toIdOrMemberExpression(["d", "startsWith"]),
                arguments: [{ type: "Literal", value: "./" }],
                optional: !1
              }
            },
            operator: "||",
            right: {
              type: "CallExpression",
              callee: toIdOrMemberExpression(["d", "startsWith"]),
              arguments: [{ type: "Literal", value: "../" }],
              optional: !1
            }
          },
          consequent: {
            type: "ReturnStatement",
            argument: {
              type: "MemberExpression",
              object: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "URL" },
                arguments: [{ type: "Identifier", name: "d" }, s]
              },
              property: { type: "Identifier", name: "href" },
              computed: !1,
              optional: !1
            }
          },
          alternate: null
        },
        {
          type: "ReturnStatement",
          argument: { type: "Identifier", name: "d" }
        }
      ]
    }
  };
}
function createImportMetaUrlVariable() {
  return [
    {
      type: "VariableDeclaration",
      declarations: [
        {
          type: "VariableDeclarator",
          id: { type: "Identifier", name: "_importMetaUrl" },
          init: toIdOrMemberExpression(["arguments", 0, "baseUrl"])
        }
      ],
      kind: "const"
    },
    {
      type: "IfStatement",
      test: {
        type: "UnaryExpression",
        operator: "!",
        prefix: !0,
        argument: { type: "Identifier", name: "_importMetaUrl" }
      },
      consequent: {
        type: "ThrowStatement",
        argument: {
          type: "NewExpression",
          callee: { type: "Identifier", name: "Error" },
          arguments: [
            {
              type: "Literal",
              value: "Unexpected missing `options.baseUrl` needed to support `export … from`, `import`, or `import.meta.url` when generating `function-body`"
            }
          ]
        }
      },
      alternate: null
    }
  ];
}
const regex = /@(jsx|jsxFrag|jsxImportSource|jsxRuntime)\s+(\S+)/g;
function buildJsx(s, o) {
  const l = o || {};
  let u = l.runtime === "automatic";
  const c = {}, m = {};
  walk$1(s, {
    enter(g) {
      if (g.type === "Program") {
        const v = g.comments || [];
        let b = -1;
        for (; ++b < v.length; ) {
          regex.lastIndex = 0;
          let S = regex.exec(v[b].value);
          for (; S; )
            c[S[1]] = S[2], S = regex.exec(v[b].value);
        }
        if (c.jsxRuntime)
          if (c.jsxRuntime === "automatic") {
            if (u = !0, c.jsx)
              throw new Error("Unexpected `@jsx` pragma w/ automatic runtime");
            if (c.jsxFrag)
              throw new Error(
                "Unexpected `@jsxFrag` pragma w/ automatic runtime"
              );
          } else if (c.jsxRuntime === "classic") {
            if (u = !1, c.jsxImportSource)
              throw new Error(
                "Unexpected `@jsxImportSource` w/ classic runtime"
              );
          } else
            throw new Error(
              "Unexpected `jsxRuntime` `" + c.jsxRuntime + "`, expected `automatic` or `classic`"
            );
      }
    },
    // eslint-disable-next-line complexity
    leave(g) {
      if (g.type === "Program") {
        const z = [];
        if (m.fragment && z.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "Fragment" },
          local: { type: "Identifier", name: "_Fragment" }
        }), m.jsx && z.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsx" },
          local: { type: "Identifier", name: "_jsx" }
        }), m.jsxs && z.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxs" },
          local: { type: "Identifier", name: "_jsxs" }
        }), m.jsxDEV && z.push({
          type: "ImportSpecifier",
          imported: { type: "Identifier", name: "jsxDEV" },
          local: { type: "Identifier", name: "_jsxDEV" }
        }), z.length > 0) {
          let Q = 0;
          for (; Q < g.body.length; ) {
            const W = g.body[Q];
            if ("directive" in W && W.directive)
              Q++;
            else
              break;
          }
          g.body.splice(Q, 0, {
            type: "ImportDeclaration",
            specifiers: z,
            source: {
              type: "Literal",
              value: (c.jsxImportSource || l.importSource || "react") + (l.development ? "/jsx-dev-runtime" : "/jsx-runtime")
            }
          });
        }
      }
      if (g.type !== "JSXElement" && g.type !== "JSXFragment")
        return;
      const v = [];
      let b = -1;
      for (; ++b < g.children.length; ) {
        const z = g.children[b];
        if (z.type === "JSXExpressionContainer")
          z.expression.type !== "JSXEmptyExpression" && v.push(z.expression);
        else if (z.type === "JSXText") {
          const Q = z.value.replace(/\t/g, " ").replace(/ *(\r?\n|\r) */g, `
`).replace(/\n+/g, `
`).replace(/\n+$/, "").replace(/^\n+/, "").replace(/\n/g, " ");
          if (Q) {
            const W = { type: "Literal", value: Q };
            create$1(z, W), v.push(W);
          }
        } else
          z.type !== "JSXElement" && z.type !== "JSXFragment" && z.type, v.push(z);
      }
      let S;
      const E = [];
      let P = [], T;
      if (g.type === "JSXElement") {
        if (S = toIdentifier(g.openingElement.name), S.type === "Identifier" && /^[a-z]/.test(S.name)) {
          const ue = { type: "Literal", value: S.name };
          create$1(S, ue), S = ue;
        }
        let z;
        const Q = g.openingElement.attributes;
        let W = -1;
        for (; ++W < Q.length; ) {
          const ue = Q[W];
          if (ue.type === "JSXSpreadAttribute")
            ue.argument.type === "ObjectExpression" ? E.push(...ue.argument.properties) : E.push({ type: "SpreadElement", argument: ue.argument }), z = !0;
          else {
            const te = toProperty(ue);
            if (u && te.key.type === "Identifier" && te.key.name === "key") {
              if (z)
                throw new Error(
                  "Expected `key` to come before any spread expressions"
                );
              const K = te.value;
              K.type !== "AssignmentPattern" && K.type !== "ArrayPattern" && K.type !== "ObjectPattern" && K.type, T = K;
            } else
              E.push(te);
          }
        }
      } else u ? (m.fragment = !0, S = { type: "Identifier", name: "_Fragment" }) : S = toMemberExpression(
        c.jsxFrag || l.pragmaFrag || "React.Fragment"
      );
      u ? v.length > 0 && E.push({
        type: "Property",
        key: { type: "Identifier", name: "children" },
        value: v.length > 1 ? { type: "ArrayExpression", elements: v } : v[0],
        kind: "init",
        method: !1,
        shorthand: !1,
        computed: !1
      }) : P = v;
      let N;
      if (u) {
        P.push({ type: "ObjectExpression", properties: E }), T ? P.push(T) : l.development && P.push({ type: "Identifier", name: "undefined" });
        const z = v.length > 1;
        if (l.development) {
          m.jsxDEV = !0, N = {
            type: "Identifier",
            name: "_jsxDEV"
          }, P.push({ type: "Literal", value: z });
          const Q = {
            type: "ObjectExpression",
            properties: [
              {
                type: "Property",
                method: !1,
                shorthand: !1,
                computed: !1,
                kind: "init",
                key: { type: "Identifier", name: "fileName" },
                value: {
                  type: "Literal",
                  value: l.filePath || "<source.js>"
                }
              }
            ]
          };
          g.loc && Q.properties.push(
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "lineNumber" },
              value: { type: "Literal", value: g.loc.start.line }
            },
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              kind: "init",
              key: { type: "Identifier", name: "columnNumber" },
              value: { type: "Literal", value: g.loc.start.column + 1 }
            }
          ), P.push(Q, { type: "ThisExpression" });
        } else z ? (m.jsxs = !0, N = { type: "Identifier", name: "_jsxs" }) : (m.jsx = !0, N = { type: "Identifier", name: "_jsx" });
      } else
        E.length > 0 ? P.unshift({ type: "ObjectExpression", properties: E }) : P.length > 0 && P.unshift({ type: "Literal", value: null }), N = toMemberExpression(
          c.jsx || l.pragma || "React.createElement"
        );
      P.unshift(S);
      const O = {
        type: "CallExpression",
        callee: N,
        arguments: P,
        optional: !1
      };
      create$1(g, O), this.replace(O);
    }
  });
}
function toProperty(s) {
  let o;
  if (s.value)
    if (s.value.type === "JSXExpressionContainer") {
      const u = s.value.expression;
      u.type, o = u;
    } else {
      const u = s.value;
      u.type !== "JSXElement" && u.type, o = u, delete o.raw;
    }
  else
    o = { type: "Literal", value: !0 };
  const l = {
    type: "Property",
    key: toIdentifier(s.name),
    value: o,
    kind: "init",
    method: !1,
    shorthand: !1,
    computed: !1
  };
  return create$1(s, l), l;
}
function toIdentifier(s) {
  let o;
  if (s.type === "JSXMemberExpression") {
    const l = toIdentifier(s.property);
    o = {
      type: "MemberExpression",
      object: toIdentifier(s.object),
      property: l,
      computed: l.type === "Literal",
      optional: !1
    };
  } else s.type === "JSXNamespacedName" ? o = {
    type: "Literal",
    value: s.namespace.name + ":" + s.name.name
  } : o = name(s.name) ? { type: "Identifier", name: s.name } : { type: "Literal", value: s.name };
  return create$1(s, o), o;
}
function toMemberExpression(s) {
  const o = s.split(".");
  let l = -1, u;
  for (; ++l < o.length; ) {
    const c = name(o[l]) ? { type: "Identifier", name: o[l] } : { type: "Literal", value: o[l] };
    u = u ? {
      type: "MemberExpression",
      object: u,
      property: c,
      computed: !!(l && c.type === "Literal"),
      optional: !1
    } : c;
  }
  return u;
}
function create$1(s, o) {
  const l = ["start", "end", "loc", "range", "comments"];
  let u = -1;
  for (; ++u < l.length; ) {
    const c = l[u];
    c in s && (o[c] = s[c]);
  }
}
function recmaJsxBuild(s) {
  const { development: o, outputFormat: l } = s || {};
  return function(u, c) {
    if (buildJsx(u, { development: o, filePath: c.history[0] }), u.comments && (u.comments = u.comments.filter(function(m) {
      var g;
      return !((g = m.data) != null && g._mdxIsPragmaComment);
    })), l === "function-body") {
      let m = 0;
      for (; m < u.body.length; ) {
        const v = u.body[m];
        if ("directive" in v && v.directive)
          m++;
        else
          break;
      }
      const g = u.body[m];
      g && g.type === "ImportDeclaration" && typeof g.source.value == "string" && /\/jsx-(dev-)?runtime$/.test(g.source.value) && (u.body[m] = {
        type: "VariableDeclaration",
        kind: "const",
        declarations: specifiersToDeclarations(
          g.specifiers,
          toIdOrMemberExpression(["arguments", 0])
        )
      });
    }
  };
}
function toBinaryAddition(s) {
  let o = -1, l;
  for (; ++o < s.length; ) {
    const u = s[o];
    l = l ? { type: "BinaryExpression", left: l, operator: "+", right: u } : u;
  }
  return l;
}
function recmaJsxRewrite(s) {
  const { development: o, outputFormat: l, providerImportSource: u } = s;
  return function(c, m) {
    const g = analyze(c), v = [];
    let b = !1, S = !1, E;
    if (walk$1(c, {
      enter(P) {
        const T = (
          /** @type {Scope | undefined} */
          g.map.get(P)
        );
        (P.type === "FunctionDeclaration" || P.type === "FunctionExpression" || P.type === "ArrowFunctionExpression") && (v.push({
          components: [],
          idToInvalidComponentName: /* @__PURE__ */ new Map(),
          node: P,
          objects: [],
          references: {},
          tags: []
        }), isNamedFunction(P, "MDXContent") && T && !inScope(T, "MDXLayout") && v[0].components.push("MDXLayout"));
        const N = v[0];
        if (!(!N || !isNamedFunction(N.node, "_createMdxContent") && !u) && (T && (T.node = P, E = T), E && P.type === "JSXElement")) {
          let O = P.openingElement.name;
          if (O.type === "JSXMemberExpression") {
            const z = [];
            for (; O.type === "JSXMemberExpression"; )
              z.unshift(O.property.name), O = O.object;
            z.unshift(O.name);
            const Q = z.join("."), W = O.name, ue = inScope(E, W);
            if (!Object.hasOwn(N.references, Q)) {
              const te = (
                /** @type {Scope | undefined} */
                E.parent
              );
              (!ue || // If the parent scope is `_createMdxContent`, then this
              // references a component we can add a check statement for.
              te && te.node.type === "FunctionDeclaration" && isNamedFunction(te.node, "_createMdxContent")) && (N.references[Q] = { component: !0, node: P });
            }
            !N.objects.includes(W) && !ue && N.objects.push(W);
          } else if (O.type !== "JSXNamespacedName") {
            if (name(O.name) && !/^[a-z]/.test(O.name)) {
              const z = O.name;
              inScope(E, z) || (z !== "MDXLayout" && !Object.hasOwn(N.references, z) && (N.references[z] = { component: !0, node: P }), N.components.includes(z) || N.components.push(z));
            } else if (!(P.data && P.data._mdxExplicitJsx)) {
              const z = O.name;
              N.tags.includes(z) || N.tags.push(z);
              let Q = ["_components", z];
              if (name(z) === !1) {
                let W = N.idToInvalidComponentName.get(z);
                W === void 0 && (W = `_component${N.idToInvalidComponentName.size}`, N.idToInvalidComponentName.set(
                  z,
                  W
                )), Q = [W];
              }
              P.openingElement.name = toJsxIdOrMemberExpression(Q), P.closingElement && (P.closingElement.name = toJsxIdOrMemberExpression(Q));
            }
          }
        }
      },
      leave(P) {
        const T = [], N = [], O = [], z = [];
        if (E && E.node === P && (E = /** @type {Scope} */
        E.parent), P.type === "FunctionDeclaration" || P.type === "FunctionExpression" || P.type === "ArrowFunctionExpression") {
          const Q = P, W = v[v.length - 1];
          let ue;
          for (ue of W.tags.sort())
            T.push({
              type: "Property",
              kind: "init",
              key: name(ue) ? { type: "Identifier", name: ue } : { type: "Literal", value: ue },
              value: { type: "Literal", value: ue },
              method: !1,
              shorthand: !1,
              computed: !1
            });
          N.push(...W.components);
          for (ue of W.objects)
            N.includes(ue) || N.push(ue);
          N.sort();
          const te = [];
          if (T.length > 0 || N.length > 0 || W.idToInvalidComponentName.size > 0) {
            if (u && (b = !0, O.push({
              type: "CallExpression",
              callee: { type: "Identifier", name: "_provideComponents" },
              arguments: [],
              optional: !1
            })), (isNamedFunction(W.node, "MDXContent") || isNamedFunction(W.node, "_createMdxContent")) && O.push(toIdOrMemberExpression(["props", "components"])), T.length > 0 || O.length > 1)
              for (const yt of O)
                T.push({ type: "SpreadElement", argument: yt });
            let Re = T.length > 0 ? { type: "ObjectExpression", properties: T } : (
              // If we’re only getting components from `props.components`,
              // make sure it’s defined.
              {
                type: "LogicalExpression",
                operator: "||",
                left: O[0],
                right: { type: "ObjectExpression", properties: [] }
              }
            ), wt;
            if (N.length > 0 && (wt = {
              type: "ObjectPattern",
              properties: N.map(function(yt) {
                return {
                  type: "Property",
                  kind: "init",
                  key: {
                    type: "Identifier",
                    name: yt === "MDXLayout" ? "wrapper" : yt
                  },
                  value: { type: "Identifier", name: yt },
                  method: !1,
                  shorthand: yt !== "MDXLayout",
                  computed: !1
                };
              })
            }), W.tags.length > 0 && (z.push({
              type: "VariableDeclarator",
              id: { type: "Identifier", name: "_components" },
              init: Re
            }), Re = { type: "Identifier", name: "_components" }), isNamedFunction(W.node, "_createMdxContent"))
              for (const [yt, xt] of [
                ...W.idToInvalidComponentName
              ].sort(function([Kt], [tn]) {
                return Kt.localeCompare(tn);
              }))
                z.push({
                  type: "VariableDeclarator",
                  id: {
                    type: "Identifier",
                    name: xt
                  },
                  init: {
                    type: "MemberExpression",
                    object: { type: "Identifier", name: "_components" },
                    property: { type: "Literal", value: yt },
                    computed: !0,
                    optional: !1
                  }
                });
            wt && z.push({
              type: "VariableDeclarator",
              id: wt,
              init: Re
            }), z.length > 0 && te.push({
              type: "VariableDeclaration",
              kind: "const",
              declarations: z
            });
          }
          let K;
          for (K in W.references)
            if (Object.hasOwn(W.references, K)) {
              const Re = K.split(".");
              let wt = 0;
              for (; ++wt < Re.length; ) {
                const yt = Re.slice(0, wt).join(".");
                Object.hasOwn(W.references, yt) || (W.references[yt] = {
                  component: !1,
                  node: W.references[K].node
                });
              }
            }
          const ve = Object.keys(W.references).sort();
          let ee = -1;
          for (; ++ee < ve.length; ) {
            const Re = ve[ee], wt = W.references[Re], yt = stringifyPosition(positionFromEstree(wt.node)), xt = [
              { type: "Literal", value: Re },
              { type: "Literal", value: wt.component }
            ];
            S = !0, o && yt && xt.push({ type: "Literal", value: yt }), te.push({
              type: "IfStatement",
              test: {
                type: "UnaryExpression",
                operator: "!",
                prefix: !0,
                argument: toIdOrMemberExpression(Re.split("."))
              },
              consequent: {
                type: "ExpressionStatement",
                expression: {
                  type: "CallExpression",
                  callee: { type: "Identifier", name: "_missingMdxReference" },
                  arguments: xt,
                  optional: !1
                }
              },
              alternate: void 0
            });
          }
          te.length > 0 && (Q.body.type !== "BlockStatement" && (Q.body = {
            type: "BlockStatement",
            body: [{ type: "ReturnStatement", argument: Q.body }]
          }), Q.body.body.unshift(...te)), v.pop();
        }
      }
    }), b && u && c.body.unshift(
      createImportProvider(u, l)
    ), S) {
      const P = [
        { type: "Literal", value: "Expected " },
        {
          type: "ConditionalExpression",
          test: { type: "Identifier", name: "component" },
          consequent: { type: "Literal", value: "component" },
          alternate: { type: "Literal", value: "object" }
        },
        { type: "Literal", value: " `" },
        { type: "Identifier", name: "id" },
        {
          type: "Literal",
          value: "` to be defined: you likely forgot to import, pass, or provide it."
        }
      ], T = [
        { type: "Identifier", name: "id" },
        { type: "Identifier", name: "component" }
      ];
      o && (P.push({
        type: "ConditionalExpression",
        test: { type: "Identifier", name: "place" },
        consequent: toBinaryAddition([
          { type: "Literal", value: "\nIt’s referenced in your code at `" },
          { type: "Identifier", name: "place" },
          {
            type: "Literal",
            value: (m.path ? "` in `" + m.path : "") + "`"
          }
        ]),
        alternate: { type: "Literal", value: "" }
      }), T.push({ type: "Identifier", name: "place" })), c.body.push({
        type: "FunctionDeclaration",
        id: { type: "Identifier", name: "_missingMdxReference" },
        generator: !1,
        async: !1,
        params: T,
        body: {
          type: "BlockStatement",
          body: [
            {
              type: "ThrowStatement",
              argument: {
                type: "NewExpression",
                callee: { type: "Identifier", name: "Error" },
                arguments: [toBinaryAddition(P)]
              }
            }
          ]
        }
      });
    }
    l === "function-body" && c.body.unshift({
      type: "ExpressionStatement",
      expression: { type: "Literal", value: "use strict" },
      directive: "use strict"
    });
  };
}
function createImportProvider(s, o) {
  const l = [
    {
      type: "ImportSpecifier",
      imported: { type: "Identifier", name: "useMDXComponents" },
      local: { type: "Identifier", name: "_provideComponents" }
    }
  ];
  return o === "function-body" ? {
    type: "VariableDeclaration",
    kind: "const",
    declarations: specifiersToDeclarations(
      l,
      toIdOrMemberExpression(["arguments", 0])
    )
  } : {
    type: "ImportDeclaration",
    specifiers: l,
    source: { type: "Literal", value: s }
  };
}
function isNamedFunction(s, o) {
  return !!(s && "id" in s && s.id && s.id.name === o);
}
function inScope(s, o) {
  let l = s;
  for (; l; ) {
    if (l.declarations.has(o))
      return !0;
    l = /** @type {Scope | undefined} */
    l.parent || void 0;
  }
  return !1;
}
const { stringify: stringify$2 } = JSON;
if (!String.prototype.repeat)
  throw new Error(
    "String.prototype.repeat is undefined, see https://github.com/davidbonnet/astring#installation"
  );
if (!String.prototype.endsWith)
  throw new Error(
    "String.prototype.endsWith is undefined, see https://github.com/davidbonnet/astring#installation"
  );
const OPERATOR_PRECEDENCE = {
  "||": 2,
  "??": 3,
  "&&": 4,
  "|": 5,
  "^": 6,
  "&": 7,
  "==": 8,
  "!=": 8,
  "===": 8,
  "!==": 8,
  "<": 9,
  ">": 9,
  "<=": 9,
  ">=": 9,
  in: 9,
  instanceof: 9,
  "<<": 10,
  ">>": 10,
  ">>>": 10,
  "+": 11,
  "-": 11,
  "*": 12,
  "%": 12,
  "/": 12,
  "**": 13
}, NEEDS_PARENTHESES = 17, EXPRESSIONS_PRECEDENCE = {
  // Definitions
  ArrayExpression: 20,
  TaggedTemplateExpression: 20,
  ThisExpression: 20,
  Identifier: 20,
  PrivateIdentifier: 20,
  Literal: 18,
  TemplateLiteral: 20,
  Super: 20,
  SequenceExpression: 20,
  // Operations
  MemberExpression: 19,
  ChainExpression: 19,
  CallExpression: 19,
  NewExpression: 19,
  // Other definitions
  ArrowFunctionExpression: NEEDS_PARENTHESES,
  ClassExpression: NEEDS_PARENTHESES,
  FunctionExpression: NEEDS_PARENTHESES,
  ObjectExpression: NEEDS_PARENTHESES,
  // Other operations
  UpdateExpression: 16,
  UnaryExpression: 15,
  AwaitExpression: 15,
  BinaryExpression: 14,
  LogicalExpression: 13,
  ConditionalExpression: 4,
  AssignmentExpression: 3,
  YieldExpression: 2,
  RestElement: 1
};
function formatSequence(s, o) {
  const { generator: l } = s;
  if (s.write("("), o != null && o.length > 0) {
    l[o[0].type](o[0], s);
    const { length: u } = o;
    for (let c = 1; c < u; c++) {
      const m = o[c];
      s.write(", "), l[m.type](m, s);
    }
  }
  s.write(")");
}
function expressionNeedsParenthesis(s, o, l, u) {
  const c = s.expressionsPrecedence[o.type];
  if (c === NEEDS_PARENTHESES)
    return !0;
  const m = s.expressionsPrecedence[l.type];
  return c !== m ? !u && c === 15 && m === 14 && l.operator === "**" || c < m : c !== 13 && c !== 14 ? !1 : o.operator === "**" && l.operator === "**" ? !u : c === 13 && m === 13 && (o.operator === "??" || l.operator === "??") ? !0 : u ? OPERATOR_PRECEDENCE[o.operator] <= OPERATOR_PRECEDENCE[l.operator] : OPERATOR_PRECEDENCE[o.operator] < OPERATOR_PRECEDENCE[l.operator];
}
function formatExpression(s, o, l, u) {
  const { generator: c } = s;
  expressionNeedsParenthesis(s, o, l, u) ? (s.write("("), c[o.type](o, s), s.write(")")) : c[o.type](o, s);
}
function reindent(s, o, l, u) {
  const c = o.split(`
`), m = c.length - 1;
  if (s.write(c[0].trim()), m > 0) {
    s.write(u);
    for (let g = 1; g < m; g++)
      s.write(l + c[g].trim() + u);
    s.write(l + c[m].trim());
  }
}
function formatComments(s, o, l, u) {
  const { length: c } = o;
  for (let m = 0; m < c; m++) {
    const g = o[m];
    s.write(l), g.type[0] === "L" ? s.write("// " + g.value.trim() + `
`, g) : (s.write("/*"), reindent(s, g.value, l, u), s.write("*/" + u));
  }
}
function hasCallExpression(s) {
  let o = s;
  for (; o != null; ) {
    const { type: l } = o;
    if (l[0] === "C" && l[1] === "a")
      return !0;
    if (l[0] === "M" && l[1] === "e" && l[2] === "m")
      o = o.object;
    else
      return !1;
  }
}
function formatVariableDeclaration(s, o) {
  const { generator: l } = s, { declarations: u } = o;
  s.write(o.kind + " ");
  const { length: c } = u;
  if (c > 0) {
    l.VariableDeclarator(u[0], s);
    for (let m = 1; m < c; m++)
      s.write(", "), l.VariableDeclarator(u[m], s);
  }
}
let ForInStatement, FunctionDeclaration, RestElement, BinaryExpression, ArrayExpression, BlockStatement;
const GENERATOR = {
  /*
  Default generator.
  */
  Program(s, o) {
    const l = o.indent.repeat(o.indentLevel), { lineEnd: u, writeComments: c } = o;
    c && s.comments != null && formatComments(o, s.comments, l, u);
    const m = s.body, { length: g } = m;
    for (let v = 0; v < g; v++) {
      const b = m[v];
      c && b.comments != null && formatComments(o, b.comments, l, u), o.write(l), this[b.type](b, o), o.write(u);
    }
    c && s.trailingComments != null && formatComments(o, s.trailingComments, l, u);
  },
  BlockStatement: BlockStatement = function(s, o) {
    const l = o.indent.repeat(o.indentLevel++), { lineEnd: u, writeComments: c } = o, m = l + o.indent;
    o.write("{");
    const g = s.body;
    if (g != null && g.length > 0) {
      o.write(u), c && s.comments != null && formatComments(o, s.comments, m, u);
      const { length: v } = g;
      for (let b = 0; b < v; b++) {
        const S = g[b];
        c && S.comments != null && formatComments(o, S.comments, m, u), o.write(m), this[S.type](S, o), o.write(u);
      }
      o.write(l);
    } else
      c && s.comments != null && (o.write(u), formatComments(o, s.comments, m, u), o.write(l));
    c && s.trailingComments != null && formatComments(o, s.trailingComments, m, u), o.write("}"), o.indentLevel--;
  },
  ClassBody: BlockStatement,
  StaticBlock(s, o) {
    o.write("static "), this.BlockStatement(s, o);
  },
  EmptyStatement(s, o) {
    o.write(";");
  },
  ExpressionStatement(s, o) {
    const l = o.expressionsPrecedence[s.expression.type];
    l === NEEDS_PARENTHESES || l === 3 && s.expression.left.type[0] === "O" ? (o.write("("), this[s.expression.type](s.expression, o), o.write(")")) : this[s.expression.type](s.expression, o), o.write(";");
  },
  IfStatement(s, o) {
    o.write("if ("), this[s.test.type](s.test, o), o.write(") "), this[s.consequent.type](s.consequent, o), s.alternate != null && (o.write(" else "), this[s.alternate.type](s.alternate, o));
  },
  LabeledStatement(s, o) {
    this[s.label.type](s.label, o), o.write(": "), this[s.body.type](s.body, o);
  },
  BreakStatement(s, o) {
    o.write("break"), s.label != null && (o.write(" "), this[s.label.type](s.label, o)), o.write(";");
  },
  ContinueStatement(s, o) {
    o.write("continue"), s.label != null && (o.write(" "), this[s.label.type](s.label, o)), o.write(";");
  },
  WithStatement(s, o) {
    o.write("with ("), this[s.object.type](s.object, o), o.write(") "), this[s.body.type](s.body, o);
  },
  SwitchStatement(s, o) {
    const l = o.indent.repeat(o.indentLevel++), { lineEnd: u, writeComments: c } = o;
    o.indentLevel++;
    const m = l + o.indent, g = m + o.indent;
    o.write("switch ("), this[s.discriminant.type](s.discriminant, o), o.write(") {" + u);
    const { cases: v } = s, { length: b } = v;
    for (let S = 0; S < b; S++) {
      const E = v[S];
      c && E.comments != null && formatComments(o, E.comments, m, u), E.test ? (o.write(m + "case "), this[E.test.type](E.test, o), o.write(":" + u)) : o.write(m + "default:" + u);
      const { consequent: P } = E, { length: T } = P;
      for (let N = 0; N < T; N++) {
        const O = P[N];
        c && O.comments != null && formatComments(o, O.comments, g, u), o.write(g), this[O.type](O, o), o.write(u);
      }
    }
    o.indentLevel -= 2, o.write(l + "}");
  },
  ReturnStatement(s, o) {
    o.write("return"), s.argument && (o.write(" "), this[s.argument.type](s.argument, o)), o.write(";");
  },
  ThrowStatement(s, o) {
    o.write("throw "), this[s.argument.type](s.argument, o), o.write(";");
  },
  TryStatement(s, o) {
    if (o.write("try "), this[s.block.type](s.block, o), s.handler) {
      const { handler: l } = s;
      l.param == null ? o.write(" catch ") : (o.write(" catch ("), this[l.param.type](l.param, o), o.write(") ")), this[l.body.type](l.body, o);
    }
    s.finalizer && (o.write(" finally "), this[s.finalizer.type](s.finalizer, o));
  },
  WhileStatement(s, o) {
    o.write("while ("), this[s.test.type](s.test, o), o.write(") "), this[s.body.type](s.body, o);
  },
  DoWhileStatement(s, o) {
    o.write("do "), this[s.body.type](s.body, o), o.write(" while ("), this[s.test.type](s.test, o), o.write(");");
  },
  ForStatement(s, o) {
    if (o.write("for ("), s.init != null) {
      const { init: l } = s;
      l.type[0] === "V" ? formatVariableDeclaration(o, l) : this[l.type](l, o);
    }
    o.write("; "), s.test && this[s.test.type](s.test, o), o.write("; "), s.update && this[s.update.type](s.update, o), o.write(") "), this[s.body.type](s.body, o);
  },
  ForInStatement: ForInStatement = function(s, o) {
    o.write(`for ${s.await ? "await " : ""}(`);
    const { left: l } = s;
    l.type[0] === "V" ? formatVariableDeclaration(o, l) : this[l.type](l, o), o.write(s.type[3] === "I" ? " in " : " of "), this[s.right.type](s.right, o), o.write(") "), this[s.body.type](s.body, o);
  },
  ForOfStatement: ForInStatement,
  DebuggerStatement(s, o) {
    o.write("debugger;", s);
  },
  FunctionDeclaration: FunctionDeclaration = function(s, o) {
    o.write(
      (s.async ? "async " : "") + (s.generator ? "function* " : "function ") + (s.id ? s.id.name : ""),
      s
    ), formatSequence(o, s.params), o.write(" "), this[s.body.type](s.body, o);
  },
  FunctionExpression: FunctionDeclaration,
  VariableDeclaration(s, o) {
    formatVariableDeclaration(o, s), o.write(";");
  },
  VariableDeclarator(s, o) {
    this[s.id.type](s.id, o), s.init != null && (o.write(" = "), this[s.init.type](s.init, o));
  },
  ClassDeclaration(s, o) {
    if (o.write("class " + (s.id ? `${s.id.name} ` : ""), s), s.superClass) {
      o.write("extends ");
      const { superClass: l } = s, { type: u } = l, c = o.expressionsPrecedence[u];
      (u[0] !== "C" || u[1] !== "l" || u[5] !== "E") && (c === NEEDS_PARENTHESES || c < o.expressionsPrecedence.ClassExpression) ? (o.write("("), this[s.superClass.type](l, o), o.write(")")) : this[l.type](l, o), o.write(" ");
    }
    this.ClassBody(s.body, o);
  },
  ImportDeclaration(s, o) {
    o.write("import ");
    const { specifiers: l } = s, { length: u } = l;
    let c = 0;
    if (u > 0) {
      for (; c < u; ) {
        c > 0 && o.write(", ");
        const m = l[c], g = m.type[6];
        if (g === "D")
          o.write(m.local.name, m), c++;
        else if (g === "N")
          o.write("* as " + m.local.name, m), c++;
        else
          break;
      }
      if (c < u) {
        for (o.write("{"); ; ) {
          const m = l[c], { name: g } = m.imported;
          if (o.write(g, m), g !== m.local.name && o.write(" as " + m.local.name), ++c < u)
            o.write(", ");
          else
            break;
        }
        o.write("}");
      }
      o.write(" from ");
    }
    this.Literal(s.source, o), o.write(";");
  },
  ImportExpression(s, o) {
    o.write("import("), this[s.source.type](s.source, o), o.write(")");
  },
  ExportDefaultDeclaration(s, o) {
    o.write("export default "), this[s.declaration.type](s.declaration, o), o.expressionsPrecedence[s.declaration.type] != null && s.declaration.type[0] !== "F" && o.write(";");
  },
  ExportNamedDeclaration(s, o) {
    if (o.write("export "), s.declaration)
      this[s.declaration.type](s.declaration, o);
    else {
      o.write("{");
      const { specifiers: l } = s, { length: u } = l;
      if (u > 0)
        for (let c = 0; ; ) {
          const m = l[c], { name: g } = m.local;
          if (o.write(g, m), g !== m.exported.name && o.write(" as " + m.exported.name), ++c < u)
            o.write(", ");
          else
            break;
        }
      o.write("}"), s.source && (o.write(" from "), this.Literal(s.source, o)), o.write(";");
    }
  },
  ExportAllDeclaration(s, o) {
    s.exported != null ? o.write("export * as " + s.exported.name + " from ") : o.write("export * from "), this.Literal(s.source, o), o.write(";");
  },
  MethodDefinition(s, o) {
    s.static && o.write("static ");
    const l = s.kind[0];
    (l === "g" || l === "s") && o.write(s.kind + " "), s.value.async && o.write("async "), s.value.generator && o.write("*"), s.computed ? (o.write("["), this[s.key.type](s.key, o), o.write("]")) : this[s.key.type](s.key, o), formatSequence(o, s.value.params), o.write(" "), this[s.value.body.type](s.value.body, o);
  },
  ClassExpression(s, o) {
    this.ClassDeclaration(s, o);
  },
  ArrowFunctionExpression(s, o) {
    o.write(s.async ? "async " : "", s);
    const { params: l } = s;
    l != null && (l.length === 1 && l[0].type[0] === "I" ? o.write(l[0].name, l[0]) : formatSequence(o, s.params)), o.write(" => "), s.body.type[0] === "O" ? (o.write("("), this.ObjectExpression(s.body, o), o.write(")")) : this[s.body.type](s.body, o);
  },
  ThisExpression(s, o) {
    o.write("this", s);
  },
  Super(s, o) {
    o.write("super", s);
  },
  RestElement: RestElement = function(s, o) {
    o.write("..."), this[s.argument.type](s.argument, o);
  },
  SpreadElement: RestElement,
  YieldExpression(s, o) {
    o.write(s.delegate ? "yield*" : "yield"), s.argument && (o.write(" "), this[s.argument.type](s.argument, o));
  },
  AwaitExpression(s, o) {
    o.write("await ", s), formatExpression(o, s.argument, s);
  },
  TemplateLiteral(s, o) {
    const { quasis: l, expressions: u } = s;
    o.write("`");
    const { length: c } = u;
    for (let g = 0; g < c; g++) {
      const v = u[g], b = l[g];
      o.write(b.value.raw, b), o.write("${"), this[v.type](v, o), o.write("}");
    }
    const m = l[l.length - 1];
    o.write(m.value.raw, m), o.write("`");
  },
  TemplateElement(s, o) {
    o.write(s.value.raw, s);
  },
  TaggedTemplateExpression(s, o) {
    formatExpression(o, s.tag, s), this[s.quasi.type](s.quasi, o);
  },
  ArrayExpression: ArrayExpression = function(s, o) {
    if (o.write("["), s.elements.length > 0) {
      const { elements: l } = s, { length: u } = l;
      for (let c = 0; ; ) {
        const m = l[c];
        if (m != null && this[m.type](m, o), ++c < u)
          o.write(", ");
        else {
          m == null && o.write(", ");
          break;
        }
      }
    }
    o.write("]");
  },
  ArrayPattern: ArrayExpression,
  ObjectExpression(s, o) {
    const l = o.indent.repeat(o.indentLevel++), { lineEnd: u, writeComments: c } = o, m = l + o.indent;
    if (o.write("{"), s.properties.length > 0) {
      o.write(u), c && s.comments != null && formatComments(o, s.comments, m, u);
      const g = "," + u, { properties: v } = s, { length: b } = v;
      for (let S = 0; ; ) {
        const E = v[S];
        if (c && E.comments != null && formatComments(o, E.comments, m, u), o.write(m), this[E.type](E, o), ++S < b)
          o.write(g);
        else
          break;
      }
      o.write(u), c && s.trailingComments != null && formatComments(o, s.trailingComments, m, u), o.write(l + "}");
    } else c ? s.comments != null ? (o.write(u), formatComments(o, s.comments, m, u), s.trailingComments != null && formatComments(o, s.trailingComments, m, u), o.write(l + "}")) : s.trailingComments != null ? (o.write(u), formatComments(o, s.trailingComments, m, u), o.write(l + "}")) : o.write("}") : o.write("}");
    o.indentLevel--;
  },
  Property(s, o) {
    s.method || s.kind[0] !== "i" ? this.MethodDefinition(s, o) : (s.shorthand || (s.computed ? (o.write("["), this[s.key.type](s.key, o), o.write("]")) : this[s.key.type](s.key, o), o.write(": ")), this[s.value.type](s.value, o));
  },
  PropertyDefinition(s, o) {
    if (s.static && o.write("static "), s.computed && o.write("["), this[s.key.type](s.key, o), s.computed && o.write("]"), s.value == null) {
      s.key.type[0] !== "F" && o.write(";");
      return;
    }
    o.write(" = "), this[s.value.type](s.value, o), o.write(";");
  },
  ObjectPattern(s, o) {
    if (o.write("{"), s.properties.length > 0) {
      const { properties: l } = s, { length: u } = l;
      for (let c = 0; this[l[c].type](l[c], o), ++c < u; )
        o.write(", ");
    }
    o.write("}");
  },
  SequenceExpression(s, o) {
    formatSequence(o, s.expressions);
  },
  UnaryExpression(s, o) {
    if (s.prefix) {
      const {
        operator: l,
        argument: u,
        argument: { type: c }
      } = s;
      o.write(l);
      const m = expressionNeedsParenthesis(o, u, s);
      !m && (l.length > 1 || c[0] === "U" && (c[1] === "n" || c[1] === "p") && u.prefix && u.operator[0] === l && (l === "+" || l === "-")) && o.write(" "), m ? (o.write(l.length > 1 ? " (" : "("), this[c](u, o), o.write(")")) : this[c](u, o);
    } else
      this[s.argument.type](s.argument, o), o.write(s.operator);
  },
  UpdateExpression(s, o) {
    s.prefix ? (o.write(s.operator), this[s.argument.type](s.argument, o)) : (this[s.argument.type](s.argument, o), o.write(s.operator));
  },
  AssignmentExpression(s, o) {
    this[s.left.type](s.left, o), o.write(" " + s.operator + " "), this[s.right.type](s.right, o);
  },
  AssignmentPattern(s, o) {
    this[s.left.type](s.left, o), o.write(" = "), this[s.right.type](s.right, o);
  },
  BinaryExpression: BinaryExpression = function(s, o) {
    const l = s.operator === "in";
    l && o.write("("), formatExpression(o, s.left, s, !1), o.write(" " + s.operator + " "), formatExpression(o, s.right, s, !0), l && o.write(")");
  },
  LogicalExpression: BinaryExpression,
  ConditionalExpression(s, o) {
    const { test: l } = s, u = o.expressionsPrecedence[l.type];
    u === NEEDS_PARENTHESES || u <= o.expressionsPrecedence.ConditionalExpression ? (o.write("("), this[l.type](l, o), o.write(")")) : this[l.type](l, o), o.write(" ? "), this[s.consequent.type](s.consequent, o), o.write(" : "), this[s.alternate.type](s.alternate, o);
  },
  NewExpression(s, o) {
    o.write("new ");
    const l = o.expressionsPrecedence[s.callee.type];
    l === NEEDS_PARENTHESES || l < o.expressionsPrecedence.CallExpression || hasCallExpression(s.callee) ? (o.write("("), this[s.callee.type](s.callee, o), o.write(")")) : this[s.callee.type](s.callee, o), formatSequence(o, s.arguments);
  },
  CallExpression(s, o) {
    const l = o.expressionsPrecedence[s.callee.type];
    l === NEEDS_PARENTHESES || l < o.expressionsPrecedence.CallExpression ? (o.write("("), this[s.callee.type](s.callee, o), o.write(")")) : this[s.callee.type](s.callee, o), s.optional && o.write("?."), formatSequence(o, s.arguments);
  },
  ChainExpression(s, o) {
    this[s.expression.type](s.expression, o);
  },
  MemberExpression(s, o) {
    const l = o.expressionsPrecedence[s.object.type];
    l === NEEDS_PARENTHESES || l < o.expressionsPrecedence.MemberExpression ? (o.write("("), this[s.object.type](s.object, o), o.write(")")) : this[s.object.type](s.object, o), s.computed ? (s.optional && o.write("?."), o.write("["), this[s.property.type](s.property, o), o.write("]")) : (s.optional ? o.write("?.") : o.write("."), this[s.property.type](s.property, o));
  },
  MetaProperty(s, o) {
    o.write(s.meta.name + "." + s.property.name, s);
  },
  Identifier(s, o) {
    o.write(s.name, s);
  },
  PrivateIdentifier(s, o) {
    o.write(`#${s.name}`, s);
  },
  Literal(s, o) {
    s.raw != null ? o.write(s.raw, s) : s.regex != null ? this.RegExpLiteral(s, o) : s.bigint != null ? o.write(s.bigint + "n", s) : o.write(stringify$2(s.value), s);
  },
  RegExpLiteral(s, o) {
    const { regex: l } = s;
    o.write(`/${l.pattern}/${l.flags}`, s);
  }
}, EMPTY_OBJECT = {};
class State {
  constructor(o) {
    const l = o ?? EMPTY_OBJECT;
    this.output = "", l.output != null ? (this.output = l.output, this.write = this.writeToStream) : this.output = "", this.generator = l.generator != null ? l.generator : GENERATOR, this.expressionsPrecedence = l.expressionsPrecedence != null ? l.expressionsPrecedence : EXPRESSIONS_PRECEDENCE, this.indent = l.indent != null ? l.indent : "  ", this.lineEnd = l.lineEnd != null ? l.lineEnd : `
`, this.indentLevel = l.startingIndentLevel != null ? l.startingIndentLevel : 0, this.writeComments = l.comments ? l.comments : !1, l.sourceMap != null && (this.write = l.output == null ? this.writeAndMap : this.writeToStreamAndMap, this.sourceMap = l.sourceMap, this.line = 1, this.column = 0, this.lineEndSize = this.lineEnd.split(`
`).length - 1, this.mapping = {
      original: null,
      // Uses the entire state to avoid generating ephemeral objects
      generated: this,
      name: void 0,
      source: l.sourceMap.file || l.sourceMap._file
    });
  }
  write(o) {
    this.output += o;
  }
  writeToStream(o) {
    this.output.write(o);
  }
  writeAndMap(o, l) {
    this.output += o, this.map(o, l);
  }
  writeToStreamAndMap(o, l) {
    this.output.write(o), this.map(o, l);
  }
  map(o, l) {
    if (l != null) {
      const { type: m } = l;
      if (m[0] === "L" && m[2] === "n") {
        this.column = 0, this.line++;
        return;
      }
      if (l.loc != null) {
        const { mapping: g } = this;
        g.original = l.loc.start, g.name = l.name, this.sourceMap.addMapping(g);
      }
      if (m[0] === "T" && m[8] === "E" || m[0] === "L" && m[1] === "i" && typeof l.value == "string") {
        const { length: g } = o;
        let { column: v, line: b } = this;
        for (let S = 0; S < g; S++)
          o[S] === `
` ? (v = 0, b++) : v++;
        this.column = v, this.line = b;
        return;
      }
    }
    const { length: u } = o, { lineEnd: c } = this;
    u > 0 && (this.lineEndSize > 0 && (c.length === 1 ? o[u - 1] === c : o.endsWith(c)) ? (this.line += this.lineEndSize, this.column = 0) : this.column += u);
  }
  toString() {
    return this.output;
  }
}
function generate(s, o) {
  const l = new State(o);
  return l.generator[s.type](s, l), l.output;
}
const emptyOptions$1 = {};
function toJs(s, o) {
  const { SourceMapGenerator: l, filePath: u, handlers: c } = o || emptyOptions$1, m = l ? new l({ file: u || "<unknown>.js" }) : void 0, g = generate(
    s,
    // @ts-expect-error: `sourceMap` can be undefined, `astring` types are buggy.
    {
      comments: !0,
      generator: { ...GENERATOR, ...c },
      sourceMap: m || void 0
    }
  ), v = m ? m.toJSON() : void 0;
  return { value: g, map: v };
}
const jsx = {
  JSXAttribute: jsxAttribute,
  JSXClosingElement: jsxClosingElement,
  JSXClosingFragment: jsxClosingFragment,
  JSXElement: jsxElement,
  JSXEmptyExpression: jsxEmptyExpression,
  JSXExpressionContainer: jsxExpressionContainer,
  JSXFragment: jsxFragment,
  JSXIdentifier: jsxIdentifier,
  JSXMemberExpression: jsxMemberExpression,
  JSXNamespacedName: jsxNamespacedName,
  JSXOpeningElement: jsxOpeningElement,
  JSXOpeningFragment: jsxOpeningFragment,
  JSXSpreadAttribute: jsxSpreadAttribute,
  JSXText: jsxText
};
function jsxAttribute(s, o) {
  this[s.name.type](s.name, o), s.value !== null && s.value !== void 0 && (o.write("="), s.value.type === "Literal" ? o.write(
    '"' + encodeJsx(String(s.value.value)).replace(/"/g, "&quot;") + '"',
    s
  ) : this[s.value.type](s.value, o));
}
function jsxClosingElement(s, o) {
  o.write("</"), this[s.name.type](s.name, o), o.write(">");
}
function jsxClosingFragment(s, o) {
  o.write("</>", s);
}
function jsxElement(s, o) {
  let l = -1;
  if (this[s.openingElement.type](s.openingElement, o), s.children)
    for (; ++l < s.children.length; ) {
      const u = s.children[l];
      if (u.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[u.type](u, o);
    }
  s.closingElement && this[s.closingElement.type](s.closingElement, o);
}
function jsxEmptyExpression() {
}
function jsxExpressionContainer(s, o) {
  o.write("{"), this[s.expression.type](s.expression, o), o.write("}");
}
function jsxFragment(s, o) {
  let l = -1;
  if (this[s.openingFragment.type](s.openingFragment, o), s.children)
    for (; ++l < s.children.length; ) {
      const u = s.children[l];
      if (u.type === "JSXSpreadChild")
        throw new Error("JSX spread children are not supported");
      this[u.type](u, o);
    }
  this[s.closingFragment.type](s.closingFragment, o);
}
function jsxIdentifier(s, o) {
  o.write(s.name, s);
}
function jsxMemberExpression(s, o) {
  this[s.object.type](s.object, o), o.write("."), this[s.property.type](s.property, o);
}
function jsxNamespacedName(s, o) {
  this[s.namespace.type](s.namespace, o), o.write(":"), this[s.name.type](s.name, o);
}
function jsxOpeningElement(s, o) {
  let l = -1;
  if (o.write("<"), this[s.name.type](s.name, o), s.attributes)
    for (; ++l < s.attributes.length; )
      o.write(" "), this[s.attributes[l].type](s.attributes[l], o);
  o.write(s.selfClosing ? " />" : ">");
}
function jsxOpeningFragment(s, o) {
  o.write("<>", s);
}
function jsxSpreadAttribute(s, o) {
  o.write("{"), this.SpreadElement(s, o), o.write("}");
}
function jsxText(s, o) {
  o.write(encodeJsx(s.value).replace(/[<>{}]/g, replaceJsxChar), s);
}
function encodeJsx(s) {
  return s.replace(/&(?=[#a-z])/gi, "&amp;");
}
function replaceJsxChar(s) {
  return s === "<" ? "&lt;" : s === ">" ? "&gt;" : s === "{" ? "&#123;" : "&#125;";
}
function recmaStringify(s) {
  const o = (
    /** @type {Processor} */
    this
  ), { SourceMapGenerator: l } = s;
  o.compiler = u;
  function u(c, m) {
    const g = l ? toJs(c, {
      SourceMapGenerator: l,
      filePath: m.path || "unknown.mdx",
      handlers: jsx
    }) : toJs(c, { handlers: jsx });
    return m.map = g.map, g.value;
  }
}
function comment(s, o) {
  const l = { type: "Block", value: s.value };
  o.inherit(s, l), o.comments.push(l);
  const u = {
    type: "JSXEmptyExpression",
    // @ts-expect-error: `comments` is custom.
    comments: [Object.assign({}, l, { leading: !1, trailing: !0 })]
  };
  o.patch(s, u);
  const c = { type: "JSXExpressionContainer", expression: u };
  return o.patch(s, c), c;
}
function stringify$1(s, o) {
  const l = {};
  return (s[s.length - 1] === "" ? [...s, ""] : s).join(
    (l.padRight ? " " : "") + "," + (l.padLeft === !1 ? "" : " ")
  ).trim();
}
class Schema {
  /**
   * @constructor
   * @param {Properties} property
   * @param {Normal} normal
   * @param {string} [space]
   */
  constructor(o, l, u) {
    this.property = o, this.normal = l, u && (this.space = u);
  }
}
Schema.prototype.property = {};
Schema.prototype.normal = {};
Schema.prototype.space = null;
function merge(s, o) {
  const l = {}, u = {};
  let c = -1;
  for (; ++c < s.length; )
    Object.assign(l, s[c].property), Object.assign(u, s[c].normal);
  return new Schema(l, u, o);
}
function normalize(s) {
  return s.toLowerCase();
}
class Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   */
  constructor(o, l) {
    this.property = o, this.attribute = l;
  }
}
Info.prototype.space = null;
Info.prototype.boolean = !1;
Info.prototype.booleanish = !1;
Info.prototype.overloadedBoolean = !1;
Info.prototype.number = !1;
Info.prototype.commaSeparated = !1;
Info.prototype.spaceSeparated = !1;
Info.prototype.commaOrSpaceSeparated = !1;
Info.prototype.mustUseProperty = !1;
Info.prototype.defined = !1;
let powers = 0;
const boolean = increment(), booleanish = increment(), overloadedBoolean = increment(), number = increment(), spaceSeparated = increment(), commaSeparated = increment(), commaOrSpaceSeparated = increment();
function increment() {
  return 2 ** ++powers;
}
const types = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  boolean,
  booleanish,
  commaOrSpaceSeparated,
  commaSeparated,
  number,
  overloadedBoolean,
  spaceSeparated
}, Symbol.toStringTag, { value: "Module" })), checks = Object.keys(types);
class DefinedInfo extends Info {
  /**
   * @constructor
   * @param {string} property
   * @param {string} attribute
   * @param {number|null} [mask]
   * @param {string} [space]
   */
  constructor(o, l, u, c) {
    let m = -1;
    if (super(o, l), mark(this, "space", c), typeof u == "number")
      for (; ++m < checks.length; ) {
        const g = checks[m];
        mark(this, checks[m], (u & types[g]) === types[g]);
      }
  }
}
DefinedInfo.prototype.defined = !0;
function mark(s, o, l) {
  l && (s[o] = l);
}
const own$4 = {}.hasOwnProperty;
function create(s) {
  const o = {}, l = {};
  let u;
  for (u in s.properties)
    if (own$4.call(s.properties, u)) {
      const c = s.properties[u], m = new DefinedInfo(
        u,
        s.transform(s.attributes || {}, u),
        c,
        s.space
      );
      s.mustUseProperty && s.mustUseProperty.includes(u) && (m.mustUseProperty = !0), o[u] = m, l[normalize(u)] = u, l[normalize(m.attribute)] = u;
    }
  return new Schema(o, l, s.space);
}
const xlink = create({
  space: "xlink",
  transform(s, o) {
    return "xlink:" + o.slice(5).toLowerCase();
  },
  properties: {
    xLinkActuate: null,
    xLinkArcRole: null,
    xLinkHref: null,
    xLinkRole: null,
    xLinkShow: null,
    xLinkTitle: null,
    xLinkType: null
  }
}), xml = create({
  space: "xml",
  transform(s, o) {
    return "xml:" + o.slice(3).toLowerCase();
  },
  properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
});
function caseSensitiveTransform(s, o) {
  return o in s ? s[o] : o;
}
function caseInsensitiveTransform(s, o) {
  return caseSensitiveTransform(s, o.toLowerCase());
}
const xmlns = create({
  space: "xmlns",
  attributes: { xmlnsxlink: "xmlns:xlink" },
  transform: caseInsensitiveTransform,
  properties: { xmlns: null, xmlnsXLink: null }
}), aria = create({
  transform(s, o) {
    return o === "role" ? o : "aria-" + o.slice(4).toLowerCase();
  },
  properties: {
    ariaActiveDescendant: null,
    ariaAtomic: booleanish,
    ariaAutoComplete: null,
    ariaBusy: booleanish,
    ariaChecked: booleanish,
    ariaColCount: number,
    ariaColIndex: number,
    ariaColSpan: number,
    ariaControls: spaceSeparated,
    ariaCurrent: null,
    ariaDescribedBy: spaceSeparated,
    ariaDetails: null,
    ariaDisabled: booleanish,
    ariaDropEffect: spaceSeparated,
    ariaErrorMessage: null,
    ariaExpanded: booleanish,
    ariaFlowTo: spaceSeparated,
    ariaGrabbed: booleanish,
    ariaHasPopup: null,
    ariaHidden: booleanish,
    ariaInvalid: null,
    ariaKeyShortcuts: null,
    ariaLabel: null,
    ariaLabelledBy: spaceSeparated,
    ariaLevel: number,
    ariaLive: null,
    ariaModal: booleanish,
    ariaMultiLine: booleanish,
    ariaMultiSelectable: booleanish,
    ariaOrientation: null,
    ariaOwns: spaceSeparated,
    ariaPlaceholder: null,
    ariaPosInSet: number,
    ariaPressed: booleanish,
    ariaReadOnly: booleanish,
    ariaRelevant: null,
    ariaRequired: booleanish,
    ariaRoleDescription: spaceSeparated,
    ariaRowCount: number,
    ariaRowIndex: number,
    ariaRowSpan: number,
    ariaSelected: booleanish,
    ariaSetSize: number,
    ariaSort: null,
    ariaValueMax: number,
    ariaValueMin: number,
    ariaValueNow: number,
    ariaValueText: null,
    role: null
  }
}), html$3 = create({
  space: "html",
  attributes: {
    acceptcharset: "accept-charset",
    classname: "class",
    htmlfor: "for",
    httpequiv: "http-equiv"
  },
  transform: caseInsensitiveTransform,
  mustUseProperty: ["checked", "multiple", "muted", "selected"],
  properties: {
    // Standard Properties.
    abbr: null,
    accept: commaSeparated,
    acceptCharset: spaceSeparated,
    accessKey: spaceSeparated,
    action: null,
    allow: null,
    allowFullScreen: boolean,
    allowPaymentRequest: boolean,
    allowUserMedia: boolean,
    alt: null,
    as: null,
    async: boolean,
    autoCapitalize: null,
    autoComplete: spaceSeparated,
    autoFocus: boolean,
    autoPlay: boolean,
    blocking: spaceSeparated,
    capture: null,
    charSet: null,
    checked: boolean,
    cite: null,
    className: spaceSeparated,
    cols: number,
    colSpan: null,
    content: null,
    contentEditable: booleanish,
    controls: boolean,
    controlsList: spaceSeparated,
    coords: number | commaSeparated,
    crossOrigin: null,
    data: null,
    dateTime: null,
    decoding: null,
    default: boolean,
    defer: boolean,
    dir: null,
    dirName: null,
    disabled: boolean,
    download: overloadedBoolean,
    draggable: booleanish,
    encType: null,
    enterKeyHint: null,
    fetchPriority: null,
    form: null,
    formAction: null,
    formEncType: null,
    formMethod: null,
    formNoValidate: boolean,
    formTarget: null,
    headers: spaceSeparated,
    height: number,
    hidden: boolean,
    high: number,
    href: null,
    hrefLang: null,
    htmlFor: spaceSeparated,
    httpEquiv: spaceSeparated,
    id: null,
    imageSizes: null,
    imageSrcSet: null,
    inert: boolean,
    inputMode: null,
    integrity: null,
    is: null,
    isMap: boolean,
    itemId: null,
    itemProp: spaceSeparated,
    itemRef: spaceSeparated,
    itemScope: boolean,
    itemType: spaceSeparated,
    kind: null,
    label: null,
    lang: null,
    language: null,
    list: null,
    loading: null,
    loop: boolean,
    low: number,
    manifest: null,
    max: null,
    maxLength: number,
    media: null,
    method: null,
    min: null,
    minLength: number,
    multiple: boolean,
    muted: boolean,
    name: null,
    nonce: null,
    noModule: boolean,
    noValidate: boolean,
    onAbort: null,
    onAfterPrint: null,
    onAuxClick: null,
    onBeforeMatch: null,
    onBeforePrint: null,
    onBeforeToggle: null,
    onBeforeUnload: null,
    onBlur: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onContextLost: null,
    onContextMenu: null,
    onContextRestored: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFormData: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLanguageChange: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadEnd: null,
    onLoadStart: null,
    onMessage: null,
    onMessageError: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRejectionHandled: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onScrollEnd: null,
    onSecurityPolicyViolation: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onSlotChange: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnhandledRejection: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onWheel: null,
    open: boolean,
    optimum: number,
    pattern: null,
    ping: spaceSeparated,
    placeholder: null,
    playsInline: boolean,
    popover: null,
    popoverTarget: null,
    popoverTargetAction: null,
    poster: null,
    preload: null,
    readOnly: boolean,
    referrerPolicy: null,
    rel: spaceSeparated,
    required: boolean,
    reversed: boolean,
    rows: number,
    rowSpan: number,
    sandbox: spaceSeparated,
    scope: null,
    scoped: boolean,
    seamless: boolean,
    selected: boolean,
    shadowRootClonable: boolean,
    shadowRootDelegatesFocus: boolean,
    shadowRootMode: null,
    shape: null,
    size: number,
    sizes: null,
    slot: null,
    span: number,
    spellCheck: booleanish,
    src: null,
    srcDoc: null,
    srcLang: null,
    srcSet: null,
    start: number,
    step: null,
    style: null,
    tabIndex: number,
    target: null,
    title: null,
    translate: null,
    type: null,
    typeMustMatch: boolean,
    useMap: null,
    value: booleanish,
    width: number,
    wrap: null,
    writingSuggestions: null,
    // Legacy.
    // See: https://html.spec.whatwg.org/#other-elements,-attributes-and-apis
    align: null,
    // Several. Use CSS `text-align` instead,
    aLink: null,
    // `<body>`. Use CSS `a:active {color}` instead
    archive: spaceSeparated,
    // `<object>`. List of URIs to archives
    axis: null,
    // `<td>` and `<th>`. Use `scope` on `<th>`
    background: null,
    // `<body>`. Use CSS `background-image` instead
    bgColor: null,
    // `<body>` and table elements. Use CSS `background-color` instead
    border: number,
    // `<table>`. Use CSS `border-width` instead,
    borderColor: null,
    // `<table>`. Use CSS `border-color` instead,
    bottomMargin: number,
    // `<body>`
    cellPadding: null,
    // `<table>`
    cellSpacing: null,
    // `<table>`
    char: null,
    // Several table elements. When `align=char`, sets the character to align on
    charOff: null,
    // Several table elements. When `char`, offsets the alignment
    classId: null,
    // `<object>`
    clear: null,
    // `<br>`. Use CSS `clear` instead
    code: null,
    // `<object>`
    codeBase: null,
    // `<object>`
    codeType: null,
    // `<object>`
    color: null,
    // `<font>` and `<hr>`. Use CSS instead
    compact: boolean,
    // Lists. Use CSS to reduce space between items instead
    declare: boolean,
    // `<object>`
    event: null,
    // `<script>`
    face: null,
    // `<font>`. Use CSS instead
    frame: null,
    // `<table>`
    frameBorder: null,
    // `<iframe>`. Use CSS `border` instead
    hSpace: number,
    // `<img>` and `<object>`
    leftMargin: number,
    // `<body>`
    link: null,
    // `<body>`. Use CSS `a:link {color: *}` instead
    longDesc: null,
    // `<frame>`, `<iframe>`, and `<img>`. Use an `<a>`
    lowSrc: null,
    // `<img>`. Use a `<picture>`
    marginHeight: number,
    // `<body>`
    marginWidth: number,
    // `<body>`
    noResize: boolean,
    // `<frame>`
    noHref: boolean,
    // `<area>`. Use no href instead of an explicit `nohref`
    noShade: boolean,
    // `<hr>`. Use background-color and height instead of borders
    noWrap: boolean,
    // `<td>` and `<th>`
    object: null,
    // `<applet>`
    profile: null,
    // `<head>`
    prompt: null,
    // `<isindex>`
    rev: null,
    // `<link>`
    rightMargin: number,
    // `<body>`
    rules: null,
    // `<table>`
    scheme: null,
    // `<meta>`
    scrolling: booleanish,
    // `<frame>`. Use overflow in the child context
    standby: null,
    // `<object>`
    summary: null,
    // `<table>`
    text: null,
    // `<body>`. Use CSS `color` instead
    topMargin: number,
    // `<body>`
    valueType: null,
    // `<param>`
    version: null,
    // `<html>`. Use a doctype.
    vAlign: null,
    // Several. Use CSS `vertical-align` instead
    vLink: null,
    // `<body>`. Use CSS `a:visited {color}` instead
    vSpace: number,
    // `<img>` and `<object>`
    // Non-standard Properties.
    allowTransparency: null,
    autoCorrect: null,
    autoSave: null,
    disablePictureInPicture: boolean,
    disableRemotePlayback: boolean,
    prefix: null,
    property: null,
    results: number,
    security: null,
    unselectable: null
  }
}), svg$1 = create({
  space: "svg",
  attributes: {
    accentHeight: "accent-height",
    alignmentBaseline: "alignment-baseline",
    arabicForm: "arabic-form",
    baselineShift: "baseline-shift",
    capHeight: "cap-height",
    className: "class",
    clipPath: "clip-path",
    clipRule: "clip-rule",
    colorInterpolation: "color-interpolation",
    colorInterpolationFilters: "color-interpolation-filters",
    colorProfile: "color-profile",
    colorRendering: "color-rendering",
    crossOrigin: "crossorigin",
    dataType: "datatype",
    dominantBaseline: "dominant-baseline",
    enableBackground: "enable-background",
    fillOpacity: "fill-opacity",
    fillRule: "fill-rule",
    floodColor: "flood-color",
    floodOpacity: "flood-opacity",
    fontFamily: "font-family",
    fontSize: "font-size",
    fontSizeAdjust: "font-size-adjust",
    fontStretch: "font-stretch",
    fontStyle: "font-style",
    fontVariant: "font-variant",
    fontWeight: "font-weight",
    glyphName: "glyph-name",
    glyphOrientationHorizontal: "glyph-orientation-horizontal",
    glyphOrientationVertical: "glyph-orientation-vertical",
    hrefLang: "hreflang",
    horizAdvX: "horiz-adv-x",
    horizOriginX: "horiz-origin-x",
    horizOriginY: "horiz-origin-y",
    imageRendering: "image-rendering",
    letterSpacing: "letter-spacing",
    lightingColor: "lighting-color",
    markerEnd: "marker-end",
    markerMid: "marker-mid",
    markerStart: "marker-start",
    navDown: "nav-down",
    navDownLeft: "nav-down-left",
    navDownRight: "nav-down-right",
    navLeft: "nav-left",
    navNext: "nav-next",
    navPrev: "nav-prev",
    navRight: "nav-right",
    navUp: "nav-up",
    navUpLeft: "nav-up-left",
    navUpRight: "nav-up-right",
    onAbort: "onabort",
    onActivate: "onactivate",
    onAfterPrint: "onafterprint",
    onBeforePrint: "onbeforeprint",
    onBegin: "onbegin",
    onCancel: "oncancel",
    onCanPlay: "oncanplay",
    onCanPlayThrough: "oncanplaythrough",
    onChange: "onchange",
    onClick: "onclick",
    onClose: "onclose",
    onCopy: "oncopy",
    onCueChange: "oncuechange",
    onCut: "oncut",
    onDblClick: "ondblclick",
    onDrag: "ondrag",
    onDragEnd: "ondragend",
    onDragEnter: "ondragenter",
    onDragExit: "ondragexit",
    onDragLeave: "ondragleave",
    onDragOver: "ondragover",
    onDragStart: "ondragstart",
    onDrop: "ondrop",
    onDurationChange: "ondurationchange",
    onEmptied: "onemptied",
    onEnd: "onend",
    onEnded: "onended",
    onError: "onerror",
    onFocus: "onfocus",
    onFocusIn: "onfocusin",
    onFocusOut: "onfocusout",
    onHashChange: "onhashchange",
    onInput: "oninput",
    onInvalid: "oninvalid",
    onKeyDown: "onkeydown",
    onKeyPress: "onkeypress",
    onKeyUp: "onkeyup",
    onLoad: "onload",
    onLoadedData: "onloadeddata",
    onLoadedMetadata: "onloadedmetadata",
    onLoadStart: "onloadstart",
    onMessage: "onmessage",
    onMouseDown: "onmousedown",
    onMouseEnter: "onmouseenter",
    onMouseLeave: "onmouseleave",
    onMouseMove: "onmousemove",
    onMouseOut: "onmouseout",
    onMouseOver: "onmouseover",
    onMouseUp: "onmouseup",
    onMouseWheel: "onmousewheel",
    onOffline: "onoffline",
    onOnline: "ononline",
    onPageHide: "onpagehide",
    onPageShow: "onpageshow",
    onPaste: "onpaste",
    onPause: "onpause",
    onPlay: "onplay",
    onPlaying: "onplaying",
    onPopState: "onpopstate",
    onProgress: "onprogress",
    onRateChange: "onratechange",
    onRepeat: "onrepeat",
    onReset: "onreset",
    onResize: "onresize",
    onScroll: "onscroll",
    onSeeked: "onseeked",
    onSeeking: "onseeking",
    onSelect: "onselect",
    onShow: "onshow",
    onStalled: "onstalled",
    onStorage: "onstorage",
    onSubmit: "onsubmit",
    onSuspend: "onsuspend",
    onTimeUpdate: "ontimeupdate",
    onToggle: "ontoggle",
    onUnload: "onunload",
    onVolumeChange: "onvolumechange",
    onWaiting: "onwaiting",
    onZoom: "onzoom",
    overlinePosition: "overline-position",
    overlineThickness: "overline-thickness",
    paintOrder: "paint-order",
    panose1: "panose-1",
    pointerEvents: "pointer-events",
    referrerPolicy: "referrerpolicy",
    renderingIntent: "rendering-intent",
    shapeRendering: "shape-rendering",
    stopColor: "stop-color",
    stopOpacity: "stop-opacity",
    strikethroughPosition: "strikethrough-position",
    strikethroughThickness: "strikethrough-thickness",
    strokeDashArray: "stroke-dasharray",
    strokeDashOffset: "stroke-dashoffset",
    strokeLineCap: "stroke-linecap",
    strokeLineJoin: "stroke-linejoin",
    strokeMiterLimit: "stroke-miterlimit",
    strokeOpacity: "stroke-opacity",
    strokeWidth: "stroke-width",
    tabIndex: "tabindex",
    textAnchor: "text-anchor",
    textDecoration: "text-decoration",
    textRendering: "text-rendering",
    transformOrigin: "transform-origin",
    typeOf: "typeof",
    underlinePosition: "underline-position",
    underlineThickness: "underline-thickness",
    unicodeBidi: "unicode-bidi",
    unicodeRange: "unicode-range",
    unitsPerEm: "units-per-em",
    vAlphabetic: "v-alphabetic",
    vHanging: "v-hanging",
    vIdeographic: "v-ideographic",
    vMathematical: "v-mathematical",
    vectorEffect: "vector-effect",
    vertAdvY: "vert-adv-y",
    vertOriginX: "vert-origin-x",
    vertOriginY: "vert-origin-y",
    wordSpacing: "word-spacing",
    writingMode: "writing-mode",
    xHeight: "x-height",
    // These were camelcased in Tiny. Now lowercased in SVG 2
    playbackOrder: "playbackorder",
    timelineBegin: "timelinebegin"
  },
  transform: caseSensitiveTransform,
  properties: {
    about: commaOrSpaceSeparated,
    accentHeight: number,
    accumulate: null,
    additive: null,
    alignmentBaseline: null,
    alphabetic: number,
    amplitude: number,
    arabicForm: null,
    ascent: number,
    attributeName: null,
    attributeType: null,
    azimuth: number,
    bandwidth: null,
    baselineShift: null,
    baseFrequency: null,
    baseProfile: null,
    bbox: null,
    begin: null,
    bias: number,
    by: null,
    calcMode: null,
    capHeight: number,
    className: spaceSeparated,
    clip: null,
    clipPath: null,
    clipPathUnits: null,
    clipRule: null,
    color: null,
    colorInterpolation: null,
    colorInterpolationFilters: null,
    colorProfile: null,
    colorRendering: null,
    content: null,
    contentScriptType: null,
    contentStyleType: null,
    crossOrigin: null,
    cursor: null,
    cx: null,
    cy: null,
    d: null,
    dataType: null,
    defaultAction: null,
    descent: number,
    diffuseConstant: number,
    direction: null,
    display: null,
    dur: null,
    divisor: number,
    dominantBaseline: null,
    download: boolean,
    dx: null,
    dy: null,
    edgeMode: null,
    editable: null,
    elevation: number,
    enableBackground: null,
    end: null,
    event: null,
    exponent: number,
    externalResourcesRequired: null,
    fill: null,
    fillOpacity: number,
    fillRule: null,
    filter: null,
    filterRes: null,
    filterUnits: null,
    floodColor: null,
    floodOpacity: null,
    focusable: null,
    focusHighlight: null,
    fontFamily: null,
    fontSize: null,
    fontSizeAdjust: null,
    fontStretch: null,
    fontStyle: null,
    fontVariant: null,
    fontWeight: null,
    format: null,
    fr: null,
    from: null,
    fx: null,
    fy: null,
    g1: commaSeparated,
    g2: commaSeparated,
    glyphName: commaSeparated,
    glyphOrientationHorizontal: null,
    glyphOrientationVertical: null,
    glyphRef: null,
    gradientTransform: null,
    gradientUnits: null,
    handler: null,
    hanging: number,
    hatchContentUnits: null,
    hatchUnits: null,
    height: null,
    href: null,
    hrefLang: null,
    horizAdvX: number,
    horizOriginX: number,
    horizOriginY: number,
    id: null,
    ideographic: number,
    imageRendering: null,
    initialVisibility: null,
    in: null,
    in2: null,
    intercept: number,
    k: number,
    k1: number,
    k2: number,
    k3: number,
    k4: number,
    kernelMatrix: commaOrSpaceSeparated,
    kernelUnitLength: null,
    keyPoints: null,
    // SEMI_COLON_SEPARATED
    keySplines: null,
    // SEMI_COLON_SEPARATED
    keyTimes: null,
    // SEMI_COLON_SEPARATED
    kerning: null,
    lang: null,
    lengthAdjust: null,
    letterSpacing: null,
    lightingColor: null,
    limitingConeAngle: number,
    local: null,
    markerEnd: null,
    markerMid: null,
    markerStart: null,
    markerHeight: null,
    markerUnits: null,
    markerWidth: null,
    mask: null,
    maskContentUnits: null,
    maskUnits: null,
    mathematical: null,
    max: null,
    media: null,
    mediaCharacterEncoding: null,
    mediaContentEncodings: null,
    mediaSize: number,
    mediaTime: null,
    method: null,
    min: null,
    mode: null,
    name: null,
    navDown: null,
    navDownLeft: null,
    navDownRight: null,
    navLeft: null,
    navNext: null,
    navPrev: null,
    navRight: null,
    navUp: null,
    navUpLeft: null,
    navUpRight: null,
    numOctaves: null,
    observer: null,
    offset: null,
    onAbort: null,
    onActivate: null,
    onAfterPrint: null,
    onBeforePrint: null,
    onBegin: null,
    onCancel: null,
    onCanPlay: null,
    onCanPlayThrough: null,
    onChange: null,
    onClick: null,
    onClose: null,
    onCopy: null,
    onCueChange: null,
    onCut: null,
    onDblClick: null,
    onDrag: null,
    onDragEnd: null,
    onDragEnter: null,
    onDragExit: null,
    onDragLeave: null,
    onDragOver: null,
    onDragStart: null,
    onDrop: null,
    onDurationChange: null,
    onEmptied: null,
    onEnd: null,
    onEnded: null,
    onError: null,
    onFocus: null,
    onFocusIn: null,
    onFocusOut: null,
    onHashChange: null,
    onInput: null,
    onInvalid: null,
    onKeyDown: null,
    onKeyPress: null,
    onKeyUp: null,
    onLoad: null,
    onLoadedData: null,
    onLoadedMetadata: null,
    onLoadStart: null,
    onMessage: null,
    onMouseDown: null,
    onMouseEnter: null,
    onMouseLeave: null,
    onMouseMove: null,
    onMouseOut: null,
    onMouseOver: null,
    onMouseUp: null,
    onMouseWheel: null,
    onOffline: null,
    onOnline: null,
    onPageHide: null,
    onPageShow: null,
    onPaste: null,
    onPause: null,
    onPlay: null,
    onPlaying: null,
    onPopState: null,
    onProgress: null,
    onRateChange: null,
    onRepeat: null,
    onReset: null,
    onResize: null,
    onScroll: null,
    onSeeked: null,
    onSeeking: null,
    onSelect: null,
    onShow: null,
    onStalled: null,
    onStorage: null,
    onSubmit: null,
    onSuspend: null,
    onTimeUpdate: null,
    onToggle: null,
    onUnload: null,
    onVolumeChange: null,
    onWaiting: null,
    onZoom: null,
    opacity: null,
    operator: null,
    order: null,
    orient: null,
    orientation: null,
    origin: null,
    overflow: null,
    overlay: null,
    overlinePosition: number,
    overlineThickness: number,
    paintOrder: null,
    panose1: null,
    path: null,
    pathLength: number,
    patternContentUnits: null,
    patternTransform: null,
    patternUnits: null,
    phase: null,
    ping: spaceSeparated,
    pitch: null,
    playbackOrder: null,
    pointerEvents: null,
    points: null,
    pointsAtX: number,
    pointsAtY: number,
    pointsAtZ: number,
    preserveAlpha: null,
    preserveAspectRatio: null,
    primitiveUnits: null,
    propagate: null,
    property: commaOrSpaceSeparated,
    r: null,
    radius: null,
    referrerPolicy: null,
    refX: null,
    refY: null,
    rel: commaOrSpaceSeparated,
    rev: commaOrSpaceSeparated,
    renderingIntent: null,
    repeatCount: null,
    repeatDur: null,
    requiredExtensions: commaOrSpaceSeparated,
    requiredFeatures: commaOrSpaceSeparated,
    requiredFonts: commaOrSpaceSeparated,
    requiredFormats: commaOrSpaceSeparated,
    resource: null,
    restart: null,
    result: null,
    rotate: null,
    rx: null,
    ry: null,
    scale: null,
    seed: null,
    shapeRendering: null,
    side: null,
    slope: null,
    snapshotTime: null,
    specularConstant: number,
    specularExponent: number,
    spreadMethod: null,
    spacing: null,
    startOffset: null,
    stdDeviation: null,
    stemh: null,
    stemv: null,
    stitchTiles: null,
    stopColor: null,
    stopOpacity: null,
    strikethroughPosition: number,
    strikethroughThickness: number,
    string: null,
    stroke: null,
    strokeDashArray: commaOrSpaceSeparated,
    strokeDashOffset: null,
    strokeLineCap: null,
    strokeLineJoin: null,
    strokeMiterLimit: number,
    strokeOpacity: number,
    strokeWidth: null,
    style: null,
    surfaceScale: number,
    syncBehavior: null,
    syncBehaviorDefault: null,
    syncMaster: null,
    syncTolerance: null,
    syncToleranceDefault: null,
    systemLanguage: commaOrSpaceSeparated,
    tabIndex: number,
    tableValues: null,
    target: null,
    targetX: number,
    targetY: number,
    textAnchor: null,
    textDecoration: null,
    textRendering: null,
    textLength: null,
    timelineBegin: null,
    title: null,
    transformBehavior: null,
    type: null,
    typeOf: commaOrSpaceSeparated,
    to: null,
    transform: null,
    transformOrigin: null,
    u1: null,
    u2: null,
    underlinePosition: number,
    underlineThickness: number,
    unicode: null,
    unicodeBidi: null,
    unicodeRange: null,
    unitsPerEm: number,
    values: null,
    vAlphabetic: number,
    vMathematical: number,
    vectorEffect: null,
    vHanging: number,
    vIdeographic: number,
    version: null,
    vertAdvY: number,
    vertOriginX: number,
    vertOriginY: number,
    viewBox: null,
    viewTarget: null,
    visibility: null,
    width: null,
    widths: null,
    wordSpacing: null,
    writingMode: null,
    x: null,
    x1: null,
    x2: null,
    xChannelSelector: null,
    xHeight: number,
    y: null,
    y1: null,
    y2: null,
    yChannelSelector: null,
    z: null,
    zoomAndPan: null
  }
}), valid = /^data[-\w.:]+$/i, dash = /-[a-z]/g, cap$1 = /[A-Z]/g;
function find(s, o) {
  const l = normalize(o);
  let u = o, c = Info;
  if (l in s.normal)
    return s.property[s.normal[l]];
  if (l.length > 4 && l.slice(0, 4) === "data" && valid.test(o)) {
    if (o.charAt(4) === "-") {
      const m = o.slice(5).replace(dash, camelcase);
      u = "data" + m.charAt(0).toUpperCase() + m.slice(1);
    } else {
      const m = o.slice(4);
      if (!dash.test(m)) {
        let g = m.replace(cap$1, kebab);
        g.charAt(0) !== "-" && (g = "-" + g), o = "data" + g;
      }
    }
    c = DefinedInfo;
  }
  return new c(u, o);
}
function kebab(s) {
  return "-" + s.toLowerCase();
}
function camelcase(s) {
  return s.charAt(1).toUpperCase();
}
const hastToReact = {
  classId: "classID",
  dataType: "datatype",
  itemId: "itemID",
  strokeDashArray: "strokeDasharray",
  strokeDashOffset: "strokeDashoffset",
  strokeLineCap: "strokeLinecap",
  strokeLineJoin: "strokeLinejoin",
  strokeMiterLimit: "strokeMiterlimit",
  typeOf: "typeof",
  xLinkActuate: "xlinkActuate",
  xLinkArcRole: "xlinkArcrole",
  xLinkHref: "xlinkHref",
  xLinkRole: "xlinkRole",
  xLinkShow: "xlinkShow",
  xLinkTitle: "xlinkTitle",
  xLinkType: "xlinkType",
  xmlnsXLink: "xmlnsXlink"
}, html$2 = merge([xml, xlink, xmlns, aria, html$3], "html"), svg = merge([xml, xlink, xmlns, aria, svg$1], "svg");
function stringify(s) {
  return s.join(" ").trim();
}
var styleToObject = { exports: {} }, COMMENT_REGEX = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, NEWLINE_REGEX = /\n/g, WHITESPACE_REGEX = /^\s*/, PROPERTY_REGEX = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, COLON_REGEX = /^:\s*/, VALUE_REGEX = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, SEMICOLON_REGEX = /^[;\s]*/, TRIM_REGEX = /^\s+|\s+$/g, NEWLINE = `
`, FORWARD_SLASH = "/", ASTERISK = "*", EMPTY_STRING = "", TYPE_COMMENT = "comment", TYPE_DECLARATION = "declaration", inlineStyleParser = function(s, o) {
  if (typeof s != "string")
    throw new TypeError("First argument must be a string");
  if (!s) return [];
  o = o || {};
  var l = 1, u = 1;
  function c(O) {
    var z = O.match(NEWLINE_REGEX);
    z && (l += z.length);
    var Q = O.lastIndexOf(NEWLINE);
    u = ~Q ? O.length - Q : u + O.length;
  }
  function m() {
    var O = { line: l, column: u };
    return function(z) {
      return z.position = new g(O), S(), z;
    };
  }
  function g(O) {
    this.start = O, this.end = { line: l, column: u }, this.source = o.source;
  }
  g.prototype.content = s;
  function v(O) {
    var z = new Error(
      o.source + ":" + l + ":" + u + ": " + O
    );
    if (z.reason = O, z.filename = o.source, z.line = l, z.column = u, z.source = s, !o.silent) throw z;
  }
  function b(O) {
    var z = O.exec(s);
    if (z) {
      var Q = z[0];
      return c(Q), s = s.slice(Q.length), z;
    }
  }
  function S() {
    b(WHITESPACE_REGEX);
  }
  function E(O) {
    var z;
    for (O = O || []; z = P(); )
      z !== !1 && O.push(z);
    return O;
  }
  function P() {
    var O = m();
    if (!(FORWARD_SLASH != s.charAt(0) || ASTERISK != s.charAt(1))) {
      for (var z = 2; EMPTY_STRING != s.charAt(z) && (ASTERISK != s.charAt(z) || FORWARD_SLASH != s.charAt(z + 1)); )
        ++z;
      if (z += 2, EMPTY_STRING === s.charAt(z - 1))
        return v("End of comment missing");
      var Q = s.slice(2, z - 2);
      return u += 2, c(Q), s = s.slice(z), u += 2, O({
        type: TYPE_COMMENT,
        comment: Q
      });
    }
  }
  function T() {
    var O = m(), z = b(PROPERTY_REGEX);
    if (z) {
      if (P(), !b(COLON_REGEX)) return v("property missing ':'");
      var Q = b(VALUE_REGEX), W = O({
        type: TYPE_DECLARATION,
        property: trim(z[0].replace(COMMENT_REGEX, EMPTY_STRING)),
        value: Q ? trim(Q[0].replace(COMMENT_REGEX, EMPTY_STRING)) : EMPTY_STRING
      });
      return b(SEMICOLON_REGEX), W;
    }
  }
  function N() {
    var O = [];
    E(O);
    for (var z; z = T(); )
      z !== !1 && (O.push(z), E(O));
    return O;
  }
  return S(), N();
};
function trim(s) {
  return s ? s.replace(TRIM_REGEX, EMPTY_STRING) : EMPTY_STRING;
}
var parse = inlineStyleParser;
function StyleToObject(s, o) {
  var l = null;
  if (!s || typeof s != "string")
    return l;
  for (var u, c = parse(s), m = typeof o == "function", g, v, b = 0, S = c.length; b < S; b++)
    u = c[b], g = u.property, v = u.value, m ? o(g, v, u) : v && (l || (l = {}), l[g] = v);
  return l;
}
styleToObject.exports = StyleToObject;
styleToObject.exports.default = StyleToObject;
var styleToObjectExports = styleToObject.exports;
const StyleToObject$1 = /* @__PURE__ */ getDefaultExportFromCjs(styleToObjectExports), own$3 = {}.hasOwnProperty, cap = /[A-Z]/g, dashSomething = /-([a-z])/g, tableCellElement = /* @__PURE__ */ new Set(["td", "th"]);
function element(s, o) {
  const l = o.schema;
  let u = l;
  const c = s.properties || {};
  l.space === "html" && s.tagName.toLowerCase() === "svg" && (u = svg, o.schema = u);
  const m = o.all(s), g = [];
  let v, b, S;
  for (v in c)
    if (own$3.call(c, v)) {
      let P = c[v];
      const T = find(u, v);
      let N;
      if (P == null || P === !1 || typeof P == "number" && Number.isNaN(P) || !P && T.boolean)
        continue;
      if (v = o.elementAttributeNameCase === "react" && T.space ? hastToReact[T.property] || T.property : T.attribute, Array.isArray(P) && (P = T.commaSeparated ? stringify$1(P) : stringify(P)), v === "style") {
        let O = typeof P == "object" ? P : parseStyle(String(P), s.tagName);
        o.stylePropertyNameCase === "css" && (O = transformStylesToCssCasing(O));
        const z = [];
        let Q;
        for (Q in O)
          own$3.call(O, Q) && z.push({
            type: "Property",
            method: !1,
            shorthand: !1,
            computed: !1,
            key: name(Q) ? { type: "Identifier", name: Q } : { type: "Literal", value: Q },
            value: { type: "Literal", value: String(O[Q]) },
            kind: "init"
          });
        S = z, N = {
          type: "JSXExpressionContainer",
          expression: { type: "ObjectExpression", properties: z }
        };
      } else if (P === !0)
        N = null;
      else if (o.tableCellAlignToStyle && tableCellElement.has(s.tagName) && v === "align") {
        b = String(P);
        continue;
      } else
        N = { type: "Literal", value: String(P) };
      name(v, { jsx: !0 }) ? g.push({
        type: "JSXAttribute",
        name: { type: "JSXIdentifier", name: v },
        value: N
      }) : g.push({
        type: "JSXSpreadAttribute",
        argument: {
          type: "ObjectExpression",
          properties: [
            {
              type: "Property",
              method: !1,
              shorthand: !1,
              computed: !1,
              key: { type: "Literal", value: String(v) },
              // @ts-expect-error No need to worry about `style` (which has a
              // `JSXExpressionContainer` value) because that’s a valid identifier.
              value: N || { type: "Literal", value: !0 },
              kind: "init"
            }
          ]
        }
      });
    }
  if (b !== void 0) {
    S || (S = [], g.push({
      type: "JSXAttribute",
      name: { type: "JSXIdentifier", name: "style" },
      value: {
        type: "JSXExpressionContainer",
        expression: { type: "ObjectExpression", properties: S }
      }
    }));
    const P = o.stylePropertyNameCase === "css" ? transformStyleToCssCasing("textAlign") : "textAlign";
    S.push({
      type: "Property",
      method: !1,
      shorthand: !1,
      computed: !1,
      key: name(P) ? { type: "Identifier", name: P } : { type: "Literal", value: P },
      value: { type: "Literal", value: b },
      kind: "init"
    });
  }
  o.schema = l;
  const E = {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: g,
      name: o.createJsxElementName(s.tagName),
      selfClosing: m.length === 0
    },
    closingElement: m.length > 0 ? {
      type: "JSXClosingElement",
      name: o.createJsxElementName(s.tagName)
    } : null,
    children: m
  };
  return o.inherit(s, E), E;
}
function parseStyle(s, o) {
  const l = {};
  try {
    StyleToObject$1(s, u);
  } catch (c) {
    const m = (
      /** @type {Error} */
      c
    );
    throw new Error(
      "Could not parse `style` attribute on `" + o + "`",
      { cause: m }
    );
  }
  return l;
  function u(c, m) {
    let g = c;
    g.slice(0, 2) !== "--" && (g.slice(0, 4) === "-ms-" && (g = "ms-" + g.slice(4)), g = g.replace(dashSomething, toCamel)), l[g] = m;
  }
}
function transformStylesToCssCasing(s) {
  const o = {};
  let l;
  for (l in s)
    own$3.call(s, l) && (o[transformStyleToCssCasing(l)] = s[l]);
  return o;
}
function transformStyleToCssCasing(s) {
  let o = s.replace(cap, toDash);
  return o.slice(0, 3) === "ms-" && (o = "-" + o), o;
}
function toCamel(s, o) {
  return o.toUpperCase();
}
function toDash(s) {
  return "-" + s.toLowerCase();
}
const own$2 = {}.hasOwnProperty, emptyComments = [];
function attachComments(s, o) {
  const l = o ? [...o].sort(compare) : emptyComments;
  l.length > 0 && walk(s, { comments: l, index: 0 });
}
function walk(s, o) {
  if (o.index === o.comments.length)
    return;
  const l = [], u = [];
  let c;
  for (c in s)
    if (own$2.call(s, c)) {
      const g = s[c];
      if (g && typeof g == "object" && c !== "comments")
        if (Array.isArray(g)) {
          let v = -1;
          for (; ++v < g.length; )
            g[v] && typeof g[v].type == "string" && l.push(g[v]);
        } else typeof g.type == "string" && l.push(g);
    }
  l.sort(compare), u.push(...slice(o, s, !1, { leading: !0, trailing: !1 }));
  let m = -1;
  for (; ++m < l.length; )
    walk(l[m], o);
  u.push(
    ...slice(o, s, !0, {
      leading: !1,
      trailing: l.length > 0
    })
  ), u.length > 0 && (s.comments = u);
}
function slice(s, o, l, u) {
  const c = [];
  for (; s.comments[s.index] && compare(s.comments[s.index], o, l) < 1; )
    c.push(Object.assign({}, s.comments[s.index++], u));
  return c;
}
function compare(s, o, l) {
  const u = l ? "end" : "start";
  return s.range && o.range ? s.range[0] - o.range[l ? 1 : 0] : s.loc && s.loc.start && o.loc && o.loc[u] ? s.loc.start.line - o.loc[u].line || s.loc.start.column - o.loc[u].column : "start" in s && u in o ? s.start - o[u] : Number.NaN;
}
function mdxExpression(s, o) {
  const l = s.data && s.data.estree, u = l && l.comments || [];
  let c;
  l && (o.comments.push(...u), attachComments(l, l.comments), c = l.body[0] && l.body[0].type === "ExpressionStatement" && l.body[0].expression || void 0), c || (c = { type: "JSXEmptyExpression" }, o.patch(s, c));
  const m = { type: "JSXExpressionContainer", expression: c };
  return o.inherit(s, m), m;
}
function mdxJsxElement(s, o) {
  const l = o.schema;
  let u = l;
  const c = s.attributes || [];
  let m = -1;
  s.name && l.space === "html" && s.name.toLowerCase() === "svg" && (u = svg, o.schema = u);
  const g = o.all(s), v = [];
  for (; ++m < c.length; ) {
    const S = c[m], E = S.value;
    let P;
    if (S.type === "mdxJsxAttribute") {
      if (E == null)
        P = null;
      else if (typeof E == "object") {
        const N = E.data && E.data.estree, O = N && N.comments || [];
        let z;
        N && (o.comments.push(...O), attachComments(N, N.comments), z = N.body[0] && N.body[0].type === "ExpressionStatement" && N.body[0].expression || void 0), P = {
          type: "JSXExpressionContainer",
          expression: z || { type: "JSXEmptyExpression" }
        }, o.inherit(E, P);
      } else
        P = { type: "Literal", value: String(E) };
      const T = {
        type: "JSXAttribute",
        name: o.createJsxAttributeName(S.name),
        value: P
      };
      o.inherit(S, T), v.push(T);
    } else {
      const T = S.data && S.data.estree, N = T && T.comments || [];
      let O;
      T && (o.comments.push(...N), attachComments(T, T.comments), O = T.body[0] && T.body[0].type === "ExpressionStatement" && T.body[0].expression && T.body[0].expression.type === "ObjectExpression" && T.body[0].expression.properties && T.body[0].expression.properties[0] && T.body[0].expression.properties[0].type === "SpreadElement" && T.body[0].expression.properties[0].argument || void 0);
      const z = {
        type: "JSXSpreadAttribute",
        argument: O || { type: "ObjectExpression", properties: [] }
      };
      o.inherit(S, z), v.push(z);
    }
  }
  o.schema = l;
  const b = s.name ? {
    type: "JSXElement",
    openingElement: {
      type: "JSXOpeningElement",
      attributes: v,
      name: o.createJsxElementName(s.name),
      selfClosing: g.length === 0
    },
    closingElement: g.length > 0 ? {
      type: "JSXClosingElement",
      name: o.createJsxElementName(s.name)
    } : null,
    children: g
  } : {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: g
  };
  return o.inherit(s, b), b;
}
function mdxjsEsm(s, o) {
  const l = s.data && s.data.estree, u = l && l.comments || [];
  l && (o.comments.push(...u), attachComments(l, u), o.esm.push(...l.body));
}
const re = /[ \t\n\f\r]/g;
function whitespace(s) {
  return typeof s == "object" ? s.type === "text" ? empty(s.value) : !1 : empty(s);
}
function empty(s) {
  return s.replace(re, "") === "";
}
function root$1(s, o) {
  const l = o.all(s), u = [];
  let c = -1, m;
  for (; ++c < l.length; ) {
    const v = l[c];
    v.type === "JSXExpressionContainer" && v.expression.type === "Literal" && whitespace(String(v.expression.value)) ? m && m.push(v) : (m && u.push(...m), u.push(v), m = []);
  }
  const g = {
    type: "JSXFragment",
    openingFragment: { type: "JSXOpeningFragment" },
    closingFragment: { type: "JSXClosingFragment" },
    children: u
  };
  return o.inherit(s, g), g;
}
function text$2(s, o) {
  const l = String(s.value || "");
  if (l) {
    const u = { type: "Literal", value: l };
    o.inherit(s, u);
    const c = { type: "JSXExpressionContainer", expression: u };
    return o.patch(s, c), c;
  }
}
const handlers = {
  comment,
  doctype: ignore,
  element,
  mdxFlowExpression: mdxExpression,
  mdxJsxFlowElement: mdxJsxElement,
  mdxJsxTextElement: mdxJsxElement,
  mdxTextExpression: mdxExpression,
  mdxjsEsm,
  root: root$1,
  text: text$2
};
function ignore() {
}
const own$1 = {}.hasOwnProperty;
function zwitch(s, o) {
  const l = o || {};
  function u(c, ...m) {
    let g = u.invalid;
    const v = u.handlers;
    if (c && own$1.call(c, s)) {
      const b = String(c[s]);
      g = own$1.call(v, b) ? v[b] : u.unknown;
    }
    if (g)
      return g.call(this, c, ...m);
  }
  return u.handlers = l.handlers || {}, u.invalid = l.invalid, u.unknown = l.unknown, u;
}
const own = {}.hasOwnProperty, tableElements = /* @__PURE__ */ new Set(["table", "tbody", "thead", "tfoot", "tr"]);
function createState(s) {
  const o = zwitch("type", {
    invalid,
    unknown,
    handlers: { ...handlers, ...s.handlers }
  });
  return {
    // Current space.
    elementAttributeNameCase: s.elementAttributeNameCase || "react",
    schema: s.space === "svg" ? svg : html$2,
    stylePropertyNameCase: s.stylePropertyNameCase || "dom",
    tableCellAlignToStyle: s.tableCellAlignToStyle !== !1,
    // Results.
    comments: [],
    esm: [],
    // Useful functions.
    all,
    createJsxAttributeName,
    createJsxElementName,
    handle: l,
    inherit,
    patch
  };
  function l(u) {
    return o(u, this);
  }
}
function invalid(s) {
  throw new Error("Cannot handle value `" + s + "`, expected node");
}
function unknown(s) {
  throw new Error("Cannot handle unknown node `" + s.type + "`");
}
function all(s) {
  const o = s.children || [];
  let l = -1;
  const u = [], c = this.schema.space === "html" && s.type === "element" && tableElements.has(s.tagName.toLowerCase());
  for (; ++l < o.length; ) {
    const m = o[l];
    if (c && m.type === "text" && m.value === `
`)
      continue;
    const g = this.handle(m);
    Array.isArray(g) ? u.push(...g) : g && u.push(g);
  }
  return u;
}
function inherit(s, o) {
  const l = (
    /** @type {Record<string, unknown> | undefined} */
    s.data
  );
  let u, c;
  if (patch(s, o), l) {
    for (c in l)
      own.call(l, c) && c !== "estree" && (u || (u = {}), u[c] = l[c]);
    u && (o.data = u);
  }
}
function patch(s, o) {
  const l = position(s);
  l && l.start.offset !== void 0 && l.end.offset !== void 0 && (o.start = l.start.offset, o.end = l.end.offset, o.loc = {
    start: { line: l.start.line, column: l.start.column - 1 },
    end: { line: l.end.line, column: l.end.column - 1 }
  }, o.range = [l.start.offset, l.end.offset]);
}
function createJsxAttributeName(s) {
  const o = createJsxNameFromString(s);
  if (o.type === "JSXMemberExpression")
    throw new Error("Member expressions in attribute names are not supported");
  return o;
}
function createJsxElementName(s) {
  return createJsxNameFromString(s);
}
function createJsxNameFromString(s) {
  if (s.includes(".")) {
    const o = s.split(".");
    let l = o.shift(), u = { type: "JSXIdentifier", name: l };
    for (; l = o.shift(); )
      u = {
        type: "JSXMemberExpression",
        object: u,
        property: { type: "JSXIdentifier", name: l }
      };
    return u;
  }
  if (s.includes(":")) {
    const o = s.split(":");
    return {
      type: "JSXNamespacedName",
      namespace: { type: "JSXIdentifier", name: o[0] },
      name: { type: "JSXIdentifier", name: o[1] }
    };
  }
  return { type: "JSXIdentifier", name: s };
}
function toEstree(s, o) {
  const l = createState(o || {});
  let u = l.handle(s);
  const c = l.esm;
  if (u) {
    u.type !== "JSXFragment" && u.type !== "JSXElement" && (u = {
      type: "JSXFragment",
      openingFragment: { type: "JSXOpeningFragment" },
      closingFragment: { type: "JSXClosingFragment" },
      children: [u]
    }, l.patch(s, u));
    const g = { type: "ExpressionStatement", expression: u };
    l.patch(s, g), c.push(g);
  }
  const m = {
    type: "Program",
    body: c,
    sourceType: "module",
    comments: l.comments
  };
  return l.patch(s, m), m;
}
function rehypeRecma(s) {
  return function(o) {
    return toEstree(o, s);
  };
}
function rehypeRemoveRaw() {
  return function(s) {
    visit(s, "raw", function(o, l, u) {
      if (u && typeof l == "number")
        return u.children.splice(l, 1), l;
    });
  };
}
const js = /\s+/g, html$1 = /[\t\n\v\f\r ]+/g;
function collapseWhiteSpace(s, o) {
  o ? typeof o == "string" && (o = { style: o }) : o = {};
  const l = o.preserveLineEndings ? replaceLineEnding : replaceSpace;
  return String(s).replace(
    o.style === "html" ? html$1 : js,
    o.trim ? trimFactory(l) : l
  );
}
function replaceLineEnding(s) {
  const o = /\r?\n|\r/.exec(s);
  return o ? o[0] : " ";
}
function replaceSpace() {
  return " ";
}
function trimFactory(s) {
  return o;
  function o(l, u, c) {
    return u === 0 || u + l.length === c.length ? "" : s(l);
  }
}
function remarkMarkAndUnravel() {
  return function(s) {
    visit(s, function(o, l, u) {
      let c = -1, m = !0, g = !1;
      if (u && typeof l == "number" && o.type === "paragraph") {
        const v = o.children;
        for (; ++c < v.length; ) {
          const b = v[c];
          if (b.type === "mdxJsxTextElement" || b.type === "mdxTextExpression")
            g = !0;
          else if (!(b.type === "text" && collapseWhiteSpace(b.value, { style: "html", trim: !0 }) === "")) {
            m = !1;
            break;
          }
        }
        if (m && g) {
          c = -1;
          const b = [];
          for (; ++c < v.length; ) {
            const S = v[c];
            S.type === "mdxJsxTextElement" && (S.type = "mdxJsxFlowElement"), S.type === "mdxTextExpression" && (S.type = "mdxFlowExpression"), S.type === "text" && /^[\t\r\n ]+$/.test(String(S.value)) || b.push(S);
          }
          return u.children.splice(l, 1, ...b), l;
        }
      }
      if (o.type === "mdxJsxFlowElement" || o.type === "mdxJsxTextElement") {
        const v = o.data || (o.data = {});
        v._mdxExplicitJsx = !0;
      }
    });
  };
}
const nodeTypes = (
  /** @type {const} */
  [
    "mdxFlowExpression",
    "mdxJsxFlowElement",
    "mdxJsxTextElement",
    "mdxTextExpression",
    "mdxjsEsm"
  ]
);
let warned = !1;
function createProcessor(s) {
  const o = s || {};
  o.format, (o.jsxRuntime === "classic" || o.pragma || o.pragmaFrag || o.pragmaImportSource) && !warned && (warned = !0, console.warn(
    "Unexpected deprecated option `jsxRuntime: 'classic'`, `pragma`, `pragmaFrag`, or `pragmaImportSource`; see <https://mdxjs.com/migrating/v3/> on how to migrate"
  ));
  const l = unified().use(remarkParse);
  o.format !== "md" && l.use(remarkMdx);
  const u = o.remarkRehypeOptions || {};
  return l.use(remarkMarkAndUnravel).use(o.remarkPlugins || []).use(remarkRehype, {
    ...u,
    allowDangerousHtml: !0,
    passThrough: [...u.passThrough || [], ...nodeTypes]
  }).use(o.rehypePlugins || []), o.format === "md" && l.use(rehypeRemoveRaw), l.use(rehypeRecma, o).use(recmaDocument, o).use(recmaJsxRewrite, o), o.jsx || l.use(recmaJsxBuild, o), l.use(recmaStringify, o).use(o.recmaPlugins || []), l;
}
function compile(s, o) {
  const { file: l, options: u } = resolveFileAndOptions(s, o);
  return createProcessor(u).process(l);
}
function compileSync(s, o) {
  const { file: l, options: u } = resolveFileAndOptions(s, o);
  return createProcessor(u).processSync(l);
}
function resolveEvaluateOptions(s) {
  const {
    Fragment: o,
    baseUrl: l,
    development: u,
    jsx: c,
    jsxDEV: m,
    jsxs: g,
    useMDXComponents: v,
    ...b
  } = s || {};
  if (!o) throw new Error("Expected `Fragment` given to `evaluate`");
  if (u) {
    if (!m) throw new Error("Expected `jsxDEV` given to `evaluate`");
  } else {
    if (!c) throw new Error("Expected `jsx` given to `evaluate`");
    if (!g) throw new Error("Expected `jsxs` given to `evaluate`");
  }
  return {
    compiletime: {
      ...b,
      development: u,
      outputFormat: "function-body",
      providerImportSource: v ? "#" : void 0
    },
    runtime: { Fragment: o, baseUrl: l, jsx: c, jsxDEV: m, jsxs: g, useMDXComponents: v }
  };
}
const AsyncFunction = Object.getPrototypeOf(run).constructor;
async function run(s, o) {
  return new AsyncFunction(String(s))(o);
}
function runSync(s, o) {
  return new Function(String(s))(o);
}
async function evaluate(s, o) {
  const { compiletime: l, runtime: u } = resolveEvaluateOptions(o);
  return run(await compile(s, l), u);
}
function evaluateSync(s, o) {
  const { compiletime: l, runtime: u } = resolveEvaluateOptions(o);
  return runSync(compileSync(s, l), u);
}
function escapeStringRegexp(s) {
  if (typeof s != "string")
    throw new TypeError("Expected a string");
  return s.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function findAndReplace(s, o, l) {
  const c = convert((l || {}).ignore || []), m = toPairs(o);
  let g = -1;
  for (; ++g < m.length; )
    visitParents(s, "text", v);
  function v(S, E) {
    let P = -1, T;
    for (; ++P < E.length; ) {
      const N = E[P], O = T ? T.children : void 0;
      if (c(
        N,
        O ? O.indexOf(N) : void 0,
        T
      ))
        return;
      T = N;
    }
    if (T)
      return b(S, E);
  }
  function b(S, E) {
    const P = E[E.length - 1], T = m[g][0], N = m[g][1];
    let O = 0;
    const Q = P.children.indexOf(S);
    let W = !1, ue = [];
    T.lastIndex = 0;
    let te = T.exec(S.value);
    for (; te; ) {
      const K = te.index, ve = {
        index: te.index,
        input: te.input,
        stack: [...E, S]
      };
      let ee = N(...te, ve);
      if (typeof ee == "string" && (ee = ee.length > 0 ? { type: "text", value: ee } : void 0), ee === !1 ? T.lastIndex = K + 1 : (O !== K && ue.push({
        type: "text",
        value: S.value.slice(O, K)
      }), Array.isArray(ee) ? ue.push(...ee) : ee && ue.push(ee), O = K + te[0].length, W = !0), !T.global)
        break;
      te = T.exec(S.value);
    }
    return W ? (O < S.value.length && ue.push({ type: "text", value: S.value.slice(O) }), P.children.splice(Q, 1, ...ue)) : ue = [S], Q + ue.length;
  }
}
function toPairs(s) {
  const o = [];
  if (!Array.isArray(s))
    throw new TypeError("Expected find and replace tuple or list of tuples");
  const l = !s[0] || Array.isArray(s[0]) ? s : [s];
  let u = -1;
  for (; ++u < l.length; ) {
    const c = l[u];
    o.push([toExpression(c[0]), toFunction(c[1])]);
  }
  return o;
}
function toExpression(s) {
  return typeof s == "string" ? new RegExp(escapeStringRegexp(s), "g") : s;
}
function toFunction(s) {
  return typeof s == "function" ? s : function() {
    return s;
  };
}
const inConstruct = "phrasing", notInConstruct = ["autolink", "link", "image", "label"];
function gfmAutolinkLiteralFromMarkdown() {
  return {
    transforms: [transformGfmAutolinkLiterals],
    enter: {
      literalAutolink: enterLiteralAutolink,
      literalAutolinkEmail: enterLiteralAutolinkValue,
      literalAutolinkHttp: enterLiteralAutolinkValue,
      literalAutolinkWww: enterLiteralAutolinkValue
    },
    exit: {
      literalAutolink: exitLiteralAutolink,
      literalAutolinkEmail: exitLiteralAutolinkEmail,
      literalAutolinkHttp: exitLiteralAutolinkHttp,
      literalAutolinkWww: exitLiteralAutolinkWww
    }
  };
}
function gfmAutolinkLiteralToMarkdown() {
  return {
    unsafe: [
      {
        character: "@",
        before: "[+\\-.\\w]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ".",
        before: "[Ww]",
        after: "[\\-.\\w]",
        inConstruct,
        notInConstruct
      },
      {
        character: ":",
        before: "[ps]",
        after: "\\/",
        inConstruct,
        notInConstruct
      }
    ]
  };
}
function enterLiteralAutolink(s) {
  this.enter({ type: "link", title: null, url: "", children: [] }, s);
}
function enterLiteralAutolinkValue(s) {
  this.config.enter.autolinkProtocol.call(this, s);
}
function exitLiteralAutolinkHttp(s) {
  this.config.exit.autolinkProtocol.call(this, s);
}
function exitLiteralAutolinkWww(s) {
  this.config.exit.data.call(this, s);
  const o = this.stack[this.stack.length - 1];
  o.type, o.url = "http://" + this.sliceSerialize(s);
}
function exitLiteralAutolinkEmail(s) {
  this.config.exit.autolinkEmail.call(this, s);
}
function exitLiteralAutolink(s) {
  this.exit(s);
}
function transformGfmAutolinkLiterals(s) {
  findAndReplace(
    s,
    [
      [/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, findUrl],
      [/([-.\w+]+)@([-\w]+(?:\.[-\w]+)+)/g, findEmail]
    ],
    { ignore: ["link", "linkReference"] }
  );
}
function findUrl(s, o, l, u, c) {
  let m = "";
  if (!previous(c) || (/^w/i.test(o) && (l = o + l, o = "", m = "http://"), !isCorrectDomain(l)))
    return !1;
  const g = splitUrl(l + u);
  if (!g[0]) return !1;
  const v = {
    type: "link",
    title: null,
    url: m + o + g[0],
    children: [{ type: "text", value: o + g[0] }]
  };
  return g[1] ? [v, { type: "text", value: g[1] }] : v;
}
function findEmail(s, o, l, u) {
  return (
    // Not an expected previous character.
    !previous(u, !0) || // Label ends in not allowed character.
    /[-\d_]$/.test(l) ? !1 : {
      type: "link",
      title: null,
      url: "mailto:" + o + "@" + l,
      children: [{ type: "text", value: o + "@" + l }]
    }
  );
}
function isCorrectDomain(s) {
  const o = s.split(".");
  return !(o.length < 2 || o[o.length - 1] && (/_/.test(o[o.length - 1]) || !/[a-zA-Z\d]/.test(o[o.length - 1])) || o[o.length - 2] && (/_/.test(o[o.length - 2]) || !/[a-zA-Z\d]/.test(o[o.length - 2])));
}
function splitUrl(s) {
  const o = /[!"&'),.:;<>?\]}]+$/.exec(s);
  if (!o)
    return [s, void 0];
  s = s.slice(0, o.index);
  let l = o[0], u = l.indexOf(")");
  const c = ccount(s, "(");
  let m = ccount(s, ")");
  for (; u !== -1 && c > m; )
    s += l.slice(0, u + 1), l = l.slice(u + 1), u = l.indexOf(")"), m++;
  return [s, l];
}
function previous(s, o) {
  const l = s.input.charCodeAt(s.index - 1);
  return (s.index === 0 || unicodeWhitespace(l) || unicodePunctuation(l)) && (!o || l !== 47);
}
footnoteReference.peek = footnoteReferencePeek;
function gfmFootnoteFromMarkdown() {
  return {
    enter: {
      gfmFootnoteDefinition: enterFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: enterFootnoteDefinitionLabelString,
      gfmFootnoteCall: enterFootnoteCall,
      gfmFootnoteCallString: enterFootnoteCallString
    },
    exit: {
      gfmFootnoteDefinition: exitFootnoteDefinition,
      gfmFootnoteDefinitionLabelString: exitFootnoteDefinitionLabelString,
      gfmFootnoteCall: exitFootnoteCall,
      gfmFootnoteCallString: exitFootnoteCallString
    }
  };
}
function gfmFootnoteToMarkdown() {
  return {
    // This is on by default already.
    unsafe: [{ character: "[", inConstruct: ["phrasing", "label", "reference"] }],
    handlers: { footnoteDefinition, footnoteReference }
  };
}
function enterFootnoteDefinition(s) {
  this.enter(
    { type: "footnoteDefinition", identifier: "", label: "", children: [] },
    s
  );
}
function enterFootnoteDefinitionLabelString() {
  this.buffer();
}
function exitFootnoteDefinitionLabelString(s) {
  const o = this.resume(), l = this.stack[this.stack.length - 1];
  l.type, l.label = o, l.identifier = normalizeIdentifier(
    this.sliceSerialize(s)
  ).toLowerCase();
}
function exitFootnoteDefinition(s) {
  this.exit(s);
}
function enterFootnoteCall(s) {
  this.enter({ type: "footnoteReference", identifier: "", label: "" }, s);
}
function enterFootnoteCallString() {
  this.buffer();
}
function exitFootnoteCallString(s) {
  const o = this.resume(), l = this.stack[this.stack.length - 1];
  l.type, l.label = o, l.identifier = normalizeIdentifier(
    this.sliceSerialize(s)
  ).toLowerCase();
}
function exitFootnoteCall(s) {
  this.exit(s);
}
function footnoteReference(s, o, l, u) {
  const c = l.createTracker(u);
  let m = c.move("[^");
  const g = l.enter("footnoteReference"), v = l.enter("reference");
  return m += c.move(
    l.safe(l.associationId(s), {
      ...c.current(),
      before: m,
      after: "]"
    })
  ), v(), g(), m += c.move("]"), m;
}
function footnoteReferencePeek() {
  return "[";
}
function footnoteDefinition(s, o, l, u) {
  const c = l.createTracker(u);
  let m = c.move("[^");
  const g = l.enter("footnoteDefinition"), v = l.enter("label");
  return m += c.move(
    l.safe(l.associationId(s), {
      ...c.current(),
      before: m,
      after: "]"
    })
  ), v(), m += c.move(
    "]:" + (s.children && s.children.length > 0 ? " " : "")
  ), c.shift(4), m += c.move(
    l.indentLines(l.containerFlow(s, c.current()), map$2)
  ), g(), m;
}
function map$2(s, o, l) {
  return o === 0 ? s : (l ? "" : "    ") + s;
}
const constructsWithoutStrikethrough = [
  "autolink",
  "destinationLiteral",
  "destinationRaw",
  "reference",
  "titleQuote",
  "titleApostrophe"
];
handleDelete.peek = peekDelete;
function gfmStrikethroughFromMarkdown() {
  return {
    canContainEols: ["delete"],
    enter: { strikethrough: enterStrikethrough },
    exit: { strikethrough: exitStrikethrough }
  };
}
function gfmStrikethroughToMarkdown() {
  return {
    unsafe: [
      {
        character: "~",
        inConstruct: "phrasing",
        notInConstruct: constructsWithoutStrikethrough
      }
    ],
    handlers: { delete: handleDelete }
  };
}
function enterStrikethrough(s) {
  this.enter({ type: "delete", children: [] }, s);
}
function exitStrikethrough(s) {
  this.exit(s);
}
function handleDelete(s, o, l, u) {
  const c = l.createTracker(u), m = l.enter("strikethrough");
  let g = c.move("~~");
  return g += l.containerPhrasing(s, {
    ...c.current(),
    before: g,
    after: "~"
  }), g += c.move("~~"), m(), g;
}
function peekDelete() {
  return "~";
}
function markdownTable(s, o = {}) {
  const l = (o.align || []).concat(), u = o.stringLength || defaultStringLength, c = [], m = [], g = [], v = [];
  let b = 0, S = -1;
  for (; ++S < s.length; ) {
    const O = [], z = [];
    let Q = -1;
    for (s[S].length > b && (b = s[S].length); ++Q < s[S].length; ) {
      const W = serialize(s[S][Q]);
      if (o.alignDelimiters !== !1) {
        const ue = u(W);
        z[Q] = ue, (v[Q] === void 0 || ue > v[Q]) && (v[Q] = ue);
      }
      O.push(W);
    }
    m[S] = O, g[S] = z;
  }
  let E = -1;
  if (typeof l == "object" && "length" in l)
    for (; ++E < b; )
      c[E] = toAlignment(l[E]);
  else {
    const O = toAlignment(l);
    for (; ++E < b; )
      c[E] = O;
  }
  E = -1;
  const P = [], T = [];
  for (; ++E < b; ) {
    const O = c[E];
    let z = "", Q = "";
    O === 99 ? (z = ":", Q = ":") : O === 108 ? z = ":" : O === 114 && (Q = ":");
    let W = o.alignDelimiters === !1 ? 1 : Math.max(
      1,
      v[E] - z.length - Q.length
    );
    const ue = z + "-".repeat(W) + Q;
    o.alignDelimiters !== !1 && (W = z.length + W + Q.length, W > v[E] && (v[E] = W), T[E] = W), P[E] = ue;
  }
  m.splice(1, 0, P), g.splice(1, 0, T), S = -1;
  const N = [];
  for (; ++S < m.length; ) {
    const O = m[S], z = g[S];
    E = -1;
    const Q = [];
    for (; ++E < b; ) {
      const W = O[E] || "";
      let ue = "", te = "";
      if (o.alignDelimiters !== !1) {
        const K = v[E] - (z[E] || 0), ve = c[E];
        ve === 114 ? ue = " ".repeat(K) : ve === 99 ? K % 2 ? (ue = " ".repeat(K / 2 + 0.5), te = " ".repeat(K / 2 - 0.5)) : (ue = " ".repeat(K / 2), te = ue) : te = " ".repeat(K);
      }
      o.delimiterStart !== !1 && !E && Q.push("|"), o.padding !== !1 && // Don’t add the opening space if we’re not aligning and the cell is
      // empty: there will be a closing space.
      !(o.alignDelimiters === !1 && W === "") && (o.delimiterStart !== !1 || E) && Q.push(" "), o.alignDelimiters !== !1 && Q.push(ue), Q.push(W), o.alignDelimiters !== !1 && Q.push(te), o.padding !== !1 && Q.push(" "), (o.delimiterEnd !== !1 || E !== b - 1) && Q.push("|");
    }
    N.push(
      o.delimiterEnd === !1 ? Q.join("").replace(/ +$/, "") : Q.join("")
    );
  }
  return N.join(`
`);
}
function serialize(s) {
  return s == null ? "" : String(s);
}
function defaultStringLength(s) {
  return s.length;
}
function toAlignment(s) {
  const o = typeof s == "string" ? s.codePointAt(0) : 0;
  return o === 67 || o === 99 ? 99 : o === 76 || o === 108 ? 108 : o === 82 || o === 114 ? 114 : 0;
}
function blockquote(s, o, l, u) {
  const c = l.enter("blockquote"), m = l.createTracker(u);
  m.move("> "), m.shift(2);
  const g = l.indentLines(
    l.containerFlow(s, m.current()),
    map$1
  );
  return c(), g;
}
function map$1(s, o, l) {
  return ">" + (l ? "" : " ") + s;
}
function patternInScope(s, o) {
  return listInScope(s, o.inConstruct, !0) && !listInScope(s, o.notInConstruct, !1);
}
function listInScope(s, o, l) {
  if (typeof o == "string" && (o = [o]), !o || o.length === 0)
    return l;
  let u = -1;
  for (; ++u < o.length; )
    if (s.includes(o[u]))
      return !0;
  return !1;
}
function hardBreak(s, o, l, u) {
  let c = -1;
  for (; ++c < l.unsafe.length; )
    if (l.unsafe[c].character === `
` && patternInScope(l.stack, l.unsafe[c]))
      return /[ \t]/.test(u.before) ? "" : " ";
  return `\\
`;
}
function longestStreak(s, o) {
  const l = String(s);
  let u = l.indexOf(o), c = u, m = 0, g = 0;
  if (typeof o != "string")
    throw new TypeError("Expected substring");
  for (; u !== -1; )
    u === c ? ++m > g && (g = m) : m = 1, c = u + o.length, u = l.indexOf(o, c);
  return g;
}
function formatCodeAsIndented(s, o) {
  return !!(o.options.fences === !1 && s.value && // If there’s no info…
  !s.lang && // And there’s a non-whitespace character…
  /[^ \r\n]/.test(s.value) && // And the value doesn’t start or end in a blank…
  !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(s.value));
}
function checkFence(s) {
  const o = s.options.fence || "`";
  if (o !== "`" && o !== "~")
    throw new Error(
      "Cannot serialize code with `" + o + "` for `options.fence`, expected `` ` `` or `~`"
    );
  return o;
}
function code$1(s, o, l, u) {
  const c = checkFence(l), m = s.value || "", g = c === "`" ? "GraveAccent" : "Tilde";
  if (formatCodeAsIndented(s, l)) {
    const P = l.enter("codeIndented"), T = l.indentLines(m, map);
    return P(), T;
  }
  const v = l.createTracker(u), b = c.repeat(Math.max(longestStreak(m, c) + 1, 3)), S = l.enter("codeFenced");
  let E = v.move(b);
  if (s.lang) {
    const P = l.enter(`codeFencedLang${g}`);
    E += v.move(
      l.safe(s.lang, {
        before: E,
        after: " ",
        encode: ["`"],
        ...v.current()
      })
    ), P();
  }
  if (s.lang && s.meta) {
    const P = l.enter(`codeFencedMeta${g}`);
    E += v.move(" "), E += v.move(
      l.safe(s.meta, {
        before: E,
        after: `
`,
        encode: ["`"],
        ...v.current()
      })
    ), P();
  }
  return E += v.move(`
`), m && (E += v.move(m + `
`)), E += v.move(b), S(), E;
}
function map(s, o, l) {
  return (l ? "" : "    ") + s;
}
function checkQuote(s) {
  const o = s.options.quote || '"';
  if (o !== '"' && o !== "'")
    throw new Error(
      "Cannot serialize title with `" + o + "` for `options.quote`, expected `\"`, or `'`"
    );
  return o;
}
function definition(s, o, l, u) {
  const c = checkQuote(l), m = c === '"' ? "Quote" : "Apostrophe", g = l.enter("definition");
  let v = l.enter("label");
  const b = l.createTracker(u);
  let S = b.move("[");
  return S += b.move(
    l.safe(l.associationId(s), {
      before: S,
      after: "]",
      ...b.current()
    })
  ), S += b.move("]: "), v(), // If there’s no url, or…
  !s.url || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(s.url) ? (v = l.enter("destinationLiteral"), S += b.move("<"), S += b.move(
    l.safe(s.url, { before: S, after: ">", ...b.current() })
  ), S += b.move(">")) : (v = l.enter("destinationRaw"), S += b.move(
    l.safe(s.url, {
      before: S,
      after: s.title ? " " : `
`,
      ...b.current()
    })
  )), v(), s.title && (v = l.enter(`title${m}`), S += b.move(" " + c), S += b.move(
    l.safe(s.title, {
      before: S,
      after: c,
      ...b.current()
    })
  ), S += b.move(c), v()), g(), S;
}
function checkEmphasis(s) {
  const o = s.options.emphasis || "*";
  if (o !== "*" && o !== "_")
    throw new Error(
      "Cannot serialize emphasis with `" + o + "` for `options.emphasis`, expected `*`, or `_`"
    );
  return o;
}
emphasis.peek = emphasisPeek;
function emphasis(s, o, l, u) {
  const c = checkEmphasis(l), m = l.enter("emphasis"), g = l.createTracker(u);
  let v = g.move(c);
  return v += g.move(
    l.containerPhrasing(s, {
      before: v,
      after: c,
      ...g.current()
    })
  ), v += g.move(c), m(), v;
}
function emphasisPeek(s, o, l) {
  return l.options.emphasis || "*";
}
function formatHeadingAsSetext(s, o) {
  let l = !1;
  return visit(s, function(u) {
    if ("value" in u && /\r?\n|\r/.test(u.value) || u.type === "break")
      return l = !0, EXIT;
  }), !!((!s.depth || s.depth < 3) && toString$1(s) && (o.options.setext || l));
}
function heading(s, o, l, u) {
  const c = Math.max(Math.min(6, s.depth || 1), 1), m = l.createTracker(u);
  if (formatHeadingAsSetext(s, l)) {
    const E = l.enter("headingSetext"), P = l.enter("phrasing"), T = l.containerPhrasing(s, {
      ...m.current(),
      before: `
`,
      after: `
`
    });
    return P(), E(), T + `
` + (c === 1 ? "=" : "-").repeat(
      // The whole size…
      T.length - // Minus the position of the character after the last EOL (or
      // 0 if there is none)…
      (Math.max(T.lastIndexOf("\r"), T.lastIndexOf(`
`)) + 1)
    );
  }
  const g = "#".repeat(c), v = l.enter("headingAtx"), b = l.enter("phrasing");
  m.move(g + " ");
  let S = l.containerPhrasing(s, {
    before: "# ",
    after: `
`,
    ...m.current()
  });
  return /^[\t ]/.test(S) && (S = "&#x" + S.charCodeAt(0).toString(16).toUpperCase() + ";" + S.slice(1)), S = S ? g + " " + S : g, l.options.closeAtx && (S += " " + g), b(), v(), S;
}
html.peek = htmlPeek;
function html(s) {
  return s.value || "";
}
function htmlPeek() {
  return "<";
}
image.peek = imagePeek;
function image(s, o, l, u) {
  const c = checkQuote(l), m = c === '"' ? "Quote" : "Apostrophe", g = l.enter("image");
  let v = l.enter("label");
  const b = l.createTracker(u);
  let S = b.move("![");
  return S += b.move(
    l.safe(s.alt, { before: S, after: "]", ...b.current() })
  ), S += b.move("]("), v(), // If there’s no url but there is a title…
  !s.url && s.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(s.url) ? (v = l.enter("destinationLiteral"), S += b.move("<"), S += b.move(
    l.safe(s.url, { before: S, after: ">", ...b.current() })
  ), S += b.move(">")) : (v = l.enter("destinationRaw"), S += b.move(
    l.safe(s.url, {
      before: S,
      after: s.title ? " " : ")",
      ...b.current()
    })
  )), v(), s.title && (v = l.enter(`title${m}`), S += b.move(" " + c), S += b.move(
    l.safe(s.title, {
      before: S,
      after: c,
      ...b.current()
    })
  ), S += b.move(c), v()), S += b.move(")"), g(), S;
}
function imagePeek() {
  return "!";
}
imageReference.peek = imageReferencePeek;
function imageReference(s, o, l, u) {
  const c = s.referenceType, m = l.enter("imageReference");
  let g = l.enter("label");
  const v = l.createTracker(u);
  let b = v.move("![");
  const S = l.safe(s.alt, {
    before: b,
    after: "]",
    ...v.current()
  });
  b += v.move(S + "]["), g();
  const E = l.stack;
  l.stack = [], g = l.enter("reference");
  const P = l.safe(l.associationId(s), {
    before: b,
    after: "]",
    ...v.current()
  });
  return g(), l.stack = E, m(), c === "full" || !S || S !== P ? b += v.move(P + "]") : c === "shortcut" ? b = b.slice(0, -1) : b += v.move("]"), b;
}
function imageReferencePeek() {
  return "!";
}
inlineCode.peek = inlineCodePeek;
function inlineCode(s, o, l) {
  let u = s.value || "", c = "`", m = -1;
  for (; new RegExp("(^|[^`])" + c + "([^`]|$)").test(u); )
    c += "`";
  for (/[^ \r\n]/.test(u) && (/^[ \r\n]/.test(u) && /[ \r\n]$/.test(u) || /^`|`$/.test(u)) && (u = " " + u + " "); ++m < l.unsafe.length; ) {
    const g = l.unsafe[m], v = l.compilePattern(g);
    let b;
    if (g.atBreak)
      for (; b = v.exec(u); ) {
        let S = b.index;
        u.charCodeAt(S) === 10 && u.charCodeAt(S - 1) === 13 && S--, u = u.slice(0, S) + " " + u.slice(b.index + 1);
      }
  }
  return c + u + c;
}
function inlineCodePeek() {
  return "`";
}
function formatLinkAsAutolink(s, o) {
  const l = toString$1(s);
  return !!(!o.options.resourceLink && // If there’s a url…
  s.url && // And there’s a no title…
  !s.title && // And the content of `node` is a single text node…
  s.children && s.children.length === 1 && s.children[0].type === "text" && // And if the url is the same as the content…
  (l === s.url || "mailto:" + l === s.url) && // And that starts w/ a protocol…
  /^[a-z][a-z+.-]+:/i.test(s.url) && // And that doesn’t contain ASCII control codes (character escapes and
  // references don’t work), space, or angle brackets…
  !/[\0- <>\u007F]/.test(s.url));
}
link.peek = linkPeek;
function link(s, o, l, u) {
  const c = checkQuote(l), m = c === '"' ? "Quote" : "Apostrophe", g = l.createTracker(u);
  let v, b;
  if (formatLinkAsAutolink(s, l)) {
    const E = l.stack;
    l.stack = [], v = l.enter("autolink");
    let P = g.move("<");
    return P += g.move(
      l.containerPhrasing(s, {
        before: P,
        after: ">",
        ...g.current()
      })
    ), P += g.move(">"), v(), l.stack = E, P;
  }
  v = l.enter("link"), b = l.enter("label");
  let S = g.move("[");
  return S += g.move(
    l.containerPhrasing(s, {
      before: S,
      after: "](",
      ...g.current()
    })
  ), S += g.move("]("), b(), // If there’s no url but there is a title…
  !s.url && s.title || // If there are control characters or whitespace.
  /[\0- \u007F]/.test(s.url) ? (b = l.enter("destinationLiteral"), S += g.move("<"), S += g.move(
    l.safe(s.url, { before: S, after: ">", ...g.current() })
  ), S += g.move(">")) : (b = l.enter("destinationRaw"), S += g.move(
    l.safe(s.url, {
      before: S,
      after: s.title ? " " : ")",
      ...g.current()
    })
  )), b(), s.title && (b = l.enter(`title${m}`), S += g.move(" " + c), S += g.move(
    l.safe(s.title, {
      before: S,
      after: c,
      ...g.current()
    })
  ), S += g.move(c), b()), S += g.move(")"), v(), S;
}
function linkPeek(s, o, l) {
  return formatLinkAsAutolink(s, l) ? "<" : "[";
}
linkReference.peek = linkReferencePeek;
function linkReference(s, o, l, u) {
  const c = s.referenceType, m = l.enter("linkReference");
  let g = l.enter("label");
  const v = l.createTracker(u);
  let b = v.move("[");
  const S = l.containerPhrasing(s, {
    before: b,
    after: "]",
    ...v.current()
  });
  b += v.move(S + "]["), g();
  const E = l.stack;
  l.stack = [], g = l.enter("reference");
  const P = l.safe(l.associationId(s), {
    before: b,
    after: "]",
    ...v.current()
  });
  return g(), l.stack = E, m(), c === "full" || !S || S !== P ? b += v.move(P + "]") : c === "shortcut" ? b = b.slice(0, -1) : b += v.move("]"), b;
}
function linkReferencePeek() {
  return "[";
}
function checkBullet(s) {
  const o = s.options.bullet || "*";
  if (o !== "*" && o !== "+" && o !== "-")
    throw new Error(
      "Cannot serialize items with `" + o + "` for `options.bullet`, expected `*`, `+`, or `-`"
    );
  return o;
}
function checkBulletOther(s) {
  const o = checkBullet(s), l = s.options.bulletOther;
  if (!l)
    return o === "*" ? "-" : "*";
  if (l !== "*" && l !== "+" && l !== "-")
    throw new Error(
      "Cannot serialize items with `" + l + "` for `options.bulletOther`, expected `*`, `+`, or `-`"
    );
  if (l === o)
    throw new Error(
      "Expected `bullet` (`" + o + "`) and `bulletOther` (`" + l + "`) to be different"
    );
  return l;
}
function checkBulletOrdered(s) {
  const o = s.options.bulletOrdered || ".";
  if (o !== "." && o !== ")")
    throw new Error(
      "Cannot serialize items with `" + o + "` for `options.bulletOrdered`, expected `.` or `)`"
    );
  return o;
}
function checkRule(s) {
  const o = s.options.rule || "*";
  if (o !== "*" && o !== "-" && o !== "_")
    throw new Error(
      "Cannot serialize rules with `" + o + "` for `options.rule`, expected `*`, `-`, or `_`"
    );
  return o;
}
function list(s, o, l, u) {
  const c = l.enter("list"), m = l.bulletCurrent;
  let g = s.ordered ? checkBulletOrdered(l) : checkBullet(l);
  const v = s.ordered ? g === "." ? ")" : "." : checkBulletOther(l);
  let b = o && l.bulletLastUsed ? g === l.bulletLastUsed : !1;
  if (!s.ordered) {
    const E = s.children ? s.children[0] : void 0;
    if (
      // Bullet could be used as a thematic break marker:
      (g === "*" || g === "-") && // Empty first list item:
      E && (!E.children || !E.children[0]) && // Directly in two other list items:
      l.stack[l.stack.length - 1] === "list" && l.stack[l.stack.length - 2] === "listItem" && l.stack[l.stack.length - 3] === "list" && l.stack[l.stack.length - 4] === "listItem" && // That are each the first child.
      l.indexStack[l.indexStack.length - 1] === 0 && l.indexStack[l.indexStack.length - 2] === 0 && l.indexStack[l.indexStack.length - 3] === 0 && (b = !0), checkRule(l) === g && E
    ) {
      let P = -1;
      for (; ++P < s.children.length; ) {
        const T = s.children[P];
        if (T && T.type === "listItem" && T.children && T.children[0] && T.children[0].type === "thematicBreak") {
          b = !0;
          break;
        }
      }
    }
  }
  b && (g = v), l.bulletCurrent = g;
  const S = l.containerFlow(s, u);
  return l.bulletLastUsed = g, l.bulletCurrent = m, c(), S;
}
function checkListItemIndent(s) {
  const o = s.options.listItemIndent || "one";
  if (o !== "tab" && o !== "one" && o !== "mixed")
    throw new Error(
      "Cannot serialize items with `" + o + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"
    );
  return o;
}
function listItem(s, o, l, u) {
  const c = checkListItemIndent(l);
  let m = l.bulletCurrent || checkBullet(l);
  o && o.type === "list" && o.ordered && (m = (typeof o.start == "number" && o.start > -1 ? o.start : 1) + (l.options.incrementListMarker === !1 ? 0 : o.children.indexOf(s)) + m);
  let g = m.length + 1;
  (c === "tab" || c === "mixed" && (o && o.type === "list" && o.spread || s.spread)) && (g = Math.ceil(g / 4) * 4);
  const v = l.createTracker(u);
  v.move(m + " ".repeat(g - m.length)), v.shift(g);
  const b = l.enter("listItem"), S = l.indentLines(
    l.containerFlow(s, v.current()),
    E
  );
  return b(), S;
  function E(P, T, N) {
    return T ? (N ? "" : " ".repeat(g)) + P : (N ? m : m + " ".repeat(g - m.length)) + P;
  }
}
function paragraph(s, o, l, u) {
  const c = l.enter("paragraph"), m = l.enter("phrasing"), g = l.containerPhrasing(s, u);
  return m(), c(), g;
}
const phrasing = (
  /** @type {(node?: unknown) => node is Exclude<PhrasingContent, Html>} */
  convert([
    "break",
    "delete",
    "emphasis",
    // To do: next major: removed since footnotes were added to GFM.
    "footnote",
    "footnoteReference",
    "image",
    "imageReference",
    "inlineCode",
    // Enabled by `mdast-util-math`:
    "inlineMath",
    "link",
    "linkReference",
    // Enabled by `mdast-util-mdx`:
    "mdxJsxTextElement",
    // Enabled by `mdast-util-mdx`:
    "mdxTextExpression",
    "strong",
    "text",
    // Enabled by `mdast-util-directive`:
    "textDirective"
  ])
);
function root(s, o, l, u) {
  return (s.children.some(function(g) {
    return phrasing(g);
  }) ? l.containerPhrasing : l.containerFlow).call(l, s, u);
}
function checkStrong(s) {
  const o = s.options.strong || "*";
  if (o !== "*" && o !== "_")
    throw new Error(
      "Cannot serialize strong with `" + o + "` for `options.strong`, expected `*`, or `_`"
    );
  return o;
}
strong.peek = strongPeek;
function strong(s, o, l, u) {
  const c = checkStrong(l), m = l.enter("strong"), g = l.createTracker(u);
  let v = g.move(c + c);
  return v += g.move(
    l.containerPhrasing(s, {
      before: v,
      after: c,
      ...g.current()
    })
  ), v += g.move(c + c), m(), v;
}
function strongPeek(s, o, l) {
  return l.options.strong || "*";
}
function text$1(s, o, l, u) {
  return l.safe(s.value, u);
}
function checkRuleRepetition(s) {
  const o = s.options.ruleRepetition || 3;
  if (o < 3)
    throw new Error(
      "Cannot serialize rules with repetition `" + o + "` for `options.ruleRepetition`, expected `3` or more"
    );
  return o;
}
function thematicBreak(s, o, l) {
  const u = (checkRule(l) + (l.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(l));
  return l.options.ruleSpaces ? u.slice(0, -1) : u;
}
const handle = {
  blockquote,
  break: hardBreak,
  code: code$1,
  definition,
  emphasis,
  hardBreak,
  heading,
  html,
  image,
  imageReference,
  inlineCode,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root,
  strong,
  text: text$1,
  thematicBreak
};
function gfmTableFromMarkdown() {
  return {
    enter: {
      table: enterTable,
      tableData: enterCell,
      tableHeader: enterCell,
      tableRow: enterRow
    },
    exit: {
      codeText: exitCodeText,
      table: exitTable,
      tableData: exit,
      tableHeader: exit,
      tableRow: exit
    }
  };
}
function enterTable(s) {
  const o = s._align;
  this.enter(
    {
      type: "table",
      align: o.map(function(l) {
        return l === "none" ? null : l;
      }),
      children: []
    },
    s
  ), this.data.inTable = !0;
}
function exitTable(s) {
  this.exit(s), this.data.inTable = void 0;
}
function enterRow(s) {
  this.enter({ type: "tableRow", children: [] }, s);
}
function exit(s) {
  this.exit(s);
}
function enterCell(s) {
  this.enter({ type: "tableCell", children: [] }, s);
}
function exitCodeText(s) {
  let o = this.resume();
  this.data.inTable && (o = o.replace(/\\([\\|])/g, replace));
  const l = this.stack[this.stack.length - 1];
  l.type, l.value = o, this.exit(s);
}
function replace(s, o) {
  return o === "|" ? o : s;
}
function gfmTableToMarkdown(s) {
  const o = s || {}, l = o.tableCellPadding, u = o.tablePipeAlign, c = o.stringLength, m = l ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: `
`, inConstruct: "tableCell" },
      // A pipe, when followed by a tab or space (padding), or a dash or colon
      // (unpadded delimiter row), could result in a table.
      { atBreak: !0, character: "|", after: "[	 :-]" },
      // A pipe in a cell must be encoded.
      { character: "|", inConstruct: "tableCell" },
      // A colon must be followed by a dash, in which case it could start a
      // delimiter row.
      { atBreak: !0, character: ":", after: "-" },
      // A delimiter row can also start with a dash, when followed by more
      // dashes, a colon, or a pipe.
      // This is a stricter version than the built in check for lists, thematic
      // breaks, and setex heading underlines though:
      // <https://github.com/syntax-tree/mdast-util-to-markdown/blob/51a2038/lib/unsafe.js#L57>
      { atBreak: !0, character: "-", after: "[:|-]" }
    ],
    handlers: {
      inlineCode: T,
      table: g,
      tableCell: b,
      tableRow: v
    }
  };
  function g(N, O, z, Q) {
    return S(E(N, z, Q), N.align);
  }
  function v(N, O, z, Q) {
    const W = P(N, z, Q), ue = S([W]);
    return ue.slice(0, ue.indexOf(`
`));
  }
  function b(N, O, z, Q) {
    const W = z.enter("tableCell"), ue = z.enter("phrasing"), te = z.containerPhrasing(N, {
      ...Q,
      before: m,
      after: m
    });
    return ue(), W(), te;
  }
  function S(N, O) {
    return markdownTable(N, {
      align: O,
      // @ts-expect-error: `markdown-table` types should support `null`.
      alignDelimiters: u,
      // @ts-expect-error: `markdown-table` types should support `null`.
      padding: l,
      // @ts-expect-error: `markdown-table` types should support `null`.
      stringLength: c
    });
  }
  function E(N, O, z) {
    const Q = N.children;
    let W = -1;
    const ue = [], te = O.enter("table");
    for (; ++W < Q.length; )
      ue[W] = P(Q[W], O, z);
    return te(), ue;
  }
  function P(N, O, z) {
    const Q = N.children;
    let W = -1;
    const ue = [], te = O.enter("tableRow");
    for (; ++W < Q.length; )
      ue[W] = b(Q[W], N, O, z);
    return te(), ue;
  }
  function T(N, O, z) {
    let Q = handle.inlineCode(N, O, z);
    return z.stack.includes("tableCell") && (Q = Q.replace(/\|/g, "\\$&")), Q;
  }
}
function gfmTaskListItemFromMarkdown() {
  return {
    exit: {
      taskListCheckValueChecked: exitCheck,
      taskListCheckValueUnchecked: exitCheck,
      paragraph: exitParagraphWithTaskListItem
    }
  };
}
function gfmTaskListItemToMarkdown() {
  return {
    unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }],
    handlers: { listItem: listItemWithTaskListItem }
  };
}
function exitCheck(s) {
  const o = this.stack[this.stack.length - 2];
  o.type, o.checked = s.type === "taskListCheckValueChecked";
}
function exitParagraphWithTaskListItem(s) {
  const o = this.stack[this.stack.length - 2];
  if (o && o.type === "listItem" && typeof o.checked == "boolean") {
    const l = this.stack[this.stack.length - 1];
    l.type;
    const u = l.children[0];
    if (u && u.type === "text") {
      const c = o.children;
      let m = -1, g;
      for (; ++m < c.length; ) {
        const v = c[m];
        if (v.type === "paragraph") {
          g = v;
          break;
        }
      }
      g === l && (u.value = u.value.slice(1), u.value.length === 0 ? l.children.shift() : l.position && u.position && typeof u.position.start.offset == "number" && (u.position.start.column++, u.position.start.offset++, l.position.start = Object.assign({}, u.position.start)));
    }
  }
  this.exit(s);
}
function listItemWithTaskListItem(s, o, l, u) {
  const c = s.children[0], m = typeof s.checked == "boolean" && c && c.type === "paragraph", g = "[" + (s.checked ? "x" : " ") + "] ", v = l.createTracker(u);
  m && v.move(g);
  let b = handle.listItem(s, o, l, {
    ...u,
    ...v.current()
  });
  return m && (b = b.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, S)), b;
  function S(E) {
    return E + g;
  }
}
function gfmFromMarkdown() {
  return [
    gfmAutolinkLiteralFromMarkdown(),
    gfmFootnoteFromMarkdown(),
    gfmStrikethroughFromMarkdown(),
    gfmTableFromMarkdown(),
    gfmTaskListItemFromMarkdown()
  ];
}
function gfmToMarkdown(s) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown(),
      gfmFootnoteToMarkdown(),
      gfmStrikethroughToMarkdown(),
      gfmTableToMarkdown(s),
      gfmTaskListItemToMarkdown()
    ]
  };
}
const wwwPrefix = {
  tokenize: tokenizeWwwPrefix,
  partial: !0
}, domain = {
  tokenize: tokenizeDomain,
  partial: !0
}, path = {
  tokenize: tokenizePath,
  partial: !0
}, trail = {
  tokenize: tokenizeTrail,
  partial: !0
}, emailDomainDotTrail = {
  tokenize: tokenizeEmailDomainDotTrail,
  partial: !0
}, wwwAutolink = {
  name: "wwwAutolink",
  tokenize: tokenizeWwwAutolink,
  previous: previousWww
}, protocolAutolink = {
  name: "protocolAutolink",
  tokenize: tokenizeProtocolAutolink,
  previous: previousProtocol
}, emailAutolink = {
  name: "emailAutolink",
  tokenize: tokenizeEmailAutolink,
  previous: previousEmail
}, text = {};
function gfmAutolinkLiteral() {
  return {
    text
  };
}
let code = 48;
for (; code < 123; )
  text[code] = emailAutolink, code++, code === 58 ? code = 65 : code === 91 && (code = 97);
text[43] = emailAutolink;
text[45] = emailAutolink;
text[46] = emailAutolink;
text[95] = emailAutolink;
text[72] = [emailAutolink, protocolAutolink];
text[104] = [emailAutolink, protocolAutolink];
text[87] = [emailAutolink, wwwAutolink];
text[119] = [emailAutolink, wwwAutolink];
function tokenizeEmailAutolink(s, o, l) {
  const u = this;
  let c, m;
  return g;
  function g(P) {
    return !gfmAtext(P) || !previousEmail.call(u, u.previous) || previousUnbalanced(u.events) ? l(P) : (s.enter("literalAutolink"), s.enter("literalAutolinkEmail"), v(P));
  }
  function v(P) {
    return gfmAtext(P) ? (s.consume(P), v) : P === 64 ? (s.consume(P), b) : l(P);
  }
  function b(P) {
    return P === 46 ? s.check(emailDomainDotTrail, E, S)(P) : P === 45 || P === 95 || asciiAlphanumeric(P) ? (m = !0, s.consume(P), b) : E(P);
  }
  function S(P) {
    return s.consume(P), c = !0, b;
  }
  function E(P) {
    return m && c && asciiAlpha(u.previous) ? (s.exit("literalAutolinkEmail"), s.exit("literalAutolink"), o(P)) : l(P);
  }
}
function tokenizeWwwAutolink(s, o, l) {
  const u = this;
  return c;
  function c(g) {
    return g !== 87 && g !== 119 || !previousWww.call(u, u.previous) || previousUnbalanced(u.events) ? l(g) : (s.enter("literalAutolink"), s.enter("literalAutolinkWww"), s.check(wwwPrefix, s.attempt(domain, s.attempt(path, m), l), l)(g));
  }
  function m(g) {
    return s.exit("literalAutolinkWww"), s.exit("literalAutolink"), o(g);
  }
}
function tokenizeProtocolAutolink(s, o, l) {
  const u = this;
  let c = "", m = !1;
  return g;
  function g(P) {
    return (P === 72 || P === 104) && previousProtocol.call(u, u.previous) && !previousUnbalanced(u.events) ? (s.enter("literalAutolink"), s.enter("literalAutolinkHttp"), c += String.fromCodePoint(P), s.consume(P), v) : l(P);
  }
  function v(P) {
    if (asciiAlpha(P) && c.length < 5)
      return c += String.fromCodePoint(P), s.consume(P), v;
    if (P === 58) {
      const T = c.toLowerCase();
      if (T === "http" || T === "https")
        return s.consume(P), b;
    }
    return l(P);
  }
  function b(P) {
    return P === 47 ? (s.consume(P), m ? S : (m = !0, b)) : l(P);
  }
  function S(P) {
    return P === null || asciiControl(P) || markdownLineEndingOrSpace(P) || unicodeWhitespace(P) || unicodePunctuation(P) ? l(P) : s.attempt(domain, s.attempt(path, E), l)(P);
  }
  function E(P) {
    return s.exit("literalAutolinkHttp"), s.exit("literalAutolink"), o(P);
  }
}
function tokenizeWwwPrefix(s, o, l) {
  let u = 0;
  return c;
  function c(g) {
    return (g === 87 || g === 119) && u < 3 ? (u++, s.consume(g), c) : g === 46 && u === 3 ? (s.consume(g), m) : l(g);
  }
  function m(g) {
    return g === null ? l(g) : o(g);
  }
}
function tokenizeDomain(s, o, l) {
  let u, c, m;
  return g;
  function g(S) {
    return S === 46 || S === 95 ? s.check(trail, b, v)(S) : S === null || markdownLineEndingOrSpace(S) || unicodeWhitespace(S) || S !== 45 && unicodePunctuation(S) ? b(S) : (m = !0, s.consume(S), g);
  }
  function v(S) {
    return S === 95 ? u = !0 : (c = u, u = void 0), s.consume(S), g;
  }
  function b(S) {
    return c || u || !m ? l(S) : o(S);
  }
}
function tokenizePath(s, o) {
  let l = 0, u = 0;
  return c;
  function c(g) {
    return g === 40 ? (l++, s.consume(g), c) : g === 41 && u < l ? m(g) : g === 33 || g === 34 || g === 38 || g === 39 || g === 41 || g === 42 || g === 44 || g === 46 || g === 58 || g === 59 || g === 60 || g === 63 || g === 93 || g === 95 || g === 126 ? s.check(trail, o, m)(g) : g === null || markdownLineEndingOrSpace(g) || unicodeWhitespace(g) ? o(g) : (s.consume(g), c);
  }
  function m(g) {
    return g === 41 && u++, s.consume(g), c;
  }
}
function tokenizeTrail(s, o, l) {
  return u;
  function u(v) {
    return v === 33 || v === 34 || v === 39 || v === 41 || v === 42 || v === 44 || v === 46 || v === 58 || v === 59 || v === 63 || v === 95 || v === 126 ? (s.consume(v), u) : v === 38 ? (s.consume(v), m) : v === 93 ? (s.consume(v), c) : (
      // `<` is an end.
      v === 60 || // So is whitespace.
      v === null || markdownLineEndingOrSpace(v) || unicodeWhitespace(v) ? o(v) : l(v)
    );
  }
  function c(v) {
    return v === null || v === 40 || v === 91 || markdownLineEndingOrSpace(v) || unicodeWhitespace(v) ? o(v) : u(v);
  }
  function m(v) {
    return asciiAlpha(v) ? g(v) : l(v);
  }
  function g(v) {
    return v === 59 ? (s.consume(v), u) : asciiAlpha(v) ? (s.consume(v), g) : l(v);
  }
}
function tokenizeEmailDomainDotTrail(s, o, l) {
  return u;
  function u(m) {
    return s.consume(m), c;
  }
  function c(m) {
    return asciiAlphanumeric(m) ? l(m) : o(m);
  }
}
function previousWww(s) {
  return s === null || s === 40 || s === 42 || s === 95 || s === 91 || s === 93 || s === 126 || markdownLineEndingOrSpace(s);
}
function previousProtocol(s) {
  return !asciiAlpha(s);
}
function previousEmail(s) {
  return !(s === 47 || gfmAtext(s));
}
function gfmAtext(s) {
  return s === 43 || s === 45 || s === 46 || s === 95 || asciiAlphanumeric(s);
}
function previousUnbalanced(s) {
  let o = s.length, l = !1;
  for (; o--; ) {
    const u = s[o][1];
    if ((u.type === "labelLink" || u.type === "labelImage") && !u._balanced) {
      l = !0;
      break;
    }
    if (u._gfmAutolinkLiteralWalkedInto) {
      l = !1;
      break;
    }
  }
  return s.length > 0 && !l && (s[s.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), l;
}
const indent = {
  tokenize: tokenizeIndent,
  partial: !0
};
function gfmFootnote() {
  return {
    document: {
      91: {
        name: "gfmFootnoteDefinition",
        tokenize: tokenizeDefinitionStart,
        continuation: {
          tokenize: tokenizeDefinitionContinuation
        },
        exit: gfmFootnoteDefinitionEnd
      }
    },
    text: {
      91: {
        name: "gfmFootnoteCall",
        tokenize: tokenizeGfmFootnoteCall
      },
      93: {
        name: "gfmPotentialFootnoteCall",
        add: "after",
        tokenize: tokenizePotentialGfmFootnoteCall,
        resolveTo: resolveToPotentialGfmFootnoteCall
      }
    }
  };
}
function tokenizePotentialGfmFootnoteCall(s, o, l) {
  const u = this;
  let c = u.events.length;
  const m = u.parser.gfmFootnotes || (u.parser.gfmFootnotes = []);
  let g;
  for (; c--; ) {
    const b = u.events[c][1];
    if (b.type === "labelImage") {
      g = b;
      break;
    }
    if (b.type === "gfmFootnoteCall" || b.type === "labelLink" || b.type === "label" || b.type === "image" || b.type === "link")
      break;
  }
  return v;
  function v(b) {
    if (!g || !g._balanced)
      return l(b);
    const S = normalizeIdentifier(u.sliceSerialize({
      start: g.end,
      end: u.now()
    }));
    return S.codePointAt(0) !== 94 || !m.includes(S.slice(1)) ? l(b) : (s.enter("gfmFootnoteCallLabelMarker"), s.consume(b), s.exit("gfmFootnoteCallLabelMarker"), o(b));
  }
}
function resolveToPotentialGfmFootnoteCall(s, o) {
  let l = s.length;
  for (; l--; )
    if (s[l][1].type === "labelImage" && s[l][0] === "enter") {
      s[l][1];
      break;
    }
  s[l + 1][1].type = "data", s[l + 3][1].type = "gfmFootnoteCallLabelMarker";
  const u = {
    type: "gfmFootnoteCall",
    start: Object.assign({}, s[l + 3][1].start),
    end: Object.assign({}, s[s.length - 1][1].end)
  }, c = {
    type: "gfmFootnoteCallMarker",
    start: Object.assign({}, s[l + 3][1].end),
    end: Object.assign({}, s[l + 3][1].end)
  };
  c.end.column++, c.end.offset++, c.end._bufferIndex++;
  const m = {
    type: "gfmFootnoteCallString",
    start: Object.assign({}, c.end),
    end: Object.assign({}, s[s.length - 1][1].start)
  }, g = {
    type: "chunkString",
    contentType: "string",
    start: Object.assign({}, m.start),
    end: Object.assign({}, m.end)
  }, v = [
    // Take the `labelImageMarker` (now `data`, the `!`)
    s[l + 1],
    s[l + 2],
    ["enter", u, o],
    // The `[`
    s[l + 3],
    s[l + 4],
    // The `^`.
    ["enter", c, o],
    ["exit", c, o],
    // Everything in between.
    ["enter", m, o],
    ["enter", g, o],
    ["exit", g, o],
    ["exit", m, o],
    // The ending (`]`, properly parsed and labelled).
    s[s.length - 2],
    s[s.length - 1],
    ["exit", u, o]
  ];
  return s.splice(l, s.length - l + 1, ...v), s;
}
function tokenizeGfmFootnoteCall(s, o, l) {
  const u = this, c = u.parser.gfmFootnotes || (u.parser.gfmFootnotes = []);
  let m = 0, g;
  return v;
  function v(P) {
    return s.enter("gfmFootnoteCall"), s.enter("gfmFootnoteCallLabelMarker"), s.consume(P), s.exit("gfmFootnoteCallLabelMarker"), b;
  }
  function b(P) {
    return P !== 94 ? l(P) : (s.enter("gfmFootnoteCallMarker"), s.consume(P), s.exit("gfmFootnoteCallMarker"), s.enter("gfmFootnoteCallString"), s.enter("chunkString").contentType = "string", S);
  }
  function S(P) {
    if (
      // Too long.
      m > 999 || // Closing brace with nothing.
      P === 93 && !g || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      P === null || P === 91 || markdownLineEndingOrSpace(P)
    )
      return l(P);
    if (P === 93) {
      s.exit("chunkString");
      const T = s.exit("gfmFootnoteCallString");
      return c.includes(normalizeIdentifier(u.sliceSerialize(T))) ? (s.enter("gfmFootnoteCallLabelMarker"), s.consume(P), s.exit("gfmFootnoteCallLabelMarker"), s.exit("gfmFootnoteCall"), o) : l(P);
    }
    return markdownLineEndingOrSpace(P) || (g = !0), m++, s.consume(P), P === 92 ? E : S;
  }
  function E(P) {
    return P === 91 || P === 92 || P === 93 ? (s.consume(P), m++, S) : S(P);
  }
}
function tokenizeDefinitionStart(s, o, l) {
  const u = this, c = u.parser.gfmFootnotes || (u.parser.gfmFootnotes = []);
  let m, g = 0, v;
  return b;
  function b(O) {
    return s.enter("gfmFootnoteDefinition")._container = !0, s.enter("gfmFootnoteDefinitionLabel"), s.enter("gfmFootnoteDefinitionLabelMarker"), s.consume(O), s.exit("gfmFootnoteDefinitionLabelMarker"), S;
  }
  function S(O) {
    return O === 94 ? (s.enter("gfmFootnoteDefinitionMarker"), s.consume(O), s.exit("gfmFootnoteDefinitionMarker"), s.enter("gfmFootnoteDefinitionLabelString"), s.enter("chunkString").contentType = "string", E) : l(O);
  }
  function E(O) {
    if (
      // Too long.
      g > 999 || // Closing brace with nothing.
      O === 93 && !v || // Space or tab is not supported by GFM for some reason.
      // `\n` and `[` not being supported makes sense.
      O === null || O === 91 || markdownLineEndingOrSpace(O)
    )
      return l(O);
    if (O === 93) {
      s.exit("chunkString");
      const z = s.exit("gfmFootnoteDefinitionLabelString");
      return m = normalizeIdentifier(u.sliceSerialize(z)), s.enter("gfmFootnoteDefinitionLabelMarker"), s.consume(O), s.exit("gfmFootnoteDefinitionLabelMarker"), s.exit("gfmFootnoteDefinitionLabel"), T;
    }
    return markdownLineEndingOrSpace(O) || (v = !0), g++, s.consume(O), O === 92 ? P : E;
  }
  function P(O) {
    return O === 91 || O === 92 || O === 93 ? (s.consume(O), g++, E) : E(O);
  }
  function T(O) {
    return O === 58 ? (s.enter("definitionMarker"), s.consume(O), s.exit("definitionMarker"), c.includes(m) || c.push(m), factorySpace(s, N, "gfmFootnoteDefinitionWhitespace")) : l(O);
  }
  function N(O) {
    return o(O);
  }
}
function tokenizeDefinitionContinuation(s, o, l) {
  return s.check(blankLine, o, s.attempt(indent, o, l));
}
function gfmFootnoteDefinitionEnd(s) {
  s.exit("gfmFootnoteDefinition");
}
function tokenizeIndent(s, o, l) {
  const u = this;
  return factorySpace(s, c, "gfmFootnoteDefinitionIndent", 5);
  function c(m) {
    const g = u.events[u.events.length - 1];
    return g && g[1].type === "gfmFootnoteDefinitionIndent" && g[2].sliceSerialize(g[1], !0).length === 4 ? o(m) : l(m);
  }
}
function gfmStrikethrough(s) {
  let l = (s || {}).singleTilde;
  const u = {
    name: "strikethrough",
    tokenize: m,
    resolveAll: c
  };
  return l == null && (l = !0), {
    text: {
      126: u
    },
    insideSpan: {
      null: [u]
    },
    attentionMarkers: {
      null: [126]
    }
  };
  function c(g, v) {
    let b = -1;
    for (; ++b < g.length; )
      if (g[b][0] === "enter" && g[b][1].type === "strikethroughSequenceTemporary" && g[b][1]._close) {
        let S = b;
        for (; S--; )
          if (g[S][0] === "exit" && g[S][1].type === "strikethroughSequenceTemporary" && g[S][1]._open && // If the sizes are the same:
          g[b][1].end.offset - g[b][1].start.offset === g[S][1].end.offset - g[S][1].start.offset) {
            g[b][1].type = "strikethroughSequence", g[S][1].type = "strikethroughSequence";
            const E = {
              type: "strikethrough",
              start: Object.assign({}, g[S][1].start),
              end: Object.assign({}, g[b][1].end)
            }, P = {
              type: "strikethroughText",
              start: Object.assign({}, g[S][1].end),
              end: Object.assign({}, g[b][1].start)
            }, T = [["enter", E, v], ["enter", g[S][1], v], ["exit", g[S][1], v], ["enter", P, v]], N = v.parser.constructs.insideSpan.null;
            N && splice(T, T.length, 0, resolveAll(N, g.slice(S + 1, b), v)), splice(T, T.length, 0, [["exit", P, v], ["enter", g[b][1], v], ["exit", g[b][1], v], ["exit", E, v]]), splice(g, S - 1, b - S + 3, T), b = S + T.length - 2;
            break;
          }
      }
    for (b = -1; ++b < g.length; )
      g[b][1].type === "strikethroughSequenceTemporary" && (g[b][1].type = "data");
    return g;
  }
  function m(g, v, b) {
    const S = this.previous, E = this.events;
    let P = 0;
    return T;
    function T(O) {
      return S === 126 && E[E.length - 1][1].type !== "characterEscape" ? b(O) : (g.enter("strikethroughSequenceTemporary"), N(O));
    }
    function N(O) {
      const z = classifyCharacter(S);
      if (O === 126)
        return P > 1 ? b(O) : (g.consume(O), P++, N);
      if (P < 2 && !l) return b(O);
      const Q = g.exit("strikethroughSequenceTemporary"), W = classifyCharacter(O);
      return Q._open = !W || W === 2 && !!z, Q._close = !z || z === 2 && !!W, v(O);
    }
  }
}
class EditMap {
  /**
   * Create a new edit map.
   */
  constructor() {
    this.map = [];
  }
  /**
   * Create an edit: a remove and/or add at a certain place.
   *
   * @param {number} index
   * @param {number} remove
   * @param {Array<Event>} add
   * @returns {undefined}
   */
  add(o, l, u) {
    addImplementation(this, o, l, u);
  }
  // To do: add this when moving to `micromark`.
  // /**
  //  * Create an edit: but insert `add` before existing additions.
  //  *
  //  * @param {number} index
  //  * @param {number} remove
  //  * @param {Array<Event>} add
  //  * @returns {undefined}
  //  */
  // addBefore(index, remove, add) {
  //   addImplementation(this, index, remove, add, true)
  // }
  /**
   * Done, change the events.
   *
   * @param {Array<Event>} events
   * @returns {undefined}
   */
  consume(o) {
    if (this.map.sort(function(m, g) {
      return m[0] - g[0];
    }), this.map.length === 0)
      return;
    let l = this.map.length;
    const u = [];
    for (; l > 0; )
      l -= 1, u.push(o.slice(this.map[l][0] + this.map[l][1]), this.map[l][2]), o.length = this.map[l][0];
    u.push([...o]), o.length = 0;
    let c = u.pop();
    for (; c; )
      o.push(...c), c = u.pop();
    this.map.length = 0;
  }
}
function addImplementation(s, o, l, u) {
  let c = 0;
  if (!(l === 0 && u.length === 0)) {
    for (; c < s.map.length; ) {
      if (s.map[c][0] === o) {
        s.map[c][1] += l, s.map[c][2].push(...u);
        return;
      }
      c += 1;
    }
    s.map.push([o, l, u]);
  }
}
function gfmTableAlign(s, o) {
  let l = !1;
  const u = [];
  for (; o < s.length; ) {
    const c = s[o];
    if (l) {
      if (c[0] === "enter")
        c[1].type === "tableContent" && u.push(s[o + 1][1].type === "tableDelimiterMarker" ? "left" : "none");
      else if (c[1].type === "tableContent") {
        if (s[o - 1][1].type === "tableDelimiterMarker") {
          const m = u.length - 1;
          u[m] = u[m] === "left" ? "center" : "right";
        }
      } else if (c[1].type === "tableDelimiterRow")
        break;
    } else c[0] === "enter" && c[1].type === "tableDelimiterRow" && (l = !0);
    o += 1;
  }
  return u;
}
function gfmTable() {
  return {
    flow: {
      null: {
        name: "table",
        tokenize: tokenizeTable,
        resolveAll: resolveTable
      }
    }
  };
}
function tokenizeTable(s, o, l) {
  const u = this;
  let c = 0, m = 0, g;
  return v;
  function v(xt) {
    let Kt = u.events.length - 1;
    for (; Kt > -1; ) {
      const rn = u.events[Kt][1].type;
      if (rn === "lineEnding" || // Note: markdown-rs uses `whitespace` instead of `linePrefix`
      rn === "linePrefix") Kt--;
      else break;
    }
    const tn = Kt > -1 ? u.events[Kt][1].type : null, ln = tn === "tableHead" || tn === "tableRow" ? ee : b;
    return ln === ee && u.parser.lazy[u.now().line] ? l(xt) : ln(xt);
  }
  function b(xt) {
    return s.enter("tableHead"), s.enter("tableRow"), S(xt);
  }
  function S(xt) {
    return xt === 124 || (g = !0, m += 1), E(xt);
  }
  function E(xt) {
    return xt === null ? l(xt) : markdownLineEnding(xt) ? m > 1 ? (m = 0, u.interrupt = !0, s.exit("tableRow"), s.enter("lineEnding"), s.consume(xt), s.exit("lineEnding"), N) : l(xt) : markdownSpace(xt) ? factorySpace(s, E, "whitespace")(xt) : (m += 1, g && (g = !1, c += 1), xt === 124 ? (s.enter("tableCellDivider"), s.consume(xt), s.exit("tableCellDivider"), g = !0, E) : (s.enter("data"), P(xt)));
  }
  function P(xt) {
    return xt === null || xt === 124 || markdownLineEndingOrSpace(xt) ? (s.exit("data"), E(xt)) : (s.consume(xt), xt === 92 ? T : P);
  }
  function T(xt) {
    return xt === 92 || xt === 124 ? (s.consume(xt), P) : P(xt);
  }
  function N(xt) {
    return u.interrupt = !1, u.parser.lazy[u.now().line] ? l(xt) : (s.enter("tableDelimiterRow"), g = !1, markdownSpace(xt) ? factorySpace(s, O, "linePrefix", u.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(xt) : O(xt));
  }
  function O(xt) {
    return xt === 45 || xt === 58 ? Q(xt) : xt === 124 ? (g = !0, s.enter("tableCellDivider"), s.consume(xt), s.exit("tableCellDivider"), z) : ve(xt);
  }
  function z(xt) {
    return markdownSpace(xt) ? factorySpace(s, Q, "whitespace")(xt) : Q(xt);
  }
  function Q(xt) {
    return xt === 58 ? (m += 1, g = !0, s.enter("tableDelimiterMarker"), s.consume(xt), s.exit("tableDelimiterMarker"), W) : xt === 45 ? (m += 1, W(xt)) : xt === null || markdownLineEnding(xt) ? K(xt) : ve(xt);
  }
  function W(xt) {
    return xt === 45 ? (s.enter("tableDelimiterFiller"), ue(xt)) : ve(xt);
  }
  function ue(xt) {
    return xt === 45 ? (s.consume(xt), ue) : xt === 58 ? (g = !0, s.exit("tableDelimiterFiller"), s.enter("tableDelimiterMarker"), s.consume(xt), s.exit("tableDelimiterMarker"), te) : (s.exit("tableDelimiterFiller"), te(xt));
  }
  function te(xt) {
    return markdownSpace(xt) ? factorySpace(s, K, "whitespace")(xt) : K(xt);
  }
  function K(xt) {
    return xt === 124 ? O(xt) : xt === null || markdownLineEnding(xt) ? !g || c !== m ? ve(xt) : (s.exit("tableDelimiterRow"), s.exit("tableHead"), o(xt)) : ve(xt);
  }
  function ve(xt) {
    return l(xt);
  }
  function ee(xt) {
    return s.enter("tableRow"), Re(xt);
  }
  function Re(xt) {
    return xt === 124 ? (s.enter("tableCellDivider"), s.consume(xt), s.exit("tableCellDivider"), Re) : xt === null || markdownLineEnding(xt) ? (s.exit("tableRow"), o(xt)) : markdownSpace(xt) ? factorySpace(s, Re, "whitespace")(xt) : (s.enter("data"), wt(xt));
  }
  function wt(xt) {
    return xt === null || xt === 124 || markdownLineEndingOrSpace(xt) ? (s.exit("data"), Re(xt)) : (s.consume(xt), xt === 92 ? yt : wt);
  }
  function yt(xt) {
    return xt === 92 || xt === 124 ? (s.consume(xt), wt) : wt(xt);
  }
}
function resolveTable(s, o) {
  let l = -1, u = !0, c = 0, m = [0, 0, 0, 0], g = [0, 0, 0, 0], v = !1, b = 0, S, E, P;
  const T = new EditMap();
  for (; ++l < s.length; ) {
    const N = s[l], O = N[1];
    N[0] === "enter" ? O.type === "tableHead" ? (v = !1, b !== 0 && (flushTableEnd(T, o, b, S, E), E = void 0, b = 0), S = {
      type: "table",
      start: Object.assign({}, O.start),
      // Note: correct end is set later.
      end: Object.assign({}, O.end)
    }, T.add(l, 0, [["enter", S, o]])) : O.type === "tableRow" || O.type === "tableDelimiterRow" ? (u = !0, P = void 0, m = [0, 0, 0, 0], g = [0, l + 1, 0, 0], v && (v = !1, E = {
      type: "tableBody",
      start: Object.assign({}, O.start),
      // Note: correct end is set later.
      end: Object.assign({}, O.end)
    }, T.add(l, 0, [["enter", E, o]])), c = O.type === "tableDelimiterRow" ? 2 : E ? 3 : 1) : c && (O.type === "data" || O.type === "tableDelimiterMarker" || O.type === "tableDelimiterFiller") ? (u = !1, g[2] === 0 && (m[1] !== 0 && (g[0] = g[1], P = flushCell(T, o, m, c, void 0, P), m = [0, 0, 0, 0]), g[2] = l)) : O.type === "tableCellDivider" && (u ? u = !1 : (m[1] !== 0 && (g[0] = g[1], P = flushCell(T, o, m, c, void 0, P)), m = g, g = [m[1], l, 0, 0])) : O.type === "tableHead" ? (v = !0, b = l) : O.type === "tableRow" || O.type === "tableDelimiterRow" ? (b = l, m[1] !== 0 ? (g[0] = g[1], P = flushCell(T, o, m, c, l, P)) : g[1] !== 0 && (P = flushCell(T, o, g, c, l, P)), c = 0) : c && (O.type === "data" || O.type === "tableDelimiterMarker" || O.type === "tableDelimiterFiller") && (g[3] = l);
  }
  for (b !== 0 && flushTableEnd(T, o, b, S, E), T.consume(o.events), l = -1; ++l < o.events.length; ) {
    const N = o.events[l];
    N[0] === "enter" && N[1].type === "table" && (N[1]._align = gfmTableAlign(o.events, l));
  }
  return s;
}
function flushCell(s, o, l, u, c, m) {
  const g = u === 1 ? "tableHeader" : u === 2 ? "tableDelimiter" : "tableData", v = "tableContent";
  l[0] !== 0 && (m.end = Object.assign({}, getPoint(o.events, l[0])), s.add(l[0], 0, [["exit", m, o]]));
  const b = getPoint(o.events, l[1]);
  if (m = {
    type: g,
    start: Object.assign({}, b),
    // Note: correct end is set later.
    end: Object.assign({}, b)
  }, s.add(l[1], 0, [["enter", m, o]]), l[2] !== 0) {
    const S = getPoint(o.events, l[2]), E = getPoint(o.events, l[3]), P = {
      type: v,
      start: Object.assign({}, S),
      end: Object.assign({}, E)
    };
    if (s.add(l[2], 0, [["enter", P, o]]), u !== 2) {
      const T = o.events[l[2]], N = o.events[l[3]];
      if (T[1].end = Object.assign({}, N[1].end), T[1].type = "chunkText", T[1].contentType = "text", l[3] > l[2] + 1) {
        const O = l[2] + 1, z = l[3] - l[2] - 1;
        s.add(O, z, []);
      }
    }
    s.add(l[3] + 1, 0, [["exit", P, o]]);
  }
  return c !== void 0 && (m.end = Object.assign({}, getPoint(o.events, c)), s.add(c, 0, [["exit", m, o]]), m = void 0), m;
}
function flushTableEnd(s, o, l, u, c) {
  const m = [], g = getPoint(o.events, l);
  c && (c.end = Object.assign({}, g), m.push(["exit", c, o])), u.end = Object.assign({}, g), m.push(["exit", u, o]), s.add(l + 1, 0, m);
}
function getPoint(s, o) {
  const l = s[o], u = l[0] === "enter" ? "start" : "end";
  return l[1][u];
}
const tasklistCheck = {
  name: "tasklistCheck",
  tokenize: tokenizeTasklistCheck
};
function gfmTaskListItem() {
  return {
    text: {
      91: tasklistCheck
    }
  };
}
function tokenizeTasklistCheck(s, o, l) {
  const u = this;
  return c;
  function c(b) {
    return (
      // Exit if there’s stuff before.
      u.previous !== null || // Exit if not in the first content that is the first child of a list
      // item.
      !u._gfmTasklistFirstContentOfListItem ? l(b) : (s.enter("taskListCheck"), s.enter("taskListCheckMarker"), s.consume(b), s.exit("taskListCheckMarker"), m)
    );
  }
  function m(b) {
    return markdownLineEndingOrSpace(b) ? (s.enter("taskListCheckValueUnchecked"), s.consume(b), s.exit("taskListCheckValueUnchecked"), g) : b === 88 || b === 120 ? (s.enter("taskListCheckValueChecked"), s.consume(b), s.exit("taskListCheckValueChecked"), g) : l(b);
  }
  function g(b) {
    return b === 93 ? (s.enter("taskListCheckMarker"), s.consume(b), s.exit("taskListCheckMarker"), s.exit("taskListCheck"), v) : l(b);
  }
  function v(b) {
    return markdownLineEnding(b) ? o(b) : markdownSpace(b) ? s.check({
      tokenize: spaceThenNonSpace
    }, o, l)(b) : l(b);
  }
}
function spaceThenNonSpace(s, o, l) {
  return factorySpace(s, u, "whitespace");
  function u(c) {
    return c === null ? l(c) : o(c);
  }
}
function gfm(s) {
  return combineExtensions([
    gfmAutolinkLiteral(),
    gfmFootnote(),
    gfmStrikethrough(s),
    gfmTable(),
    gfmTaskListItem()
  ]);
}
const emptyOptions = {};
function remarkGfm(s) {
  const o = (
    /** @type {Processor} */
    this
  ), l = s || emptyOptions, u = o.data(), c = u.micromarkExtensions || (u.micromarkExtensions = []), m = u.fromMarkdownExtensions || (u.fromMarkdownExtensions = []), g = u.toMarkdownExtensions || (u.toMarkdownExtensions = []);
  c.push(gfm(l)), m.push(gfmFromMarkdown()), g.push(gfmToMarkdown(l));
}
class MarkdownRenderFoundation extends BaseFoundation$1 {
  constructor() {
    super(...arguments), this.getOptions = () => ({
      evaluateOptions: {
        remarkPlugins: [remarkGfm],
        format: this.getProp("format")
      },
      compileOptions: {
        format: this.getProp("format")
      },
      runOptions: {}
    }), this.compile = async (o) => await compile(o, this.getOptions().compileOptions), this.evaluate = async (o) => (await evaluate(o, {
      ...this.getOptions().runOptions,
      ...this.getOptions().evaluateOptions,
      ...this._adapter.getRuntime()
    })).default, this.evaluateSync = (o) => evaluateSync(o, {
      ...this.getOptions().runOptions,
      ...this.getOptions().evaluateOptions,
      ...this._adapter.getRuntime()
    }).default;
  }
}
const propTypes = {
  className: string$3,
  style: object$1,
  format: {
    type: node$1,
    required: !0
  },
  components: {
    type: any$1,
    required: !0
  },
  raw: {
    type: string$3,
    required: !0
  }
}, defaultProps = {
  format: "mdx"
}, vuePropsType = vuePropsMake(propTypes, defaultProps), index = /* @__PURE__ */ defineComponent({
  props: {
    ...vuePropsType
  },
  name: "index",
  setup(s, {
    attrs: o
  }) {
    useSlots();
    const l = reactive({
      MDXContentComponent: void 0
    }), {
      adapter: u,
      setStateAsync: c
    } = useBaseComponent(s, l);
    function m(S, E, P) {
      const T = typeof S == "symbol" ? Fragment : S;
      return arguments.length > 2 && (E.key = P), h(T, typeof T == "string" || T === Fragment ? lodashExports.omit(E, "children") : E, typeof T == "string" || T === Fragment ? E.children : () => E.children);
    }
    function g() {
      return {
        ...u(),
        getRuntime: () => ({
          Fragment,
          jsx: m,
          jsxs: m
        })
      };
    }
    const v = g(), b = new MarkdownRenderFoundation(v);
    return watch(() => s.raw, (S) => {
      S && (l.MDXContentComponent = b.evaluateSync(s.raw));
    }, {
      immediate: !0
    }), () => {
      const S = l.MDXContentComponent;
      return createVNode("div", mergeProps$1({
        class: cls(cssClasses.PREFIX, s.className),
        style: s.style
      }, o), [createVNode(S, {
        components: {
          ...SemiMarkdownComponents,
          ...s.components
        }
      }, null)]);
    };
  }
}), index$1 = index;
export {
  Anchor$1 as Anchor,
  Link$1 as AnchorLink,
  ArrayFieldComponent$1 as ArrayField,
  AutoComplete,
  AutoCompleteFunc,
  AutoComplete as AutoCompleteItems,
  AutoCompleteVModel,
  Avatar$1 as Avatar,
  AvatarGroup$1 as AvatarGroup,
  BackTop$1 as BackTop,
  Badge$1 as Badge,
  Banner$1 as Banner,
  BaseFoundation$1 as BaseFoundation,
  Breadcrumb$1 as Breadcrumb,
  BreadcrumbItem$1 as BreadcrumbItem,
  Button$2 as Button,
  ButtonGroup$1 as ButtonGroup,
  Card$1 as Card,
  CardGroup$1 as CardGroup,
  Carousel$1 as Carousel,
  Cascader,
  CascaderVModel,
  Checkbox,
  CheckboxGroup,
  CheckboxGroupVModel,
  CodeHighlight,
  Col$1 as Col,
  Collapse$1 as Collapse,
  CollapsePanel$1 as CollapsePanel,
  Collapsible$1 as Collapsible,
  ConfigProvider$1 as ConfigProvider,
  DatePicker,
  DatePickerVModel,
  Descriptions$1 as Descriptions,
  Item$2 as DescriptionsItem,
  Divider$1 as Divider,
  Dropdown,
  DropdownDivider$1 as DropdownDivider,
  DropdownItem$1 as DropdownItem,
  DropdownMenu$1 as DropdownMenu,
  DropdownTitle$1 as DropdownTitle,
  Empty$1 as Empty,
  BaseForm$1 as Form,
  FormAutoComplete,
  FormCascader,
  FormCheckbox,
  FormCheckboxGroup,
  FormDatePicker,
  FormInput,
  FormInputNumber,
  FormRadio,
  FormRadioGroup,
  FormRating,
  FormSelectBase as FormSelect,
  FormSelectOption,
  FormSelectOptionGroup,
  FormSlider,
  FormSwitch,
  FormTagInput,
  FormTextArea,
  FormTimePicker,
  FormTreeSelect,
  FormUpload,
  Highlight$1 as Highlight,
  Icon,
  Button$3 as IconButton,
  Icon as Icons,
  Image$1 as Image,
  Preview$1 as ImagePreview,
  Input$1 as Input,
  InputGroup$2 as InputGroup,
  InputNumber$1 as InputNumber,
  InputNumberVModel,
  InputVModel,
  BaseLayout$1 as Layout,
  LayoutContent,
  LayoutFooter,
  LayoutHeader,
  LayoutSider,
  Link$1 as Link,
  List$1 as List,
  ListItem$1 as ListItem,
  LocaleConsumer$6 as LocaleConsumer,
  LocaleProvider$1 as LocaleProvider,
  index$5 as Lottie,
  index$1 as MarkdownRender,
  Modal,
  ModalClass,
  BaseNav$1 as Nav,
  Footer$1 as NavFooter,
  Header$1 as NavHeader,
  Item$1 as NavItem,
  NotificationListClass as Notification,
  NotificationList$1 as NotificationList,
  OverflowList$1 as OverflowList,
  Pagination$1 as Pagination,
  PinCode$1 as PinCode,
  Popconfirm$1 as Popconfirm,
  Popover$1 as Popover,
  Progress$1 as Progress,
  Radio$1 as Radio,
  RadioGroup$1 as RadioGroup,
  RadioGroupVModel,
  Rating$1 as Rating,
  RatingVModel,
  Row$1 as Row,
  ScrollItem$1 as ScrollItem,
  ScrollList,
  Select,
  Option$1 as SelectOption,
  SelectVModel,
  SideSheet$1 as SideSheet,
  Skeleton$1 as Skeleton,
  Avatar as SkeletonAvatar,
  Button as SkeletonButton,
  Image$2 as SkeletonImage,
  Paragraph as SkeletonParagraph,
  Title as SkeletonTitle,
  Slider$1 as Slider,
  SliderVModel,
  Space,
  Spin,
  SplitButtonGroup$1 as SplitButtonGroup,
  Step$1 as Step,
  BaseSteps$1 as Steps,
  Step$1 as StepsStep,
  SubNav$1 as SubNav,
  Switch$1 as Switch,
  SwitchVModel,
  TabPane$1 as TabPane,
  Table$1 as Table,
  Table as TableMaker,
  Tabs$1 as Tabs,
  Tag,
  TagGroup,
  TagInput,
  TagInputVModel,
  TextArea$1 as TextArea,
  TimePicker,
  TimePickerVModel,
  BaseTimeline$1 as Timeline,
  Item as TimelineItem,
  index$6 as Toast,
  ToastFactory,
  Tooltip$1 as Tooltip,
  Transfer$1 as Transfer,
  TransferVModel,
  Tree$1 as Tree,
  TreeNode$1 as TreeNode,
  TreeSelect$1 as TreeSelect,
  TreeSelectVModel,
  Typography,
  Numeral$1 as TypographyNumeral,
  Paragraph$1 as TypographyParagraph,
  TypographyText,
  TypographyTitle,
  Upload$1 as Upload,
  UploadVModel,
  WithVModel,
  Button$3 as iconButton,
  useBaseComponent,
  useFieldApi,
  useFieldState,
  useFormApi,
  useFormState,
  useNotification,
  withField,
  withFormApi$1 as withFormApi,
  withFormState$1 as withFormState
};
//# sourceMappingURL=semi-ui-vue.js.map
