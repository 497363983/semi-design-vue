{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@douyinfe+semi-foundation@2.34.0/node_modules/@douyinfe/semi-foundation/lib/es/form/foundation.js"],
  "sourcesContent": ["import _toPath from \"lodash/toPath\";\nimport _isFunction from \"lodash/isFunction\";\nimport _isUndefined from \"lodash/isUndefined\";\n\n/* eslint-disable prefer-const, max-len */\nimport BaseFoundation from '../base/foundation';\nimport * as ObjectUtil from '../utils/object';\nimport isPromise from '../utils/isPromise';\nimport { isValid } from './utils';\nimport scrollIntoView from 'scroll-into-view-if-needed';\nexport default class FormFoundation extends BaseFoundation {\n  constructor(adapter) {\n    super(Object.assign({}, adapter));\n    /*\n        Also need to read initValue here, because the Form level can set the initial value,\n        and the Field level can also set the initial value.\n        The field set in the Form does not necessarily have a Field entity,\n        so you cannot completely rely on the register moment to set the initial value\n         这里也需要读一次initValue，因为Form级别可设置初始值，Field级别也可设置初始值.\n        Form中设置的字段，不一定会存在Field实体，所以不能完全依赖register时刻来设置初始值\n    */\n\n    let {\n      initValues\n    } = this._adapter.getProps();\n\n    initValues = this._adapter.cloneDeep(initValues);\n    this.data = {\n      values: initValues ? initValues : {},\n      errors: {},\n      touched: {} // invalid: false,\n      // dirty: false,\n\n    }; // Map store all fields\n    // key: fieldName\n    // value:  { field, fieldApi, keepState, initValue}\n\n    this.fields = new Map(); // Record all registered fields\n\n    this.registered = {}; // Record all registered ArrayField\n\n    this.registeredArrayField = new Map();\n    this.register = this.register.bind(this);\n    this.unRegister = this.unRegister.bind(this);\n    this.registerArrayField = this.registerArrayField.bind(this);\n    this.unRegisterArrayField = this.unRegisterArrayField.bind(this);\n    this.getArrayField = this.getArrayField.bind(this);\n    this.updateArrayField = this.updateArrayField.bind(this);\n    this.getField = this.getField.bind(this);\n    this.setValues = this.setValues.bind(this);\n    this.updateStateValue = this.updateStateValue.bind(this);\n    this.updateStateError = this.updateStateError.bind(this);\n    this.updateStateTouched = this.updateStateTouched.bind(this);\n    this.getFormState = this.getFormState.bind(this);\n    this.getValue = this.getValue.bind(this);\n    this.getError = this.getError.bind(this);\n    this.getTouched = this.getTouched.bind(this);\n    this.getInitValues = this.getInitValues.bind(this);\n    this.getInitValue = this.getInitValue.bind(this);\n    this.getFormProps = this.getFormProps.bind(this);\n    this.getFieldExist = this.getFieldExist.bind(this);\n    this.scrollToField = this.scrollToField.bind(this);\n  }\n\n  init() {\n    this._adapter.initFormId();\n  }\n\n  getField(field) {\n    const targetField = this.fields.get(field);\n    return targetField;\n  }\n\n  register(field, fieldState, fieldStuff) {\n    // determine if this field has been register before\n    const registered = this.registered[field];\n    this.registered[field] = true;\n    this.fields.set(field, fieldStuff);\n\n    if (fieldStuff.keepState) {// TODO support keepState\n    } else {\n      const allowEmpty = fieldStuff.allowEmpty || false;\n      const opts = {\n        notNotify: true,\n        notUpdate: false,\n        allowEmpty\n      };\n      let fieldValue = fieldState.value; // When allowEmpty is false, 'is equivalent to undefined, and the key of the field does not need to be reflected on values\n\n      if (!allowEmpty && fieldValue === '') {\n        fieldValue = undefined;\n      }\n\n      this.updateStateValue(field, fieldValue, opts);\n\n      if (fieldState.error) {\n        this.updateStateError(field, fieldState.error, opts);\n      }\n    } // this.log(this.fields);\n\n  }\n\n  unRegister(field) {\n    const targetField = this.fields.get(field); // delete data\n\n    try {\n      if (!targetField.keepState) {\n        ObjectUtil.remove(this.data.values, field);\n        ObjectUtil.remove(this.data.errors, field);\n        ObjectUtil.remove(this.data.touched, field);\n      }\n    } catch (error) {\n      console.error(`some thing wrong when unregister field:${field}`);\n    } // delete field\n\n\n    this.fields.delete(field);\n\n    this._adapter.notifyChange(this.data);\n\n    this._adapter.forceUpdate();\n  } // in order to slove byted-issue-289\n\n\n  registerArrayField(arrayFieldPath, val) {\n    this.updateArrayField(arrayFieldPath, {\n      updateKey: new Date().valueOf(),\n      initValue: val\n    });\n  }\n\n  unRegisterArrayField(arrayField) {\n    this.registeredArrayField.delete(arrayField);\n  }\n\n  getArrayField(arrayField) {\n    return this.registeredArrayField.get(arrayField);\n  }\n\n  updateArrayField(arrayField, updateValue) {\n    const mergeVal = Object.assign(Object.assign({}, this.registeredArrayField.get(arrayField)), updateValue);\n    this.registeredArrayField.set(arrayField, mergeVal);\n  }\n\n  validate(fieldPaths) {\n    const {\n      validateFields\n    } = this.getProps();\n\n    if (validateFields && _isFunction(validateFields)) {\n      return this._formValidate();\n    } else {\n      return this._fieldsValidate(fieldPaths);\n    }\n  } // form level validate\n\n\n  _formValidate() {\n    const {\n      values\n    } = this.data;\n    const {\n      validateFields\n    } = this.getProps();\n    return new Promise((resolve, reject) => {\n      let maybePromisedErrors;\n\n      try {\n        maybePromisedErrors = validateFields(values);\n      } catch (errors) {\n        // error throw by sync validate directly\n        maybePromisedErrors = errors;\n      }\n\n      if (!maybePromisedErrors) {\n        resolve(values);\n        this.injectErrorToField({});\n      } else if (isPromise(maybePromisedErrors)) {\n        maybePromisedErrors.then(result => {\n          // validate success，clear error\n          if (!result) {\n            resolve(values);\n            this.injectErrorToField({});\n          } else {\n            this.data.errors = result;\n\n            this._adapter.notifyChange(this.data);\n\n            this.injectErrorToField(result);\n\n            this._adapter.forceUpdate();\n\n            this._autoScroll(100);\n\n            reject(result);\n          }\n        }, errors => {\n          // validate failed\n          // this._adapter.notifyChange(this.data);\n          this._autoScroll(100);\n\n          reject(errors);\n        });\n      } else {\n        // TODO: current design, returning an empty object will be considered a checksum failure and will be rejected. Only returning an empty string will be considered a success, consider resetting it in 1.0?\n        this.data.errors = maybePromisedErrors;\n        this.injectErrorToField(maybePromisedErrors);\n\n        this._adapter.notifyChange(this.data);\n\n        this._adapter.forceUpdate();\n\n        this._autoScroll(100);\n\n        reject(maybePromisedErrors);\n      }\n    });\n  } // field level validate\n\n\n  _fieldsValidate(fieldPaths) {\n    const {\n      values\n    } = this.data; // When there is no custom validation function at Form level, perform validation of each Field\n\n    return new Promise((resolve, reject) => {\n      let promiseSet = [];\n\n      const targetFields = this._getOperateFieldMap(fieldPaths);\n\n      targetFields.forEach((field, fieldPath) => {\n        // Call each fieldApi for verification\n        const fieldValue = this.getValue(fieldPath); // When centralized verification, no need to trigger forceUpdate and notify\n\n        const opts = {\n          notNotify: true,\n          notUpdate: true\n        };\n        const validateResult = field.fieldApi.validate(fieldValue, opts);\n        promiseSet.push(validateResult);\n        field.fieldApi.setTouched(true, opts);\n      });\n      Promise.all(promiseSet).then(() => {\n        // After the centralized verification is completed, trigger notify and forceUpdate once.\n        this._adapter.notifyChange(this.data);\n\n        this._adapter.forceUpdate();\n\n        const errors = this.getError();\n\n        if (this._isValid(targetFields)) {\n          resolve(values);\n        } else {\n          this._autoScroll();\n\n          reject(errors);\n        }\n      });\n    });\n  }\n\n  submit() {\n    const {\n      values\n    } = this.data; // validate form\n\n    this.validate().then(resolveValues => {\n      // if valid do submit\n      const _values = this._adapter.cloneDeep(resolveValues);\n\n      this._adapter.notifySubmit(_values);\n    }).catch(errors => {\n      const _errors = this._adapter.cloneDeep(errors);\n\n      const _values = this._adapter.cloneDeep(values);\n\n      this._adapter.notifySubmitFail(_errors, _values);\n    });\n  }\n  /**\n   * Case A：\n   *      All fields: a[0]、a[1]、b.type、b.name[2]、b.name[0]\n   *      input => output:\n   *           a  => a[0]、a[1]\n   *           b  => b.type、b.name[0]、b.name[2]\n   *\n   * Case B：\n   *      All fields: activity.a[0]、activity.a[1]、activity.c、activity.d、other\n   *      input => output:\n   *           activity.a => activity.a[0]、activity.a[1]\n   *\n   */\n\n\n  _getNestedField(path) {\n    const allRegisterField = this.fields;\n    const allFieldPath = [...allRegisterField].map(item => item[0]);\n    let nestedFieldPath = new Map();\n    allFieldPath.forEach(item => {\n      let itemPath = _toPath(item);\n\n      let targetPath = _toPath(path);\n\n      if (targetPath.every((path, i) => targetPath[i] === itemPath[i])) {\n        const realField = allRegisterField.get(item);\n        nestedFieldPath.set(item, realField);\n      }\n    });\n    return nestedFieldPath;\n  } // get all operate fields, called by validate() / reset()\n\n\n  _getOperateFieldMap(fieldPaths) {\n    let targetFields = new Map();\n\n    if (!_isUndefined(fieldPaths)) {\n      // reset or validate specific fields\n      fieldPaths.forEach(path => {\n        const field = this.fields.get(path); // may be undefined, if exists two fields like 'a[0]'、'a[1]', but user directly call reset(['a']) / validate(['a'])\n\n        if (_isUndefined(field)) {\n          const nestedFields = this._getNestedField(path);\n\n          targetFields = new Map([...targetFields, ...nestedFields]);\n        } else {\n          targetFields.set(path, field);\n        }\n      });\n    } else {\n      // reset or validate all fields\n      targetFields = this.fields;\n    }\n\n    return targetFields;\n  } // Reset the entire form, reset all fields and remove validation results\n\n\n  reset(fieldPaths) {\n    const targetFields = this._getOperateFieldMap(fieldPaths);\n\n    targetFields.forEach(field => {\n      field.fieldApi.reset();\n    });\n\n    if (this.registeredArrayField.size) {\n      this._resetArrayField();\n    }\n\n    this._adapter.notifyChange(this.data);\n\n    this._adapter.forceUpdate();\n\n    this._adapter.notifyReset();\n  }\n\n  _resetArrayField() {\n    /*\n        When Reset, arrayField needs to be processed separately. Restore the key/value of arrayField in formState according to the initial value\n        Update the key inside the arrayField to make it actively renderer\n        Reset时，arrayField需要单独处理, 根据初始值还原 arrayField在formState中的key/value, 更新 arrayField内部的key，使其主动rerender\n    */\n    const arrayFieldPaths = [...this.registeredArrayField.keys()];\n    arrayFieldPaths.forEach(path => {\n      const arrayFieldState = this.registeredArrayField.get(path);\n      const arrayFieldInitValue = arrayFieldState.initValue;\n      this.updateStateValue(path, arrayFieldInitValue, {\n        notNotify: true,\n        notUpdate: true\n      });\n      this.updateArrayField(path, {\n        updateKey: new Date().valueOf()\n      });\n    });\n  } // After calling the form's custom validateFields function, reject the returned error to the corresponding field\n  // 调用了Form的自定义validateFields函数后，将返回的错误展示到对应的field中\n\n\n  injectErrorToField(errors) {\n    this.fields.forEach(field => {\n      const fieldError = ObjectUtil.get(errors, field.field);\n      const opts = {\n        notNotify: true,\n        notUpdate: true\n      };\n      field.fieldApi.setError(fieldError, opts);\n    });\n  }\n\n  getValue(field, opts) {\n    const isAllField = typeof field === 'undefined';\n    const needClone = opts && opts.needClone;\n    let result, fieldValue;\n\n    switch (true) {\n      case !isAllField && !needClone:\n        result = ObjectUtil.get(this.data.values, field);\n        break;\n\n      case !isAllField && needClone:\n        fieldValue = ObjectUtil.get(this.data.values, field);\n        result = this._adapter.cloneDeep(fieldValue);\n        break;\n\n      case isAllField && !needClone:\n        result = Object.assign({}, this.data.values);\n        break;\n\n      case isAllField && needClone:\n        result = this._adapter.cloneDeep(this.data.values);\n        break;\n\n      default:\n        break;\n    }\n\n    return result;\n  }\n\n  setValues(values, _ref) {\n    let {\n      isOverride = false\n    } = _ref;\n\n    const _values = this._adapter.cloneDeep(values);\n\n    this.fields.forEach(field => {\n      const value = ObjectUtil.get(_values, field.field); // When calling setValues to override the values, only need to trigger onValueChange and onChange once, so setNotNotify of setValue to true\n      // 调用setValues进行值的覆盖时，只需要回调一次onValueChange、onChange即可，所以此处将setValue的notNotify置为true\n\n      const opts = {\n        notNotify: true,\n        notUpdate: true\n      };\n      field.fieldApi.setValue(value, opts);\n    }); // if there exists any arrayField component in this form\n\n    if (this.registeredArrayField.size) {\n      const arrayFieldPaths = [...this.registeredArrayField.keys()];\n      arrayFieldPaths.forEach(path => {\n        this.updateArrayField(path, {\n          updateKey: new Date().valueOf()\n        });\n      });\n    } // When isOverride is true, there may be a non-existent field in the values passed in, directly synchronized to formState.values\n    // 当isOverride为true，传入的values中可能存在不存在的field时，直接将其同步到formState.values中\n\n\n    if (isOverride) {\n      this.data.values = _values;\n    } // After completing the assignment, the unified callback can be done once.\n    // 在完成赋值后，统一回调一次即可\n\n\n    this._adapter.notifyChange(this.data);\n\n    this._adapter.notifyValueChange(this.data.values, Object.assign({}, values));\n\n    this._adapter.forceUpdate();\n  } // update formState value\n\n\n  updateStateValue(field, value, opts, callback) {\n    const notNotify = opts && opts.notNotify;\n    const notUpdate = opts && opts.notUpdate;\n    const fieldAllowEmpty = opts && opts.fieldAllowEmpty;\n    /**\n     * 当Form.allowEmpty为true时，所有的field，key都会在formState.values中出现，如果值为空那么就是undefined\n     * 当Form.allowEmpty为false时，只有有值的field，key才会在formState.values中出现\n     * When F orm.allow Empty is true, all fields and keys will appear in the formS tate.values. If the value is empty, it is undefined\n     * When F orm.allow Empty is false, only fields with values will key appear in the formS tate.values\n     */\n\n    const formAllowEmpty = this.getProp('allowEmpty'); // priority at Field level\n\n    const allowEmpty = fieldAllowEmpty ? fieldAllowEmpty : formAllowEmpty;\n    ObjectUtil.set(this.data.values, field, value, allowEmpty);\n    /**\n     * When registering, setValue called when Field initValue is synchronized to FormState should not trigger notify\n     * but need to trigger forceUpdate, otherwise useFormState, useFieldState initial rendering will have problems\n     *\n     * register时，Field中同步initValue到FormState时调用的setValue不应该触发notify\n     * 但需要触发forceUpdate，否则useFormState、useFieldState初始渲染会有问题\n     */\n\n    if (!notNotify) {\n      this._adapter.notifyChange(this.data);\n\n      this._adapter.notifyValueChange(this.data.values, {\n        [field]: value\n      });\n    }\n\n    if (!notUpdate) {\n      this._adapter.forceUpdate(callback);\n    }\n  } // get touched from formState\n\n\n  getTouched(field) {\n    if (typeof field === 'undefined') {\n      return this.data.touched;\n    }\n\n    return ObjectUtil.get(this.data.touched, field);\n  } // update formState touched\n\n\n  updateStateTouched(field, isTouched, opts, callback) {\n    const notNotify = opts && opts.notNotify;\n    const notUpdate = opts && opts.notUpdate;\n    ObjectUtil.set(this.data.touched, field, isTouched);\n\n    if (!notNotify) {\n      this._adapter.notifyChange(this.data);\n    }\n\n    if (!notUpdate) {\n      this._adapter.forceUpdate(callback);\n    }\n  } // get error from formState\n\n\n  getError(field) {\n    if (typeof field === 'undefined') {\n      return this.data.errors;\n    }\n\n    return ObjectUtil.get(this.data.errors, field);\n  } // update formState error\n\n\n  updateStateError(field, error, opts, callback) {\n    const notNotify = opts && opts.notNotify;\n    const notUpdate = opts && opts.notUpdate;\n    ObjectUtil.set(this.data.errors, field, error); // The setError caused by centralized validation does not need to trigger notify, otherwise it will be called too frequently, as many times as there are fields\n    // 集中validate时，引起的setError不需要触发notify，否则会过于频繁调用，有多少个field就调用了多少次\n\n    if (!notNotify) {\n      this._adapter.notifyChange(this.data);\n    }\n\n    if (!notUpdate) {\n      this._adapter.forceUpdate(callback);\n    }\n  } // For internal use in the FormApi Operating Field\n\n\n  getFieldSetterApi() {\n    const setValue = (field, value, opts) => {\n      const fieldApi = this.fields.get(field) ? this.fields.get(field).fieldApi : undefined; // DeepClone the value entered from the outside to avoid unexpected errors caused by not isolating the scope to the greatest extent. This setValue will be called in eg: ArrayField\n\n      const newValue = this._adapter.cloneDeep(value);\n\n      if (fieldApi) {\n        // If there is a corresponding Field entity, call FieldApi to update the value\n        fieldApi.setValue(newValue, opts);\n      } else {\n        // If you reset an entire array, such as Array Field, the array as a whole may actually have no Field entities (but each array element corresponds to a Field)\n        // At this time, first modify formState directly, then find out the subordinate fields and drive them to update\n        // Eg: peoples: [0, 2, 3]. Each value of the peoples array corresponds to an Input Field\n        // When the user directly calls formA pi.set Value ('peoples', [2,3])\n        this.updateStateValue(field, newValue, opts, () => {\n          let nestedFields = this._getNestedField(field);\n\n          if (nestedFields.size) {\n            nestedFields.forEach(fieldStaff => {\n              let fieldPath = fieldStaff.field;\n              let newFieldVal = ObjectUtil.get(this.data.values, fieldPath);\n              let nestedBatchUpdateOpts = {\n                notNotify: true,\n                notUpdate: true\n              };\n              fieldStaff.fieldApi.setValue(newFieldVal, nestedBatchUpdateOpts);\n            });\n          }\n        }); // If the reset happens to be, then update the updateKey corresponding to ArrayField to render it again\n\n        if (this.getArrayField(field)) {\n          this.updateArrayField(field, {\n            updateKey: new Date().valueOf()\n          });\n        }\n      }\n    };\n\n    const setError = (field, error, opts) => {\n      const fieldApi = this.fields.get(field) ? this.fields.get(field).fieldApi : undefined;\n\n      const newError = this._adapter.cloneDeep(error);\n\n      if (fieldApi) {\n        fieldApi.setError(newError, opts);\n      } else {\n        this.updateStateError(field, newError, opts, () => {\n          let nestedFields = this._getNestedField(field);\n\n          if (nestedFields.size) {\n            nestedFields.forEach(fieldStaff => {\n              let fieldPath = fieldStaff.field;\n              let newFieldError = ObjectUtil.get(this.data.errors, fieldPath);\n              let nestedBatchUpdateOpts = {\n                notNotify: true,\n                notUpdate: true\n              };\n              fieldStaff.fieldApi.setError(newFieldError, nestedBatchUpdateOpts);\n            });\n          }\n        });\n\n        if (this.getArrayField(field)) {\n          this.updateArrayField(field, {\n            updateKey: new Date().valueOf()\n          });\n        }\n      }\n    };\n\n    const setTouched = (field, isTouched, opts) => {\n      const fieldApi = this.fields.get(field) ? this.fields.get(field).fieldApi : undefined; // touched is boolean variable, no need to exec deepClone like setValue\n\n      if (fieldApi) {\n        fieldApi.setTouched(isTouched, opts);\n      } else {\n        this.updateStateTouched(field, isTouched, opts, () => {\n          let nestedFields = this._getNestedField(field);\n\n          if (nestedFields.size) {\n            nestedFields.forEach(fieldStaff => {\n              let fieldPath = fieldStaff.field;\n              let newFieldTouch = ObjectUtil.get(this.data.touched, fieldPath);\n              let nestedBatchUpdateOpts = {\n                notNotify: true,\n                notUpdate: true\n              };\n              fieldStaff.fieldApi.setTouched(newFieldTouch, nestedBatchUpdateOpts);\n            });\n          }\n        });\n\n        if (this.getArrayField(field)) {\n          this.updateArrayField(field, {\n            updateKey: new Date().valueOf()\n          });\n        }\n      }\n    };\n\n    return {\n      setValue,\n      setError,\n      setTouched\n    };\n  } // For Field and ArrayField to read and modify FormState\n\n\n  getModifyFormStateApi() {\n    return {\n      register: this.register,\n      unRegister: this.unRegister,\n      updateStateValue: this.updateStateValue,\n      updateStateError: this.updateStateError,\n      updateStateTouched: this.updateStateTouched,\n      getValue: this.getValue,\n      getError: this.getError,\n      getTouched: this.getTouched,\n      getInitValues: this.getInitValues,\n      getInitValue: this.getInitValue,\n      getFormProps: this.getFormProps,\n      getField: this.getField,\n      registerArrayField: this.registerArrayField,\n      unRegisterArrayField: this.unRegisterArrayField,\n      getArrayField: this.getArrayField,\n      updateArrayField: this.updateArrayField\n    };\n  } // Form APIs for external use, exposed to the user\n\n\n  getFormApi() {\n    const fieldSetterApi = this.getFieldSetterApi();\n    return Object.assign(Object.assign({}, fieldSetterApi), {\n      reset: fields => this.reset(fields),\n      validate: fields => this.validate(fields),\n      getValue: field => this.getValue(field, {\n        needClone: true\n      }),\n      getValues: () => this.getValue(undefined, {\n        needClone: true\n      }),\n      getFormState: () => this.getFormState(true),\n      getInitValue: field => this.getInitValue(field),\n      getInitValues: () => this.getInitValues(),\n      getTouched: field => this.getTouched(field),\n      getError: field => this.getError(field),\n      setValues: (values, opts) => this.setValues(values, opts || {\n        isOverride: false\n      }),\n      submitForm: () => this.submit(),\n      getFieldExist: field => this.getFieldExist(field),\n      scrollToField: (field, scrollOpts) => this.scrollToField(field, scrollOpts)\n    });\n  }\n\n  getFormState() {\n    let needClone = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n\n    // NOTES：这里如果直接返回this.data，forceUpdate 触发 Form rerender 时，通过context传下去的formState会被认为是同一个对象【应该是浅对比的原因】\n    // 使用了useFormState相关的component都不会触发重新渲染。所以使用...复制一次\n\n    /*\n        The reason for distinguishing deepClone: When semi is calling getFormState for internal consumption,\n        the value of formState will not be modified, so deep cloning is not necessary, which can reduce performance loss\n        But if the users use formApi.getFormState(), the behavior is unpredictable, and invasive modifications may be performed,\n        so deep clones are used for isolation.\n        对deepClone进行区分的原因：semi调用getFormState内部消费时，不会对formState的值进行修改，所以无需深克隆，节约开销\n        但如果是业务方用formApi调用getFormState时，行为无法预料，有可能会进行侵入式修改，所以用深克隆进行隔离\n    */\n    if (!needClone) {\n      return Object.assign({}, this.data);\n    } else {\n      return this._adapter.cloneDeep(this.data);\n    }\n  }\n\n  _isValid(targetFields) {\n    let valid = true;\n\n    if (!targetFields) {\n      valid = Boolean(ObjectUtil.empty(this.data.errors));\n    } else {\n      // when trigger partial validate\n      const targetFieldStr = [...targetFields.keys()];\n      targetFieldStr.forEach(fieldStr => {\n        const fieldError = ObjectUtil.get(this.data.errors, fieldStr);\n\n        if (!isValid(fieldError)) {\n          valid = false;\n        }\n      });\n    }\n\n    return valid;\n  } // get form.props.initValues\n\n\n  getInitValues() {\n    return this._adapter.getInitValues();\n  }\n\n  getInitValue(field) {\n    if (typeof field === 'undefined') {\n      return this._adapter.getInitValues();\n    }\n\n    return ObjectUtil.get(this._adapter.getInitValues(), field);\n  }\n\n  getFormProps(keys) {\n    return this._adapter.getFormProps(keys);\n  }\n\n  getFieldExist(field) {\n    return Boolean(this.fields.has(field));\n  }\n\n  _autoScroll(timeout) {\n    const {\n      autoScrollToError\n    } = this.getFormProps();\n\n    if (!autoScrollToError) {\n      return;\n    }\n\n    let scrollOpts = {\n      behavior: 'smooth',\n      block: 'start'\n    };\n    typeof autoScrollToError === 'object' ? scrollOpts = autoScrollToError : null;\n\n    if (timeout) {\n      setTimeout(() => this._getErrorFieldAndScroll(scrollOpts), 100);\n    } else {\n      this._getErrorFieldAndScroll(scrollOpts);\n    }\n  }\n\n  _getErrorFieldAndScroll(scrollOpts) {\n    const errorDOM = this._adapter.getAllErrorDOM();\n\n    if (errorDOM && errorDOM.length) {\n      try {\n        const fieldDom = errorDOM[0].parentNode.parentNode;\n        scrollIntoView(fieldDom, scrollOpts);\n      } catch (error) {}\n    }\n  }\n\n  scrollToField(field) {\n    let scrollOpts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      behavior: 'smooth',\n      block: 'start'\n    };\n\n    if (this.getFieldExist(field)) {\n      const fieldDOM = this._adapter.getFieldDOM(field);\n\n      scrollIntoView(fieldDOM, scrollOpts);\n    }\n  }\n\n}"],
  "mappings": "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",
  "names": ["_isFunction", "_toPath", "path", "_isUndefined"]
}
