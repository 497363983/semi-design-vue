{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@douyinfe+semi-foundation@2.34.0/node_modules/@douyinfe/semi-foundation/lib/es/utils/getHighlight.js"],
  "sourcesContent": ["import _isString from \"lodash/isString\";\n\nconst escapeRegExpFn = string => string.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, '\\\\$&');\n/**\n   * Examine text for any matches.\n   * If we find matches, add them to the returned array as a \"chunk\" object ({start:number, end:number}).\n   * @return { start:number, end:number }[]\n   */\n\n\nconst findChunks = _ref => {\n  let {\n    autoEscape,\n    caseSensitive,\n    searchWords,\n    sourceString\n  } = _ref;\n  return searchWords.filter(searchWord => searchWord) // Remove empty words\n  .reduce((chunks, searchWord) => {\n    if (autoEscape) {\n      searchWord = escapeRegExpFn(searchWord);\n    }\n\n    const regex = new RegExp(searchWord, caseSensitive ? 'g' : 'gi');\n    let match;\n\n    while (match = regex.exec(sourceString)) {\n      const start = match.index;\n      const end = regex.lastIndex; // We do not return zero-length matches\n\n      if (end > start) {\n        chunks.push({\n          highlight: false,\n          start,\n          end\n        });\n      } // Prevent browsers like Firefox from getting stuck in an infinite loop\n      // See http://www.regexguru.com/2008/04/watch-out-for-zero-length-matches/\n\n\n      if (match.index === regex.lastIndex) {\n        regex.lastIndex++;\n      }\n    }\n\n    return chunks;\n  }, []);\n};\n/**\n   * Takes an array of {start:number, end:number} objects and combines chunks that overlap into single chunks.\n   * @return {start:number, end:number}[]\n   */\n\n\nconst combineChunks = _ref2 => {\n  let {\n    chunks\n  } = _ref2;\n  chunks = chunks.sort((first, second) => first.start - second.start).reduce((processedChunks, nextChunk) => {\n    // First chunk just goes straight in the array...\n    if (processedChunks.length === 0) {\n      return [nextChunk];\n    } else {\n      // ... subsequent chunks get checked to see if they overlap...\n      const prevChunk = processedChunks.pop();\n\n      if (nextChunk.start <= prevChunk.end) {\n        // It may be the case that prevChunk completely surrounds nextChunk, so take the\n        // largest of the end indeces.\n        const endIndex = Math.max(prevChunk.end, nextChunk.end);\n        processedChunks.push({\n          highlight: false,\n          start: prevChunk.start,\n          end: endIndex\n        });\n      } else {\n        processedChunks.push(prevChunk, nextChunk);\n      }\n\n      return processedChunks;\n    }\n  }, []);\n  return chunks;\n};\n/**\n   * Given a set of chunks to highlight, create an additional set of chunks\n   * to represent the bits of text between the highlighted text.\n   * @param chunksToHighlight {start:number, end:number}[]\n   * @param totalLength number\n   * @return {start:number, end:number, highlight:boolean}[]\n   */\n\n\nconst fillInChunks = _ref3 => {\n  let {\n    chunksToHighlight,\n    totalLength\n  } = _ref3;\n  const allChunks = [];\n\n  const append = (start, end, highlight) => {\n    if (end - start > 0) {\n      allChunks.push({\n        start,\n        end,\n        highlight\n      });\n    }\n  };\n\n  if (chunksToHighlight.length === 0) {\n    append(0, totalLength, false);\n  } else {\n    let lastIndex = 0;\n    chunksToHighlight.forEach(chunk => {\n      append(lastIndex, chunk.start, false);\n      append(chunk.start, chunk.end, true);\n      lastIndex = chunk.end;\n    });\n    append(lastIndex, totalLength, false);\n  }\n\n  return allChunks;\n};\n/**\n * Creates an array of chunk objects representing both higlightable and non highlightable pieces of text that match each search word.\n *\n    findAll ['z'], 'aaazaaazaaa'\n        result #=> [\n            { start: 0, end: 3, highlight: false }\n            { start: 3, end: 4, highlight: true }\n            { start: 4, end: 7, highlight: false }\n            { start: 7, end: 8, highlight: true }\n            { start: 8, end: 11, highlight: false }\n        ]\n\n    findAll ['do', 'dollar'], 'aaa do dollar aaa'\n        #=> chunks: [\n                { start: 4, end: 6 },\n                { start: 7, end: 9 },\n                { start: 7, end: 13 },\n            ]\n        #=> chunksToHight: [\n                { start: 4, end: 6 },\n                { start: 7, end: 13 },\n            ]\n        #=> result: [\n                { start: 0, end: 4, highlight: false },\n                { start: 4, end: 6, highlight: true },\n                { start: 6, end: 7, highlight: false },\n                { start: 7, end: 13, highlight: true },\n                { start: 13, end: 17, highlight: false },\n            ]\n\n * @return Array of \"chunks\" (where a Chunk is { start:number, end:number, highlight:boolean })\n */\n\n\nconst findAll = _ref4 => {\n  let {\n    autoEscape = true,\n    caseSensitive = false,\n    searchWords,\n    sourceString\n  } = _ref4;\n\n  if (_isString(searchWords)) {\n    searchWords = [searchWords];\n  }\n\n  const chunks = findChunks({\n    autoEscape,\n    caseSensitive,\n    searchWords,\n    sourceString\n  });\n  const chunksToHighlight = combineChunks({\n    chunks\n  });\n  const result = fillInChunks({\n    chunksToHighlight,\n    totalLength: sourceString ? sourceString.length : 0\n  });\n  return result;\n};\n\nexport { findAll };"],
  "mappings": ";;;;;;;;;;;AAAA,sBAAsB;AAEtB,IAAM,iBAAiB,YAAU,OAAO,QAAQ,uCAAuC,MAAM;AAQ7F,IAAM,aAAa,UAAQ;AACzB,MAAI;AAAA,IACF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,IAAI;AACJ,SAAO,YAAY,OAAO,gBAAc,UAAU,EACjD,OAAO,CAAC,QAAQ,eAAe;AAC9B,QAAI,YAAY;AACd,mBAAa,eAAe,UAAU;AAAA,IACxC;AAEA,UAAM,QAAQ,IAAI,OAAO,YAAY,gBAAgB,MAAM,IAAI;AAC/D,QAAI;AAEJ,WAAO,QAAQ,MAAM,KAAK,YAAY,GAAG;AACvC,YAAM,QAAQ,MAAM;AACpB,YAAM,MAAM,MAAM;AAElB,UAAI,MAAM,OAAO;AACf,eAAO,KAAK;AAAA,UACV,WAAW;AAAA,UACX;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAIA,UAAI,MAAM,UAAU,MAAM,WAAW;AACnC,cAAM;AAAA,MACR;AAAA,IACF;AAEA,WAAO;AAAA,EACT,GAAG,CAAC,CAAC;AACP;AAOA,IAAM,gBAAgB,WAAS;AAC7B,MAAI;AAAA,IACF;AAAA,EACF,IAAI;AACJ,WAAS,OAAO,KAAK,CAAC,OAAO,WAAW,MAAM,QAAQ,OAAO,KAAK,EAAE,OAAO,CAAC,iBAAiB,cAAc;AAEzG,QAAI,gBAAgB,WAAW,GAAG;AAChC,aAAO,CAAC,SAAS;AAAA,IACnB,OAAO;AAEL,YAAM,YAAY,gBAAgB,IAAI;AAEtC,UAAI,UAAU,SAAS,UAAU,KAAK;AAGpC,cAAM,WAAW,KAAK,IAAI,UAAU,KAAK,UAAU,GAAG;AACtD,wBAAgB,KAAK;AAAA,UACnB,WAAW;AAAA,UACX,OAAO,UAAU;AAAA,UACjB,KAAK;AAAA,QACP,CAAC;AAAA,MACH,OAAO;AACL,wBAAgB,KAAK,WAAW,SAAS;AAAA,MAC3C;AAEA,aAAO;AAAA,IACT;AAAA,EACF,GAAG,CAAC,CAAC;AACL,SAAO;AACT;AAUA,IAAM,eAAe,WAAS;AAC5B,MAAI;AAAA,IACF;AAAA,IACA;AAAA,EACF,IAAI;AACJ,QAAM,YAAY,CAAC;AAEnB,QAAM,SAAS,CAAC,OAAO,KAAK,cAAc;AACxC,QAAI,MAAM,QAAQ,GAAG;AACnB,gBAAU,KAAK;AAAA,QACb;AAAA,QACA;AAAA,QACA;AAAA,MACF,CAAC;AAAA,IACH;AAAA,EACF;AAEA,MAAI,kBAAkB,WAAW,GAAG;AAClC,WAAO,GAAG,aAAa,KAAK;AAAA,EAC9B,OAAO;AACL,QAAI,YAAY;AAChB,sBAAkB,QAAQ,WAAS;AACjC,aAAO,WAAW,MAAM,OAAO,KAAK;AACpC,aAAO,MAAM,OAAO,MAAM,KAAK,IAAI;AACnC,kBAAY,MAAM;AAAA,IACpB,CAAC;AACD,WAAO,WAAW,aAAa,KAAK;AAAA,EACtC;AAEA,SAAO;AACT;AAmCA,IAAM,UAAU,WAAS;AACvB,MAAI;AAAA,IACF,aAAa;AAAA,IACb,gBAAgB;AAAA,IAChB;AAAA,IACA;AAAA,EACF,IAAI;AAEJ,UAAI,gBAAAA,SAAU,WAAW,GAAG;AAC1B,kBAAc,CAAC,WAAW;AAAA,EAC5B;AAEA,QAAM,SAAS,WAAW;AAAA,IACxB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,QAAM,oBAAoB,cAAc;AAAA,IACtC;AAAA,EACF,CAAC;AACD,QAAM,SAAS,aAAa;AAAA,IAC1B;AAAA,IACA,aAAa,eAAe,aAAa,SAAS;AAAA,EACpD,CAAC;AACD,SAAO;AACT;",
  "names": ["_isString"]
}
