{
  "version": 3,
  "sources": ["../../../../node_modules/.pnpm/@douyinfe+semi-foundation@2.34.0/node_modules/@douyinfe/semi-foundation/lib/es/select/foundation.js"],
  "sourcesContent": ["import _omit from \"lodash/omit\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isString from \"lodash/isString\";\nimport _isNumber from \"lodash/isNumber\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n/* argus-disable unPkgSensitiveInfo */\n\n/* eslint-disable max-len */\n\n\nimport BaseFoundation from '../base/foundation';\nimport KeyCode, { ENTER_KEY } from '../utils/keyCode';\nimport warning from '../utils/warning';\nimport isNullOrUndefined from '../utils/isNullOrUndefined';\nimport isEnterPress from '../utils/isEnterPress';\nimport { handlePrevent } from '../utils/a11y';\nexport default class SelectFoundation extends BaseFoundation {\n  constructor(adapter) {\n    super(Object.assign({}, adapter)); // keyboard event listner\n    // eslint-disable-next-line @typescript-eslint/member-ordering\n\n    this._keydownHandler = null;\n  }\n\n  init() {\n    this._setDropdownWidth();\n\n    const isDefaultOpen = this.getProp('defaultOpen');\n    const isOpen = this.getProp('open');\n\n    const originalOptions = this._collectOptions();\n\n    this._setDefaultSelection(originalOptions);\n\n    if (isDefaultOpen || isOpen) {\n      this.open(undefined, originalOptions);\n    }\n\n    const autoFocus = this.getProp('autoFocus');\n\n    if (autoFocus) {\n      this.focus();\n    }\n  }\n\n  focus() {\n    const isFilterable = this._isFilterable();\n\n    const isMultiple = this._isMultiple();\n\n    this._adapter.updateFocusState(true);\n\n    this._adapter.setIsFocusInContainer(false);\n\n    if (isFilterable && isMultiple) {\n      // when filter and multiple, only focus input\n      this.focusInput();\n    } else if (isFilterable && !isMultiple) {\n      // when filter and not multiple, only show input and focus input\n      this.toggle2SearchInput(true);\n    } else {\n      this._focusTrigger();\n    }\n  }\n\n  _focusTrigger() {\n    this._adapter.focusTrigger(); // this.bindKeyBoardEvent();\n\n  }\n\n  destroy() {\n    this._adapter.unregisterClickOutsideHandler(); // this.unBindKeyBoardEvent();\n\n  }\n\n  _setDropdownWidth() {\n    const {\n      style,\n      dropdownMatchSelectWidth\n    } = this.getProps();\n    let width;\n\n    if (dropdownMatchSelectWidth) {\n      if (style && _isNumber(style.width)) {\n        width = style.width;\n      } else if (style && _isString(style.width) && !style.width.includes('%')) {\n        width = style.width;\n      } else {\n        width = this._adapter.getTriggerWidth();\n      }\n\n      this._adapter.setOptionWrapperWidth(width);\n    }\n  }\n\n  _collectOptions() {\n    const originalOptions = this._adapter.getOptionsFromChildren();\n\n    this._adapter.updateOptions(originalOptions); // Reposition the drop-down layer\n\n\n    this._adapter.rePositionDropdown();\n\n    return originalOptions;\n  }\n\n  _setDefaultSelection(originalOptions) {\n    let {\n      value\n    } = this.getProps();\n    const {\n      defaultValue\n    } = this.getProps();\n\n    if (this._isControlledComponent()) {// do nothing\n    } else {\n      value = defaultValue;\n    }\n\n    this._update(value, originalOptions);\n  } // call when props.optionList change\n\n\n  handleOptionListChange() {\n    const newOptionList = this._collectOptions();\n\n    const {\n      selections\n    } = this.getStates();\n    this.updateOptionsActiveStatus(selections, newOptionList); // reset focusIndex\n\n    const {\n      defaultActiveFirstOption\n    } = this.getProps();\n\n    if (defaultActiveFirstOption) {\n      this._adapter.updateFocusIndex(0);\n    }\n  } // In uncontrolled mode, when props.optionList change,\n  // but already had defaultValue or choose some option\n\n\n  handleOptionListChangeHadDefaultValue() {\n    const selections = this.getState('selections');\n    let value;\n    const {\n      onChangeWithObject\n    } = this.getProps();\n\n    const isMultiple = this._isMultiple();\n\n    switch (true) {\n      case isMultiple && Boolean(selections.size):\n        try {\n          value = [...selections].map(item => // At this point item1 is directly the object\n          onChangeWithObject ? item[1] : item[1].value);\n        } catch (error) {\n          value = [];\n        }\n\n        break;\n\n      case isMultiple && !selections.size:\n        value = [];\n        break;\n\n      case !isMultiple && Boolean(selections.size):\n        try {\n          value = onChangeWithObject ? [...selections][0][1] : [...selections][0][1].value;\n        } catch (error) {}\n\n        break;\n\n      case !isMultiple && !selections.size:\n        break;\n\n      default:\n        break;\n    }\n\n    const originalOptions = this._adapter.getOptionsFromChildren();\n\n    this._update(value, originalOptions);\n  } // call when props.value change\n\n\n  handleValueChange(value) {\n    const {\n      allowCreate,\n      autoClearSearchValue,\n      remote\n    } = this.getProps();\n    const {\n      inputValue\n    } = this.getStates();\n    let originalOptions; // AllowCreate and controlled mode, no need to re-collect optionList\n\n    if (allowCreate && this._isControlledComponent()) {\n      originalOptions = this.getState('options');\n      originalOptions.forEach(item => item._show = true);\n    } else {\n      // originalOptions = this.getState('options');\n      // The options in state cannot be used directly here,\n      // because it is possible to update the optionList and props.value at the same time, and the options in state are still old at this time\n      originalOptions = this._adapter.getOptionsFromChildren();\n    } // Multi-selection, controlled mode, you need to reposition the drop-down menu after updating\n\n\n    this._adapter.rePositionDropdown();\n\n    if (this._isFilterable() && !autoClearSearchValue && inputValue && !remote) {\n      originalOptions = this._filterOption(originalOptions, inputValue);\n    }\n\n    this._update(value, originalOptions);\n  } // Update the selected item in the selection box\n\n\n  _update(propValue, originalOptions) {\n    let selections;\n\n    if (!this._isMultiple()) {\n      // Radio\n      selections = this._updateSingle(propValue, originalOptions);\n    } else {\n      selections = this._updateMultiple(propValue, originalOptions);\n      this.updateOverflowItemCount(selections.size);\n    } // Update the text in the selection box\n\n\n    this._adapter.updateSelection(selections); // Update the selected item in the drop-down box\n\n\n    this.updateOptionsActiveStatus(selections, originalOptions);\n  } // Optionally selected updates (when components are mounted, or after value changes)\n\n\n  _updateSingle(propValue, originalOptions) {\n    const selections = new Map();\n    const {\n      onChangeWithObject\n    } = this.getProps(); // When onChangeWithObject is true, the defaultValue or Value passed by the props should be the object, which corresponds to the result returned by onChange, so the value of the object needs to be taken as a judgment comparison\n\n    const selectedValue = onChangeWithObject && typeof propValue !== 'undefined' ? propValue.value : propValue;\n    const selectedOptions = originalOptions.filter(option => option.value === selectedValue);\n    const noMatchOptionInList = !selectedOptions.length && typeof selectedValue !== 'undefined'; // If the current value, there is a matching option in the optionList\n\n    if (selectedOptions.length) {\n      const selectedOption = selectedOptions[0];\n      const optionExist = Object.assign({}, selectedOption); // if (onChangeWithObject) {\n      //     OptionExist = {... propValue }; // value is the object with the'value 'Key\n      // }\n\n      selections.set(optionExist.label, optionExist);\n    } else if (noMatchOptionInList) {\n      // If the current value does not have a corresponding item in the optionList, construct an option and update it to the selection. However, it does not need to be inserted into the list\n      let optionNotExist = {\n        value: propValue,\n        label: propValue,\n        _notExist: true,\n        _scrollIndex: -1\n      };\n\n      if (onChangeWithObject) {\n        optionNotExist = Object.assign(Object.assign({}, propValue), {\n          _notExist: true,\n          _scrollIndex: -1\n        });\n      }\n\n      selections.set(optionNotExist.label, optionNotExist);\n    }\n\n    return selections;\n  } // Multi-selected option update (when the component is mounted, or after the value changes)\n\n\n  _updateMultiple(propValue, originalOptions) {\n    const nowSelections = this.getState('selections');\n    let selectedOptionList = []; // Multiple selection is to determine whether it is an array to avoid the problem of defaultValue/value incoming string error\n\n    const propValueIsArray = Array.isArray(propValue);\n    this.checkMultipleProps(); // If N values are currently selected, the corresponding option data is retrieved from the current selections for retrieval. Because these selected options may not exist in the new optionList\n\n    if (nowSelections.size) {\n      selectedOptionList = [...nowSelections].map(item => item[1]);\n    }\n\n    const selections = new Map();\n    let selectedValues = propValue;\n    const {\n      onChangeWithObject\n    } = this.getProps(); // When onChangeWithObject is true\n\n    if (onChangeWithObject && propValueIsArray) {\n      selectedValues = propValue.map(item => item.value);\n    }\n\n    if (propValueIsArray && selectedValues.length) {\n      selectedValues.forEach((selectedValue, i) => {\n        // The current value exists in the current optionList\n        const index = originalOptions.findIndex(option => option.value === selectedValue);\n\n        if (index !== -1) {\n          selections.set(originalOptions[index].label, originalOptions[index]);\n        } else {\n          // The current value exists in the optionList that has been selected before the change, and does not exist in the current optionList, then directly take the corresponding value from the selections, no need to construct a new option\n          const indexInSelectedList = selectedOptionList.findIndex(option => option.value === selectedValue);\n\n          if (indexInSelectedList !== -1) {\n            const option = selectedOptionList[indexInSelectedList];\n            selections.set(option.label, option);\n          } else {\n            // The current value does not exist in the current optionList or the list before the change. Construct an option and update it to the selection\n            let optionNotExist = {\n              value: selectedValue,\n              label: selectedValue,\n              _notExist: true\n            };\n            onChangeWithObject ? optionNotExist = Object.assign(Object.assign({}, propValue[i]), {\n              _notExist: true\n            }) : null;\n            selections.set(optionNotExist.label, Object.assign(Object.assign({}, optionNotExist), {\n              _scrollIndex: -1\n            }));\n          }\n        }\n      });\n    }\n\n    return selections;\n  }\n\n  _isMultiple() {\n    return this.getProp('multiple');\n  }\n\n  _isDisabled() {\n    return this.getProp('disabled');\n  }\n\n  _isFilterable() {\n    return Boolean(this.getProp('filter')); // filter can be boolean or function\n  }\n\n  handleClick(e) {\n    const {\n      clickToHide\n    } = this.getProps();\n    const {\n      isOpen\n    } = this.getStates();\n\n    const isDisabled = this._isDisabled();\n\n    if (isDisabled) {\n      return;\n    } else if (!isOpen) {\n      this.open();\n\n      this._notifyFocus(e);\n    } else if (isOpen && clickToHide) {\n      this.close(e);\n    } else if (isOpen && !clickToHide) {\n      this.focusInput();\n    }\n  }\n\n  open(acInput, originalOptions) {\n    const isFilterable = this._isFilterable();\n\n    const options = originalOptions || this.getState('options'); // When searchable, when the drop-down box expands\n\n    if (isFilterable) {\n      // Also clears the options filter to show all candidates\n      // Options created dynamically but not selected are also filtered out\n      const sugInput = '';\n\n      const newOptions = this._filterOption(options, sugInput).filter(item => !item._inputCreateOnly);\n\n      this._adapter.updateOptions(newOptions);\n\n      this.toggle2SearchInput(true);\n    }\n\n    this._adapter.openMenu();\n\n    this._setDropdownWidth();\n\n    this._adapter.notifyDropdownVisibleChange(true);\n\n    this.bindKeyBoardEvent();\n\n    this._adapter.registerClickOutsideHandler(e => {\n      this.close(e);\n\n      this._notifyBlur(e);\n\n      this._adapter.updateFocusState(false);\n    });\n  }\n\n  toggle2SearchInput(isShow) {\n    if (isShow) {\n      this._adapter.toggleInputShow(isShow, () => this.focusInput());\n    } else {\n      // only when choose the option and close the panel, the input can be hide\n      this._adapter.toggleInputShow(isShow, () => undefined);\n    }\n  }\n\n  close(e, closeCb) {\n    // to support A11y, closing the panel trigger does not necessarily lose focus\n    this._adapter.closeMenu();\n\n    this._adapter.notifyDropdownVisibleChange(false);\n\n    this._adapter.setIsFocusInContainer(false); // this.unBindKeyBoardEvent();\n    // this._notifyBlur(e);\n\n\n    this._adapter.unregisterClickOutsideHandler(); // this._adapter.updateFocusState(false);\n\n\n    const isFilterable = this._isFilterable();\n\n    if (isFilterable) {\n      this.toggle2SearchInput(false);\n    }\n\n    this._adapter.once('popoverClose', () => {\n      if (isFilterable) {\n        this.clearInput(e);\n      }\n\n      if (closeCb) {\n        closeCb();\n      }\n    });\n  }\n\n  onSelect(option, optionIndex, event) {\n    const isDisabled = this._isDisabled();\n\n    if (isDisabled) {\n      return;\n    } // If the allowCreate dynamically created option is selected, onCreate needs to be triggered\n\n\n    if (option._inputCreateOnly) {\n      this._adapter.notifyCreate(option);\n    }\n\n    const isMultiple = this._isMultiple();\n\n    if (!isMultiple) {\n      this._handleSingleSelect(option, event);\n\n      this._focusTrigger();\n    } else {\n      this._handleMultipleSelect(option, event);\n    }\n\n    this._adapter.updateFocusIndex(optionIndex);\n  }\n\n  _handleSingleSelect(_a, event) {\n    var {\n      value,\n      label\n    } = _a,\n        rest = __rest(_a, [\"value\", \"label\"]);\n\n    const selections = new Map().set(label, Object.assign({\n      value,\n      label\n    }, rest)); // First trigger onSelect, then trigger onChange\n\n    this._notifySelect(value, Object.assign({\n      value,\n      label\n    }, rest)); // If it is a controlled component, directly notify\n    // Make sure that the operations of updating updateOptions are done after the animation ends\n    // otherwise the content will be updated when the popup layer is not collapsed, and it looks like it will flash once when it is closed\n\n\n    if (this._isControlledComponent()) {\n      this.close(event, () => {\n        this._notifyChange(selections);\n      });\n    } else {\n      this._adapter.updateSelection(selections); // notify user\n\n\n      this._notifyChange(selections);\n\n      this.close(event, () => {\n        // Update the selected item in the drop-down box\n        this.updateOptionsActiveStatus(selections);\n      });\n    }\n  }\n\n  _handleMultipleSelect(_a, event) {\n    var {\n      value,\n      label\n    } = _a,\n        rest = __rest(_a, [\"value\", \"label\"]);\n\n    const maxLimit = this._adapter.getMaxLimit();\n\n    const selections = this._adapter.getSelections();\n\n    const {\n      autoClearSearchValue\n    } = this.getProps();\n\n    if (selections.has(label)) {\n      this._notifyDeselect(value, Object.assign({\n        value,\n        label\n      }, rest));\n\n      selections.delete(label);\n    } else if (maxLimit && selections.size === maxLimit) {\n      this._adapter.notifyMaxLimit(Object.assign({\n        value,\n        label\n      }, _omit(rest, '_scrollIndex')));\n\n      return;\n    } else {\n      this._notifySelect(value, Object.assign({\n        value,\n        label\n      }, rest));\n\n      selections.set(label, Object.assign({\n        value,\n        label\n      }, rest));\n    }\n\n    if (this._isControlledComponent()) {\n      // Controlled components, directly notified\n      this._notifyChange(selections);\n\n      if (this._isFilterable()) {\n        if (autoClearSearchValue) {\n          this.clearInput(event);\n        }\n\n        this.focusInput();\n      }\n    } else {\n      // Uncontrolled components, update ui\n      this._adapter.updateSelection(selections);\n\n      this.updateOverflowItemCount(selections.size); // In multi-select mode, the drop-down pop-up layer is repositioned every time the value is changed, because the height selection of the selection box may have changed\n\n      this._adapter.rePositionDropdown();\n\n      let {\n        options\n      } = this.getStates(); // Searchable filtering, when selected, resets Input\n\n      if (this._isFilterable()) {\n        // When filter active，if autoClearSearchValue is true，reset input after select\n        if (autoClearSearchValue) {\n          this.clearInput(event); // At the same time, the filtering of options is also cleared, in order to show all candidates\n\n          const sugInput = '';\n          options = this._filterOption(options, sugInput);\n        }\n\n        this.focusInput();\n      }\n\n      this.updateOptionsActiveStatus(selections, options);\n\n      this._notifyChange(selections);\n    }\n  }\n\n  clearSelected() {\n    const selections = new Map();\n\n    if (this._isControlledComponent()) {\n      this._notifyChange(selections);\n\n      this._adapter.notifyClear();\n    } else {\n      this._adapter.updateSelection(selections);\n\n      this.updateOptionsActiveStatus(selections);\n\n      this._notifyChange(selections);\n\n      this._adapter.notifyClear();\n    } // when call manually by ref method\n\n\n    const {\n      isOpen\n    } = this.getStates();\n\n    if (isOpen) {\n      this._adapter.rePositionDropdown();\n    }\n  } // Update the selected item in the drop-down box\n\n\n  updateOptionsActiveStatus(selections) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getState('options');\n    const {\n      allowCreate\n    } = this.getProps();\n    const newOptions = options.map(option => {\n      if (selections.has(option.label)) {\n        option._selected = true;\n\n        if (allowCreate) {\n          delete option._inputCreateOnly;\n        }\n      } else {\n        if (option._inputCreateOnly) {\n          option._show = false;\n        }\n\n        option._selected = false;\n      }\n\n      return option;\n    });\n\n    this._adapter.updateOptions(newOptions);\n  }\n\n  removeTag(item) {\n    const selections = this._adapter.getSelections();\n\n    selections.delete(item.label);\n\n    if (this._isControlledComponent()) {\n      this._notifyDeselect(item.value, item);\n\n      this._notifyChange(selections);\n    } else {\n      this._notifyDeselect(item.value, item);\n\n      this._adapter.updateSelection(selections);\n\n      this.updateOverflowItemCount(selections.size);\n      this.updateOptionsActiveStatus(selections); // Repostion drop-down layer, because the selection may have changed the number of rows, resulting in a height change\n\n      this._adapter.rePositionDropdown();\n\n      this._notifyChange(selections);\n    }\n  } // The reason why event input is optional is that clearInput may be manually called by the user through ref\n\n\n  clearInput(event) {\n    const {\n      inputValue\n    } = this.getStates(); // only when input is not null, select should notifySearch and updateOptions\n\n    if (inputValue !== '') {\n      this._adapter.updateInputValue('');\n\n      this._adapter.notifySearch('', event); // reset options filter\n\n\n      const {\n        options\n      } = this.getStates();\n      const {\n        remote\n      } = this.getProps();\n      let optionsAfterFilter = options;\n\n      if (!remote) {\n        optionsAfterFilter = this._filterOption(options, '');\n      }\n\n      this._adapter.updateOptions(optionsAfterFilter);\n    }\n  }\n\n  focusInput() {\n    this._adapter.focusInput();\n\n    this._adapter.updateFocusState(true);\n\n    this._adapter.setIsFocusInContainer(false);\n  }\n\n  handleInputChange(sugInput, event) {\n    // Input is a controlled component, so the value needs to be updated\n    this._adapter.updateInputValue(sugInput);\n\n    const {\n      options,\n      isOpen\n    } = this.getStates();\n    const {\n      allowCreate,\n      remote\n    } = this.getProps();\n    let optionsAfterFilter = options;\n\n    if (!remote) {\n      // Filter options based on input\n      optionsAfterFilter = this._filterOption(options, sugInput);\n    } // When allowClear is true, an entry can be created. You need to include the current input as a new Option input\n\n\n    optionsAfterFilter = this._createOptionByInput(allowCreate, optionsAfterFilter, sugInput);\n\n    this._adapter.updateOptions(optionsAfterFilter);\n\n    this._adapter.notifySearch(sugInput, event); // In multi-select mode, the drop-down box is repositioned each time you enter, because it may cause a line break as the input changes\n\n\n    if (this._isMultiple()) {\n      this._adapter.rePositionDropdown();\n    }\n  }\n\n  _filterOption(originalOptions, sugInput) {\n    const filter = this.getProp('filter');\n\n    if (!filter) {\n      // 1. No filtering\n      return originalOptions;\n    } else if (typeof filter === 'boolean' && filter) {\n      // 2. When true, the default filter is used\n      const input = sugInput.toLowerCase();\n      return originalOptions.map(option => {\n        const label = option.label.toString().toLowerCase();\n        const groupLabel = option._parentGroup && option._parentGroup.label;\n        const matchOption = label.includes(input);\n        const matchGroup = _isString(groupLabel) && groupLabel.toLowerCase().includes(input);\n\n        if (matchOption || matchGroup) {\n          option._show = true;\n        } else {\n          option._show = false;\n        }\n\n        return option;\n      });\n    } else if (typeof filter === 'function') {\n      // 3. When passing in a custom function, use a custom function for filtering\n      return originalOptions.map(option => {\n        filter(sugInput, option) ? option._show = true : option._show = false;\n        return option;\n      });\n    }\n\n    return undefined;\n  }\n\n  _createOptionByInput(allowCreate, optionsAfterFilter, sugInput) {\n    if (allowCreate) {\n      if (sugInput) {\n        // optionsAfterFilter clone ??? needClone ?\n        const newOptionByInput = {\n          _show: true,\n          _selected: false,\n          value: sugInput,\n          label: sugInput,\n          // True indicates that the option was dynamically created during user filtering\n          _inputCreateOnly: true\n        };\n        let createOptionIndex = -1;\n        let matchOptionIndex = -1;\n        optionsAfterFilter.forEach((option, index) => {\n          if (!option._show && !option._inputCreateOnly) {\n            return;\n          } // The matching algorithm is not necessarily through labels?\n\n\n          if (option.label === sugInput) {\n            matchOptionIndex = index;\n          }\n\n          if (option._inputCreateOnly) {\n            createOptionIndex = index;\n            option.value = sugInput;\n            option.label = sugInput;\n            option._show = true;\n          }\n        });\n\n        if (createOptionIndex === -1 && matchOptionIndex === -1) {\n          optionsAfterFilter.push(newOptionByInput);\n        }\n\n        if (matchOptionIndex !== -1) {\n          optionsAfterFilter = optionsAfterFilter.filter(item => !item._inputCreateOnly);\n        }\n      } else {\n        // Delete input unselected items\n        optionsAfterFilter = optionsAfterFilter.filter(item => !item._inputCreateOnly);\n      }\n    } // TODO Promise supports asynchronous creation\n\n\n    return optionsAfterFilter;\n  }\n\n  bindKeyBoardEvent() {\n    this._keydownHandler = event => {\n      this._handleKeyDown(event);\n    };\n\n    this._adapter.registerKeyDown(this._keydownHandler);\n  }\n\n  unBindKeyBoardEvent() {\n    if (this._keydownHandler) {\n      this._adapter.unregisterKeyDown();\n    }\n  }\n\n  _handleKeyDown(event) {\n    const key = event.keyCode;\n    const {\n      loading,\n      filter,\n      multiple,\n      disabled\n    } = this.getProps();\n    const {\n      isOpen\n    } = this.getStates();\n\n    if (loading || disabled) {\n      return;\n    }\n\n    switch (key) {\n      case KeyCode.UP:\n        // Prevent Input's cursor from following\n        // Prevent Input cursor from following\n        event.preventDefault();\n\n        this._handleArrowKeyDown(-1);\n\n        break;\n\n      case KeyCode.DOWN:\n        // Prevent Input's cursor from following\n        // Prevent Input cursor from following\n        event.preventDefault();\n\n        this._handleArrowKeyDown(1);\n\n        break;\n\n      case KeyCode.BACKSPACE:\n        this._handleBackspaceKeyDown();\n\n        break;\n\n      case KeyCode.ENTER:\n        // internal-issues:302\n        // prevent trigger form’s submit when use in form\n        handlePrevent(event);\n\n        this._handleEnterKeyDown(event);\n\n        break;\n\n      case KeyCode.ESC:\n        isOpen && this.close(event);\n        filter && !multiple && this._focusTrigger();\n        break;\n\n      case KeyCode.TAB:\n        // check if slot have focusable element\n        this._handleTabKeyDown(event);\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  handleContainerKeyDown(event) {\n    // when focus in contanier, handle the key down\n    const key = event.keyCode;\n    const {\n      isOpen\n    } = this.getStates();\n\n    switch (key) {\n      case KeyCode.TAB:\n        isOpen && this._handleTabKeyDown(event);\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  _getEnableFocusIndex(offset) {\n    const {\n      focusIndex,\n      options\n    } = this.getStates();\n    const visibleOptions = options.filter(item => item._show); // let visibleOptions = options;\n\n    const optionsLength = visibleOptions.length;\n    let index = focusIndex + offset;\n\n    if (index < 0) {\n      index = optionsLength - 1;\n    }\n\n    if (index >= optionsLength) {\n      index = 0;\n    } // avoid newIndex option is disabled\n\n\n    if (offset > 0) {\n      let nearestActiveOption = -1;\n\n      for (let i = 0; i < visibleOptions.length; i++) {\n        const optionIsActive = !visibleOptions[i].disabled;\n\n        if (optionIsActive) {\n          nearestActiveOption = i;\n        }\n\n        if (nearestActiveOption >= index) {\n          break;\n        }\n      }\n\n      index = nearestActiveOption;\n    } else {\n      let nearestActiveOption = visibleOptions.length;\n\n      for (let i = optionsLength - 1; i >= 0; i--) {\n        const optionIsActive = !visibleOptions[i].disabled;\n\n        if (optionIsActive) {\n          nearestActiveOption = i;\n        }\n\n        if (nearestActiveOption <= index) {\n          break;\n        }\n      }\n\n      index = nearestActiveOption;\n    } // console.log('new:' + index);\n\n\n    this._adapter.updateFocusIndex(index);\n\n    this._adapter.updateScrollTop(index);\n  }\n\n  _handleArrowKeyDown(offset) {\n    const {\n      isOpen\n    } = this.getStates();\n    isOpen ? this._getEnableFocusIndex(offset) : this.open();\n  }\n\n  _handleTabKeyDown(event) {\n    const {\n      isOpen\n    } = this.getStates();\n\n    this._adapter.updateFocusState(false);\n\n    if (isOpen) {\n      const container = this._adapter.getContainer();\n\n      const focusableElements = this._adapter.getFocusableElements(container);\n\n      const focusableNum = focusableElements.length;\n\n      if (focusableNum > 0) {\n        // Shift + Tab will move focus backward\n        if (event.shiftKey) {\n          this._handlePanelOpenShiftTabKeyDown(focusableElements, event);\n        } else {\n          this._handlePanelOpenTabKeyDown(focusableElements, event);\n        }\n      } else {\n        // there are no focusable elements inside the container, tab to next element and trigger blur\n        this.close(event);\n\n        this._notifyBlur(event);\n      }\n    } else {\n      // tab or shift tab to next element and trigger blur\n      this._notifyBlur(event);\n    }\n  }\n\n  _handlePanelOpenTabKeyDown(focusableElements, event) {\n    const activeElement = this._adapter.getActiveElement();\n\n    const isFocusInContainer = this._adapter.getIsFocusInContainer();\n\n    if (!isFocusInContainer) {\n      // focus in trigger, set next focus to the first element in container\n      focusableElements[0].focus();\n\n      this._adapter.setIsFocusInContainer(true);\n\n      handlePrevent(event);\n    } else if (activeElement === focusableElements[focusableElements.length - 1]) {\n      // focus in the last element in container, focus back to trigger and close panel\n      this._focusTrigger();\n\n      this.close(event);\n      handlePrevent(event);\n    }\n  }\n\n  _handlePanelOpenShiftTabKeyDown(focusableElements, event) {\n    const activeElement = this._adapter.getActiveElement();\n\n    const isFocusInContainer = this._adapter.getIsFocusInContainer();\n\n    if (!isFocusInContainer) {\n      // focus in trigger, close the panel, shift tab to previe element and trigger blur\n      this.close(event);\n\n      this._notifyBlur(event);\n    } else if (activeElement === focusableElements[0]) {\n      // focus in the first element in container, focus back to trigger\n      this._focusTrigger();\n\n      this._adapter.setIsFocusInContainer(false);\n\n      handlePrevent(event);\n    }\n  }\n\n  _handleEnterKeyDown(event) {\n    const {\n      isOpen,\n      options,\n      focusIndex\n    } = this.getStates();\n\n    if (!isOpen) {\n      this.open();\n    } else {\n      if (focusIndex !== -1) {\n        const visibleOptions = options.filter(item => item._show);\n        const {\n          length\n        } = visibleOptions; // fix issue 1201\n\n        if (length <= focusIndex) {\n          return;\n        }\n\n        if (visibleOptions && length) {\n          const selectedOption = visibleOptions[focusIndex];\n\n          if (selectedOption.disabled) {\n            return;\n          }\n\n          this.onSelect(selectedOption, focusIndex, event);\n        }\n      } else {\n        this.close(event);\n      }\n    }\n  }\n\n  _handleBackspaceKeyDown() {\n    if (this._isMultiple()) {\n      const selections = this._adapter.getSelections();\n\n      const {\n        inputValue\n      } = this.getStates();\n      const length = selections.size;\n\n      if (length && !inputValue) {\n        const keys = [...selections.keys()];\n        let index = length - 1;\n        let targetLabel = keys[index];\n        let targetItem = selections.get(targetLabel);\n        let isAllDisabled = false; // can skip disabled item when remove trigger by backspace\n\n        if (targetItem.disabled && index === 0) {\n          return;\n        }\n\n        while (targetItem.disabled && index !== 0) {\n          index = index - 1;\n          targetLabel = keys[index];\n          targetItem = selections.get(targetLabel); // eslint-disable-next-line\n\n          if (index == 0 && targetItem.disabled) {\n            isAllDisabled = true;\n          }\n        }\n\n        if (!isAllDisabled) {\n          this.removeTag(targetItem);\n        }\n      }\n    }\n  }\n\n  _notifyChange(selections) {\n    const {\n      onChangeWithObject\n    } = this.getProps();\n    const stateSelections = this.getState('selections');\n    let notifyVal;\n    const selectionsProps = [...selections.values()];\n\n    const isMultiple = this._isMultiple();\n\n    const hasChange = this._diffSelections(selections, stateSelections, isMultiple);\n\n    if (!hasChange) {\n      return;\n    }\n\n    switch (true) {\n      case onChangeWithObject:\n        this._notifyChangeWithObject(selections);\n\n        break;\n\n      case !onChangeWithObject && !isMultiple:\n        notifyVal = selectionsProps.length ? selectionsProps[0].value : undefined;\n\n        this._adapter.notifyChange(notifyVal);\n\n        break;\n\n      case !onChangeWithObject && isMultiple:\n        notifyVal = selectionsProps.length ? selectionsProps.map(props => props.value) : [];\n\n        this._adapter.notifyChange(notifyVal);\n\n        break;\n\n      default:\n        break;\n    }\n  }\n\n  _removeInternalKey(option) {\n    // eslint-disable-next-line\n    let newOption = Object.assign({}, option);\n    delete newOption._parentGroup;\n    delete newOption._show;\n    delete newOption._selected;\n    delete newOption._scrollIndex;\n\n    if ('_keyInOptionList' in newOption) {\n      newOption.key = newOption._keyInOptionList;\n      delete newOption._keyInOptionList;\n    }\n\n    return newOption;\n  }\n\n  _notifySelect(value, option) {\n    const newOption = this._removeInternalKey(option);\n\n    this._adapter.notifySelect(value, newOption);\n  }\n\n  _notifyDeselect(value, option) {\n    const newOption = this._removeInternalKey(option);\n\n    this._adapter.notifyDeselect(value, newOption);\n  }\n\n  _diffSelections(selections, oldSelections, isMultiple) {\n    let diff = true;\n\n    if (!isMultiple) {\n      const selectionProps = [...selections.values()];\n      const oldSelectionProps = [...oldSelections.values()];\n      const optionLabel = selectionProps[0] ? selectionProps[0].label : selectionProps[0];\n      const oldOptionLabel = oldSelectionProps[0] ? oldSelectionProps[0].label : oldSelectionProps[0];\n      diff = !_isEqual(optionLabel, oldOptionLabel);\n    } else {// When multiple selection, there is no scene where the value is different between the two operations\n    }\n\n    return diff;\n  } // When onChangeWithObject is true, the onChange input parameter is not only value, but also label and other parameters\n\n\n  _notifyChangeWithObject(selections) {\n    const stateSelections = this.getState('selections');\n    const values = [];\n\n    for (const item of selections.entries()) {\n      let val = Object.assign({\n        label: item[0]\n      }, item[1]);\n      val = this._removeInternalKey(val);\n      values.push(val);\n    }\n\n    if (!this._isMultiple()) {\n      this._adapter.notifyChange(values[0]);\n    } else {\n      this._adapter.notifyChange(values);\n    }\n  } // Scenes that may trigger blur：\n  // 1、clickOutSide\n  // 2、 tab to next element/ shift tab to previous element\n  // 3、[remove when add a11y] click option / press enter, and then select complete（when multiple is false \n  // 4、[remove when add a11y] press esc when dropdown list open \n\n\n  _notifyBlur(e) {\n    this._adapter.notifyBlur(e);\n  } // Scenes that may trigger focus:\n  // 1、click selection\n\n\n  _notifyFocus(e) {\n    this._adapter.notifyFocus(e);\n  }\n\n  handleMouseEnter(e) {\n    this._adapter.updateHovering(true);\n\n    this._adapter.notifyMouseEnter(e);\n  }\n\n  handleMouseLeave(e) {\n    this._adapter.updateHovering(false);\n\n    this._adapter.notifyMouseLeave(e);\n  }\n\n  handleClearClick(e) {\n    const {\n      filter\n    } = this.getProps();\n\n    if (filter) {\n      this.clearInput(e);\n    }\n\n    this.clearSelected(); // prevent this click open dropdown\n\n    e.stopPropagation();\n  }\n\n  handleKeyPress(e) {\n    if (e && e.key === ENTER_KEY) {\n      this.handleClick(e);\n    }\n  }\n  /* istanbul ignore next */\n\n\n  handleClearBtnEnterPress(e) {\n    if (isEnterPress(e)) {\n      this.handleClearClick(e);\n    }\n  }\n\n  handleOptionMouseEnter(optionIndex) {\n    this._adapter.updateFocusIndex(optionIndex);\n  }\n\n  handleListScroll(e) {\n    this._adapter.notifyListScroll(e);\n  }\n\n  handleTriggerFocus(e) {\n    this.bindKeyBoardEvent(); // close the tag in multiple select did not trigger select focus, but trigger TriggerFocus, so not need to updateFocusState in this function\n    // this._adapter.updateFocusState(true);\n\n    this._adapter.setIsFocusInContainer(false);\n  }\n\n  handleTriggerBlur(e) {\n    this._adapter.updateFocusState(false);\n\n    const {\n      filter,\n      autoFocus\n    } = this.getProps();\n    const {\n      isOpen,\n      isFocus\n    } = this.getStates(); // Under normal circumstances, blur will be accompanied by clickOutsideHandler, so the notify of blur can be called uniformly in clickOutsideHandler\n    // But when autoFocus or the panel is close, because clickOutsideHandler is not register or unregister, you need to listen for the trigger's blur and trigger the notify callback\n\n    if (isFocus && !isOpen) {\n      this._notifyBlur(e);\n    }\n  }\n\n  handleInputBlur(e) {\n    const {\n      filter,\n      autoFocus\n    } = this.getProps();\n\n    const isMultiple = this._isMultiple();\n\n    if (autoFocus && filter && !isMultiple) {\n      // under this condition, when input blur, hide the input\n      this.toggle2SearchInput(false);\n    }\n  }\n\n  selectAll() {\n    const {\n      options\n    } = this.getStates();\n    const {\n      onChangeWithObject\n    } = this.getProps();\n    let selectedValues = [];\n\n    const isMultiple = this._isMultiple();\n\n    if (!isMultiple) {\n      console.warn(`[Semi Select]: It seems that you have called the selectAll method in the single-selection Select.\n                Please note that this is not a legal way to use it`);\n      return;\n    }\n\n    if (onChangeWithObject) {\n      selectedValues = options;\n    } else {\n      selectedValues = options.map(option => option.value);\n    }\n\n    this.handleValueChange(selectedValues);\n\n    this._adapter.notifyChange(selectedValues);\n  }\n  /**\n   * Check whether the props\n   *  -defaultValue/value in multiple selection mode is array\n   * @param {Object} props\n   */\n\n\n  checkMultipleProps(props) {\n    if (this._isMultiple()) {\n      const currentProps = props ? props : this.getProps();\n      const {\n        defaultValue,\n        value\n      } = currentProps;\n      const selectedValues = value || defaultValue;\n\n      if (!isNullOrUndefined(selectedValues) && !Array.isArray(selectedValues)) {\n        /* istanbul ignore next */\n        warning(true, '[Semi Select] defaultValue/value should be array type in multiple mode');\n      }\n    }\n  }\n\n  updateScrollTop() {\n    this._adapter.updateScrollTop();\n  }\n\n  updateOverflowItemCount(selectionLength, overFlowCount) {\n    const {\n      maxTagCount,\n      ellipsisTrigger\n    } = this.getProps();\n\n    if (!ellipsisTrigger) {\n      return;\n    }\n\n    if (overFlowCount) {\n      this._adapter.updateOverflowItemCount(overFlowCount);\n    } else if (typeof maxTagCount === 'number') {\n      if (selectionLength - maxTagCount > 0) {\n        this._adapter.updateOverflowItemCount(selectionLength - maxTagCount);\n      } else {\n        this._adapter.updateOverflowItemCount(0);\n      }\n    }\n  }\n\n  updateIsFullTags() {\n    const {\n      isFullTags\n    } = this.getStates();\n\n    if (!isFullTags) {\n      this._adapter.setState({\n        isFullTags: true\n      });\n    }\n  }\n\n  handlePopoverClose() {\n    this._adapter.emit('popoverClose');\n  } // need to remove focus style of option when user hover slot\n\n\n  handleSlotMouseEnter() {\n    this._adapter.updateFocusIndex(-1);\n  }\n\n}"],
  "mappings": "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",
  "names": ["_isNumber", "_isString", "_omit", "_isEqual"]
}
